I: 	div
Cannot outline slice because instruction calls non-builtin function with no body:   %call = call i64 @clock() #5
Cannot outline because inst may not return:   %call = call i64 @clock() #5
I: 	conv10
Cannot outline slice because instruction calls non-builtin function with no body:   %0 = call double @llvm.fabs.f64(double %sub6)
Cannot outline slice because instruction calls non-builtin function with no body:   %1 = call double @llvm.fabs.f64(double %conv9)


 ==== Slicing instruction: [  %conv10 = fptrunc double %mul to float] in function: epslon with size 4 ====

======== SLICED FUNCTION ==========
; Function Attrs: nounwind willreturn
define internal float @_wyvern_slice_epslon_conv10_346752190(float %x) #5 {
sliceclone_entry:
  br label %sliceclone_while.cond

sliceclone_while.cond:                            ; preds = %sliceclone_while.body, %sliceclone_entry
  %0 = phi float [ 0.000000e+00, %sliceclone_entry ], [ %11, %sliceclone_while.body ]
  %1 = fpext float %0 to double
  %2 = fcmp oeq double %1, 0.000000e+00
  br i1 %2, label %sliceclone_while.body, label %sliceclone_while.end

sliceclone_while.body:                            ; preds = %sliceclone_while.cond
  %3 = fpext float 0x3FF5555560000000 to double
  %4 = fsub double %3, 1.000000e+00
  %5 = fptrunc double %4 to float
  %6 = fadd float %5, %5
  %7 = fadd float %6, %5
  %8 = fpext float %7 to double
  %9 = fsub double %8, 1.000000e+00
  %10 = call double @llvm.fabs.f64(double %9)
  %11 = fptrunc double %10 to float
  br label %sliceclone_while.cond

sliceclone_while.end:                             ; preds = %sliceclone_while.cond
  %12 = phi float [ %0, %sliceclone_while.cond ]
  %13 = fpext float %12 to double
  %14 = fpext float %x to double
  %15 = call double @llvm.fabs.f64(double %14)
  %16 = fmul double %13, %15
  %17 = fptrunc double %16 to float
  ret float %17
}
I: 	retval.0
Cannot outline slice because instruction calls non-builtin function with no body:   %1 = call double @llvm.fabs.f64(double %conv)
Cannot outline slice because instruction calls non-builtin function with no body:   %3 = call double @llvm.fabs.f64(double %conv10)
Cannot outline slice because instruction calls non-builtin function with no body:   %5 = call double @llvm.fabs.f64(double %conv17)
Cannot outline slice because instruction calls non-builtin function with no body:   %7 = call double @llvm.fabs.f64(double %conv22)
Cannot outline slice because instruction calls non-builtin function with no body:   %9 = call double @llvm.fabs.f64(double %conv30)
Cannot outline slice because instruction calls non-builtin function with no body:   %11 = call double @llvm.fabs.f64(double %conv37)


 ==== Slicing instruction: [  %retval.0 = phi i32 [ -1, %if.then ], [ 0, %if.then2 ], [ %itemp.4, %if.end43 ]] in function: idamax with size 21 ====

======== SLICED FUNCTION ==========
; Function Attrs: nounwind willreturn
define internal i32 @_wyvern_slice_idamax_retval.0_373045362(i32 %n, ptr %dx, i32 %incx) #5 {
sliceclone_entry:
  %0 = icmp slt i32 %n, 1
  br i1 %0, label %sliceclone_if.then, label %sliceclone_if.end

sliceclone_if.then:                               ; preds = %sliceclone_entry
  br label %sliceclone_return

sliceclone_if.end:                                ; preds = %sliceclone_entry
  %1 = icmp eq i32 %n, 1
  br i1 %1, label %sliceclone_if.then2, label %sliceclone_if.end3

sliceclone_return:                                ; preds = %sliceclone_if.end43, %sliceclone_if.then2, %sliceclone_if.then
  %2 = phi i32 [ -1, %sliceclone_if.then ], [ 0, %sliceclone_if.then2 ], [ %38, %sliceclone_if.end43 ]
  ret i32 %2

sliceclone_if.then2:                              ; preds = %sliceclone_if.end
  br label %sliceclone_return

sliceclone_if.end3:                               ; preds = %sliceclone_if.end
  %3 = icmp ne i32 %incx, 1
  br i1 %3, label %sliceclone_if.then5, label %sliceclone_if.else

sliceclone_if.then5:                              ; preds = %sliceclone_if.end3
  %4 = getelementptr inbounds float, ptr %dx, i64 0
  %5 = load float, ptr %4, align 4
  %6 = fpext float %5 to double
  %7 = call double @llvm.fabs.f64(double %6)
  %8 = fptrunc double %7 to float
  %9 = add nsw i32 1, %incx
  br label %sliceclone_for.cond

sliceclone_for.body:                              ; preds = %sliceclone_for.cond
  %10 = sext i32 %25 to i64
  %11 = getelementptr inbounds float, ptr %dx, i64 %10
  %12 = load float, ptr %11, align 4
  %13 = fpext float %12 to double
  %14 = call double @llvm.fabs.f64(double %13)
  %15 = fpext float %23 to double
  %16 = fcmp ogt double %14, %15
  br i1 %16, label %sliceclone_if.then14, label %sliceclone_if.end19

sliceclone_for.end:                               ; preds = %sliceclone_for.cond
  %17 = phi i32 [ %26, %sliceclone_for.cond ]
  br label %sliceclone_if.end43

sliceclone_if.else:                               ; preds = %sliceclone_if.end3
  %18 = getelementptr inbounds float, ptr %dx, i64 0
  %19 = load float, ptr %18, align 4
  %20 = fpext float %19 to double
  %21 = call double @llvm.fabs.f64(double %20)
  %22 = fptrunc double %21 to float
  br label %sliceclone_for.cond24

sliceclone_for.cond:                              ; preds = %sliceclone_for.inc, %sliceclone_if.then5
  %23 = phi float [ %8, %sliceclone_if.then5 ], [ %35, %sliceclone_for.inc ]
  %24 = phi i32 [ 1, %sliceclone_if.then5 ], [ %28, %sliceclone_for.inc ]
  %25 = phi i32 [ %9, %sliceclone_if.then5 ], [ %37, %sliceclone_for.inc ]
  %26 = phi i32 [ undef, %sliceclone_if.then5 ], [ %36, %sliceclone_for.inc ]
  %27 = icmp slt i32 %24, %n
  br i1 %27, label %sliceclone_for.body, label %sliceclone_for.end

sliceclone_for.inc:                               ; preds = %sliceclone_if.end19
  %28 = add nsw i32 %24, 1
  br label %sliceclone_for.cond

sliceclone_if.then14:                             ; preds = %sliceclone_for.body
  %29 = sext i32 %25 to i64
  %30 = getelementptr inbounds float, ptr %dx, i64 %29
  %31 = load float, ptr %30, align 4
  %32 = fpext float %31 to double
  %33 = call double @llvm.fabs.f64(double %32)
  %34 = fptrunc double %33 to float
  br label %sliceclone_if.end19

sliceclone_if.end19:                              ; preds = %sliceclone_if.then14, %sliceclone_for.body
  %35 = phi float [ %34, %sliceclone_if.then14 ], [ %23, %sliceclone_for.body ]
  %36 = phi i32 [ %24, %sliceclone_if.then14 ], [ %26, %sliceclone_for.body ]
  %37 = add nsw i32 %25, %incx
  br label %sliceclone_for.inc

sliceclone_if.end43:                              ; preds = %sliceclone_for.end42, %sliceclone_for.end
  %38 = phi i32 [ %17, %sliceclone_for.end ], [ %51, %sliceclone_for.end42 ]
  br label %sliceclone_return

sliceclone_for.cond24:                            ; preds = %sliceclone_for.inc40, %sliceclone_if.else
  %39 = phi float [ %22, %sliceclone_if.else ], [ %58, %sliceclone_for.inc40 ]
  %40 = phi i32 [ 1, %sliceclone_if.else ], [ %43, %sliceclone_for.inc40 ]
  %41 = phi i32 [ 0, %sliceclone_if.else ], [ %59, %sliceclone_for.inc40 ]
  %42 = icmp slt i32 %40, %n
  br i1 %42, label %sliceclone_for.body27, label %sliceclone_for.end42

sliceclone_for.inc40:                             ; preds = %sliceclone_if.end39
  %43 = add nsw i32 %40, 1
  br label %sliceclone_for.cond24

sliceclone_for.body27:                            ; preds = %sliceclone_for.cond24
  %44 = sext i32 %40 to i64
  %45 = getelementptr inbounds float, ptr %dx, i64 %44
  %46 = load float, ptr %45, align 4
  %47 = fpext float %46 to double
  %48 = call double @llvm.fabs.f64(double %47)
  %49 = fpext float %39 to double
  %50 = fcmp ogt double %48, %49
  br i1 %50, label %sliceclone_if.then34, label %sliceclone_if.end39

sliceclone_for.end42:                             ; preds = %sliceclone_for.cond24
  %51 = phi i32 [ %41, %sliceclone_for.cond24 ]
  br label %sliceclone_if.end43

sliceclone_if.then34:                             ; preds = %sliceclone_for.body27
  %52 = sext i32 %40 to i64
  %53 = getelementptr inbounds float, ptr %dx, i64 %52
  %54 = load float, ptr %53, align 4
  %55 = fpext float %54 to double
  %56 = call double @llvm.fabs.f64(double %55)
  %57 = fptrunc double %56 to float
  br label %sliceclone_if.end39

sliceclone_if.end39:                              ; preds = %sliceclone_if.then34, %sliceclone_for.body27
  %58 = phi float [ %57, %sliceclone_if.then34 ], [ %39, %sliceclone_for.body27 ]
  %59 = phi i32 [ %40, %sliceclone_if.then34 ], [ %41, %sliceclone_for.body27 ]
  br label %sliceclone_for.inc40
}
I: 	retval.0
Cannot outline slice because instruction calls non-builtin function with no body:   %5 = call float @llvm.fmuladd.f32(float %3, float %4, float %dtemp.1)
Cannot outline slice because instruction calls non-builtin function with no body:   %2 = call float @llvm.fmuladd.f32(float %0, float %1, float %dtemp.0)


 ==== Slicing instruction: [  %retval.0 = phi float [ 0.000000e+00, %if.then ], [ %dtemp.0.lcssa, %for.end ], [ %dtemp.1.lcssa, %for.end30 ]] in function: ddot with size 19 ====

======== SLICED FUNCTION ==========
; Function Attrs: nounwind willreturn
define internal float @_wyvern_slice_ddot_retval.0_181003522(i32 %n, ptr %dx, i32 %incx, ptr %dy, i32 %incy) #5 {
sliceclone_entry:
  %0 = icmp sle i32 %n, 0
  br i1 %0, label %sliceclone_if.then, label %sliceclone_if.end

sliceclone_if.then:                               ; preds = %sliceclone_entry
  br label %sliceclone_return

sliceclone_if.end:                                ; preds = %sliceclone_entry
  %1 = icmp ne i32 %incx, 1
  br i1 %1, label %sliceclone_if.then3, label %sliceclone_lor.lhs.false

sliceclone_return:                                ; preds = %sliceclone_for.end, %sliceclone_for.end30, %sliceclone_if.then
  %2 = phi float [ 0.000000e+00, %sliceclone_if.then ], [ %37, %sliceclone_for.end ], [ %21, %sliceclone_for.end30 ]
  ret float %2

sliceclone_if.then3:                              ; preds = %sliceclone_lor.lhs.false, %sliceclone_if.end
  %3 = icmp slt i32 %incx, 0
  br i1 %3, label %sliceclone_if.then5, label %sliceclone_if.end6

sliceclone_lor.lhs.false:                         ; preds = %sliceclone_if.end
  %4 = icmp ne i32 %incy, 1
  br i1 %4, label %sliceclone_if.then3, label %sliceclone_if.end19

sliceclone_if.end19:                              ; preds = %sliceclone_lor.lhs.false
  br label %sliceclone_for.cond20

sliceclone_if.then5:                              ; preds = %sliceclone_if.then3
  %5 = sub nsw i32 0, %n
  %6 = add nsw i32 %5, 1
  %7 = mul nsw i32 %6, %incx
  br label %sliceclone_if.end6

sliceclone_if.end6:                               ; preds = %sliceclone_if.then5, %sliceclone_if.then3
  %8 = phi i32 [ %7, %sliceclone_if.then5 ], [ 0, %sliceclone_if.then3 ]
  %9 = icmp slt i32 %incy, 0
  br i1 %9, label %sliceclone_if.then8, label %sliceclone_if.end12

sliceclone_if.then8:                              ; preds = %sliceclone_if.end6
  %10 = sub nsw i32 0, %n
  %11 = add nsw i32 %10, 1
  %12 = mul nsw i32 %11, %incy
  br label %sliceclone_if.end12

sliceclone_if.end12:                              ; preds = %sliceclone_if.then8, %sliceclone_if.end6
  %13 = phi i32 [ %12, %sliceclone_if.then8 ], [ 0, %sliceclone_if.end6 ]
  br label %sliceclone_for.cond

sliceclone_for.body22:                            ; preds = %sliceclone_for.cond20
  %14 = sext i32 %39 to i64
  %15 = getelementptr inbounds float, ptr %dx, i64 %14
  %16 = load float, ptr %15, align 4
  %17 = sext i32 %39 to i64
  %18 = getelementptr inbounds float, ptr %dy, i64 %17
  %19 = load float, ptr %18, align 4
  %20 = call float @llvm.fmuladd.f32(float %16, float %19, float %38)
  br label %sliceclone_for.inc28

sliceclone_for.end30:                             ; preds = %sliceclone_for.cond20
  %21 = phi float [ %38, %sliceclone_for.cond20 ]
  br label %sliceclone_return

sliceclone_for.cond:                              ; preds = %sliceclone_for.inc, %sliceclone_if.end12
  %22 = phi float [ 0.000000e+00, %sliceclone_if.end12 ], [ %34, %sliceclone_for.inc ]
  %23 = phi i32 [ 0, %sliceclone_if.end12 ], [ %27, %sliceclone_for.inc ]
  %24 = phi i32 [ %8, %sliceclone_if.end12 ], [ %35, %sliceclone_for.inc ]
  %25 = phi i32 [ %13, %sliceclone_if.end12 ], [ %36, %sliceclone_for.inc ]
  %26 = icmp slt i32 %23, %n
  br i1 %26, label %sliceclone_for.body, label %sliceclone_for.end

sliceclone_for.inc:                               ; preds = %sliceclone_for.body
  %27 = add nsw i32 %23, 1
  br label %sliceclone_for.cond

sliceclone_for.body:                              ; preds = %sliceclone_for.cond
  %28 = sext i32 %24 to i64
  %29 = getelementptr inbounds float, ptr %dx, i64 %28
  %30 = load float, ptr %29, align 4
  %31 = sext i32 %25 to i64
  %32 = getelementptr inbounds float, ptr %dy, i64 %31
  %33 = load float, ptr %32, align 4
  %34 = call float @llvm.fmuladd.f32(float %30, float %33, float %22)
  %35 = add nsw i32 %24, %incx
  %36 = add nsw i32 %25, %incy
  br label %sliceclone_for.inc

sliceclone_for.end:                               ; preds = %sliceclone_for.cond
  %37 = phi float [ %22, %sliceclone_for.cond ]
  br label %sliceclone_return

sliceclone_for.cond20:                            ; preds = %sliceclone_for.inc28, %sliceclone_if.end19
  %38 = phi float [ 0.000000e+00, %sliceclone_if.end19 ], [ %20, %sliceclone_for.inc28 ]
  %39 = phi i32 [ 0, %sliceclone_if.end19 ], [ %41, %sliceclone_for.inc28 ]
  %40 = icmp slt i32 %39, %n
  br i1 %40, label %sliceclone_for.body22, label %sliceclone_for.end30

sliceclone_for.inc28:                             ; preds = %sliceclone_for.body22
  %41 = add nsw i32 %39, 1
  br label %sliceclone_for.cond20
}
Removing inst
Instruction to remove:
  %eps.0 = phi float [ 0.000000e+00, %entry ], [ %conv7, %while.body ]
  %conv = fpext float %eps.0 to double
  %cmp = fcmp oeq double %conv, 0.000000e+00
  br i1 %cmp, label %while.body, label %while.end
  %conv2 = fpext float 0x3FF5555560000000 to double
  %sub = fsub double %conv2, 1.000000e+00
  %conv3 = fptrunc double %sub to float
  %add = fadd float %conv3, %conv3
  %add4 = fadd float %add, %conv3
  %conv5 = fpext float %add4 to double
  %sub6 = fsub double %conv5, 1.000000e+00
  %0 = call double @llvm.fabs.f64(double %sub6)
  %conv7 = fptrunc double %0 to float
  %eps.0.lcssa = phi float [ %eps.0, %while.cond ]
  %conv8 = fpext float %eps.0.lcssa to double
  %conv9 = fpext float %x to double
  %1 = call double @llvm.fabs.f64(double %conv9)
  %mul = fmul double %conv8, %1
  %conv10 = fptrunc double %mul to float
END
Instruction to remove:
  %cmp = icmp slt i32 %n, 1
  br i1 %cmp, label %if.then, label %if.end
  %cmp1 = icmp eq i32 %n, 1
  br i1 %cmp1, label %if.then2, label %if.end3
  %cmp4 = icmp ne i32 %incx, 1
  br i1 %cmp4, label %if.then5, label %if.else
  %arrayidx = getelementptr inbounds float, ptr %dx, i64 0
  %0 = load float, ptr %arrayidx, align 4
  %conv = fpext float %0 to double
  %1 = call double @llvm.fabs.f64(double %conv)
  %conv6 = fptrunc double %1 to float
  %add = add nsw i32 1, %incx
  %dmax.0 = phi float [ %conv6, %if.then5 ], [ %dmax.1, %for.inc ]
  %i.0 = phi i32 [ 1, %if.then5 ], [ %inc, %for.inc ]
  %ix.0 = phi i32 [ %add, %if.then5 ], [ %add20, %for.inc ]
  %itemp.0 = phi i32 [ undef, %if.then5 ], [ %itemp.1, %for.inc ]
  %cmp7 = icmp slt i32 %i.0, %n
  %dmax.2 = phi float [ %conv23, %if.else ], [ %dmax.3, %for.inc40 ]
  %i.1 = phi i32 [ 1, %if.else ], [ %inc41, %for.inc40 ]
  %itemp.2 = phi i32 [ 0, %if.else ], [ %itemp.3, %for.inc40 ]
  %cmp25 = icmp slt i32 %i.1, %n
  br i1 %cmp7, label %for.body, label %for.end
  %idxprom = sext i32 %ix.0 to i64
  %arrayidx9 = getelementptr inbounds float, ptr %dx, i64 %idxprom
  %2 = load float, ptr %arrayidx9, align 4
  %conv10 = fpext float %2 to double
  %3 = call double @llvm.fabs.f64(double %conv10)
  %conv11 = fpext float %dmax.0 to double
  %cmp12 = fcmp ogt double %3, %conv11
  br i1 %cmp12, label %if.then14, label %if.end19
  %idxprom15 = sext i32 %ix.0 to i64
  %arrayidx16 = getelementptr inbounds float, ptr %dx, i64 %idxprom15
  %4 = load float, ptr %arrayidx16, align 4
  %conv17 = fpext float %4 to double
  %5 = call double @llvm.fabs.f64(double %conv17)
  %conv18 = fptrunc double %5 to float
  %dmax.1 = phi float [ %conv18, %if.then14 ], [ %dmax.0, %for.body ]
  %itemp.1 = phi i32 [ %i.0, %if.then14 ], [ %itemp.0, %for.body ]
  %add20 = add nsw i32 %ix.0, %incx
  %inc = add nsw i32 %i.0, 1
  %itemp.0.lcssa = phi i32 [ %itemp.0, %for.cond ]
  %arrayidx21 = getelementptr inbounds float, ptr %dx, i64 0
  %6 = load float, ptr %arrayidx21, align 4
  %conv22 = fpext float %6 to double
  %7 = call double @llvm.fabs.f64(double %conv22)
  %conv23 = fptrunc double %7 to float
  br i1 %cmp25, label %for.body27, label %for.end42
  %idxprom28 = sext i32 %i.1 to i64
  %arrayidx29 = getelementptr inbounds float, ptr %dx, i64 %idxprom28
  %8 = load float, ptr %arrayidx29, align 4
  %conv30 = fpext float %8 to double
  %9 = call double @llvm.fabs.f64(double %conv30)
  %conv31 = fpext float %dmax.2 to double
  %cmp32 = fcmp ogt double %9, %conv31
  br i1 %cmp32, label %if.then34, label %if.end39
  %idxprom35 = sext i32 %i.1 to i64
  %arrayidx36 = getelementptr inbounds float, ptr %dx, i64 %idxprom35
  %10 = load float, ptr %arrayidx36, align 4
  %conv37 = fpext float %10 to double
  %11 = call double @llvm.fabs.f64(double %conv37)
  %conv38 = fptrunc double %11 to float
  %dmax.3 = phi float [ %conv38, %if.then34 ], [ %dmax.2, %for.body27 ]
  %itemp.3 = phi i32 [ %i.1, %if.then34 ], [ %itemp.2, %for.body27 ]
  %inc41 = add nsw i32 %i.1, 1
  %itemp.2.lcssa = phi i32 [ %itemp.2, %for.cond24 ]
  %itemp.4 = phi i32 [ %itemp.0.lcssa, %for.end ], [ %itemp.2.lcssa, %for.end42 ]
  %retval.0 = phi i32 [ -1, %if.then ], [ 0, %if.then2 ], [ %itemp.4, %if.end43 ]
END
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: opt -passes=daedalus -load-pass-plugin build/lib/libdaedalus.so -disable-output tests/linpack-pc.ll
 #0 0x00007f04d5549e78 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/daniel/llvm-project/llvm/lib/Support/Unix/Signals.inc:602:22
 #1 0x00007f04d554a24c PrintStackTraceSignalHandler(void*) /home/daniel/llvm-project/llvm/lib/Support/Unix/Signals.inc:675:1
 #2 0x00007f04d5547a42 llvm::sys::RunSignalHandlers() /home/daniel/llvm-project/llvm/lib/Support/Signals.cpp:104:20
 #3 0x00007f04d55497ac SignalHandler(int) /home/daniel/llvm-project/llvm/lib/Support/Unix/Signals.inc:413:1
 #4 0x00007f04d4d90090 (/lib/x86_64-linux-gnu/libc.so.6+0x43090)
 #5 0x00007f04d12863a2 llvm::Value::getValueID() const (build/lib/libdaedalus.so+0x723a2)
 #6 0x00007f04d128661c llvm::Instruction::classof(llvm::Value const*) (build/lib/libdaedalus.so+0x7261c)
 #7 0x00007f04d12937b2 llvm::isa_impl<llvm::Instruction, llvm::User, void>::doit(llvm::User const&) (build/lib/libdaedalus.so+0x7f7b2)
 #8 0x00007f04d12929a6 llvm::isa_impl_cl<llvm::Instruction, llvm::User const*>::doit(llvm::User const*) (build/lib/libdaedalus.so+0x7e9a6)
 #9 0x00007f04d12910b5 llvm::isa_impl_wrap<llvm::Instruction, llvm::User const*, llvm::User const*>::doit(llvm::User const* const&) (build/lib/libdaedalus.so+0x7d0b5)
#10 0x00007f04d128e36d llvm::isa_impl_wrap<llvm::Instruction, llvm::User* const, llvm::User const*>::doit(llvm::User* const&) (build/lib/libdaedalus.so+0x7a36d)
#11 0x00007f04d128b285 llvm::CastIsPossible<llvm::Instruction, llvm::User*, void>::isPossible(llvm::User* const&) (build/lib/libdaedalus.so+0x77285)
#12 0x00007f04d1288bda llvm::CastInfo<llvm::Instruction, llvm::User*, void>::doCastIfPossible(llvm::User* const&) (build/lib/libdaedalus.so+0x74bda)
#13 0x00007f04d12871cd decltype(auto) llvm::dyn_cast<llvm::Instruction, llvm::User>(llvm::User*) (build/lib/libdaedalus.so+0x731cd)
#14 0x00007f04d12845e3 tryRemoveInstruction(llvm::Instruction*, std::set<llvm::Instruction*, std::less<llvm::Instruction*>, std::allocator<llvm::Instruction*>>&, std::map<llvm::Instruction*, instState, std::less<llvm::Instruction*>, std::allocator<std::pair<llvm::Instruction* const, instState>>>&, llvm::Instruction*) (build/lib/libdaedalus.so+0x705e3)
#15 0x00007f04d128460f tryRemoveInstruction(llvm::Instruction*, std::set<llvm::Instruction*, std::less<llvm::Instruction*>, std::allocator<llvm::Instruction*>>&, std::map<llvm::Instruction*, instState, std::less<llvm::Instruction*>, std::allocator<std::pair<llvm::Instruction* const, instState>>>&, llvm::Instruction*) (build/lib/libdaedalus.so+0x7060f)
#16 0x00007f04d128460f tryRemoveInstruction(llvm::Instruction*, std::set<llvm::Instruction*, std::less<llvm::Instruction*>, std::allocator<llvm::Instruction*>>&, std::map<llvm::Instruction*, instState, std::less<llvm::Instruction*>, std::allocator<std::pair<llvm::Instruction* const, instState>>>&, llvm::Instruction*) (build/lib/libdaedalus.so+0x7060f)
#17 0x00007f04d128460f tryRemoveInstruction(llvm::Instruction*, std::set<llvm::Instruction*, std::less<llvm::Instruction*>, std::allocator<llvm::Instruction*>>&, std::map<llvm::Instruction*, instState, std::less<llvm::Instruction*>, std::allocator<std::pair<llvm::Instruction* const, instState>>>&, llvm::Instruction*) (build/lib/libdaedalus.so+0x7060f)
#18 0x00007f04d128460f tryRemoveInstruction(llvm::Instruction*, std::set<llvm::Instruction*, std::less<llvm::Instruction*>, std::allocator<llvm::Instruction*>>&, std::map<llvm::Instruction*, instState, std::less<llvm::Instruction*>, std::allocator<std::pair<llvm::Instruction* const, instState>>>&, llvm::Instruction*) (build/lib/libdaedalus.so+0x7060f)
#19 0x00007f04d128460f tryRemoveInstruction(llvm::Instruction*, std::set<llvm::Instruction*, std::less<llvm::Instruction*>, std::allocator<llvm::Instruction*>>&, std::map<llvm::Instruction*, instState, std::less<llvm::Instruction*>, std::allocator<std::pair<llvm::Instruction* const, instState>>>&, llvm::Instruction*) (build/lib/libdaedalus.so+0x7060f)
#20 0x00007f04d128460f tryRemoveInstruction(llvm::Instruction*, std::set<llvm::Instruction*, std::less<llvm::Instruction*>, std::allocator<llvm::Instruction*>>&, std::map<llvm::Instruction*, instState, std::less<llvm::Instruction*>, std::allocator<std::pair<llvm::Instruction* const, instState>>>&, llvm::Instruction*) (build/lib/libdaedalus.so+0x7060f)
#21 0x00007f04d1285548 Daedalus::DaedalusPass::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (build/lib/libdaedalus.so+0x71548)
#22 0x00007f04d1297cc5 llvm::detail::PassModel<llvm::Module, Daedalus::DaedalusPass, llvm::PreservedAnalyses, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (build/lib/libdaedalus.so+0x83cc5)
#23 0x00007f04d5eb0c99 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) /home/daniel/llvm-project/llvm/include/llvm/IR/PassManager.h:521:7
#24 0x000056307ab27e26 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) /home/daniel/llvm-project/llvm/tools/opt/NewPMDriver.cpp:527:10
#25 0x000056307ab54eb7 main /home/daniel/llvm-project/llvm/tools/opt/opt.cpp:709:27
#26 0x00007f04d4d71083 __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:342:3
#27 0x000056307ab2524e _start (/home/daniel/llvm-project/build/bin/opt+0x7224e)
Segmentation fault (core dumped)
