; ModuleID = '/src/llvm-test-suite/build/SingleSource/Benchmarks/Adobe-C++/loop_unroll.e.bc'
source_filename = "ld-temp.o"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.one_result = type { double, ptr }

$_ZN14for_loop_testsILi31EiE7do_testEPKiPKc = comdat any

$_Z27test_for_loop_unroll_factorILi32EiEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi31EiE7do_testEPKiPKc = comdat any

$_Z29test_while_loop_unroll_factorILi32EiEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi31EiE7do_testEPKiPKc = comdat any

$_Z26test_do_loop_unroll_factorILi32EiEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi31EiE7do_testEPKiPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi32EiEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi31EdE7do_testEPKdPKc = comdat any

$_Z27test_for_loop_unroll_factorILi32EdEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi31EdE7do_testEPKdPKc = comdat any

$_Z29test_while_loop_unroll_factorILi32EdEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi31EdE7do_testEPKdPKc = comdat any

$_Z26test_do_loop_unroll_factorILi32EdEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi31EdE7do_testEPKdPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi32EdEvPKT0_iPKc = comdat any

$_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi = comdat any

$_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi = comdat any

$_ZN15loop_inner_bodyILi10EdE7do_workERdPKdi = comdat any

$_ZN15goto_loop_testsILi29EdE7do_testEPKdPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi30EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi31EdEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi27EdE7do_testEPKdPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi28EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi29EdEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi25EdE7do_testEPKdPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi26EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi27EdEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi23EdE7do_testEPKdPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi24EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi25EdEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi21EdE7do_testEPKdPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi22EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi23EdEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi19EdE7do_testEPKdPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi20EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi21EdEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi17EdE7do_testEPKdPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi18EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi19EdEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi15EdE7do_testEPKdPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi16EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi17EdEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi13EdE7do_testEPKdPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi14EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi15EdEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi11EdE7do_testEPKdPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi12EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi13EdEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi9EdE7do_testEPKdPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi10EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi11EdEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi7EdE7do_testEPKdPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi8EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi9EdEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi5EdE7do_testEPKdPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi6EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi7EdEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi3EdE7do_testEPKdPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi4EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi5EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi1EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi2EdEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi3EdEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi29EdE7do_testEPKdPKc = comdat any

$_Z26test_do_loop_unroll_factorILi30EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi31EdEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi27EdE7do_testEPKdPKc = comdat any

$_Z26test_do_loop_unroll_factorILi28EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi29EdEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi25EdE7do_testEPKdPKc = comdat any

$_Z26test_do_loop_unroll_factorILi26EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi27EdEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi23EdE7do_testEPKdPKc = comdat any

$_Z26test_do_loop_unroll_factorILi24EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi25EdEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi21EdE7do_testEPKdPKc = comdat any

$_Z26test_do_loop_unroll_factorILi22EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi23EdEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi19EdE7do_testEPKdPKc = comdat any

$_Z26test_do_loop_unroll_factorILi20EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi21EdEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi17EdE7do_testEPKdPKc = comdat any

$_Z26test_do_loop_unroll_factorILi18EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi19EdEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi15EdE7do_testEPKdPKc = comdat any

$_Z26test_do_loop_unroll_factorILi16EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi17EdEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi13EdE7do_testEPKdPKc = comdat any

$_Z26test_do_loop_unroll_factorILi14EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi15EdEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi11EdE7do_testEPKdPKc = comdat any

$_Z26test_do_loop_unroll_factorILi12EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi13EdEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi9EdE7do_testEPKdPKc = comdat any

$_Z26test_do_loop_unroll_factorILi10EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi11EdEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi7EdE7do_testEPKdPKc = comdat any

$_Z26test_do_loop_unroll_factorILi8EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi9EdEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi5EdE7do_testEPKdPKc = comdat any

$_Z26test_do_loop_unroll_factorILi6EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi7EdEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi3EdE7do_testEPKdPKc = comdat any

$_Z26test_do_loop_unroll_factorILi4EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi5EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi1EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi2EdEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi3EdEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi29EdE7do_testEPKdPKc = comdat any

$_Z29test_while_loop_unroll_factorILi30EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi31EdEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi27EdE7do_testEPKdPKc = comdat any

$_Z29test_while_loop_unroll_factorILi28EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi29EdEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi25EdE7do_testEPKdPKc = comdat any

$_Z29test_while_loop_unroll_factorILi26EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi27EdEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi23EdE7do_testEPKdPKc = comdat any

$_Z29test_while_loop_unroll_factorILi24EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi25EdEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi21EdE7do_testEPKdPKc = comdat any

$_Z29test_while_loop_unroll_factorILi22EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi23EdEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi19EdE7do_testEPKdPKc = comdat any

$_Z29test_while_loop_unroll_factorILi20EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi21EdEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi17EdE7do_testEPKdPKc = comdat any

$_Z29test_while_loop_unroll_factorILi18EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi19EdEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi15EdE7do_testEPKdPKc = comdat any

$_Z29test_while_loop_unroll_factorILi16EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi17EdEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi13EdE7do_testEPKdPKc = comdat any

$_Z29test_while_loop_unroll_factorILi14EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi15EdEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi11EdE7do_testEPKdPKc = comdat any

$_Z29test_while_loop_unroll_factorILi12EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi13EdEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi9EdE7do_testEPKdPKc = comdat any

$_Z29test_while_loop_unroll_factorILi10EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi11EdEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi7EdE7do_testEPKdPKc = comdat any

$_Z29test_while_loop_unroll_factorILi8EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi9EdEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi5EdE7do_testEPKdPKc = comdat any

$_Z29test_while_loop_unroll_factorILi6EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi7EdEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi3EdE7do_testEPKdPKc = comdat any

$_Z29test_while_loop_unroll_factorILi4EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi5EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi1EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi2EdEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi3EdEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi29EdE7do_testEPKdPKc = comdat any

$_Z27test_for_loop_unroll_factorILi30EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi31EdEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi27EdE7do_testEPKdPKc = comdat any

$_Z27test_for_loop_unroll_factorILi28EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi29EdEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi25EdE7do_testEPKdPKc = comdat any

$_Z27test_for_loop_unroll_factorILi26EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi27EdEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi23EdE7do_testEPKdPKc = comdat any

$_Z27test_for_loop_unroll_factorILi24EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi25EdEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi21EdE7do_testEPKdPKc = comdat any

$_Z27test_for_loop_unroll_factorILi22EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi23EdEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi19EdE7do_testEPKdPKc = comdat any

$_Z27test_for_loop_unroll_factorILi20EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi21EdEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi17EdE7do_testEPKdPKc = comdat any

$_Z27test_for_loop_unroll_factorILi18EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi19EdEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi15EdE7do_testEPKdPKc = comdat any

$_Z27test_for_loop_unroll_factorILi16EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi17EdEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi13EdE7do_testEPKdPKc = comdat any

$_Z27test_for_loop_unroll_factorILi14EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi15EdEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi11EdE7do_testEPKdPKc = comdat any

$_Z27test_for_loop_unroll_factorILi12EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi13EdEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi9EdE7do_testEPKdPKc = comdat any

$_Z27test_for_loop_unroll_factorILi10EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi11EdEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi7EdE7do_testEPKdPKc = comdat any

$_Z27test_for_loop_unroll_factorILi8EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi9EdEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi5EdE7do_testEPKdPKc = comdat any

$_Z27test_for_loop_unroll_factorILi6EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi7EdEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi3EdE7do_testEPKdPKc = comdat any

$_Z27test_for_loop_unroll_factorILi4EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi5EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi1EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi2EdEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi3EdEvPKT0_iPKc = comdat any

$_ZN15loop_inner_bodyILi30EiE7do_workERiPKii = comdat any

$_ZN15loop_inner_bodyILi16EiE7do_workERiPKii = comdat any

$_ZN15goto_loop_testsILi29EiE7do_testEPKiPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi30EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi31EiEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi27EiE7do_testEPKiPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi28EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi29EiEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi25EiE7do_testEPKiPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi26EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi27EiEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi23EiE7do_testEPKiPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi24EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi25EiEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi21EiE7do_testEPKiPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi22EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi23EiEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi19EiE7do_testEPKiPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi20EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi21EiEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi17EiE7do_testEPKiPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi18EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi19EiEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi15EiE7do_testEPKiPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi16EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi17EiEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi13EiE7do_testEPKiPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi14EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi15EiEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi11EiE7do_testEPKiPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi12EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi13EiEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi9EiE7do_testEPKiPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi10EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi11EiEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi7EiE7do_testEPKiPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi8EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi9EiEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi5EiE7do_testEPKiPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi6EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi7EiEvPKT0_iPKc = comdat any

$_ZN15goto_loop_testsILi3EiE7do_testEPKiPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi4EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi5EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi1EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi2EiEvPKT0_iPKc = comdat any

$_Z28test_goto_loop_unroll_factorILi3EiEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi29EiE7do_testEPKiPKc = comdat any

$_Z26test_do_loop_unroll_factorILi30EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi31EiEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi27EiE7do_testEPKiPKc = comdat any

$_Z26test_do_loop_unroll_factorILi28EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi29EiEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi25EiE7do_testEPKiPKc = comdat any

$_Z26test_do_loop_unroll_factorILi26EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi27EiEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi23EiE7do_testEPKiPKc = comdat any

$_Z26test_do_loop_unroll_factorILi24EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi25EiEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi21EiE7do_testEPKiPKc = comdat any

$_Z26test_do_loop_unroll_factorILi22EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi23EiEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi19EiE7do_testEPKiPKc = comdat any

$_Z26test_do_loop_unroll_factorILi20EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi21EiEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi17EiE7do_testEPKiPKc = comdat any

$_Z26test_do_loop_unroll_factorILi18EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi19EiEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi15EiE7do_testEPKiPKc = comdat any

$_Z26test_do_loop_unroll_factorILi16EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi17EiEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi13EiE7do_testEPKiPKc = comdat any

$_Z26test_do_loop_unroll_factorILi14EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi15EiEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi11EiE7do_testEPKiPKc = comdat any

$_Z26test_do_loop_unroll_factorILi12EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi13EiEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi9EiE7do_testEPKiPKc = comdat any

$_Z26test_do_loop_unroll_factorILi10EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi11EiEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi7EiE7do_testEPKiPKc = comdat any

$_Z26test_do_loop_unroll_factorILi8EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi9EiEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi5EiE7do_testEPKiPKc = comdat any

$_Z26test_do_loop_unroll_factorILi6EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi7EiEvPKT0_iPKc = comdat any

$_ZN13do_loop_testsILi3EiE7do_testEPKiPKc = comdat any

$_Z26test_do_loop_unroll_factorILi4EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi5EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi1EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi2EiEvPKT0_iPKc = comdat any

$_Z26test_do_loop_unroll_factorILi3EiEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi29EiE7do_testEPKiPKc = comdat any

$_Z29test_while_loop_unroll_factorILi30EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi31EiEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi27EiE7do_testEPKiPKc = comdat any

$_Z29test_while_loop_unroll_factorILi28EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi29EiEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi25EiE7do_testEPKiPKc = comdat any

$_Z29test_while_loop_unroll_factorILi26EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi27EiEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi23EiE7do_testEPKiPKc = comdat any

$_Z29test_while_loop_unroll_factorILi24EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi25EiEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi21EiE7do_testEPKiPKc = comdat any

$_Z29test_while_loop_unroll_factorILi22EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi23EiEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi19EiE7do_testEPKiPKc = comdat any

$_Z29test_while_loop_unroll_factorILi20EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi21EiEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi17EiE7do_testEPKiPKc = comdat any

$_Z29test_while_loop_unroll_factorILi18EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi19EiEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi15EiE7do_testEPKiPKc = comdat any

$_Z29test_while_loop_unroll_factorILi16EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi17EiEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi13EiE7do_testEPKiPKc = comdat any

$_Z29test_while_loop_unroll_factorILi14EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi15EiEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi11EiE7do_testEPKiPKc = comdat any

$_Z29test_while_loop_unroll_factorILi12EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi13EiEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi9EiE7do_testEPKiPKc = comdat any

$_Z29test_while_loop_unroll_factorILi10EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi11EiEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi7EiE7do_testEPKiPKc = comdat any

$_Z29test_while_loop_unroll_factorILi8EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi9EiEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi5EiE7do_testEPKiPKc = comdat any

$_Z29test_while_loop_unroll_factorILi6EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi7EiEvPKT0_iPKc = comdat any

$_ZN16while_loop_testsILi3EiE7do_testEPKiPKc = comdat any

$_Z29test_while_loop_unroll_factorILi4EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi5EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi1EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi2EiEvPKT0_iPKc = comdat any

$_Z29test_while_loop_unroll_factorILi3EiEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi29EiE7do_testEPKiPKc = comdat any

$_Z27test_for_loop_unroll_factorILi30EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi31EiEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi27EiE7do_testEPKiPKc = comdat any

$_Z27test_for_loop_unroll_factorILi28EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi29EiEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi25EiE7do_testEPKiPKc = comdat any

$_Z27test_for_loop_unroll_factorILi26EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi27EiEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi23EiE7do_testEPKiPKc = comdat any

$_Z27test_for_loop_unroll_factorILi24EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi25EiEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi21EiE7do_testEPKiPKc = comdat any

$_Z27test_for_loop_unroll_factorILi22EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi23EiEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi19EiE7do_testEPKiPKc = comdat any

$_Z27test_for_loop_unroll_factorILi20EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi21EiEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi17EiE7do_testEPKiPKc = comdat any

$_Z27test_for_loop_unroll_factorILi18EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi19EiEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi15EiE7do_testEPKiPKc = comdat any

$_Z27test_for_loop_unroll_factorILi16EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi17EiEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi13EiE7do_testEPKiPKc = comdat any

$_Z27test_for_loop_unroll_factorILi14EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi15EiEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi11EiE7do_testEPKiPKc = comdat any

$_Z27test_for_loop_unroll_factorILi12EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi13EiEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi9EiE7do_testEPKiPKc = comdat any

$_Z27test_for_loop_unroll_factorILi10EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi11EiEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi7EiE7do_testEPKiPKc = comdat any

$_Z27test_for_loop_unroll_factorILi8EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi9EiEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi5EiE7do_testEPKiPKc = comdat any

$_Z27test_for_loop_unroll_factorILi6EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi7EiEvPKT0_iPKc = comdat any

$_ZN14for_loop_testsILi3EiE7do_testEPKiPKc = comdat any

$_Z27test_for_loop_unroll_factorILi4EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi5EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi1EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi2EiEvPKT0_iPKc = comdat any

$_Z27test_for_loop_unroll_factorILi3EiEvPKT0_iPKc = comdat any

@results = internal global ptr null, align 8
@current_test = internal global i32 0, align 4
@allocated_results = internal global i32 0, align 4
@.str = private unnamed_addr constant [31 x i8] c"Could not allocate %d results\0A\00", align 1
@start_time = internal global i64 0, align 8
@end_time = internal global i64 0, align 8
@iterations = internal global i32 1000, align 4
@init_value = internal global double 1.000000e+00, align 8
@dataDouble = internal global [8000 x double] zeroinitializer, align 16
@data32 = internal global [8000 x i32] zeroinitializer, align 16
@temp_string = internal global [32 x [100 x i8]] zeroinitializer, align 16
@.str.11 = private unnamed_addr constant [24 x i8] c"int32_t for loop unroll\00", align 1
@.str.12 = private unnamed_addr constant [26 x i8] c"int32_t while loop unroll\00", align 1
@.str.13 = private unnamed_addr constant [23 x i8] c"int32_t do loop unroll\00", align 1
@.str.14 = private unnamed_addr constant [25 x i8] c"int32_t goto loop unroll\00", align 1
@.str.15 = private unnamed_addr constant [23 x i8] c"double for loop unroll\00", align 1
@.str.16 = private unnamed_addr constant [25 x i8] c"double while loop unroll\00", align 1
@.str.17 = private unnamed_addr constant [22 x i8] c"double do loop unroll\00", align 1
@.str.18 = private unnamed_addr constant [24 x i8] c"double goto loop unroll\00", align 1
@.str.19 = private unnamed_addr constant [16 x i8] c"test %i failed\0A\00", align 1

; Function Attrs: mustprogress nounwind optsize uwtable
define internal void @_Z13record_resultdPKc(double noundef %0, ptr noundef %1) #0 {
  %3 = load ptr, ptr @results, align 8, !tbaa !7
  %4 = icmp ne ptr %3, null
  %5 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %6 = load i32, ptr @current_test, align 4
  %7 = icmp slt i32 %6, %5
  %8 = select i1 %4, i1 %7, i1 false
  br i1 %8, label %20, label %9

9:                                                ; preds = %2
  %10 = add nsw i32 %5, 10
  store i32 %10, ptr @allocated_results, align 4, !tbaa !11
  %11 = sext i32 %10 to i64
  %12 = shl nsw i64 %11, 4
  %13 = tail call ptr @realloc(ptr noundef %3, i64 noundef %12) #11
  store ptr %13, ptr @results, align 8, !tbaa !7
  %14 = icmp eq ptr %13, null
  br i1 %14, label %17, label %15

15:                                               ; preds = %9
  %16 = load i32, ptr @current_test, align 4, !tbaa !11
  br label %20

17:                                               ; preds = %9
  %18 = load i32, ptr @allocated_results, align 4, !tbaa !11
  %19 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %18) #12
  tail call void @exit(i32 noundef -1) #13
  unreachable

20:                                               ; preds = %15, %2
  %21 = phi i32 [ %16, %15 ], [ %6, %2 ]
  %22 = phi ptr [ %13, %15 ], [ %3, %2 ]
  %23 = sext i32 %21 to i64
  %24 = getelementptr inbounds %struct.one_result, ptr %22, i64 %23
  store double %0, ptr %24, align 8, !tbaa !13
  %25 = getelementptr inbounds %struct.one_result, ptr %22, i64 %23, i32 1
  store ptr %1, ptr %25, align 8, !tbaa !16
  %26 = add nsw i32 %21, 1
  store i32 %26, ptr @current_test, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress nounwind optsize willreturn allockind("realloc") allocsize(1) memory(argmem: readwrite, inaccessiblemem: readwrite)
declare noalias noundef ptr @realloc(ptr allocptr nocapture noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nofree nounwind optsize
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: noreturn nounwind optsize
declare void @exit(i32 noundef) local_unnamed_addr #3

; Function Attrs: mustprogress norecurse optsize uwtable
define dso_local noundef i32 @main(i32 noundef %0, ptr nocapture noundef readonly %1) #4 {
  %3 = icmp sgt i32 %0, 1
  br i1 %3, label %4, label %13

4:                                                ; preds = %2
  %5 = getelementptr inbounds ptr, ptr %1, i64 1
  %6 = load ptr, ptr %5, align 8, !tbaa !7
  %7 = tail call i32 @atoi(ptr nocapture noundef %6) #14
  store i32 %7, ptr @iterations, align 4, !tbaa !11
  %8 = icmp eq i32 %0, 2
  br i1 %8, label %13, label %9

9:                                                ; preds = %4
  %10 = getelementptr inbounds ptr, ptr %1, i64 2
  %11 = load ptr, ptr %10, align 8, !tbaa !7
  %12 = tail call double @atof(ptr noundef %11) #14
  store double %12, ptr @init_value, align 8, !tbaa !17
  br label %13

13:                                               ; preds = %9, %4, %2
  %14 = load double, ptr @init_value, align 8, !tbaa !17
  %15 = fptosi double %14 to i32
  %16 = insertelement <4 x i32> poison, i32 %15, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  br label %18

18:                                               ; preds = %18, %13
  %19 = phi i64 [ 0, %13 ], [ %22, %18 ]
  %20 = shl i64 %19, 2
  %21 = getelementptr i8, ptr @data32, i64 %20
  store <4 x i32> %17, ptr %21, align 16, !tbaa !11
  %22 = add nuw i64 %19, 4
  %23 = icmp eq i64 %22, 8000
  br i1 %23, label %24, label %18, !llvm.loop !18

24:                                               ; preds = %18
  tail call void @_ZN14for_loop_testsILi31EiE7do_testEPKiPKc(ptr noundef nonnull @data32, ptr noundef nonnull @.str.11) #12
  tail call void @_Z27test_for_loop_unroll_factorILi32EiEvPKT0_iPKc(ptr noundef nonnull @data32, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 31)) #12
  tail call void @_ZN16while_loop_testsILi31EiE7do_testEPKiPKc(ptr noundef nonnull @data32, ptr noundef nonnull @.str.12) #12
  tail call void @_Z29test_while_loop_unroll_factorILi32EiEvPKT0_iPKc(ptr noundef nonnull @data32, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 31)) #12
  tail call void @_ZN13do_loop_testsILi31EiE7do_testEPKiPKc(ptr noundef nonnull @data32, ptr noundef nonnull @.str.13) #12
  tail call void @_Z26test_do_loop_unroll_factorILi32EiEvPKT0_iPKc(ptr noundef nonnull @data32, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 31)) #12
  tail call void @_ZN15goto_loop_testsILi31EiE7do_testEPKiPKc(ptr noundef nonnull @data32, ptr noundef nonnull @.str.14) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi32EiEvPKT0_iPKc(ptr noundef nonnull @data32, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 31)) #12
  %25 = load i32, ptr @iterations, align 4, !tbaa !11
  %26 = sdiv i32 %25, 4
  store i32 %26, ptr @iterations, align 4, !tbaa !11
  %27 = load double, ptr @init_value, align 8, !tbaa !17
  %28 = insertelement <2 x double> poison, double %27, i64 0
  %29 = shufflevector <2 x double> %28, <2 x double> poison, <2 x i32> zeroinitializer
  br label %30

30:                                               ; preds = %30, %24
  %31 = phi i64 [ 0, %24 ], [ %34, %30 ]
  %32 = shl i64 %31, 3
  %33 = getelementptr i8, ptr @dataDouble, i64 %32
  store <2 x double> %29, ptr %33, align 16, !tbaa !17
  %34 = add nuw i64 %31, 2
  %35 = icmp eq i64 %34, 8000
  br i1 %35, label %36, label %30, !llvm.loop !22

36:                                               ; preds = %30
  tail call void @_ZN14for_loop_testsILi31EdE7do_testEPKdPKc(ptr noundef nonnull @dataDouble, ptr noundef nonnull @.str.15) #12
  tail call void @_Z27test_for_loop_unroll_factorILi32EdEvPKT0_iPKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 31)) #12
  tail call void @_ZN16while_loop_testsILi31EdE7do_testEPKdPKc(ptr noundef nonnull @dataDouble, ptr noundef nonnull @.str.16) #12
  tail call void @_Z29test_while_loop_unroll_factorILi32EdEvPKT0_iPKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 31)) #12
  tail call void @_ZN13do_loop_testsILi31EdE7do_testEPKdPKc(ptr noundef nonnull @dataDouble, ptr noundef nonnull @.str.17) #12
  tail call void @_Z26test_do_loop_unroll_factorILi32EdEvPKT0_iPKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 31)) #12
  tail call void @_ZN15goto_loop_testsILi31EdE7do_testEPKdPKc(ptr noundef nonnull @dataDouble, ptr noundef nonnull @.str.18) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi32EdEvPKT0_iPKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 31)) #12
  ret i32 0
}

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(read)
declare i32 @atoi(ptr nocapture noundef) local_unnamed_addr #5

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(read)
declare double @atof(ptr nocapture noundef) local_unnamed_addr #5

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi31EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi29EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi30EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 29)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi31EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 30)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi32EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca i32, align 4
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %63

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -31
  %10 = icmp sgt i32 %1, 31
  br label %11

11:                                               ; preds = %59, %8
  %12 = phi i32 [ 0, %8 ], [ %60, %59 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #16
  store i32 0, ptr %4, align 4, !tbaa !11
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi i32 [ 0, %11 ], [ %33, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %35, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %49

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %37

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %34, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi30EiE7do_workERiPKii(ptr noundef nonnull align 4 dereferenceable(4) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = or i64 %20, 30
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load i32, ptr %23, align 4, !tbaa !11
  %25 = mul i32 %24, 269850533
  %26 = load i32, ptr %4, align 4, !tbaa !11
  %27 = or i64 %20, 31
  %28 = getelementptr inbounds i32, ptr %0, i64 %27
  %29 = load i32, ptr %28, align 4, !tbaa !11
  %30 = mul i32 %29, 269850533
  %31 = add i32 %25, 2018317168
  %32 = add i32 %30, %26
  %33 = add i32 %31, %32
  store i32 %33, ptr %4, align 4, !tbaa !11
  %34 = add nuw i64 %20, 32
  %35 = trunc i64 %34 to i32
  %36 = icmp sgt i32 %9, %35
  br i1 %36, label %19, label %13, !llvm.loop !25

37:                                               ; preds = %37, %17
  %38 = phi i64 [ %18, %17 ], [ %45, %37 ]
  %39 = phi i32 [ %14, %17 ], [ %44, %37 ]
  %40 = getelementptr inbounds i32, ptr %0, i64 %38
  %41 = load i32, ptr %40, align 4, !tbaa !11
  %42 = mul i32 %41, 269850533
  %43 = add i32 %42, -1138325064
  %44 = add nsw i32 %43, %39
  %45 = add nuw nsw i64 %38, 1
  %46 = trunc i64 %45 to i32
  %47 = icmp slt i32 %46, %1
  br i1 %47, label %37, label %48, !llvm.loop !26

48:                                               ; preds = %37
  %.lcssa = phi i32 [ %44, %37 ]
  store i32 %.lcssa, ptr %4, align 4, !tbaa !11
  br label %49

49:                                               ; preds = %48, %13
  %50 = phi i32 [ %.lcssa, %48 ], [ %14, %13 ]
  %51 = load double, ptr @init_value, align 8, !tbaa !17
  %52 = fptosi double %51 to i32
  %53 = mul i32 %52, -1564285888
  %54 = add i32 %53, -1269844480
  %55 = icmp eq i32 %54, %50
  br i1 %55, label %59, label %56

56:                                               ; preds = %49
  %57 = load i32, ptr @current_test, align 4, !tbaa !11
  %58 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %57) #12
  br label %59

59:                                               ; preds = %56, %49
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #16
  %60 = add nuw nsw i32 %12, 1
  %61 = load i32, ptr @iterations, align 4, !tbaa !11
  %62 = icmp slt i32 %60, %61
  br i1 %62, label %11, label %63, !llvm.loop !27

63:                                               ; preds = %59, %3
  %64 = call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi31EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi29EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi30EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 29)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi31EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 30)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi32EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca i32, align 4
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %63

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -31
  %10 = icmp sgt i32 %1, 31
  br label %11

11:                                               ; preds = %59, %8
  %12 = phi i32 [ 0, %8 ], [ %60, %59 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #16
  store i32 0, ptr %4, align 4, !tbaa !11
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi i32 [ 0, %11 ], [ %33, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %35, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %49

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %37

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %34, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi30EiE7do_workERiPKii(ptr noundef nonnull align 4 dereferenceable(4) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = or i64 %20, 30
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load i32, ptr %23, align 4, !tbaa !11
  %25 = mul i32 %24, 269850533
  %26 = load i32, ptr %4, align 4, !tbaa !11
  %27 = or i64 %20, 31
  %28 = getelementptr inbounds i32, ptr %0, i64 %27
  %29 = load i32, ptr %28, align 4, !tbaa !11
  %30 = mul i32 %29, 269850533
  %31 = add i32 %25, 2018317168
  %32 = add i32 %30, %26
  %33 = add i32 %31, %32
  store i32 %33, ptr %4, align 4, !tbaa !11
  %34 = add nuw i64 %20, 32
  %35 = trunc i64 %34 to i32
  %36 = icmp sgt i32 %9, %35
  br i1 %36, label %19, label %13, !llvm.loop !28

37:                                               ; preds = %37, %17
  %38 = phi i64 [ %18, %17 ], [ %45, %37 ]
  %39 = phi i32 [ %14, %17 ], [ %44, %37 ]
  %40 = getelementptr inbounds i32, ptr %0, i64 %38
  %41 = load i32, ptr %40, align 4, !tbaa !11
  %42 = mul i32 %41, 269850533
  %43 = add i32 %42, -1138325064
  %44 = add nsw i32 %43, %39
  %45 = add nuw nsw i64 %38, 1
  %46 = trunc i64 %45 to i32
  %47 = icmp slt i32 %46, %1
  br i1 %47, label %37, label %48, !llvm.loop !29

48:                                               ; preds = %37
  %.lcssa = phi i32 [ %44, %37 ]
  store i32 %.lcssa, ptr %4, align 4, !tbaa !11
  br label %49

49:                                               ; preds = %48, %13
  %50 = phi i32 [ %.lcssa, %48 ], [ %14, %13 ]
  %51 = load double, ptr @init_value, align 8, !tbaa !17
  %52 = fptosi double %51 to i32
  %53 = mul i32 %52, -1564285888
  %54 = add i32 %53, -1269844480
  %55 = icmp eq i32 %54, %50
  br i1 %55, label %59, label %56

56:                                               ; preds = %49
  %57 = load i32, ptr @current_test, align 4, !tbaa !11
  %58 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %57) #12
  br label %59

59:                                               ; preds = %56, %49
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #16
  %60 = add nuw nsw i32 %12, 1
  %61 = load i32, ptr @iterations, align 4, !tbaa !11
  %62 = icmp slt i32 %60, %61
  br i1 %62, label %11, label %63, !llvm.loop !30

63:                                               ; preds = %59, %3
  %64 = call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi31EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi29EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi30EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 29)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi31EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 30)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi32EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca i32, align 4
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %63

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 31
  %10 = add nsw i32 %1, -31
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %59, %8
  %13 = phi i32 [ 0, %8 ], [ %60, %59 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #16
  store i32 0, ptr %4, align 4, !tbaa !11
  br i1 %9, label %14, label %32

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %29, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi30EiE7do_workERiPKii(ptr noundef nonnull align 4 dereferenceable(4) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = or i64 %15, 30
  %18 = getelementptr inbounds i32, ptr %0, i64 %17
  %19 = load i32, ptr %18, align 4, !tbaa !11
  %20 = mul i32 %19, 269850533
  %21 = load i32, ptr %4, align 4, !tbaa !11
  %22 = or i64 %15, 31
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load i32, ptr %23, align 4, !tbaa !11
  %25 = mul i32 %24, 269850533
  %26 = add i32 %20, 2018317168
  %27 = add i32 %25, %21
  %28 = add i32 %26, %27
  store i32 %28, ptr %4, align 4, !tbaa !11
  %29 = add nuw i64 %15, 32
  %30 = trunc i64 %29 to i32
  %31 = icmp sgt i32 %10, %30
  br i1 %31, label %14, label %32, !llvm.loop !31

32:                                               ; preds = %14, %12
  %33 = phi i32 [ 0, %12 ], [ %28, %14 ]
  %34 = phi i32 [ 0, %12 ], [ %30, %14 ]
  %35 = icmp slt i32 %34, %1
  br i1 %35, label %36, label %49

36:                                               ; preds = %32
  %37 = sext i32 %34 to i64
  br label %38

38:                                               ; preds = %38, %36
  %39 = phi i64 [ %37, %36 ], [ %46, %38 ]
  %40 = phi i32 [ %33, %36 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %43, -1138325064
  %45 = add nsw i32 %44, %40
  %46 = add nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38, !llvm.loop !32

48:                                               ; preds = %38
  %.lcssa = phi i32 [ %45, %38 ]
  store i32 %.lcssa, ptr %4, align 4, !tbaa !11
  br label %49

49:                                               ; preds = %48, %32
  %50 = phi i32 [ %.lcssa, %48 ], [ %33, %32 ]
  %51 = load double, ptr @init_value, align 8, !tbaa !17
  %52 = fptosi double %51 to i32
  %53 = mul i32 %52, -1564285888
  %54 = add i32 %53, -1269844480
  %55 = icmp eq i32 %54, %50
  br i1 %55, label %59, label %56

56:                                               ; preds = %49
  %57 = load i32, ptr @current_test, align 4, !tbaa !11
  %58 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %57) #12
  br label %59

59:                                               ; preds = %56, %49
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #16
  %60 = add nuw nsw i32 %13, 1
  %61 = load i32, ptr @iterations, align 4, !tbaa !11
  %62 = icmp slt i32 %60, %61
  br i1 %62, label %12, label %63, !llvm.loop !33

63:                                               ; preds = %59, %3
  %64 = call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi31EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi29EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi30EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 29)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi31EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 30)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi32EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca i32, align 4
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %63

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 31
  %10 = add nsw i32 %1, -31
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %59, %8
  %13 = phi i32 [ 0, %8 ], [ %60, %59 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #16
  store i32 0, ptr %4, align 4, !tbaa !11
  br i1 %9, label %14, label %32

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %29, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi30EiE7do_workERiPKii(ptr noundef nonnull align 4 dereferenceable(4) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = or i64 %15, 30
  %18 = getelementptr inbounds i32, ptr %0, i64 %17
  %19 = load i32, ptr %18, align 4, !tbaa !11
  %20 = mul i32 %19, 269850533
  %21 = load i32, ptr %4, align 4, !tbaa !11
  %22 = or i64 %15, 31
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load i32, ptr %23, align 4, !tbaa !11
  %25 = mul i32 %24, 269850533
  %26 = add i32 %20, 2018317168
  %27 = add i32 %25, %21
  %28 = add i32 %26, %27
  store i32 %28, ptr %4, align 4, !tbaa !11
  %29 = add nuw i64 %15, 32
  %30 = trunc i64 %29 to i32
  %31 = icmp sgt i32 %10, %30
  br i1 %31, label %14, label %32

32:                                               ; preds = %14, %12
  %33 = phi i32 [ 0, %12 ], [ %28, %14 ]
  %34 = phi i32 [ 0, %12 ], [ %30, %14 ]
  %35 = icmp slt i32 %34, %1
  br i1 %35, label %36, label %49

36:                                               ; preds = %32
  %37 = sext i32 %34 to i64
  br label %38

38:                                               ; preds = %38, %36
  %39 = phi i64 [ %37, %36 ], [ %46, %38 ]
  %40 = phi i32 [ %33, %36 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %43, -1138325064
  %45 = add nsw i32 %44, %40
  %46 = add nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38

48:                                               ; preds = %38
  %.lcssa = phi i32 [ %45, %38 ]
  store i32 %.lcssa, ptr %4, align 4, !tbaa !11
  br label %49

49:                                               ; preds = %48, %32
  %50 = phi i32 [ %.lcssa, %48 ], [ %33, %32 ]
  %51 = load double, ptr @init_value, align 8, !tbaa !17
  %52 = fptosi double %51 to i32
  %53 = mul i32 %52, -1564285888
  %54 = add i32 %53, -1269844480
  %55 = icmp eq i32 %54, %50
  br i1 %55, label %59, label %56

56:                                               ; preds = %49
  %57 = load i32, ptr @current_test, align 4, !tbaa !11
  %58 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %57) #12
  br label %59

59:                                               ; preds = %56, %49
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #16
  %60 = add nuw nsw i32 %13, 1
  %61 = load i32, ptr @iterations, align 4, !tbaa !11
  %62 = icmp slt i32 %60, %61
  br i1 %62, label %12, label %63, !llvm.loop !34

63:                                               ; preds = %59, %3
  %64 = call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi31EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi29EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi30EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 29)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi31EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 30)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi32EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %106

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -31
  %10 = icmp sgt i32 %1, 31
  br label %11

11:                                               ; preds = %102, %8
  %12 = phi i32 [ 0, %8 ], [ %103, %102 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %62, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %64, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %82

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %66

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %63, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = or i64 %20, 28
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = or i64 %20, 29
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = or i64 %20, 30
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  %53 = or i64 %20, 31
  %54 = getelementptr inbounds double, ptr %0, i64 %53
  %55 = load double, ptr %54, align 8, !tbaa !17
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %57, 1.234500e+04
  %59 = call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %52, %61
  store double %62, ptr %4, align 8, !tbaa !17
  %63 = add nuw i64 %20, 32
  %64 = trunc i64 %63 to i32
  %65 = icmp sgt i32 %9, %64
  br i1 %65, label %19, label %13, !llvm.loop !35

66:                                               ; preds = %66, %17
  %67 = phi i64 [ %18, %17 ], [ %78, %66 ]
  %68 = phi double [ %14, %17 ], [ %77, %66 ]
  %69 = getelementptr inbounds double, ptr %0, i64 %67
  %70 = load double, ptr %69, align 8, !tbaa !17
  %71 = fadd double %70, 1.234500e+04
  %72 = call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %68, %76
  %78 = add nuw nsw i64 %67, 1
  %79 = trunc i64 %78 to i32
  %80 = icmp slt i32 %79, %1
  br i1 %80, label %66, label %81, !llvm.loop !36

81:                                               ; preds = %66
  %.lcssa = phi double [ %77, %66 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %82

82:                                               ; preds = %81, %13
  %83 = phi double [ %.lcssa, %81 ], [ %14, %13 ]
  %84 = load double, ptr @init_value, align 8, !tbaa !17
  %85 = fadd double %84, 1.234500e+04
  %86 = call double @llvm.fmuladd.f64(double %85, double 9.142370e+05, double -1.300000e+01)
  %87 = fadd double %86, 1.234500e+04
  %88 = call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fmul double %90, 8.000000e+03
  %92 = fsub double %83, %91
  %93 = call double @llvm.fabs.f64(double %83)
  %94 = fcmp ogt double %93, 1.000000e-08
  %95 = select i1 %94, double %83, double 1.000000e+00
  %96 = fdiv double %92, %95
  %97 = call double @llvm.fabs.f64(double %96)
  %98 = fcmp olt double %97, 0x3EB0C6F7A0B5ED8D
  br i1 %98, label %102, label %99

99:                                               ; preds = %82
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  %101 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %100) #12
  br label %102

102:                                              ; preds = %99, %82
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %103 = add nuw nsw i32 %12, 1
  %104 = load i32, ptr @iterations, align 4, !tbaa !11
  %105 = icmp slt i32 %103, %104
  br i1 %105, label %11, label %106, !llvm.loop !37

106:                                              ; preds = %102, %3
  %107 = call i64 @clock() #15
  store i64 %107, ptr @end_time, align 8, !tbaa !23
  %108 = load i64, ptr @start_time, align 8, !tbaa !23
  %109 = sub nsw i64 %107, %108
  %110 = sitofp i64 %109 to double
  %111 = fdiv double %110, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %111, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi31EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi29EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi30EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 29)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi31EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 30)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi32EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %106

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -31
  %10 = icmp sgt i32 %1, 31
  br label %11

11:                                               ; preds = %102, %8
  %12 = phi i32 [ 0, %8 ], [ %103, %102 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %62, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %64, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %82

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %66

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %63, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = or i64 %20, 28
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = or i64 %20, 29
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = or i64 %20, 30
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  %53 = or i64 %20, 31
  %54 = getelementptr inbounds double, ptr %0, i64 %53
  %55 = load double, ptr %54, align 8, !tbaa !17
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %57, 1.234500e+04
  %59 = call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %52, %61
  store double %62, ptr %4, align 8, !tbaa !17
  %63 = add nuw i64 %20, 32
  %64 = trunc i64 %63 to i32
  %65 = icmp sgt i32 %9, %64
  br i1 %65, label %19, label %13, !llvm.loop !38

66:                                               ; preds = %66, %17
  %67 = phi i64 [ %18, %17 ], [ %78, %66 ]
  %68 = phi double [ %14, %17 ], [ %77, %66 ]
  %69 = getelementptr inbounds double, ptr %0, i64 %67
  %70 = load double, ptr %69, align 8, !tbaa !17
  %71 = fadd double %70, 1.234500e+04
  %72 = call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %68, %76
  %78 = add nuw nsw i64 %67, 1
  %79 = trunc i64 %78 to i32
  %80 = icmp slt i32 %79, %1
  br i1 %80, label %66, label %81, !llvm.loop !39

81:                                               ; preds = %66
  %.lcssa = phi double [ %77, %66 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %82

82:                                               ; preds = %81, %13
  %83 = phi double [ %.lcssa, %81 ], [ %14, %13 ]
  %84 = load double, ptr @init_value, align 8, !tbaa !17
  %85 = fadd double %84, 1.234500e+04
  %86 = call double @llvm.fmuladd.f64(double %85, double 9.142370e+05, double -1.300000e+01)
  %87 = fadd double %86, 1.234500e+04
  %88 = call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fmul double %90, 8.000000e+03
  %92 = fsub double %83, %91
  %93 = call double @llvm.fabs.f64(double %83)
  %94 = fcmp ogt double %93, 1.000000e-08
  %95 = select i1 %94, double %83, double 1.000000e+00
  %96 = fdiv double %92, %95
  %97 = call double @llvm.fabs.f64(double %96)
  %98 = fcmp olt double %97, 0x3EB0C6F7A0B5ED8D
  br i1 %98, label %102, label %99

99:                                               ; preds = %82
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  %101 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %100) #12
  br label %102

102:                                              ; preds = %99, %82
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %103 = add nuw nsw i32 %12, 1
  %104 = load i32, ptr @iterations, align 4, !tbaa !11
  %105 = icmp slt i32 %103, %104
  br i1 %105, label %11, label %106, !llvm.loop !40

106:                                              ; preds = %102, %3
  %107 = call i64 @clock() #15
  store i64 %107, ptr @end_time, align 8, !tbaa !23
  %108 = load i64, ptr @start_time, align 8, !tbaa !23
  %109 = sub nsw i64 %107, %108
  %110 = sitofp i64 %109 to double
  %111 = fdiv double %110, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %111, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi31EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi29EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi30EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 29)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi31EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 30)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi32EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %106

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 31
  %10 = add nsw i32 %1, -31
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %102, %8
  %13 = phi i32 [ 0, %8 ], [ %103, %102 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %61

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %58, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = or i64 %15, 28
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = or i64 %15, 29
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = or i64 %15, 30
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  %48 = or i64 %15, 31
  %49 = getelementptr inbounds double, ptr %0, i64 %48
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %47, %56
  store double %57, ptr %4, align 8, !tbaa !17
  %58 = add nuw i64 %15, 32
  %59 = trunc i64 %58 to i32
  %60 = icmp sgt i32 %10, %59
  br i1 %60, label %14, label %61, !llvm.loop !41

61:                                               ; preds = %14, %12
  %62 = phi double [ 0.000000e+00, %12 ], [ %57, %14 ]
  %63 = phi i32 [ 0, %12 ], [ %59, %14 ]
  %64 = icmp slt i32 %63, %1
  br i1 %64, label %65, label %82

65:                                               ; preds = %61
  %66 = sext i32 %63 to i64
  br label %67

67:                                               ; preds = %67, %65
  %68 = phi i64 [ %66, %65 ], [ %79, %67 ]
  %69 = phi double [ %62, %65 ], [ %78, %67 ]
  %70 = getelementptr inbounds double, ptr %0, i64 %68
  %71 = load double, ptr %70, align 8, !tbaa !17
  %72 = fadd double %71, 1.234500e+04
  %73 = call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %75, 1.234500e+04
  %77 = call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %69, %77
  %79 = add nsw i64 %68, 1
  %80 = icmp eq i64 %79, %11
  br i1 %80, label %81, label %67, !llvm.loop !42

81:                                               ; preds = %67
  %.lcssa = phi double [ %78, %67 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %82

82:                                               ; preds = %81, %61
  %83 = phi double [ %.lcssa, %81 ], [ %62, %61 ]
  %84 = load double, ptr @init_value, align 8, !tbaa !17
  %85 = fadd double %84, 1.234500e+04
  %86 = call double @llvm.fmuladd.f64(double %85, double 9.142370e+05, double -1.300000e+01)
  %87 = fadd double %86, 1.234500e+04
  %88 = call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fmul double %90, 8.000000e+03
  %92 = fsub double %83, %91
  %93 = call double @llvm.fabs.f64(double %83)
  %94 = fcmp ogt double %93, 1.000000e-08
  %95 = select i1 %94, double %83, double 1.000000e+00
  %96 = fdiv double %92, %95
  %97 = call double @llvm.fabs.f64(double %96)
  %98 = fcmp olt double %97, 0x3EB0C6F7A0B5ED8D
  br i1 %98, label %102, label %99

99:                                               ; preds = %82
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  %101 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %100) #12
  br label %102

102:                                              ; preds = %99, %82
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %103 = add nuw nsw i32 %13, 1
  %104 = load i32, ptr @iterations, align 4, !tbaa !11
  %105 = icmp slt i32 %103, %104
  br i1 %105, label %12, label %106, !llvm.loop !43

106:                                              ; preds = %102, %3
  %107 = call i64 @clock() #15
  store i64 %107, ptr @end_time, align 8, !tbaa !23
  %108 = load i64, ptr @start_time, align 8, !tbaa !23
  %109 = sub nsw i64 %107, %108
  %110 = sitofp i64 %109 to double
  %111 = fdiv double %110, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %111, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi31EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi29EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi30EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 29)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi31EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 30)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi32EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %106

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 31
  %10 = add nsw i32 %1, -31
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %102, %8
  %13 = phi i32 [ 0, %8 ], [ %103, %102 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %61

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %58, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = or i64 %15, 28
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = or i64 %15, 29
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = or i64 %15, 30
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  %48 = or i64 %15, 31
  %49 = getelementptr inbounds double, ptr %0, i64 %48
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %47, %56
  store double %57, ptr %4, align 8, !tbaa !17
  %58 = add nuw i64 %15, 32
  %59 = trunc i64 %58 to i32
  %60 = icmp sgt i32 %10, %59
  br i1 %60, label %14, label %61

61:                                               ; preds = %14, %12
  %62 = phi double [ 0.000000e+00, %12 ], [ %57, %14 ]
  %63 = phi i32 [ 0, %12 ], [ %59, %14 ]
  %64 = icmp slt i32 %63, %1
  br i1 %64, label %65, label %82

65:                                               ; preds = %61
  %66 = sext i32 %63 to i64
  br label %67

67:                                               ; preds = %67, %65
  %68 = phi i64 [ %66, %65 ], [ %79, %67 ]
  %69 = phi double [ %62, %65 ], [ %78, %67 ]
  %70 = getelementptr inbounds double, ptr %0, i64 %68
  %71 = load double, ptr %70, align 8, !tbaa !17
  %72 = fadd double %71, 1.234500e+04
  %73 = call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %75, 1.234500e+04
  %77 = call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %69, %77
  %79 = add nsw i64 %68, 1
  %80 = icmp eq i64 %79, %11
  br i1 %80, label %81, label %67

81:                                               ; preds = %67
  %.lcssa = phi double [ %78, %67 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %82

82:                                               ; preds = %81, %61
  %83 = phi double [ %.lcssa, %81 ], [ %62, %61 ]
  %84 = load double, ptr @init_value, align 8, !tbaa !17
  %85 = fadd double %84, 1.234500e+04
  %86 = call double @llvm.fmuladd.f64(double %85, double 9.142370e+05, double -1.300000e+01)
  %87 = fadd double %86, 1.234500e+04
  %88 = call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fmul double %90, 8.000000e+03
  %92 = fsub double %83, %91
  %93 = call double @llvm.fabs.f64(double %83)
  %94 = fcmp ogt double %93, 1.000000e-08
  %95 = select i1 %94, double %83, double 1.000000e+00
  %96 = fdiv double %92, %95
  %97 = call double @llvm.fabs.f64(double %96)
  %98 = fcmp olt double %97, 0x3EB0C6F7A0B5ED8D
  br i1 %98, label %102, label %99

99:                                               ; preds = %82
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  %101 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %100) #12
  br label %102

102:                                              ; preds = %99, %82
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %103 = add nuw nsw i32 %13, 1
  %104 = load i32, ptr @iterations, align 4, !tbaa !11
  %105 = icmp slt i32 %103, %104
  br i1 %105, label %12, label %106, !llvm.loop !44

106:                                              ; preds = %102, %3
  %107 = call i64 @clock() #15
  store i64 %107, ptr @end_time, align 8, !tbaa !23
  %108 = load i64, ptr @start_time, align 8, !tbaa !23
  %109 = sub nsw i64 %107, %108
  %110 = sitofp i64 %109 to double
  %111 = fdiv double %110, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %111, ptr noundef %2) #12
  ret void
}

; Function Attrs: nounwind optsize
declare i64 @clock() local_unnamed_addr #7

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #8

; Function Attrs: inlinehint mustprogress optsize uwtable
define internal void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef %1, i32 noundef %2) #9 comdat align 2 {
  tail call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef %1, i32 noundef %2) #12
  %4 = add nsw i32 %2, 19
  %5 = sext i32 %4 to i64
  %6 = getelementptr inbounds double, ptr %1, i64 %5
  %7 = load double, ptr %6, align 8, !tbaa !17
  %8 = fadd double %7, 1.234500e+04
  %9 = tail call double @llvm.fmuladd.f64(double %8, double 9.142370e+05, double -1.300000e+01)
  %10 = fadd double %9, 1.234500e+04
  %11 = tail call double @llvm.fmuladd.f64(double %10, double 9.142370e+05, double -1.300000e+01)
  %12 = fadd double %11, 1.234500e+04
  %13 = tail call double @llvm.fmuladd.f64(double %12, double 9.142370e+05, double -1.300000e+01)
  %14 = load double, ptr %0, align 8, !tbaa !17
  %15 = fadd double %14, %13
  store double %15, ptr %0, align 8, !tbaa !17
  %16 = add nsw i32 %2, 20
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds double, ptr %1, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %15, %25
  store double %26, ptr %0, align 8, !tbaa !17
  %27 = add nsw i32 %2, 21
  %28 = sext i32 %27 to i64
  %29 = getelementptr inbounds double, ptr %1, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = tail call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %26, %36
  store double %37, ptr %0, align 8, !tbaa !17
  %38 = add nsw i32 %2, 22
  %39 = sext i32 %38 to i64
  %40 = getelementptr inbounds double, ptr %1, i64 %39
  %41 = load double, ptr %40, align 8, !tbaa !17
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %45, 1.234500e+04
  %47 = tail call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %37, %47
  store double %48, ptr %0, align 8, !tbaa !17
  %49 = add nsw i32 %2, 23
  %50 = sext i32 %49 to i64
  %51 = getelementptr inbounds double, ptr %1, i64 %50
  %52 = load double, ptr %51, align 8, !tbaa !17
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = tail call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %48, %58
  store double %59, ptr %0, align 8, !tbaa !17
  %60 = add nsw i32 %2, 24
  %61 = sext i32 %60 to i64
  %62 = getelementptr inbounds double, ptr %1, i64 %61
  %63 = load double, ptr %62, align 8, !tbaa !17
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %65, 1.234500e+04
  %67 = tail call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %59, %69
  store double %70, ptr %0, align 8, !tbaa !17
  %71 = add nsw i32 %2, 25
  %72 = sext i32 %71 to i64
  %73 = getelementptr inbounds double, ptr %1, i64 %72
  %74 = load double, ptr %73, align 8, !tbaa !17
  %75 = fadd double %74, 1.234500e+04
  %76 = tail call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %70, %80
  store double %81, ptr %0, align 8, !tbaa !17
  %82 = add nsw i32 %2, 26
  %83 = sext i32 %82 to i64
  %84 = getelementptr inbounds double, ptr %1, i64 %83
  %85 = load double, ptr %84, align 8, !tbaa !17
  %86 = fadd double %85, 1.234500e+04
  %87 = tail call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %87, 1.234500e+04
  %89 = tail call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fadd double %89, 1.234500e+04
  %91 = tail call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %81, %91
  store double %92, ptr %0, align 8, !tbaa !17
  %93 = add nsw i32 %2, 27
  %94 = sext i32 %93 to i64
  %95 = getelementptr inbounds double, ptr %1, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %92, %102
  store double %103, ptr %0, align 8, !tbaa !17
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fmuladd.f64(double, double, double) #10

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fabs.f64(double) #10

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #8

; Function Attrs: inlinehint mustprogress optsize uwtable
define internal void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef %1, i32 noundef %2) #9 comdat align 2 {
  tail call void @_ZN15loop_inner_bodyILi10EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef %1, i32 noundef %2) #12
  %4 = add nsw i32 %2, 10
  %5 = sext i32 %4 to i64
  %6 = getelementptr inbounds double, ptr %1, i64 %5
  %7 = load double, ptr %6, align 8, !tbaa !17
  %8 = fadd double %7, 1.234500e+04
  %9 = tail call double @llvm.fmuladd.f64(double %8, double 9.142370e+05, double -1.300000e+01)
  %10 = fadd double %9, 1.234500e+04
  %11 = tail call double @llvm.fmuladd.f64(double %10, double 9.142370e+05, double -1.300000e+01)
  %12 = fadd double %11, 1.234500e+04
  %13 = tail call double @llvm.fmuladd.f64(double %12, double 9.142370e+05, double -1.300000e+01)
  %14 = load double, ptr %0, align 8, !tbaa !17
  %15 = fadd double %14, %13
  store double %15, ptr %0, align 8, !tbaa !17
  %16 = add nsw i32 %2, 11
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds double, ptr %1, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %15, %25
  store double %26, ptr %0, align 8, !tbaa !17
  %27 = add nsw i32 %2, 12
  %28 = sext i32 %27 to i64
  %29 = getelementptr inbounds double, ptr %1, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = tail call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %26, %36
  store double %37, ptr %0, align 8, !tbaa !17
  %38 = add nsw i32 %2, 13
  %39 = sext i32 %38 to i64
  %40 = getelementptr inbounds double, ptr %1, i64 %39
  %41 = load double, ptr %40, align 8, !tbaa !17
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %45, 1.234500e+04
  %47 = tail call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %37, %47
  store double %48, ptr %0, align 8, !tbaa !17
  %49 = add nsw i32 %2, 14
  %50 = sext i32 %49 to i64
  %51 = getelementptr inbounds double, ptr %1, i64 %50
  %52 = load double, ptr %51, align 8, !tbaa !17
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = tail call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %48, %58
  store double %59, ptr %0, align 8, !tbaa !17
  %60 = add nsw i32 %2, 15
  %61 = sext i32 %60 to i64
  %62 = getelementptr inbounds double, ptr %1, i64 %61
  %63 = load double, ptr %62, align 8, !tbaa !17
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %65, 1.234500e+04
  %67 = tail call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %59, %69
  store double %70, ptr %0, align 8, !tbaa !17
  %71 = add nsw i32 %2, 16
  %72 = sext i32 %71 to i64
  %73 = getelementptr inbounds double, ptr %1, i64 %72
  %74 = load double, ptr %73, align 8, !tbaa !17
  %75 = fadd double %74, 1.234500e+04
  %76 = tail call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %70, %80
  store double %81, ptr %0, align 8, !tbaa !17
  %82 = add nsw i32 %2, 17
  %83 = sext i32 %82 to i64
  %84 = getelementptr inbounds double, ptr %1, i64 %83
  %85 = load double, ptr %84, align 8, !tbaa !17
  %86 = fadd double %85, 1.234500e+04
  %87 = tail call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %87, 1.234500e+04
  %89 = tail call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fadd double %89, 1.234500e+04
  %91 = tail call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %81, %91
  store double %92, ptr %0, align 8, !tbaa !17
  %93 = add nsw i32 %2, 18
  %94 = sext i32 %93 to i64
  %95 = getelementptr inbounds double, ptr %1, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %92, %102
  store double %103, ptr %0, align 8, !tbaa !17
  ret void
}

; Function Attrs: inlinehint mustprogress optsize uwtable
define internal void @_ZN15loop_inner_bodyILi10EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef %1, i32 noundef %2) #9 comdat align 2 {
  %4 = sext i32 %2 to i64
  %5 = getelementptr inbounds double, ptr %1, i64 %4
  %6 = load double, ptr %5, align 8, !tbaa !17
  %7 = fadd double %6, 1.234500e+04
  %8 = tail call double @llvm.fmuladd.f64(double %7, double 9.142370e+05, double -1.300000e+01)
  %9 = fadd double %8, 1.234500e+04
  %10 = tail call double @llvm.fmuladd.f64(double %9, double 9.142370e+05, double -1.300000e+01)
  %11 = fadd double %10, 1.234500e+04
  %12 = tail call double @llvm.fmuladd.f64(double %11, double 9.142370e+05, double -1.300000e+01)
  %13 = load double, ptr %0, align 8, !tbaa !17
  %14 = fadd double %13, %12
  store double %14, ptr %0, align 8, !tbaa !17
  %15 = add nsw i32 %2, 1
  %16 = sext i32 %15 to i64
  %17 = getelementptr inbounds double, ptr %1, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %14, %24
  store double %25, ptr %0, align 8, !tbaa !17
  %26 = add nsw i32 %2, 2
  %27 = sext i32 %26 to i64
  %28 = getelementptr inbounds double, ptr %1, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %25, %35
  store double %36, ptr %0, align 8, !tbaa !17
  %37 = add nsw i32 %2, 3
  %38 = sext i32 %37 to i64
  %39 = getelementptr inbounds double, ptr %1, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = tail call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %36, %46
  store double %47, ptr %0, align 8, !tbaa !17
  %48 = add nsw i32 %2, 4
  %49 = sext i32 %48 to i64
  %50 = getelementptr inbounds double, ptr %1, i64 %49
  %51 = load double, ptr %50, align 8, !tbaa !17
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %55, 1.234500e+04
  %57 = tail call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %47, %57
  store double %58, ptr %0, align 8, !tbaa !17
  %59 = add nsw i32 %2, 5
  %60 = sext i32 %59 to i64
  %61 = getelementptr inbounds double, ptr %1, i64 %60
  %62 = load double, ptr %61, align 8, !tbaa !17
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %64, 1.234500e+04
  %66 = tail call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %58, %68
  store double %69, ptr %0, align 8, !tbaa !17
  %70 = add nsw i32 %2, 6
  %71 = sext i32 %70 to i64
  %72 = getelementptr inbounds double, ptr %1, i64 %71
  %73 = load double, ptr %72, align 8, !tbaa !17
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %75, 1.234500e+04
  %77 = tail call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %77, 1.234500e+04
  %79 = tail call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fadd double %69, %79
  store double %80, ptr %0, align 8, !tbaa !17
  %81 = add nsw i32 %2, 7
  %82 = sext i32 %81 to i64
  %83 = getelementptr inbounds double, ptr %1, i64 %82
  %84 = load double, ptr %83, align 8, !tbaa !17
  %85 = fadd double %84, 1.234500e+04
  %86 = tail call double @llvm.fmuladd.f64(double %85, double 9.142370e+05, double -1.300000e+01)
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %80, %90
  store double %91, ptr %0, align 8, !tbaa !17
  %92 = add nsw i32 %2, 8
  %93 = sext i32 %92 to i64
  %94 = getelementptr inbounds double, ptr %1, i64 %93
  %95 = load double, ptr %94, align 8, !tbaa !17
  %96 = fadd double %95, 1.234500e+04
  %97 = tail call double @llvm.fmuladd.f64(double %96, double 9.142370e+05, double -1.300000e+01)
  %98 = fadd double %97, 1.234500e+04
  %99 = tail call double @llvm.fmuladd.f64(double %98, double 9.142370e+05, double -1.300000e+01)
  %100 = fadd double %99, 1.234500e+04
  %101 = tail call double @llvm.fmuladd.f64(double %100, double 9.142370e+05, double -1.300000e+01)
  %102 = fadd double %91, %101
  store double %102, ptr %0, align 8, !tbaa !17
  %103 = add nsw i32 %2, 9
  %104 = sext i32 %103 to i64
  %105 = getelementptr inbounds double, ptr %1, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %102, %112
  store double %113, ptr %0, align 8, !tbaa !17
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi29EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi27EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi28EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 27)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi29EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 28)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi30EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 29
  %10 = add nsw i32 %1, -29
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %82, %8
  %13 = phi i32 [ 0, %8 ], [ %83, %82 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %41

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %38, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 28
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 29
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  store double %37, ptr %4, align 8, !tbaa !17
  %38 = add nuw i64 %15, 30
  %39 = trunc i64 %38 to i32
  %40 = icmp sgt i32 %10, %39
  br i1 %40, label %14, label %41

41:                                               ; preds = %14, %12
  %42 = phi double [ 0.000000e+00, %12 ], [ %37, %14 ]
  %43 = phi i32 [ 0, %12 ], [ %39, %14 ]
  %44 = icmp slt i32 %43, %1
  br i1 %44, label %45, label %62

45:                                               ; preds = %41
  %46 = sext i32 %43 to i64
  br label %47

47:                                               ; preds = %47, %45
  %48 = phi i64 [ %46, %45 ], [ %59, %47 ]
  %49 = phi double [ %42, %45 ], [ %58, %47 ]
  %50 = getelementptr inbounds double, ptr %0, i64 %48
  %51 = load double, ptr %50, align 8, !tbaa !17
  %52 = fadd double %51, 1.234500e+04
  %53 = call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %49, %57
  %59 = add nsw i64 %48, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %47

61:                                               ; preds = %47
  %.lcssa = phi double [ %58, %47 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %62

62:                                               ; preds = %61, %41
  %63 = phi double [ %.lcssa, %61 ], [ %42, %41 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !17
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %66, 1.234500e+04
  %68 = call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fmul double %70, 8.000000e+03
  %72 = fsub double %63, %71
  %73 = call double @llvm.fabs.f64(double %63)
  %74 = fcmp ogt double %73, 1.000000e-08
  %75 = select i1 %74, double %63, double 1.000000e+00
  %76 = fdiv double %72, %75
  %77 = call double @llvm.fabs.f64(double %76)
  %78 = fcmp olt double %77, 0x3EB0C6F7A0B5ED8D
  br i1 %78, label %82, label %79

79:                                               ; preds = %62
  %80 = load i32, ptr @current_test, align 4, !tbaa !11
  %81 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %80) #12
  br label %82

82:                                               ; preds = %79, %62
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %83 = add nuw nsw i32 %13, 1
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  %85 = icmp slt i32 %83, %84
  br i1 %85, label %12, label %86, !llvm.loop !45

86:                                               ; preds = %82, %3
  %87 = call i64 @clock() #15
  store i64 %87, ptr @end_time, align 8, !tbaa !23
  %88 = load i64, ptr @start_time, align 8, !tbaa !23
  %89 = sub nsw i64 %87, %88
  %90 = sitofp i64 %89 to double
  %91 = fdiv double %90, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %91, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi31EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %96

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 30
  %10 = add nsw i32 %1, -30
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %92, %8
  %13 = phi i32 [ 0, %8 ], [ %93, %92 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %51

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %48, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 28
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 29
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = add nuw nsw i64 %15, 30
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  store double %47, ptr %4, align 8, !tbaa !17
  %48 = add nuw i64 %15, 31
  %49 = trunc i64 %48 to i32
  %50 = icmp sgt i32 %10, %49
  br i1 %50, label %14, label %51

51:                                               ; preds = %14, %12
  %52 = phi double [ 0.000000e+00, %12 ], [ %47, %14 ]
  %53 = phi i32 [ 0, %12 ], [ %49, %14 ]
  %54 = icmp slt i32 %53, %1
  br i1 %54, label %55, label %72

55:                                               ; preds = %51
  %56 = sext i32 %53 to i64
  br label %57

57:                                               ; preds = %57, %55
  %58 = phi i64 [ %56, %55 ], [ %69, %57 ]
  %59 = phi double [ %52, %55 ], [ %68, %57 ]
  %60 = getelementptr inbounds double, ptr %0, i64 %58
  %61 = load double, ptr %60, align 8, !tbaa !17
  %62 = fadd double %61, 1.234500e+04
  %63 = call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %65, 1.234500e+04
  %67 = call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %59, %67
  %69 = add nsw i64 %58, 1
  %70 = icmp eq i64 %69, %11
  br i1 %70, label %71, label %57

71:                                               ; preds = %57
  %.lcssa = phi double [ %68, %57 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %72

72:                                               ; preds = %71, %51
  %73 = phi double [ %.lcssa, %71 ], [ %52, %51 ]
  %74 = load double, ptr @init_value, align 8, !tbaa !17
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %76, 1.234500e+04
  %78 = call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fmul double %80, 8.000000e+03
  %82 = fsub double %73, %81
  %83 = call double @llvm.fabs.f64(double %73)
  %84 = fcmp ogt double %83, 1.000000e-08
  %85 = select i1 %84, double %73, double 1.000000e+00
  %86 = fdiv double %82, %85
  %87 = call double @llvm.fabs.f64(double %86)
  %88 = fcmp olt double %87, 0x3EB0C6F7A0B5ED8D
  br i1 %88, label %92, label %89

89:                                               ; preds = %72
  %90 = load i32, ptr @current_test, align 4, !tbaa !11
  %91 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %90) #12
  br label %92

92:                                               ; preds = %89, %72
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %93 = add nuw nsw i32 %13, 1
  %94 = load i32, ptr @iterations, align 4, !tbaa !11
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %12, label %96, !llvm.loop !46

96:                                               ; preds = %92, %3
  %97 = call i64 @clock() #15
  store i64 %97, ptr @end_time, align 8, !tbaa !23
  %98 = load i64, ptr @start_time, align 8, !tbaa !23
  %99 = sub nsw i64 %97, %98
  %100 = sitofp i64 %99 to double
  %101 = fdiv double %100, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %101, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi27EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi25EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi26EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 25)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi27EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 26)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi28EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %65

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 27
  %10 = add nsw i32 %1, -27
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %61, %8
  %13 = phi i32 [ 0, %8 ], [ %62, %61 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %20

14:                                               ; preds = %14, %12
  %15 = phi i32 [ %16, %14 ], [ 0, %12 ]
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %15) #12
  %16 = add nuw nsw i32 %15, 28
  %17 = icmp slt i32 %16, %10
  br i1 %17, label %14, label %18

18:                                               ; preds = %14
  %.lcssa = phi i32 [ %16, %14 ]
  %19 = load double, ptr %4, align 8, !tbaa !17
  br label %20

20:                                               ; preds = %18, %12
  %21 = phi double [ 0.000000e+00, %12 ], [ %19, %18 ]
  %22 = phi i32 [ 0, %12 ], [ %.lcssa, %18 ]
  %23 = icmp slt i32 %22, %1
  br i1 %23, label %24, label %41

24:                                               ; preds = %20
  %25 = sext i32 %22 to i64
  br label %26

26:                                               ; preds = %26, %24
  %27 = phi i64 [ %25, %24 ], [ %38, %26 ]
  %28 = phi double [ %21, %24 ], [ %37, %26 ]
  %29 = getelementptr inbounds double, ptr %0, i64 %27
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %28, %36
  %38 = add nsw i64 %27, 1
  %39 = icmp eq i64 %38, %11
  br i1 %39, label %40, label %26

40:                                               ; preds = %26
  %.lcssa1 = phi double [ %37, %26 ]
  store double %.lcssa1, ptr %4, align 8, !tbaa !17
  br label %41

41:                                               ; preds = %40, %20
  %42 = phi double [ %.lcssa1, %40 ], [ %21, %20 ]
  %43 = load double, ptr @init_value, align 8, !tbaa !17
  %44 = fadd double %43, 1.234500e+04
  %45 = call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fmul double %49, 8.000000e+03
  %51 = fsub double %42, %50
  %52 = call double @llvm.fabs.f64(double %42)
  %53 = fcmp ogt double %52, 1.000000e-08
  %54 = select i1 %53, double %42, double 1.000000e+00
  %55 = fdiv double %51, %54
  %56 = call double @llvm.fabs.f64(double %55)
  %57 = fcmp olt double %56, 0x3EB0C6F7A0B5ED8D
  br i1 %57, label %61, label %58

58:                                               ; preds = %41
  %59 = load i32, ptr @current_test, align 4, !tbaa !11
  %60 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %59) #12
  br label %61

61:                                               ; preds = %58, %41
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %62 = add nuw nsw i32 %13, 1
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  %64 = icmp slt i32 %62, %63
  br i1 %64, label %12, label %65, !llvm.loop !47

65:                                               ; preds = %61, %3
  %66 = call i64 @clock() #15
  store i64 %66, ptr @end_time, align 8, !tbaa !23
  %67 = load i64, ptr @start_time, align 8, !tbaa !23
  %68 = sub nsw i64 %66, %67
  %69 = sitofp i64 %68 to double
  %70 = fdiv double %69, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %70, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi29EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %76

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 28
  %10 = add nsw i32 %1, -28
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %72, %8
  %13 = phi i32 [ 0, %8 ], [ %73, %72 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %31

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %28, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 28
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  store double %27, ptr %4, align 8, !tbaa !17
  %28 = add nuw i64 %15, 29
  %29 = trunc i64 %28 to i32
  %30 = icmp sgt i32 %10, %29
  br i1 %30, label %14, label %31

31:                                               ; preds = %14, %12
  %32 = phi double [ 0.000000e+00, %12 ], [ %27, %14 ]
  %33 = phi i32 [ 0, %12 ], [ %29, %14 ]
  %34 = icmp slt i32 %33, %1
  br i1 %34, label %35, label %52

35:                                               ; preds = %31
  %36 = sext i32 %33 to i64
  br label %37

37:                                               ; preds = %37, %35
  %38 = phi i64 [ %36, %35 ], [ %49, %37 ]
  %39 = phi double [ %32, %35 ], [ %48, %37 ]
  %40 = getelementptr inbounds double, ptr %0, i64 %38
  %41 = load double, ptr %40, align 8, !tbaa !17
  %42 = fadd double %41, 1.234500e+04
  %43 = call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %39, %47
  %49 = add nsw i64 %38, 1
  %50 = icmp eq i64 %49, %11
  br i1 %50, label %51, label %37

51:                                               ; preds = %37
  %.lcssa = phi double [ %48, %37 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %52

52:                                               ; preds = %51, %31
  %53 = phi double [ %.lcssa, %51 ], [ %32, %31 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %56, 1.234500e+04
  %58 = call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fmul double %60, 8.000000e+03
  %62 = fsub double %53, %61
  %63 = call double @llvm.fabs.f64(double %53)
  %64 = fcmp ogt double %63, 1.000000e-08
  %65 = select i1 %64, double %53, double 1.000000e+00
  %66 = fdiv double %62, %65
  %67 = call double @llvm.fabs.f64(double %66)
  %68 = fcmp olt double %67, 0x3EB0C6F7A0B5ED8D
  br i1 %68, label %72, label %69

69:                                               ; preds = %52
  %70 = load i32, ptr @current_test, align 4, !tbaa !11
  %71 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %70) #12
  br label %72

72:                                               ; preds = %69, %52
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %73 = add nuw nsw i32 %13, 1
  %74 = load i32, ptr @iterations, align 4, !tbaa !11
  %75 = icmp slt i32 %73, %74
  br i1 %75, label %12, label %76, !llvm.loop !48

76:                                               ; preds = %72, %3
  %77 = call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi25EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi23EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi24EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 23)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi25EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 24)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi26EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %136

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 25
  %10 = add nsw i32 %1, -25
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %132, %8
  %13 = phi i32 [ 0, %8 ], [ %133, %132 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %91

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %88, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 20
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = add nuw nsw i64 %15, 21
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  %48 = add nuw nsw i64 %15, 22
  %49 = getelementptr inbounds double, ptr %0, i64 %48
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %47, %56
  %58 = add nuw nsw i64 %15, 23
  %59 = getelementptr inbounds double, ptr %0, i64 %58
  %60 = load double, ptr %59, align 8, !tbaa !17
  %61 = fadd double %60, 1.234500e+04
  %62 = call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %57, %66
  %68 = add nuw nsw i64 %15, 24
  %69 = getelementptr inbounds double, ptr %0, i64 %68
  %70 = load double, ptr %69, align 8, !tbaa !17
  %71 = fadd double %70, 1.234500e+04
  %72 = call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %67, %76
  %78 = add nuw nsw i64 %15, 25
  %79 = getelementptr inbounds double, ptr %0, i64 %78
  %80 = load double, ptr %79, align 8, !tbaa !17
  %81 = fadd double %80, 1.234500e+04
  %82 = call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %84, 1.234500e+04
  %86 = call double @llvm.fmuladd.f64(double %85, double 9.142370e+05, double -1.300000e+01)
  %87 = fadd double %77, %86
  store double %87, ptr %4, align 8, !tbaa !17
  %88 = add nuw i64 %15, 26
  %89 = trunc i64 %88 to i32
  %90 = icmp sgt i32 %10, %89
  br i1 %90, label %14, label %91

91:                                               ; preds = %14, %12
  %92 = phi double [ 0.000000e+00, %12 ], [ %87, %14 ]
  %93 = phi i32 [ 0, %12 ], [ %89, %14 ]
  %94 = icmp slt i32 %93, %1
  br i1 %94, label %95, label %112

95:                                               ; preds = %91
  %96 = sext i32 %93 to i64
  br label %97

97:                                               ; preds = %97, %95
  %98 = phi i64 [ %96, %95 ], [ %109, %97 ]
  %99 = phi double [ %92, %95 ], [ %108, %97 ]
  %100 = getelementptr inbounds double, ptr %0, i64 %98
  %101 = load double, ptr %100, align 8, !tbaa !17
  %102 = fadd double %101, 1.234500e+04
  %103 = call double @llvm.fmuladd.f64(double %102, double 9.142370e+05, double -1.300000e+01)
  %104 = fadd double %103, 1.234500e+04
  %105 = call double @llvm.fmuladd.f64(double %104, double 9.142370e+05, double -1.300000e+01)
  %106 = fadd double %105, 1.234500e+04
  %107 = call double @llvm.fmuladd.f64(double %106, double 9.142370e+05, double -1.300000e+01)
  %108 = fadd double %99, %107
  %109 = add nsw i64 %98, 1
  %110 = icmp eq i64 %109, %11
  br i1 %110, label %111, label %97

111:                                              ; preds = %97
  %.lcssa = phi double [ %108, %97 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %112

112:                                              ; preds = %111, %91
  %113 = phi double [ %.lcssa, %111 ], [ %92, %91 ]
  %114 = load double, ptr @init_value, align 8, !tbaa !17
  %115 = fadd double %114, 1.234500e+04
  %116 = call double @llvm.fmuladd.f64(double %115, double 9.142370e+05, double -1.300000e+01)
  %117 = fadd double %116, 1.234500e+04
  %118 = call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fmul double %120, 8.000000e+03
  %122 = fsub double %113, %121
  %123 = call double @llvm.fabs.f64(double %113)
  %124 = fcmp ogt double %123, 1.000000e-08
  %125 = select i1 %124, double %113, double 1.000000e+00
  %126 = fdiv double %122, %125
  %127 = call double @llvm.fabs.f64(double %126)
  %128 = fcmp olt double %127, 0x3EB0C6F7A0B5ED8D
  br i1 %128, label %132, label %129

129:                                              ; preds = %112
  %130 = load i32, ptr @current_test, align 4, !tbaa !11
  %131 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %130) #12
  br label %132

132:                                              ; preds = %129, %112
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %133 = add nuw nsw i32 %13, 1
  %134 = load i32, ptr @iterations, align 4, !tbaa !11
  %135 = icmp slt i32 %133, %134
  br i1 %135, label %12, label %136, !llvm.loop !49

136:                                              ; preds = %132, %3
  %137 = call i64 @clock() #15
  store i64 %137, ptr @end_time, align 8, !tbaa !23
  %138 = load i64, ptr @start_time, align 8, !tbaa !23
  %139 = sub nsw i64 %137, %138
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %141, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi27EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %146

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 26
  %10 = add nsw i32 %1, -26
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %142, %8
  %13 = phi i32 [ 0, %8 ], [ %143, %142 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %101

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %98, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 20
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = add nuw nsw i64 %15, 21
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  %48 = add nuw nsw i64 %15, 22
  %49 = getelementptr inbounds double, ptr %0, i64 %48
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %47, %56
  %58 = add nuw nsw i64 %15, 23
  %59 = getelementptr inbounds double, ptr %0, i64 %58
  %60 = load double, ptr %59, align 8, !tbaa !17
  %61 = fadd double %60, 1.234500e+04
  %62 = call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %57, %66
  %68 = add nuw nsw i64 %15, 24
  %69 = getelementptr inbounds double, ptr %0, i64 %68
  %70 = load double, ptr %69, align 8, !tbaa !17
  %71 = fadd double %70, 1.234500e+04
  %72 = call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %67, %76
  %78 = add nuw nsw i64 %15, 25
  %79 = getelementptr inbounds double, ptr %0, i64 %78
  %80 = load double, ptr %79, align 8, !tbaa !17
  %81 = fadd double %80, 1.234500e+04
  %82 = call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %84, 1.234500e+04
  %86 = call double @llvm.fmuladd.f64(double %85, double 9.142370e+05, double -1.300000e+01)
  %87 = fadd double %77, %86
  %88 = add nuw nsw i64 %15, 26
  %89 = getelementptr inbounds double, ptr %0, i64 %88
  %90 = load double, ptr %89, align 8, !tbaa !17
  %91 = fadd double %90, 1.234500e+04
  %92 = call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %94, 1.234500e+04
  %96 = call double @llvm.fmuladd.f64(double %95, double 9.142370e+05, double -1.300000e+01)
  %97 = fadd double %87, %96
  store double %97, ptr %4, align 8, !tbaa !17
  %98 = add nuw i64 %15, 27
  %99 = trunc i64 %98 to i32
  %100 = icmp sgt i32 %10, %99
  br i1 %100, label %14, label %101

101:                                              ; preds = %14, %12
  %102 = phi double [ 0.000000e+00, %12 ], [ %97, %14 ]
  %103 = phi i32 [ 0, %12 ], [ %99, %14 ]
  %104 = icmp slt i32 %103, %1
  br i1 %104, label %105, label %122

105:                                              ; preds = %101
  %106 = sext i32 %103 to i64
  br label %107

107:                                              ; preds = %107, %105
  %108 = phi i64 [ %106, %105 ], [ %119, %107 ]
  %109 = phi double [ %102, %105 ], [ %118, %107 ]
  %110 = getelementptr inbounds double, ptr %0, i64 %108
  %111 = load double, ptr %110, align 8, !tbaa !17
  %112 = fadd double %111, 1.234500e+04
  %113 = call double @llvm.fmuladd.f64(double %112, double 9.142370e+05, double -1.300000e+01)
  %114 = fadd double %113, 1.234500e+04
  %115 = call double @llvm.fmuladd.f64(double %114, double 9.142370e+05, double -1.300000e+01)
  %116 = fadd double %115, 1.234500e+04
  %117 = call double @llvm.fmuladd.f64(double %116, double 9.142370e+05, double -1.300000e+01)
  %118 = fadd double %109, %117
  %119 = add nsw i64 %108, 1
  %120 = icmp eq i64 %119, %11
  br i1 %120, label %121, label %107

121:                                              ; preds = %107
  %.lcssa = phi double [ %118, %107 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %122

122:                                              ; preds = %121, %101
  %123 = phi double [ %.lcssa, %121 ], [ %102, %101 ]
  %124 = load double, ptr @init_value, align 8, !tbaa !17
  %125 = fadd double %124, 1.234500e+04
  %126 = call double @llvm.fmuladd.f64(double %125, double 9.142370e+05, double -1.300000e+01)
  %127 = fadd double %126, 1.234500e+04
  %128 = call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fmul double %130, 8.000000e+03
  %132 = fsub double %123, %131
  %133 = call double @llvm.fabs.f64(double %123)
  %134 = fcmp ogt double %133, 1.000000e-08
  %135 = select i1 %134, double %123, double 1.000000e+00
  %136 = fdiv double %132, %135
  %137 = call double @llvm.fabs.f64(double %136)
  %138 = fcmp olt double %137, 0x3EB0C6F7A0B5ED8D
  br i1 %138, label %142, label %139

139:                                              ; preds = %122
  %140 = load i32, ptr @current_test, align 4, !tbaa !11
  %141 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %140) #12
  br label %142

142:                                              ; preds = %139, %122
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %143 = add nuw nsw i32 %13, 1
  %144 = load i32, ptr @iterations, align 4, !tbaa !11
  %145 = icmp slt i32 %143, %144
  br i1 %145, label %12, label %146, !llvm.loop !50

146:                                              ; preds = %142, %3
  %147 = call i64 @clock() #15
  store i64 %147, ptr @end_time, align 8, !tbaa !23
  %148 = load i64, ptr @start_time, align 8, !tbaa !23
  %149 = sub nsw i64 %147, %148
  %150 = sitofp i64 %149 to double
  %151 = fdiv double %150, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %151, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi23EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi21EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi22EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 21)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi23EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 22)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi24EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %116

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 23
  %10 = add nsw i32 %1, -23
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %112, %8
  %13 = phi i32 [ 0, %8 ], [ %113, %112 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %71

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %68, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 20
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = add nuw nsw i64 %15, 21
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  %48 = add nuw nsw i64 %15, 22
  %49 = getelementptr inbounds double, ptr %0, i64 %48
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %47, %56
  %58 = add nuw nsw i64 %15, 23
  %59 = getelementptr inbounds double, ptr %0, i64 %58
  %60 = load double, ptr %59, align 8, !tbaa !17
  %61 = fadd double %60, 1.234500e+04
  %62 = call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %57, %66
  store double %67, ptr %4, align 8, !tbaa !17
  %68 = add nuw i64 %15, 24
  %69 = trunc i64 %68 to i32
  %70 = icmp sgt i32 %10, %69
  br i1 %70, label %14, label %71

71:                                               ; preds = %14, %12
  %72 = phi double [ 0.000000e+00, %12 ], [ %67, %14 ]
  %73 = phi i32 [ 0, %12 ], [ %69, %14 ]
  %74 = icmp slt i32 %73, %1
  br i1 %74, label %75, label %92

75:                                               ; preds = %71
  %76 = sext i32 %73 to i64
  br label %77

77:                                               ; preds = %77, %75
  %78 = phi i64 [ %76, %75 ], [ %89, %77 ]
  %79 = phi double [ %72, %75 ], [ %88, %77 ]
  %80 = getelementptr inbounds double, ptr %0, i64 %78
  %81 = load double, ptr %80, align 8, !tbaa !17
  %82 = fadd double %81, 1.234500e+04
  %83 = call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %83, 1.234500e+04
  %85 = call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %85, 1.234500e+04
  %87 = call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %79, %87
  %89 = add nsw i64 %78, 1
  %90 = icmp eq i64 %89, %11
  br i1 %90, label %91, label %77

91:                                               ; preds = %77
  %.lcssa = phi double [ %88, %77 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %92

92:                                               ; preds = %91, %71
  %93 = phi double [ %.lcssa, %91 ], [ %72, %71 ]
  %94 = load double, ptr @init_value, align 8, !tbaa !17
  %95 = fadd double %94, 1.234500e+04
  %96 = call double @llvm.fmuladd.f64(double %95, double 9.142370e+05, double -1.300000e+01)
  %97 = fadd double %96, 1.234500e+04
  %98 = call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fmul double %100, 8.000000e+03
  %102 = fsub double %93, %101
  %103 = call double @llvm.fabs.f64(double %93)
  %104 = fcmp ogt double %103, 1.000000e-08
  %105 = select i1 %104, double %93, double 1.000000e+00
  %106 = fdiv double %102, %105
  %107 = call double @llvm.fabs.f64(double %106)
  %108 = fcmp olt double %107, 0x3EB0C6F7A0B5ED8D
  br i1 %108, label %112, label %109

109:                                              ; preds = %92
  %110 = load i32, ptr @current_test, align 4, !tbaa !11
  %111 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %110) #12
  br label %112

112:                                              ; preds = %109, %92
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %113 = add nuw nsw i32 %13, 1
  %114 = load i32, ptr @iterations, align 4, !tbaa !11
  %115 = icmp slt i32 %113, %114
  br i1 %115, label %12, label %116, !llvm.loop !51

116:                                              ; preds = %112, %3
  %117 = call i64 @clock() #15
  store i64 %117, ptr @end_time, align 8, !tbaa !23
  %118 = load i64, ptr @start_time, align 8, !tbaa !23
  %119 = sub nsw i64 %117, %118
  %120 = sitofp i64 %119 to double
  %121 = fdiv double %120, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %121, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi25EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %126

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 24
  %10 = add nsw i32 %1, -24
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %122, %8
  %13 = phi i32 [ 0, %8 ], [ %123, %122 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %81

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %78, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 20
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = add nuw nsw i64 %15, 21
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  %48 = add nuw nsw i64 %15, 22
  %49 = getelementptr inbounds double, ptr %0, i64 %48
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %47, %56
  %58 = add nuw nsw i64 %15, 23
  %59 = getelementptr inbounds double, ptr %0, i64 %58
  %60 = load double, ptr %59, align 8, !tbaa !17
  %61 = fadd double %60, 1.234500e+04
  %62 = call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %57, %66
  %68 = add nuw nsw i64 %15, 24
  %69 = getelementptr inbounds double, ptr %0, i64 %68
  %70 = load double, ptr %69, align 8, !tbaa !17
  %71 = fadd double %70, 1.234500e+04
  %72 = call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %67, %76
  store double %77, ptr %4, align 8, !tbaa !17
  %78 = add nuw i64 %15, 25
  %79 = trunc i64 %78 to i32
  %80 = icmp sgt i32 %10, %79
  br i1 %80, label %14, label %81

81:                                               ; preds = %14, %12
  %82 = phi double [ 0.000000e+00, %12 ], [ %77, %14 ]
  %83 = phi i32 [ 0, %12 ], [ %79, %14 ]
  %84 = icmp slt i32 %83, %1
  br i1 %84, label %85, label %102

85:                                               ; preds = %81
  %86 = sext i32 %83 to i64
  br label %87

87:                                               ; preds = %87, %85
  %88 = phi i64 [ %86, %85 ], [ %99, %87 ]
  %89 = phi double [ %82, %85 ], [ %98, %87 ]
  %90 = getelementptr inbounds double, ptr %0, i64 %88
  %91 = load double, ptr %90, align 8, !tbaa !17
  %92 = fadd double %91, 1.234500e+04
  %93 = call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %93, 1.234500e+04
  %95 = call double @llvm.fmuladd.f64(double %94, double 9.142370e+05, double -1.300000e+01)
  %96 = fadd double %95, 1.234500e+04
  %97 = call double @llvm.fmuladd.f64(double %96, double 9.142370e+05, double -1.300000e+01)
  %98 = fadd double %89, %97
  %99 = add nsw i64 %88, 1
  %100 = icmp eq i64 %99, %11
  br i1 %100, label %101, label %87

101:                                              ; preds = %87
  %.lcssa = phi double [ %98, %87 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %102

102:                                              ; preds = %101, %81
  %103 = phi double [ %.lcssa, %101 ], [ %82, %81 ]
  %104 = load double, ptr @init_value, align 8, !tbaa !17
  %105 = fadd double %104, 1.234500e+04
  %106 = call double @llvm.fmuladd.f64(double %105, double 9.142370e+05, double -1.300000e+01)
  %107 = fadd double %106, 1.234500e+04
  %108 = call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fmul double %110, 8.000000e+03
  %112 = fsub double %103, %111
  %113 = call double @llvm.fabs.f64(double %103)
  %114 = fcmp ogt double %113, 1.000000e-08
  %115 = select i1 %114, double %103, double 1.000000e+00
  %116 = fdiv double %112, %115
  %117 = call double @llvm.fabs.f64(double %116)
  %118 = fcmp olt double %117, 0x3EB0C6F7A0B5ED8D
  br i1 %118, label %122, label %119

119:                                              ; preds = %102
  %120 = load i32, ptr @current_test, align 4, !tbaa !11
  %121 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %120) #12
  br label %122

122:                                              ; preds = %119, %102
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %123 = add nuw nsw i32 %13, 1
  %124 = load i32, ptr @iterations, align 4, !tbaa !11
  %125 = icmp slt i32 %123, %124
  br i1 %125, label %12, label %126, !llvm.loop !52

126:                                              ; preds = %122, %3
  %127 = call i64 @clock() #15
  store i64 %127, ptr @end_time, align 8, !tbaa !23
  %128 = load i64, ptr @start_time, align 8, !tbaa !23
  %129 = sub nsw i64 %127, %128
  %130 = sitofp i64 %129 to double
  %131 = fdiv double %130, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %131, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi21EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi19EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi20EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 19)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi21EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 20)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi22EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %96

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 21
  %10 = add nsw i32 %1, -21
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %92, %8
  %13 = phi i32 [ 0, %8 ], [ %93, %92 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %51

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %48, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 20
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = add nuw nsw i64 %15, 21
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  store double %47, ptr %4, align 8, !tbaa !17
  %48 = add nuw i64 %15, 22
  %49 = trunc i64 %48 to i32
  %50 = icmp sgt i32 %10, %49
  br i1 %50, label %14, label %51

51:                                               ; preds = %14, %12
  %52 = phi double [ 0.000000e+00, %12 ], [ %47, %14 ]
  %53 = phi i32 [ 0, %12 ], [ %49, %14 ]
  %54 = icmp slt i32 %53, %1
  br i1 %54, label %55, label %72

55:                                               ; preds = %51
  %56 = sext i32 %53 to i64
  br label %57

57:                                               ; preds = %57, %55
  %58 = phi i64 [ %56, %55 ], [ %69, %57 ]
  %59 = phi double [ %52, %55 ], [ %68, %57 ]
  %60 = getelementptr inbounds double, ptr %0, i64 %58
  %61 = load double, ptr %60, align 8, !tbaa !17
  %62 = fadd double %61, 1.234500e+04
  %63 = call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %65, 1.234500e+04
  %67 = call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %59, %67
  %69 = add nsw i64 %58, 1
  %70 = icmp eq i64 %69, %11
  br i1 %70, label %71, label %57

71:                                               ; preds = %57
  %.lcssa = phi double [ %68, %57 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %72

72:                                               ; preds = %71, %51
  %73 = phi double [ %.lcssa, %71 ], [ %52, %51 ]
  %74 = load double, ptr @init_value, align 8, !tbaa !17
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %76, 1.234500e+04
  %78 = call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fmul double %80, 8.000000e+03
  %82 = fsub double %73, %81
  %83 = call double @llvm.fabs.f64(double %73)
  %84 = fcmp ogt double %83, 1.000000e-08
  %85 = select i1 %84, double %73, double 1.000000e+00
  %86 = fdiv double %82, %85
  %87 = call double @llvm.fabs.f64(double %86)
  %88 = fcmp olt double %87, 0x3EB0C6F7A0B5ED8D
  br i1 %88, label %92, label %89

89:                                               ; preds = %72
  %90 = load i32, ptr @current_test, align 4, !tbaa !11
  %91 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %90) #12
  br label %92

92:                                               ; preds = %89, %72
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %93 = add nuw nsw i32 %13, 1
  %94 = load i32, ptr @iterations, align 4, !tbaa !11
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %12, label %96, !llvm.loop !53

96:                                               ; preds = %92, %3
  %97 = call i64 @clock() #15
  store i64 %97, ptr @end_time, align 8, !tbaa !23
  %98 = load i64, ptr @start_time, align 8, !tbaa !23
  %99 = sub nsw i64 %97, %98
  %100 = sitofp i64 %99 to double
  %101 = fdiv double %100, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %101, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi23EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %106

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 22
  %10 = add nsw i32 %1, -22
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %102, %8
  %13 = phi i32 [ 0, %8 ], [ %103, %102 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %61

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %58, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 20
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = add nuw nsw i64 %15, 21
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  %48 = add nuw nsw i64 %15, 22
  %49 = getelementptr inbounds double, ptr %0, i64 %48
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %47, %56
  store double %57, ptr %4, align 8, !tbaa !17
  %58 = add nuw i64 %15, 23
  %59 = trunc i64 %58 to i32
  %60 = icmp sgt i32 %10, %59
  br i1 %60, label %14, label %61

61:                                               ; preds = %14, %12
  %62 = phi double [ 0.000000e+00, %12 ], [ %57, %14 ]
  %63 = phi i32 [ 0, %12 ], [ %59, %14 ]
  %64 = icmp slt i32 %63, %1
  br i1 %64, label %65, label %82

65:                                               ; preds = %61
  %66 = sext i32 %63 to i64
  br label %67

67:                                               ; preds = %67, %65
  %68 = phi i64 [ %66, %65 ], [ %79, %67 ]
  %69 = phi double [ %62, %65 ], [ %78, %67 ]
  %70 = getelementptr inbounds double, ptr %0, i64 %68
  %71 = load double, ptr %70, align 8, !tbaa !17
  %72 = fadd double %71, 1.234500e+04
  %73 = call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %75, 1.234500e+04
  %77 = call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %69, %77
  %79 = add nsw i64 %68, 1
  %80 = icmp eq i64 %79, %11
  br i1 %80, label %81, label %67

81:                                               ; preds = %67
  %.lcssa = phi double [ %78, %67 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %82

82:                                               ; preds = %81, %61
  %83 = phi double [ %.lcssa, %81 ], [ %62, %61 ]
  %84 = load double, ptr @init_value, align 8, !tbaa !17
  %85 = fadd double %84, 1.234500e+04
  %86 = call double @llvm.fmuladd.f64(double %85, double 9.142370e+05, double -1.300000e+01)
  %87 = fadd double %86, 1.234500e+04
  %88 = call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fmul double %90, 8.000000e+03
  %92 = fsub double %83, %91
  %93 = call double @llvm.fabs.f64(double %83)
  %94 = fcmp ogt double %93, 1.000000e-08
  %95 = select i1 %94, double %83, double 1.000000e+00
  %96 = fdiv double %92, %95
  %97 = call double @llvm.fabs.f64(double %96)
  %98 = fcmp olt double %97, 0x3EB0C6F7A0B5ED8D
  br i1 %98, label %102, label %99

99:                                               ; preds = %82
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  %101 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %100) #12
  br label %102

102:                                              ; preds = %99, %82
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %103 = add nuw nsw i32 %13, 1
  %104 = load i32, ptr @iterations, align 4, !tbaa !11
  %105 = icmp slt i32 %103, %104
  br i1 %105, label %12, label %106, !llvm.loop !54

106:                                              ; preds = %102, %3
  %107 = call i64 @clock() #15
  store i64 %107, ptr @end_time, align 8, !tbaa !23
  %108 = load i64, ptr @start_time, align 8, !tbaa !23
  %109 = sub nsw i64 %107, %108
  %110 = sitofp i64 %109 to double
  %111 = fdiv double %110, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %111, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi19EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi17EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi18EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 17)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi19EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 18)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi20EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %76

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 19
  %10 = add nsw i32 %1, -19
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %72, %8
  %13 = phi i32 [ 0, %8 ], [ %73, %72 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %31

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %28, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  store double %27, ptr %4, align 8, !tbaa !17
  %28 = add nuw i64 %15, 20
  %29 = trunc i64 %28 to i32
  %30 = icmp sgt i32 %10, %29
  br i1 %30, label %14, label %31

31:                                               ; preds = %14, %12
  %32 = phi double [ 0.000000e+00, %12 ], [ %27, %14 ]
  %33 = phi i32 [ 0, %12 ], [ %29, %14 ]
  %34 = icmp slt i32 %33, %1
  br i1 %34, label %35, label %52

35:                                               ; preds = %31
  %36 = sext i32 %33 to i64
  br label %37

37:                                               ; preds = %37, %35
  %38 = phi i64 [ %36, %35 ], [ %49, %37 ]
  %39 = phi double [ %32, %35 ], [ %48, %37 ]
  %40 = getelementptr inbounds double, ptr %0, i64 %38
  %41 = load double, ptr %40, align 8, !tbaa !17
  %42 = fadd double %41, 1.234500e+04
  %43 = call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %39, %47
  %49 = add nsw i64 %38, 1
  %50 = icmp eq i64 %49, %11
  br i1 %50, label %51, label %37

51:                                               ; preds = %37
  %.lcssa = phi double [ %48, %37 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %52

52:                                               ; preds = %51, %31
  %53 = phi double [ %.lcssa, %51 ], [ %32, %31 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %56, 1.234500e+04
  %58 = call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fmul double %60, 8.000000e+03
  %62 = fsub double %53, %61
  %63 = call double @llvm.fabs.f64(double %53)
  %64 = fcmp ogt double %63, 1.000000e-08
  %65 = select i1 %64, double %53, double 1.000000e+00
  %66 = fdiv double %62, %65
  %67 = call double @llvm.fabs.f64(double %66)
  %68 = fcmp olt double %67, 0x3EB0C6F7A0B5ED8D
  br i1 %68, label %72, label %69

69:                                               ; preds = %52
  %70 = load i32, ptr @current_test, align 4, !tbaa !11
  %71 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %70) #12
  br label %72

72:                                               ; preds = %69, %52
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %73 = add nuw nsw i32 %13, 1
  %74 = load i32, ptr @iterations, align 4, !tbaa !11
  %75 = icmp slt i32 %73, %74
  br i1 %75, label %12, label %76, !llvm.loop !55

76:                                               ; preds = %72, %3
  %77 = call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi21EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 20
  %10 = add nsw i32 %1, -20
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %82, %8
  %13 = phi i32 [ 0, %8 ], [ %83, %82 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %41

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %38, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 20
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  store double %37, ptr %4, align 8, !tbaa !17
  %38 = add nuw i64 %15, 21
  %39 = trunc i64 %38 to i32
  %40 = icmp sgt i32 %10, %39
  br i1 %40, label %14, label %41

41:                                               ; preds = %14, %12
  %42 = phi double [ 0.000000e+00, %12 ], [ %37, %14 ]
  %43 = phi i32 [ 0, %12 ], [ %39, %14 ]
  %44 = icmp slt i32 %43, %1
  br i1 %44, label %45, label %62

45:                                               ; preds = %41
  %46 = sext i32 %43 to i64
  br label %47

47:                                               ; preds = %47, %45
  %48 = phi i64 [ %46, %45 ], [ %59, %47 ]
  %49 = phi double [ %42, %45 ], [ %58, %47 ]
  %50 = getelementptr inbounds double, ptr %0, i64 %48
  %51 = load double, ptr %50, align 8, !tbaa !17
  %52 = fadd double %51, 1.234500e+04
  %53 = call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %49, %57
  %59 = add nsw i64 %48, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %47

61:                                               ; preds = %47
  %.lcssa = phi double [ %58, %47 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %62

62:                                               ; preds = %61, %41
  %63 = phi double [ %.lcssa, %61 ], [ %42, %41 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !17
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %66, 1.234500e+04
  %68 = call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fmul double %70, 8.000000e+03
  %72 = fsub double %63, %71
  %73 = call double @llvm.fabs.f64(double %63)
  %74 = fcmp ogt double %73, 1.000000e-08
  %75 = select i1 %74, double %63, double 1.000000e+00
  %76 = fdiv double %72, %75
  %77 = call double @llvm.fabs.f64(double %76)
  %78 = fcmp olt double %77, 0x3EB0C6F7A0B5ED8D
  br i1 %78, label %82, label %79

79:                                               ; preds = %62
  %80 = load i32, ptr @current_test, align 4, !tbaa !11
  %81 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %80) #12
  br label %82

82:                                               ; preds = %79, %62
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %83 = add nuw nsw i32 %13, 1
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  %85 = icmp slt i32 %83, %84
  br i1 %85, label %12, label %86, !llvm.loop !56

86:                                               ; preds = %82, %3
  %87 = call i64 @clock() #15
  store i64 %87, ptr @end_time, align 8, !tbaa !23
  %88 = load i64, ptr @start_time, align 8, !tbaa !23
  %89 = sub nsw i64 %87, %88
  %90 = sitofp i64 %89 to double
  %91 = fdiv double %90, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %91, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi17EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi15EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi16EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 15)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi17EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 16)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi18EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %244

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 17
  %9 = add nsw i32 %1, -17
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %240, %7
  %13 = phi i32 [ 0, %7 ], [ %241, %240 ]
  br i1 %8, label %14, label %200

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %196, %14 ], [ 0, %12 ]
  %16 = phi double [ %195, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = or i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = add nuw nsw i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = add nuw nsw i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = add nuw nsw i64 %15, 11
  %127 = getelementptr inbounds double, ptr %0, i64 %126
  %128 = load double, ptr %127, align 8, !tbaa !17
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %125, %134
  %136 = add nuw nsw i64 %15, 12
  %137 = getelementptr inbounds double, ptr %0, i64 %136
  %138 = load double, ptr %137, align 8, !tbaa !17
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %135, %144
  %146 = add nuw nsw i64 %15, 13
  %147 = getelementptr inbounds double, ptr %0, i64 %146
  %148 = load double, ptr %147, align 8, !tbaa !17
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %145, %154
  %156 = add nuw nsw i64 %15, 14
  %157 = getelementptr inbounds double, ptr %0, i64 %156
  %158 = load double, ptr %157, align 8, !tbaa !17
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %155, %164
  %166 = add nuw nsw i64 %15, 15
  %167 = getelementptr inbounds double, ptr %0, i64 %166
  %168 = load double, ptr %167, align 8, !tbaa !17
  %169 = fadd double %168, 1.234500e+04
  %170 = tail call double @llvm.fmuladd.f64(double %169, double 9.142370e+05, double -1.300000e+01)
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %172, 1.234500e+04
  %174 = tail call double @llvm.fmuladd.f64(double %173, double 9.142370e+05, double -1.300000e+01)
  %175 = fadd double %165, %174
  %176 = add nuw nsw i64 %15, 16
  %177 = getelementptr inbounds double, ptr %0, i64 %176
  %178 = load double, ptr %177, align 8, !tbaa !17
  %179 = fadd double %178, 1.234500e+04
  %180 = tail call double @llvm.fmuladd.f64(double %179, double 9.142370e+05, double -1.300000e+01)
  %181 = fadd double %180, 1.234500e+04
  %182 = tail call double @llvm.fmuladd.f64(double %181, double 9.142370e+05, double -1.300000e+01)
  %183 = fadd double %182, 1.234500e+04
  %184 = tail call double @llvm.fmuladd.f64(double %183, double 9.142370e+05, double -1.300000e+01)
  %185 = fadd double %175, %184
  %186 = add nuw nsw i64 %15, 17
  %187 = getelementptr inbounds double, ptr %0, i64 %186
  %188 = load double, ptr %187, align 8, !tbaa !17
  %189 = fadd double %188, 1.234500e+04
  %190 = tail call double @llvm.fmuladd.f64(double %189, double 9.142370e+05, double -1.300000e+01)
  %191 = fadd double %190, 1.234500e+04
  %192 = tail call double @llvm.fmuladd.f64(double %191, double 9.142370e+05, double -1.300000e+01)
  %193 = fadd double %192, 1.234500e+04
  %194 = tail call double @llvm.fmuladd.f64(double %193, double 9.142370e+05, double -1.300000e+01)
  %195 = fadd double %185, %194
  %196 = add nuw nsw i64 %15, 18
  %197 = icmp slt i64 %196, %10
  br i1 %197, label %14, label %198

198:                                              ; preds = %14
  %.lcssa1 = phi double [ %195, %14 ]
  %.lcssa = phi i64 [ %196, %14 ]
  %199 = trunc i64 %.lcssa to i32
  br label %200

200:                                              ; preds = %198, %12
  %201 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %198 ]
  %202 = phi i32 [ 0, %12 ], [ %199, %198 ]
  %203 = icmp slt i32 %202, %1
  br i1 %203, label %204, label %220

204:                                              ; preds = %200
  %205 = zext i32 %202 to i64
  br label %206

206:                                              ; preds = %206, %204
  %207 = phi i64 [ %205, %204 ], [ %218, %206 ]
  %208 = phi double [ %201, %204 ], [ %217, %206 ]
  %209 = getelementptr inbounds double, ptr %0, i64 %207
  %210 = load double, ptr %209, align 8, !tbaa !17
  %211 = fadd double %210, 1.234500e+04
  %212 = tail call double @llvm.fmuladd.f64(double %211, double 9.142370e+05, double -1.300000e+01)
  %213 = fadd double %212, 1.234500e+04
  %214 = tail call double @llvm.fmuladd.f64(double %213, double 9.142370e+05, double -1.300000e+01)
  %215 = fadd double %214, 1.234500e+04
  %216 = tail call double @llvm.fmuladd.f64(double %215, double 9.142370e+05, double -1.300000e+01)
  %217 = fadd double %208, %216
  %218 = add nuw nsw i64 %207, 1
  %219 = icmp eq i64 %218, %11
  br i1 %219, label %220, label %206

220:                                              ; preds = %206, %200
  %221 = phi double [ %201, %200 ], [ %217, %206 ]
  %222 = load double, ptr @init_value, align 8, !tbaa !17
  %223 = fadd double %222, 1.234500e+04
  %224 = tail call double @llvm.fmuladd.f64(double %223, double 9.142370e+05, double -1.300000e+01)
  %225 = fadd double %224, 1.234500e+04
  %226 = tail call double @llvm.fmuladd.f64(double %225, double 9.142370e+05, double -1.300000e+01)
  %227 = fadd double %226, 1.234500e+04
  %228 = tail call double @llvm.fmuladd.f64(double %227, double 9.142370e+05, double -1.300000e+01)
  %229 = fmul double %228, 8.000000e+03
  %230 = fsub double %221, %229
  %231 = tail call double @llvm.fabs.f64(double %221)
  %232 = fcmp ogt double %231, 1.000000e-08
  %233 = select i1 %232, double %221, double 1.000000e+00
  %234 = fdiv double %230, %233
  %235 = tail call double @llvm.fabs.f64(double %234)
  %236 = fcmp olt double %235, 0x3EB0C6F7A0B5ED8D
  br i1 %236, label %240, label %237

237:                                              ; preds = %220
  %238 = load i32, ptr @current_test, align 4, !tbaa !11
  %239 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %238) #12
  br label %240

240:                                              ; preds = %237, %220
  %241 = add nuw nsw i32 %13, 1
  %242 = load i32, ptr @iterations, align 4, !tbaa !11
  %243 = icmp slt i32 %241, %242
  br i1 %243, label %12, label %244, !llvm.loop !57

244:                                              ; preds = %240, %3
  %245 = tail call i64 @clock() #15
  store i64 %245, ptr @end_time, align 8, !tbaa !23
  %246 = load i64, ptr @start_time, align 8, !tbaa !23
  %247 = sub nsw i64 %245, %246
  %248 = sitofp i64 %247 to double
  %249 = fdiv double %248, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %249, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi19EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %65

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 18
  %10 = add nsw i32 %1, -18
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %61, %8
  %13 = phi i32 [ 0, %8 ], [ %62, %61 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %20

14:                                               ; preds = %14, %12
  %15 = phi i32 [ %16, %14 ], [ 0, %12 ]
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %15) #12
  %16 = add nuw nsw i32 %15, 19
  %17 = icmp slt i32 %16, %10
  br i1 %17, label %14, label %18

18:                                               ; preds = %14
  %.lcssa = phi i32 [ %16, %14 ]
  %19 = load double, ptr %4, align 8, !tbaa !17
  br label %20

20:                                               ; preds = %18, %12
  %21 = phi double [ 0.000000e+00, %12 ], [ %19, %18 ]
  %22 = phi i32 [ 0, %12 ], [ %.lcssa, %18 ]
  %23 = icmp slt i32 %22, %1
  br i1 %23, label %24, label %41

24:                                               ; preds = %20
  %25 = sext i32 %22 to i64
  br label %26

26:                                               ; preds = %26, %24
  %27 = phi i64 [ %25, %24 ], [ %38, %26 ]
  %28 = phi double [ %21, %24 ], [ %37, %26 ]
  %29 = getelementptr inbounds double, ptr %0, i64 %27
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %28, %36
  %38 = add nsw i64 %27, 1
  %39 = icmp eq i64 %38, %11
  br i1 %39, label %40, label %26

40:                                               ; preds = %26
  %.lcssa1 = phi double [ %37, %26 ]
  store double %.lcssa1, ptr %4, align 8, !tbaa !17
  br label %41

41:                                               ; preds = %40, %20
  %42 = phi double [ %.lcssa1, %40 ], [ %21, %20 ]
  %43 = load double, ptr @init_value, align 8, !tbaa !17
  %44 = fadd double %43, 1.234500e+04
  %45 = call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fmul double %49, 8.000000e+03
  %51 = fsub double %42, %50
  %52 = call double @llvm.fabs.f64(double %42)
  %53 = fcmp ogt double %52, 1.000000e-08
  %54 = select i1 %53, double %42, double 1.000000e+00
  %55 = fdiv double %51, %54
  %56 = call double @llvm.fabs.f64(double %55)
  %57 = fcmp olt double %56, 0x3EB0C6F7A0B5ED8D
  br i1 %57, label %61, label %58

58:                                               ; preds = %41
  %59 = load i32, ptr @current_test, align 4, !tbaa !11
  %60 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %59) #12
  br label %61

61:                                               ; preds = %58, %41
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %62 = add nuw nsw i32 %13, 1
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  %64 = icmp slt i32 %62, %63
  br i1 %64, label %12, label %65, !llvm.loop !58

65:                                               ; preds = %61, %3
  %66 = call i64 @clock() #15
  store i64 %66, ptr @end_time, align 8, !tbaa !23
  %67 = load i64, ptr @start_time, align 8, !tbaa !23
  %68 = sub nsw i64 %66, %67
  %69 = sitofp i64 %68 to double
  %70 = fdiv double %69, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %70, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi15EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi13EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi14EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 13)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi15EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 14)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi16EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %224

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 15
  %9 = add nsw i32 %1, -15
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %220, %7
  %13 = phi i32 [ 0, %7 ], [ %221, %220 ]
  br i1 %8, label %14, label %180

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %176, %14 ], [ 0, %12 ]
  %16 = phi double [ %175, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = or i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = or i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = or i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = or i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = or i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = or i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = or i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = or i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = or i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = or i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = or i64 %15, 11
  %127 = getelementptr inbounds double, ptr %0, i64 %126
  %128 = load double, ptr %127, align 8, !tbaa !17
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %125, %134
  %136 = or i64 %15, 12
  %137 = getelementptr inbounds double, ptr %0, i64 %136
  %138 = load double, ptr %137, align 8, !tbaa !17
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %135, %144
  %146 = or i64 %15, 13
  %147 = getelementptr inbounds double, ptr %0, i64 %146
  %148 = load double, ptr %147, align 8, !tbaa !17
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %145, %154
  %156 = or i64 %15, 14
  %157 = getelementptr inbounds double, ptr %0, i64 %156
  %158 = load double, ptr %157, align 8, !tbaa !17
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %155, %164
  %166 = or i64 %15, 15
  %167 = getelementptr inbounds double, ptr %0, i64 %166
  %168 = load double, ptr %167, align 8, !tbaa !17
  %169 = fadd double %168, 1.234500e+04
  %170 = tail call double @llvm.fmuladd.f64(double %169, double 9.142370e+05, double -1.300000e+01)
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %172, 1.234500e+04
  %174 = tail call double @llvm.fmuladd.f64(double %173, double 9.142370e+05, double -1.300000e+01)
  %175 = fadd double %165, %174
  %176 = add nuw nsw i64 %15, 16
  %177 = icmp slt i64 %176, %10
  br i1 %177, label %14, label %178

178:                                              ; preds = %14
  %.lcssa1 = phi double [ %175, %14 ]
  %.lcssa = phi i64 [ %176, %14 ]
  %179 = trunc i64 %.lcssa to i32
  br label %180

180:                                              ; preds = %178, %12
  %181 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %178 ]
  %182 = phi i32 [ 0, %12 ], [ %179, %178 ]
  %183 = icmp slt i32 %182, %1
  br i1 %183, label %184, label %200

184:                                              ; preds = %180
  %185 = zext i32 %182 to i64
  br label %186

186:                                              ; preds = %186, %184
  %187 = phi i64 [ %185, %184 ], [ %198, %186 ]
  %188 = phi double [ %181, %184 ], [ %197, %186 ]
  %189 = getelementptr inbounds double, ptr %0, i64 %187
  %190 = load double, ptr %189, align 8, !tbaa !17
  %191 = fadd double %190, 1.234500e+04
  %192 = tail call double @llvm.fmuladd.f64(double %191, double 9.142370e+05, double -1.300000e+01)
  %193 = fadd double %192, 1.234500e+04
  %194 = tail call double @llvm.fmuladd.f64(double %193, double 9.142370e+05, double -1.300000e+01)
  %195 = fadd double %194, 1.234500e+04
  %196 = tail call double @llvm.fmuladd.f64(double %195, double 9.142370e+05, double -1.300000e+01)
  %197 = fadd double %188, %196
  %198 = add nuw nsw i64 %187, 1
  %199 = icmp eq i64 %198, %11
  br i1 %199, label %200, label %186

200:                                              ; preds = %186, %180
  %201 = phi double [ %181, %180 ], [ %197, %186 ]
  %202 = load double, ptr @init_value, align 8, !tbaa !17
  %203 = fadd double %202, 1.234500e+04
  %204 = tail call double @llvm.fmuladd.f64(double %203, double 9.142370e+05, double -1.300000e+01)
  %205 = fadd double %204, 1.234500e+04
  %206 = tail call double @llvm.fmuladd.f64(double %205, double 9.142370e+05, double -1.300000e+01)
  %207 = fadd double %206, 1.234500e+04
  %208 = tail call double @llvm.fmuladd.f64(double %207, double 9.142370e+05, double -1.300000e+01)
  %209 = fmul double %208, 8.000000e+03
  %210 = fsub double %201, %209
  %211 = tail call double @llvm.fabs.f64(double %201)
  %212 = fcmp ogt double %211, 1.000000e-08
  %213 = select i1 %212, double %201, double 1.000000e+00
  %214 = fdiv double %210, %213
  %215 = tail call double @llvm.fabs.f64(double %214)
  %216 = fcmp olt double %215, 0x3EB0C6F7A0B5ED8D
  br i1 %216, label %220, label %217

217:                                              ; preds = %200
  %218 = load i32, ptr @current_test, align 4, !tbaa !11
  %219 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %218) #12
  br label %220

220:                                              ; preds = %217, %200
  %221 = add nuw nsw i32 %13, 1
  %222 = load i32, ptr @iterations, align 4, !tbaa !11
  %223 = icmp slt i32 %221, %222
  br i1 %223, label %12, label %224, !llvm.loop !59

224:                                              ; preds = %220, %3
  %225 = tail call i64 @clock() #15
  store i64 %225, ptr @end_time, align 8, !tbaa !23
  %226 = load i64, ptr @start_time, align 8, !tbaa !23
  %227 = sub nsw i64 %225, %226
  %228 = sitofp i64 %227 to double
  %229 = fdiv double %228, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %229, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi17EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %234

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 16
  %9 = add nsw i32 %1, -16
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %230, %7
  %13 = phi i32 [ 0, %7 ], [ %231, %230 ]
  br i1 %8, label %14, label %190

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %186, %14 ], [ 0, %12 ]
  %16 = phi double [ %185, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = add nuw nsw i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = add nuw nsw i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = add nuw nsw i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = add nuw nsw i64 %15, 11
  %127 = getelementptr inbounds double, ptr %0, i64 %126
  %128 = load double, ptr %127, align 8, !tbaa !17
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %125, %134
  %136 = add nuw nsw i64 %15, 12
  %137 = getelementptr inbounds double, ptr %0, i64 %136
  %138 = load double, ptr %137, align 8, !tbaa !17
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %135, %144
  %146 = add nuw nsw i64 %15, 13
  %147 = getelementptr inbounds double, ptr %0, i64 %146
  %148 = load double, ptr %147, align 8, !tbaa !17
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %145, %154
  %156 = add nuw nsw i64 %15, 14
  %157 = getelementptr inbounds double, ptr %0, i64 %156
  %158 = load double, ptr %157, align 8, !tbaa !17
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %155, %164
  %166 = add nuw nsw i64 %15, 15
  %167 = getelementptr inbounds double, ptr %0, i64 %166
  %168 = load double, ptr %167, align 8, !tbaa !17
  %169 = fadd double %168, 1.234500e+04
  %170 = tail call double @llvm.fmuladd.f64(double %169, double 9.142370e+05, double -1.300000e+01)
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %172, 1.234500e+04
  %174 = tail call double @llvm.fmuladd.f64(double %173, double 9.142370e+05, double -1.300000e+01)
  %175 = fadd double %165, %174
  %176 = add nuw nsw i64 %15, 16
  %177 = getelementptr inbounds double, ptr %0, i64 %176
  %178 = load double, ptr %177, align 8, !tbaa !17
  %179 = fadd double %178, 1.234500e+04
  %180 = tail call double @llvm.fmuladd.f64(double %179, double 9.142370e+05, double -1.300000e+01)
  %181 = fadd double %180, 1.234500e+04
  %182 = tail call double @llvm.fmuladd.f64(double %181, double 9.142370e+05, double -1.300000e+01)
  %183 = fadd double %182, 1.234500e+04
  %184 = tail call double @llvm.fmuladd.f64(double %183, double 9.142370e+05, double -1.300000e+01)
  %185 = fadd double %175, %184
  %186 = add nuw nsw i64 %15, 17
  %187 = icmp slt i64 %186, %10
  br i1 %187, label %14, label %188

188:                                              ; preds = %14
  %.lcssa1 = phi double [ %185, %14 ]
  %.lcssa = phi i64 [ %186, %14 ]
  %189 = trunc i64 %.lcssa to i32
  br label %190

190:                                              ; preds = %188, %12
  %191 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %188 ]
  %192 = phi i32 [ 0, %12 ], [ %189, %188 ]
  %193 = icmp slt i32 %192, %1
  br i1 %193, label %194, label %210

194:                                              ; preds = %190
  %195 = zext i32 %192 to i64
  br label %196

196:                                              ; preds = %196, %194
  %197 = phi i64 [ %195, %194 ], [ %208, %196 ]
  %198 = phi double [ %191, %194 ], [ %207, %196 ]
  %199 = getelementptr inbounds double, ptr %0, i64 %197
  %200 = load double, ptr %199, align 8, !tbaa !17
  %201 = fadd double %200, 1.234500e+04
  %202 = tail call double @llvm.fmuladd.f64(double %201, double 9.142370e+05, double -1.300000e+01)
  %203 = fadd double %202, 1.234500e+04
  %204 = tail call double @llvm.fmuladd.f64(double %203, double 9.142370e+05, double -1.300000e+01)
  %205 = fadd double %204, 1.234500e+04
  %206 = tail call double @llvm.fmuladd.f64(double %205, double 9.142370e+05, double -1.300000e+01)
  %207 = fadd double %198, %206
  %208 = add nuw nsw i64 %197, 1
  %209 = icmp eq i64 %208, %11
  br i1 %209, label %210, label %196

210:                                              ; preds = %196, %190
  %211 = phi double [ %191, %190 ], [ %207, %196 ]
  %212 = load double, ptr @init_value, align 8, !tbaa !17
  %213 = fadd double %212, 1.234500e+04
  %214 = tail call double @llvm.fmuladd.f64(double %213, double 9.142370e+05, double -1.300000e+01)
  %215 = fadd double %214, 1.234500e+04
  %216 = tail call double @llvm.fmuladd.f64(double %215, double 9.142370e+05, double -1.300000e+01)
  %217 = fadd double %216, 1.234500e+04
  %218 = tail call double @llvm.fmuladd.f64(double %217, double 9.142370e+05, double -1.300000e+01)
  %219 = fmul double %218, 8.000000e+03
  %220 = fsub double %211, %219
  %221 = tail call double @llvm.fabs.f64(double %211)
  %222 = fcmp ogt double %221, 1.000000e-08
  %223 = select i1 %222, double %211, double 1.000000e+00
  %224 = fdiv double %220, %223
  %225 = tail call double @llvm.fabs.f64(double %224)
  %226 = fcmp olt double %225, 0x3EB0C6F7A0B5ED8D
  br i1 %226, label %230, label %227

227:                                              ; preds = %210
  %228 = load i32, ptr @current_test, align 4, !tbaa !11
  %229 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %228) #12
  br label %230

230:                                              ; preds = %227, %210
  %231 = add nuw nsw i32 %13, 1
  %232 = load i32, ptr @iterations, align 4, !tbaa !11
  %233 = icmp slt i32 %231, %232
  br i1 %233, label %12, label %234, !llvm.loop !60

234:                                              ; preds = %230, %3
  %235 = tail call i64 @clock() #15
  store i64 %235, ptr @end_time, align 8, !tbaa !23
  %236 = load i64, ptr @start_time, align 8, !tbaa !23
  %237 = sub nsw i64 %235, %236
  %238 = sitofp i64 %237 to double
  %239 = fdiv double %238, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %239, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi13EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi11EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi12EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 11)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi13EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 12)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi14EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %204

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 13
  %9 = add nsw i32 %1, -13
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %200, %7
  %13 = phi i32 [ 0, %7 ], [ %201, %200 ]
  br i1 %8, label %14, label %160

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %156, %14 ], [ 0, %12 ]
  %16 = phi double [ %155, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = or i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = add nuw nsw i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = add nuw nsw i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = add nuw nsw i64 %15, 11
  %127 = getelementptr inbounds double, ptr %0, i64 %126
  %128 = load double, ptr %127, align 8, !tbaa !17
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %125, %134
  %136 = add nuw nsw i64 %15, 12
  %137 = getelementptr inbounds double, ptr %0, i64 %136
  %138 = load double, ptr %137, align 8, !tbaa !17
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %135, %144
  %146 = add nuw nsw i64 %15, 13
  %147 = getelementptr inbounds double, ptr %0, i64 %146
  %148 = load double, ptr %147, align 8, !tbaa !17
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %145, %154
  %156 = add nuw nsw i64 %15, 14
  %157 = icmp slt i64 %156, %10
  br i1 %157, label %14, label %158

158:                                              ; preds = %14
  %.lcssa1 = phi double [ %155, %14 ]
  %.lcssa = phi i64 [ %156, %14 ]
  %159 = trunc i64 %.lcssa to i32
  br label %160

160:                                              ; preds = %158, %12
  %161 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %158 ]
  %162 = phi i32 [ 0, %12 ], [ %159, %158 ]
  %163 = icmp slt i32 %162, %1
  br i1 %163, label %164, label %180

164:                                              ; preds = %160
  %165 = zext i32 %162 to i64
  br label %166

166:                                              ; preds = %166, %164
  %167 = phi i64 [ %165, %164 ], [ %178, %166 ]
  %168 = phi double [ %161, %164 ], [ %177, %166 ]
  %169 = getelementptr inbounds double, ptr %0, i64 %167
  %170 = load double, ptr %169, align 8, !tbaa !17
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %172, 1.234500e+04
  %174 = tail call double @llvm.fmuladd.f64(double %173, double 9.142370e+05, double -1.300000e+01)
  %175 = fadd double %174, 1.234500e+04
  %176 = tail call double @llvm.fmuladd.f64(double %175, double 9.142370e+05, double -1.300000e+01)
  %177 = fadd double %168, %176
  %178 = add nuw nsw i64 %167, 1
  %179 = icmp eq i64 %178, %11
  br i1 %179, label %180, label %166

180:                                              ; preds = %166, %160
  %181 = phi double [ %161, %160 ], [ %177, %166 ]
  %182 = load double, ptr @init_value, align 8, !tbaa !17
  %183 = fadd double %182, 1.234500e+04
  %184 = tail call double @llvm.fmuladd.f64(double %183, double 9.142370e+05, double -1.300000e+01)
  %185 = fadd double %184, 1.234500e+04
  %186 = tail call double @llvm.fmuladd.f64(double %185, double 9.142370e+05, double -1.300000e+01)
  %187 = fadd double %186, 1.234500e+04
  %188 = tail call double @llvm.fmuladd.f64(double %187, double 9.142370e+05, double -1.300000e+01)
  %189 = fmul double %188, 8.000000e+03
  %190 = fsub double %181, %189
  %191 = tail call double @llvm.fabs.f64(double %181)
  %192 = fcmp ogt double %191, 1.000000e-08
  %193 = select i1 %192, double %181, double 1.000000e+00
  %194 = fdiv double %190, %193
  %195 = tail call double @llvm.fabs.f64(double %194)
  %196 = fcmp olt double %195, 0x3EB0C6F7A0B5ED8D
  br i1 %196, label %200, label %197

197:                                              ; preds = %180
  %198 = load i32, ptr @current_test, align 4, !tbaa !11
  %199 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %198) #12
  br label %200

200:                                              ; preds = %197, %180
  %201 = add nuw nsw i32 %13, 1
  %202 = load i32, ptr @iterations, align 4, !tbaa !11
  %203 = icmp slt i32 %201, %202
  br i1 %203, label %12, label %204, !llvm.loop !61

204:                                              ; preds = %200, %3
  %205 = tail call i64 @clock() #15
  store i64 %205, ptr @end_time, align 8, !tbaa !23
  %206 = load i64, ptr @start_time, align 8, !tbaa !23
  %207 = sub nsw i64 %205, %206
  %208 = sitofp i64 %207 to double
  %209 = fdiv double %208, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %209, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi15EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %214

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 14
  %9 = add nsw i32 %1, -14
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %210, %7
  %13 = phi i32 [ 0, %7 ], [ %211, %210 ]
  br i1 %8, label %14, label %170

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %166, %14 ], [ 0, %12 ]
  %16 = phi double [ %165, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = add nuw nsw i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = add nuw nsw i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = add nuw nsw i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = add nuw nsw i64 %15, 11
  %127 = getelementptr inbounds double, ptr %0, i64 %126
  %128 = load double, ptr %127, align 8, !tbaa !17
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %125, %134
  %136 = add nuw nsw i64 %15, 12
  %137 = getelementptr inbounds double, ptr %0, i64 %136
  %138 = load double, ptr %137, align 8, !tbaa !17
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %135, %144
  %146 = add nuw nsw i64 %15, 13
  %147 = getelementptr inbounds double, ptr %0, i64 %146
  %148 = load double, ptr %147, align 8, !tbaa !17
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %145, %154
  %156 = add nuw nsw i64 %15, 14
  %157 = getelementptr inbounds double, ptr %0, i64 %156
  %158 = load double, ptr %157, align 8, !tbaa !17
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %155, %164
  %166 = add nuw nsw i64 %15, 15
  %167 = icmp slt i64 %166, %10
  br i1 %167, label %14, label %168

168:                                              ; preds = %14
  %.lcssa1 = phi double [ %165, %14 ]
  %.lcssa = phi i64 [ %166, %14 ]
  %169 = trunc i64 %.lcssa to i32
  br label %170

170:                                              ; preds = %168, %12
  %171 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %168 ]
  %172 = phi i32 [ 0, %12 ], [ %169, %168 ]
  %173 = icmp slt i32 %172, %1
  br i1 %173, label %174, label %190

174:                                              ; preds = %170
  %175 = zext i32 %172 to i64
  br label %176

176:                                              ; preds = %176, %174
  %177 = phi i64 [ %175, %174 ], [ %188, %176 ]
  %178 = phi double [ %171, %174 ], [ %187, %176 ]
  %179 = getelementptr inbounds double, ptr %0, i64 %177
  %180 = load double, ptr %179, align 8, !tbaa !17
  %181 = fadd double %180, 1.234500e+04
  %182 = tail call double @llvm.fmuladd.f64(double %181, double 9.142370e+05, double -1.300000e+01)
  %183 = fadd double %182, 1.234500e+04
  %184 = tail call double @llvm.fmuladd.f64(double %183, double 9.142370e+05, double -1.300000e+01)
  %185 = fadd double %184, 1.234500e+04
  %186 = tail call double @llvm.fmuladd.f64(double %185, double 9.142370e+05, double -1.300000e+01)
  %187 = fadd double %178, %186
  %188 = add nuw nsw i64 %177, 1
  %189 = icmp eq i64 %188, %11
  br i1 %189, label %190, label %176

190:                                              ; preds = %176, %170
  %191 = phi double [ %171, %170 ], [ %187, %176 ]
  %192 = load double, ptr @init_value, align 8, !tbaa !17
  %193 = fadd double %192, 1.234500e+04
  %194 = tail call double @llvm.fmuladd.f64(double %193, double 9.142370e+05, double -1.300000e+01)
  %195 = fadd double %194, 1.234500e+04
  %196 = tail call double @llvm.fmuladd.f64(double %195, double 9.142370e+05, double -1.300000e+01)
  %197 = fadd double %196, 1.234500e+04
  %198 = tail call double @llvm.fmuladd.f64(double %197, double 9.142370e+05, double -1.300000e+01)
  %199 = fmul double %198, 8.000000e+03
  %200 = fsub double %191, %199
  %201 = tail call double @llvm.fabs.f64(double %191)
  %202 = fcmp ogt double %201, 1.000000e-08
  %203 = select i1 %202, double %191, double 1.000000e+00
  %204 = fdiv double %200, %203
  %205 = tail call double @llvm.fabs.f64(double %204)
  %206 = fcmp olt double %205, 0x3EB0C6F7A0B5ED8D
  br i1 %206, label %210, label %207

207:                                              ; preds = %190
  %208 = load i32, ptr @current_test, align 4, !tbaa !11
  %209 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %208) #12
  br label %210

210:                                              ; preds = %207, %190
  %211 = add nuw nsw i32 %13, 1
  %212 = load i32, ptr @iterations, align 4, !tbaa !11
  %213 = icmp slt i32 %211, %212
  br i1 %213, label %12, label %214, !llvm.loop !62

214:                                              ; preds = %210, %3
  %215 = tail call i64 @clock() #15
  store i64 %215, ptr @end_time, align 8, !tbaa !23
  %216 = load i64, ptr @start_time, align 8, !tbaa !23
  %217 = sub nsw i64 %215, %216
  %218 = sitofp i64 %217 to double
  %219 = fdiv double %218, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %219, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi11EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi9EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi10EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 9)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi11EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 10)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi12EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %184

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 11
  %9 = add nsw i32 %1, -11
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %180, %7
  %13 = phi i32 [ 0, %7 ], [ %181, %180 ]
  br i1 %8, label %14, label %140

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %136, %14 ], [ 0, %12 ]
  %16 = phi double [ %135, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = or i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = or i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = or i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = add nuw nsw i64 %15, 11
  %127 = getelementptr inbounds double, ptr %0, i64 %126
  %128 = load double, ptr %127, align 8, !tbaa !17
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %125, %134
  %136 = add nuw nsw i64 %15, 12
  %137 = icmp slt i64 %136, %10
  br i1 %137, label %14, label %138

138:                                              ; preds = %14
  %.lcssa1 = phi double [ %135, %14 ]
  %.lcssa = phi i64 [ %136, %14 ]
  %139 = trunc i64 %.lcssa to i32
  br label %140

140:                                              ; preds = %138, %12
  %141 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %138 ]
  %142 = phi i32 [ 0, %12 ], [ %139, %138 ]
  %143 = icmp slt i32 %142, %1
  br i1 %143, label %144, label %160

144:                                              ; preds = %140
  %145 = zext i32 %142 to i64
  br label %146

146:                                              ; preds = %146, %144
  %147 = phi i64 [ %145, %144 ], [ %158, %146 ]
  %148 = phi double [ %141, %144 ], [ %157, %146 ]
  %149 = getelementptr inbounds double, ptr %0, i64 %147
  %150 = load double, ptr %149, align 8, !tbaa !17
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %154, 1.234500e+04
  %156 = tail call double @llvm.fmuladd.f64(double %155, double 9.142370e+05, double -1.300000e+01)
  %157 = fadd double %148, %156
  %158 = add nuw nsw i64 %147, 1
  %159 = icmp eq i64 %158, %11
  br i1 %159, label %160, label %146

160:                                              ; preds = %146, %140
  %161 = phi double [ %141, %140 ], [ %157, %146 ]
  %162 = load double, ptr @init_value, align 8, !tbaa !17
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %164, 1.234500e+04
  %166 = tail call double @llvm.fmuladd.f64(double %165, double 9.142370e+05, double -1.300000e+01)
  %167 = fadd double %166, 1.234500e+04
  %168 = tail call double @llvm.fmuladd.f64(double %167, double 9.142370e+05, double -1.300000e+01)
  %169 = fmul double %168, 8.000000e+03
  %170 = fsub double %161, %169
  %171 = tail call double @llvm.fabs.f64(double %161)
  %172 = fcmp ogt double %171, 1.000000e-08
  %173 = select i1 %172, double %161, double 1.000000e+00
  %174 = fdiv double %170, %173
  %175 = tail call double @llvm.fabs.f64(double %174)
  %176 = fcmp olt double %175, 0x3EB0C6F7A0B5ED8D
  br i1 %176, label %180, label %177

177:                                              ; preds = %160
  %178 = load i32, ptr @current_test, align 4, !tbaa !11
  %179 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %178) #12
  br label %180

180:                                              ; preds = %177, %160
  %181 = add nuw nsw i32 %13, 1
  %182 = load i32, ptr @iterations, align 4, !tbaa !11
  %183 = icmp slt i32 %181, %182
  br i1 %183, label %12, label %184, !llvm.loop !63

184:                                              ; preds = %180, %3
  %185 = tail call i64 @clock() #15
  store i64 %185, ptr @end_time, align 8, !tbaa !23
  %186 = load i64, ptr @start_time, align 8, !tbaa !23
  %187 = sub nsw i64 %185, %186
  %188 = sitofp i64 %187 to double
  %189 = fdiv double %188, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %189, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi13EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %194

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 12
  %9 = add nsw i32 %1, -12
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %190, %7
  %13 = phi i32 [ 0, %7 ], [ %191, %190 ]
  br i1 %8, label %14, label %150

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %146, %14 ], [ 0, %12 ]
  %16 = phi double [ %145, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = add nuw nsw i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = add nuw nsw i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = add nuw nsw i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = add nuw nsw i64 %15, 11
  %127 = getelementptr inbounds double, ptr %0, i64 %126
  %128 = load double, ptr %127, align 8, !tbaa !17
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %125, %134
  %136 = add nuw nsw i64 %15, 12
  %137 = getelementptr inbounds double, ptr %0, i64 %136
  %138 = load double, ptr %137, align 8, !tbaa !17
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %135, %144
  %146 = add nuw nsw i64 %15, 13
  %147 = icmp slt i64 %146, %10
  br i1 %147, label %14, label %148

148:                                              ; preds = %14
  %.lcssa1 = phi double [ %145, %14 ]
  %.lcssa = phi i64 [ %146, %14 ]
  %149 = trunc i64 %.lcssa to i32
  br label %150

150:                                              ; preds = %148, %12
  %151 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %148 ]
  %152 = phi i32 [ 0, %12 ], [ %149, %148 ]
  %153 = icmp slt i32 %152, %1
  br i1 %153, label %154, label %170

154:                                              ; preds = %150
  %155 = zext i32 %152 to i64
  br label %156

156:                                              ; preds = %156, %154
  %157 = phi i64 [ %155, %154 ], [ %168, %156 ]
  %158 = phi double [ %151, %154 ], [ %167, %156 ]
  %159 = getelementptr inbounds double, ptr %0, i64 %157
  %160 = load double, ptr %159, align 8, !tbaa !17
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %164, 1.234500e+04
  %166 = tail call double @llvm.fmuladd.f64(double %165, double 9.142370e+05, double -1.300000e+01)
  %167 = fadd double %158, %166
  %168 = add nuw nsw i64 %157, 1
  %169 = icmp eq i64 %168, %11
  br i1 %169, label %170, label %156

170:                                              ; preds = %156, %150
  %171 = phi double [ %151, %150 ], [ %167, %156 ]
  %172 = load double, ptr @init_value, align 8, !tbaa !17
  %173 = fadd double %172, 1.234500e+04
  %174 = tail call double @llvm.fmuladd.f64(double %173, double 9.142370e+05, double -1.300000e+01)
  %175 = fadd double %174, 1.234500e+04
  %176 = tail call double @llvm.fmuladd.f64(double %175, double 9.142370e+05, double -1.300000e+01)
  %177 = fadd double %176, 1.234500e+04
  %178 = tail call double @llvm.fmuladd.f64(double %177, double 9.142370e+05, double -1.300000e+01)
  %179 = fmul double %178, 8.000000e+03
  %180 = fsub double %171, %179
  %181 = tail call double @llvm.fabs.f64(double %171)
  %182 = fcmp ogt double %181, 1.000000e-08
  %183 = select i1 %182, double %171, double 1.000000e+00
  %184 = fdiv double %180, %183
  %185 = tail call double @llvm.fabs.f64(double %184)
  %186 = fcmp olt double %185, 0x3EB0C6F7A0B5ED8D
  br i1 %186, label %190, label %187

187:                                              ; preds = %170
  %188 = load i32, ptr @current_test, align 4, !tbaa !11
  %189 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %188) #12
  br label %190

190:                                              ; preds = %187, %170
  %191 = add nuw nsw i32 %13, 1
  %192 = load i32, ptr @iterations, align 4, !tbaa !11
  %193 = icmp slt i32 %191, %192
  br i1 %193, label %12, label %194, !llvm.loop !64

194:                                              ; preds = %190, %3
  %195 = tail call i64 @clock() #15
  store i64 %195, ptr @end_time, align 8, !tbaa !23
  %196 = load i64, ptr @start_time, align 8, !tbaa !23
  %197 = sub nsw i64 %195, %196
  %198 = sitofp i64 %197 to double
  %199 = fdiv double %198, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %199, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi9EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi7EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi8EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 7)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi9EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 8)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi10EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %164

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 9
  %9 = add nsw i32 %1, -9
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %160, %7
  %13 = phi i32 [ 0, %7 ], [ %161, %160 ]
  br i1 %8, label %14, label %120

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %116, %14 ], [ 0, %12 ]
  %16 = phi double [ %115, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = or i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = add nuw nsw i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = add nuw nsw i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = icmp slt i64 %116, %10
  br i1 %117, label %14, label %118

118:                                              ; preds = %14
  %.lcssa1 = phi double [ %115, %14 ]
  %.lcssa = phi i64 [ %116, %14 ]
  %119 = trunc i64 %.lcssa to i32
  br label %120

120:                                              ; preds = %118, %12
  %121 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %118 ]
  %122 = phi i32 [ 0, %12 ], [ %119, %118 ]
  %123 = icmp slt i32 %122, %1
  br i1 %123, label %124, label %140

124:                                              ; preds = %120
  %125 = zext i32 %122 to i64
  br label %126

126:                                              ; preds = %126, %124
  %127 = phi i64 [ %125, %124 ], [ %138, %126 ]
  %128 = phi double [ %121, %124 ], [ %137, %126 ]
  %129 = getelementptr inbounds double, ptr %0, i64 %127
  %130 = load double, ptr %129, align 8, !tbaa !17
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %134, 1.234500e+04
  %136 = tail call double @llvm.fmuladd.f64(double %135, double 9.142370e+05, double -1.300000e+01)
  %137 = fadd double %128, %136
  %138 = add nuw nsw i64 %127, 1
  %139 = icmp eq i64 %138, %11
  br i1 %139, label %140, label %126

140:                                              ; preds = %126, %120
  %141 = phi double [ %121, %120 ], [ %137, %126 ]
  %142 = load double, ptr @init_value, align 8, !tbaa !17
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %144, 1.234500e+04
  %146 = tail call double @llvm.fmuladd.f64(double %145, double 9.142370e+05, double -1.300000e+01)
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fmul double %148, 8.000000e+03
  %150 = fsub double %141, %149
  %151 = tail call double @llvm.fabs.f64(double %141)
  %152 = fcmp ogt double %151, 1.000000e-08
  %153 = select i1 %152, double %141, double 1.000000e+00
  %154 = fdiv double %150, %153
  %155 = tail call double @llvm.fabs.f64(double %154)
  %156 = fcmp olt double %155, 0x3EB0C6F7A0B5ED8D
  br i1 %156, label %160, label %157

157:                                              ; preds = %140
  %158 = load i32, ptr @current_test, align 4, !tbaa !11
  %159 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %158) #12
  br label %160

160:                                              ; preds = %157, %140
  %161 = add nuw nsw i32 %13, 1
  %162 = load i32, ptr @iterations, align 4, !tbaa !11
  %163 = icmp slt i32 %161, %162
  br i1 %163, label %12, label %164, !llvm.loop !65

164:                                              ; preds = %160, %3
  %165 = tail call i64 @clock() #15
  store i64 %165, ptr @end_time, align 8, !tbaa !23
  %166 = load i64, ptr @start_time, align 8, !tbaa !23
  %167 = sub nsw i64 %165, %166
  %168 = sitofp i64 %167 to double
  %169 = fdiv double %168, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %169, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi11EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %174

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 10
  %9 = add nsw i32 %1, -10
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %170, %7
  %13 = phi i32 [ 0, %7 ], [ %171, %170 ]
  br i1 %8, label %14, label %130

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %126, %14 ], [ 0, %12 ]
  %16 = phi double [ %125, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = add nuw nsw i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = add nuw nsw i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = add nuw nsw i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = add nuw nsw i64 %15, 11
  %127 = icmp slt i64 %126, %10
  br i1 %127, label %14, label %128

128:                                              ; preds = %14
  %.lcssa1 = phi double [ %125, %14 ]
  %.lcssa = phi i64 [ %126, %14 ]
  %129 = trunc i64 %.lcssa to i32
  br label %130

130:                                              ; preds = %128, %12
  %131 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %128 ]
  %132 = phi i32 [ 0, %12 ], [ %129, %128 ]
  %133 = icmp slt i32 %132, %1
  br i1 %133, label %134, label %150

134:                                              ; preds = %130
  %135 = zext i32 %132 to i64
  br label %136

136:                                              ; preds = %136, %134
  %137 = phi i64 [ %135, %134 ], [ %148, %136 ]
  %138 = phi double [ %131, %134 ], [ %147, %136 ]
  %139 = getelementptr inbounds double, ptr %0, i64 %137
  %140 = load double, ptr %139, align 8, !tbaa !17
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %144, 1.234500e+04
  %146 = tail call double @llvm.fmuladd.f64(double %145, double 9.142370e+05, double -1.300000e+01)
  %147 = fadd double %138, %146
  %148 = add nuw nsw i64 %137, 1
  %149 = icmp eq i64 %148, %11
  br i1 %149, label %150, label %136

150:                                              ; preds = %136, %130
  %151 = phi double [ %131, %130 ], [ %147, %136 ]
  %152 = load double, ptr @init_value, align 8, !tbaa !17
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %154, 1.234500e+04
  %156 = tail call double @llvm.fmuladd.f64(double %155, double 9.142370e+05, double -1.300000e+01)
  %157 = fadd double %156, 1.234500e+04
  %158 = tail call double @llvm.fmuladd.f64(double %157, double 9.142370e+05, double -1.300000e+01)
  %159 = fmul double %158, 8.000000e+03
  %160 = fsub double %151, %159
  %161 = tail call double @llvm.fabs.f64(double %151)
  %162 = fcmp ogt double %161, 1.000000e-08
  %163 = select i1 %162, double %151, double 1.000000e+00
  %164 = fdiv double %160, %163
  %165 = tail call double @llvm.fabs.f64(double %164)
  %166 = fcmp olt double %165, 0x3EB0C6F7A0B5ED8D
  br i1 %166, label %170, label %167

167:                                              ; preds = %150
  %168 = load i32, ptr @current_test, align 4, !tbaa !11
  %169 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %168) #12
  br label %170

170:                                              ; preds = %167, %150
  %171 = add nuw nsw i32 %13, 1
  %172 = load i32, ptr @iterations, align 4, !tbaa !11
  %173 = icmp slt i32 %171, %172
  br i1 %173, label %12, label %174, !llvm.loop !66

174:                                              ; preds = %170, %3
  %175 = tail call i64 @clock() #15
  store i64 %175, ptr @end_time, align 8, !tbaa !23
  %176 = load i64, ptr @start_time, align 8, !tbaa !23
  %177 = sub nsw i64 %175, %176
  %178 = sitofp i64 %177 to double
  %179 = fdiv double %178, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %179, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi7EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi5EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi6EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 5)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi7EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 6)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi8EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %146

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 7
  %9 = add nsw i32 %1, -7
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %142, %7
  %13 = phi i32 [ %5, %7 ], [ %143, %142 ]
  %14 = phi i32 [ 0, %7 ], [ %144, %142 ]
  br i1 %8, label %15, label %101

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %97, %15 ], [ 0, %12 ]
  %17 = phi double [ %96, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = or i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = or i64 %16, 2
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !17
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %36, %45
  %47 = or i64 %16, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !17
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %46, %55
  %57 = or i64 %16, 4
  %58 = getelementptr inbounds double, ptr %0, i64 %57
  %59 = load double, ptr %58, align 8, !tbaa !17
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %56, %65
  %67 = or i64 %16, 5
  %68 = getelementptr inbounds double, ptr %0, i64 %67
  %69 = load double, ptr %68, align 8, !tbaa !17
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %66, %75
  %77 = or i64 %16, 6
  %78 = getelementptr inbounds double, ptr %0, i64 %77
  %79 = load double, ptr %78, align 8, !tbaa !17
  %80 = fadd double %79, 1.234500e+04
  %81 = tail call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %83, 1.234500e+04
  %85 = tail call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %76, %85
  %87 = or i64 %16, 7
  %88 = getelementptr inbounds double, ptr %0, i64 %87
  %89 = load double, ptr %88, align 8, !tbaa !17
  %90 = fadd double %89, 1.234500e+04
  %91 = tail call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %91, 1.234500e+04
  %93 = tail call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %93, 1.234500e+04
  %95 = tail call double @llvm.fmuladd.f64(double %94, double 9.142370e+05, double -1.300000e+01)
  %96 = fadd double %86, %95
  %97 = add nuw nsw i64 %16, 8
  %98 = icmp slt i64 %97, %10
  br i1 %98, label %15, label %99

99:                                               ; preds = %15
  %.lcssa1 = phi double [ %96, %15 ]
  %.lcssa = phi i64 [ %97, %15 ]
  %100 = trunc i64 %.lcssa to i32
  br label %101

101:                                              ; preds = %99, %12
  %102 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %99 ]
  %103 = phi i32 [ 0, %12 ], [ %100, %99 ]
  %104 = icmp slt i32 %103, %1
  br i1 %104, label %105, label %121

105:                                              ; preds = %101
  %106 = zext i32 %103 to i64
  br label %107

107:                                              ; preds = %107, %105
  %108 = phi i64 [ %106, %105 ], [ %119, %107 ]
  %109 = phi double [ %102, %105 ], [ %118, %107 ]
  %110 = getelementptr inbounds double, ptr %0, i64 %108
  %111 = load double, ptr %110, align 8, !tbaa !17
  %112 = fadd double %111, 1.234500e+04
  %113 = tail call double @llvm.fmuladd.f64(double %112, double 9.142370e+05, double -1.300000e+01)
  %114 = fadd double %113, 1.234500e+04
  %115 = tail call double @llvm.fmuladd.f64(double %114, double 9.142370e+05, double -1.300000e+01)
  %116 = fadd double %115, 1.234500e+04
  %117 = tail call double @llvm.fmuladd.f64(double %116, double 9.142370e+05, double -1.300000e+01)
  %118 = fadd double %109, %117
  %119 = add nuw nsw i64 %108, 1
  %120 = icmp eq i64 %119, %11
  br i1 %120, label %121, label %107

121:                                              ; preds = %107, %101
  %122 = phi double [ %102, %101 ], [ %118, %107 ]
  %123 = load double, ptr @init_value, align 8, !tbaa !17
  %124 = fadd double %123, 1.234500e+04
  %125 = tail call double @llvm.fmuladd.f64(double %124, double 9.142370e+05, double -1.300000e+01)
  %126 = fadd double %125, 1.234500e+04
  %127 = tail call double @llvm.fmuladd.f64(double %126, double 9.142370e+05, double -1.300000e+01)
  %128 = fadd double %127, 1.234500e+04
  %129 = tail call double @llvm.fmuladd.f64(double %128, double 9.142370e+05, double -1.300000e+01)
  %130 = fmul double %129, 8.000000e+03
  %131 = fsub double %122, %130
  %132 = tail call double @llvm.fabs.f64(double %122)
  %133 = fcmp ogt double %132, 1.000000e-08
  %134 = select i1 %133, double %122, double 1.000000e+00
  %135 = fdiv double %131, %134
  %136 = tail call double @llvm.fabs.f64(double %135)
  %137 = fcmp olt double %136, 0x3EB0C6F7A0B5ED8D
  br i1 %137, label %142, label %138

138:                                              ; preds = %121
  %139 = load i32, ptr @current_test, align 4, !tbaa !11
  %140 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %139) #12
  %141 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %142

142:                                              ; preds = %138, %121
  %143 = phi i32 [ %13, %121 ], [ %141, %138 ]
  %144 = add nuw nsw i32 %14, 1
  %145 = icmp slt i32 %144, %143
  br i1 %145, label %12, label %146, !llvm.loop !67

146:                                              ; preds = %142, %3
  %147 = tail call i64 @clock() #15
  store i64 %147, ptr @end_time, align 8, !tbaa !23
  %148 = load i64, ptr @start_time, align 8, !tbaa !23
  %149 = sub nsw i64 %147, %148
  %150 = sitofp i64 %149 to double
  %151 = fdiv double %150, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %151, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi9EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %156

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 8
  %9 = add nsw i32 %1, -8
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %152, %7
  %13 = phi i32 [ %5, %7 ], [ %153, %152 ]
  %14 = phi i32 [ 0, %7 ], [ %154, %152 ]
  br i1 %8, label %15, label %111

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %107, %15 ], [ 0, %12 ]
  %17 = phi double [ %106, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = add nuw nsw i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = add nuw nsw i64 %16, 2
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !17
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %36, %45
  %47 = add nuw nsw i64 %16, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !17
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %46, %55
  %57 = add nuw nsw i64 %16, 4
  %58 = getelementptr inbounds double, ptr %0, i64 %57
  %59 = load double, ptr %58, align 8, !tbaa !17
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %56, %65
  %67 = add nuw nsw i64 %16, 5
  %68 = getelementptr inbounds double, ptr %0, i64 %67
  %69 = load double, ptr %68, align 8, !tbaa !17
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %66, %75
  %77 = add nuw nsw i64 %16, 6
  %78 = getelementptr inbounds double, ptr %0, i64 %77
  %79 = load double, ptr %78, align 8, !tbaa !17
  %80 = fadd double %79, 1.234500e+04
  %81 = tail call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %83, 1.234500e+04
  %85 = tail call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %76, %85
  %87 = add nuw nsw i64 %16, 7
  %88 = getelementptr inbounds double, ptr %0, i64 %87
  %89 = load double, ptr %88, align 8, !tbaa !17
  %90 = fadd double %89, 1.234500e+04
  %91 = tail call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %91, 1.234500e+04
  %93 = tail call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %93, 1.234500e+04
  %95 = tail call double @llvm.fmuladd.f64(double %94, double 9.142370e+05, double -1.300000e+01)
  %96 = fadd double %86, %95
  %97 = add nuw nsw i64 %16, 8
  %98 = getelementptr inbounds double, ptr %0, i64 %97
  %99 = load double, ptr %98, align 8, !tbaa !17
  %100 = fadd double %99, 1.234500e+04
  %101 = tail call double @llvm.fmuladd.f64(double %100, double 9.142370e+05, double -1.300000e+01)
  %102 = fadd double %101, 1.234500e+04
  %103 = tail call double @llvm.fmuladd.f64(double %102, double 9.142370e+05, double -1.300000e+01)
  %104 = fadd double %103, 1.234500e+04
  %105 = tail call double @llvm.fmuladd.f64(double %104, double 9.142370e+05, double -1.300000e+01)
  %106 = fadd double %96, %105
  %107 = add nuw nsw i64 %16, 9
  %108 = icmp slt i64 %107, %10
  br i1 %108, label %15, label %109

109:                                              ; preds = %15
  %.lcssa1 = phi double [ %106, %15 ]
  %.lcssa = phi i64 [ %107, %15 ]
  %110 = trunc i64 %.lcssa to i32
  br label %111

111:                                              ; preds = %109, %12
  %112 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %109 ]
  %113 = phi i32 [ 0, %12 ], [ %110, %109 ]
  %114 = icmp slt i32 %113, %1
  br i1 %114, label %115, label %131

115:                                              ; preds = %111
  %116 = zext i32 %113 to i64
  br label %117

117:                                              ; preds = %117, %115
  %118 = phi i64 [ %116, %115 ], [ %129, %117 ]
  %119 = phi double [ %112, %115 ], [ %128, %117 ]
  %120 = getelementptr inbounds double, ptr %0, i64 %118
  %121 = load double, ptr %120, align 8, !tbaa !17
  %122 = fadd double %121, 1.234500e+04
  %123 = tail call double @llvm.fmuladd.f64(double %122, double 9.142370e+05, double -1.300000e+01)
  %124 = fadd double %123, 1.234500e+04
  %125 = tail call double @llvm.fmuladd.f64(double %124, double 9.142370e+05, double -1.300000e+01)
  %126 = fadd double %125, 1.234500e+04
  %127 = tail call double @llvm.fmuladd.f64(double %126, double 9.142370e+05, double -1.300000e+01)
  %128 = fadd double %119, %127
  %129 = add nuw nsw i64 %118, 1
  %130 = icmp eq i64 %129, %11
  br i1 %130, label %131, label %117

131:                                              ; preds = %117, %111
  %132 = phi double [ %112, %111 ], [ %128, %117 ]
  %133 = load double, ptr @init_value, align 8, !tbaa !17
  %134 = fadd double %133, 1.234500e+04
  %135 = tail call double @llvm.fmuladd.f64(double %134, double 9.142370e+05, double -1.300000e+01)
  %136 = fadd double %135, 1.234500e+04
  %137 = tail call double @llvm.fmuladd.f64(double %136, double 9.142370e+05, double -1.300000e+01)
  %138 = fadd double %137, 1.234500e+04
  %139 = tail call double @llvm.fmuladd.f64(double %138, double 9.142370e+05, double -1.300000e+01)
  %140 = fmul double %139, 8.000000e+03
  %141 = fsub double %132, %140
  %142 = tail call double @llvm.fabs.f64(double %132)
  %143 = fcmp ogt double %142, 1.000000e-08
  %144 = select i1 %143, double %132, double 1.000000e+00
  %145 = fdiv double %141, %144
  %146 = tail call double @llvm.fabs.f64(double %145)
  %147 = fcmp olt double %146, 0x3EB0C6F7A0B5ED8D
  br i1 %147, label %152, label %148

148:                                              ; preds = %131
  %149 = load i32, ptr @current_test, align 4, !tbaa !11
  %150 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %149) #12
  %151 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %152

152:                                              ; preds = %148, %131
  %153 = phi i32 [ %13, %131 ], [ %151, %148 ]
  %154 = add nuw nsw i32 %14, 1
  %155 = icmp slt i32 %154, %153
  br i1 %155, label %12, label %156, !llvm.loop !68

156:                                              ; preds = %152, %3
  %157 = tail call i64 @clock() #15
  store i64 %157, ptr @end_time, align 8, !tbaa !23
  %158 = load i64, ptr @start_time, align 8, !tbaa !23
  %159 = sub nsw i64 %157, %158
  %160 = sitofp i64 %159 to double
  %161 = fdiv double %160, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %161, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi5EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi3EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi4EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 3)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi5EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 4)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi6EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %126

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 5
  %9 = add nsw i32 %1, -5
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %122, %7
  %13 = phi i32 [ %5, %7 ], [ %123, %122 ]
  %14 = phi i32 [ 0, %7 ], [ %124, %122 ]
  br i1 %8, label %15, label %81

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %77, %15 ], [ 0, %12 ]
  %17 = phi double [ %76, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = or i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = add nuw nsw i64 %16, 2
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !17
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %36, %45
  %47 = add nuw nsw i64 %16, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !17
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %46, %55
  %57 = add nuw nsw i64 %16, 4
  %58 = getelementptr inbounds double, ptr %0, i64 %57
  %59 = load double, ptr %58, align 8, !tbaa !17
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %56, %65
  %67 = add nuw nsw i64 %16, 5
  %68 = getelementptr inbounds double, ptr %0, i64 %67
  %69 = load double, ptr %68, align 8, !tbaa !17
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %66, %75
  %77 = add nuw nsw i64 %16, 6
  %78 = icmp slt i64 %77, %10
  br i1 %78, label %15, label %79

79:                                               ; preds = %15
  %.lcssa1 = phi double [ %76, %15 ]
  %.lcssa = phi i64 [ %77, %15 ]
  %80 = trunc i64 %.lcssa to i32
  br label %81

81:                                               ; preds = %79, %12
  %82 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %79 ]
  %83 = phi i32 [ 0, %12 ], [ %80, %79 ]
  %84 = icmp slt i32 %83, %1
  br i1 %84, label %85, label %101

85:                                               ; preds = %81
  %86 = zext i32 %83 to i64
  br label %87

87:                                               ; preds = %87, %85
  %88 = phi i64 [ %86, %85 ], [ %99, %87 ]
  %89 = phi double [ %82, %85 ], [ %98, %87 ]
  %90 = getelementptr inbounds double, ptr %0, i64 %88
  %91 = load double, ptr %90, align 8, !tbaa !17
  %92 = fadd double %91, 1.234500e+04
  %93 = tail call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %93, 1.234500e+04
  %95 = tail call double @llvm.fmuladd.f64(double %94, double 9.142370e+05, double -1.300000e+01)
  %96 = fadd double %95, 1.234500e+04
  %97 = tail call double @llvm.fmuladd.f64(double %96, double 9.142370e+05, double -1.300000e+01)
  %98 = fadd double %89, %97
  %99 = add nuw nsw i64 %88, 1
  %100 = icmp eq i64 %99, %11
  br i1 %100, label %101, label %87

101:                                              ; preds = %87, %81
  %102 = phi double [ %82, %81 ], [ %98, %87 ]
  %103 = load double, ptr @init_value, align 8, !tbaa !17
  %104 = fadd double %103, 1.234500e+04
  %105 = tail call double @llvm.fmuladd.f64(double %104, double 9.142370e+05, double -1.300000e+01)
  %106 = fadd double %105, 1.234500e+04
  %107 = tail call double @llvm.fmuladd.f64(double %106, double 9.142370e+05, double -1.300000e+01)
  %108 = fadd double %107, 1.234500e+04
  %109 = tail call double @llvm.fmuladd.f64(double %108, double 9.142370e+05, double -1.300000e+01)
  %110 = fmul double %109, 8.000000e+03
  %111 = fsub double %102, %110
  %112 = tail call double @llvm.fabs.f64(double %102)
  %113 = fcmp ogt double %112, 1.000000e-08
  %114 = select i1 %113, double %102, double 1.000000e+00
  %115 = fdiv double %111, %114
  %116 = tail call double @llvm.fabs.f64(double %115)
  %117 = fcmp olt double %116, 0x3EB0C6F7A0B5ED8D
  br i1 %117, label %122, label %118

118:                                              ; preds = %101
  %119 = load i32, ptr @current_test, align 4, !tbaa !11
  %120 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %119) #12
  %121 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %122

122:                                              ; preds = %118, %101
  %123 = phi i32 [ %13, %101 ], [ %121, %118 ]
  %124 = add nuw nsw i32 %14, 1
  %125 = icmp slt i32 %124, %123
  br i1 %125, label %12, label %126, !llvm.loop !69

126:                                              ; preds = %122, %3
  %127 = tail call i64 @clock() #15
  store i64 %127, ptr @end_time, align 8, !tbaa !23
  %128 = load i64, ptr @start_time, align 8, !tbaa !23
  %129 = sub nsw i64 %127, %128
  %130 = sitofp i64 %129 to double
  %131 = fdiv double %130, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %131, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi7EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %136

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 6
  %9 = add nsw i32 %1, -6
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %132, %7
  %13 = phi i32 [ %5, %7 ], [ %133, %132 ]
  %14 = phi i32 [ 0, %7 ], [ %134, %132 ]
  br i1 %8, label %15, label %91

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %87, %15 ], [ 0, %12 ]
  %17 = phi double [ %86, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = add nuw nsw i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = add nuw nsw i64 %16, 2
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !17
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %36, %45
  %47 = add nuw nsw i64 %16, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !17
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %46, %55
  %57 = add nuw nsw i64 %16, 4
  %58 = getelementptr inbounds double, ptr %0, i64 %57
  %59 = load double, ptr %58, align 8, !tbaa !17
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %56, %65
  %67 = add nuw nsw i64 %16, 5
  %68 = getelementptr inbounds double, ptr %0, i64 %67
  %69 = load double, ptr %68, align 8, !tbaa !17
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %66, %75
  %77 = add nuw nsw i64 %16, 6
  %78 = getelementptr inbounds double, ptr %0, i64 %77
  %79 = load double, ptr %78, align 8, !tbaa !17
  %80 = fadd double %79, 1.234500e+04
  %81 = tail call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %83, 1.234500e+04
  %85 = tail call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %76, %85
  %87 = add nuw nsw i64 %16, 7
  %88 = icmp slt i64 %87, %10
  br i1 %88, label %15, label %89

89:                                               ; preds = %15
  %.lcssa1 = phi double [ %86, %15 ]
  %.lcssa = phi i64 [ %87, %15 ]
  %90 = trunc i64 %.lcssa to i32
  br label %91

91:                                               ; preds = %89, %12
  %92 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %89 ]
  %93 = phi i32 [ 0, %12 ], [ %90, %89 ]
  %94 = icmp slt i32 %93, %1
  br i1 %94, label %95, label %111

95:                                               ; preds = %91
  %96 = zext i32 %93 to i64
  br label %97

97:                                               ; preds = %97, %95
  %98 = phi i64 [ %96, %95 ], [ %109, %97 ]
  %99 = phi double [ %92, %95 ], [ %108, %97 ]
  %100 = getelementptr inbounds double, ptr %0, i64 %98
  %101 = load double, ptr %100, align 8, !tbaa !17
  %102 = fadd double %101, 1.234500e+04
  %103 = tail call double @llvm.fmuladd.f64(double %102, double 9.142370e+05, double -1.300000e+01)
  %104 = fadd double %103, 1.234500e+04
  %105 = tail call double @llvm.fmuladd.f64(double %104, double 9.142370e+05, double -1.300000e+01)
  %106 = fadd double %105, 1.234500e+04
  %107 = tail call double @llvm.fmuladd.f64(double %106, double 9.142370e+05, double -1.300000e+01)
  %108 = fadd double %99, %107
  %109 = add nuw nsw i64 %98, 1
  %110 = icmp eq i64 %109, %11
  br i1 %110, label %111, label %97

111:                                              ; preds = %97, %91
  %112 = phi double [ %92, %91 ], [ %108, %97 ]
  %113 = load double, ptr @init_value, align 8, !tbaa !17
  %114 = fadd double %113, 1.234500e+04
  %115 = tail call double @llvm.fmuladd.f64(double %114, double 9.142370e+05, double -1.300000e+01)
  %116 = fadd double %115, 1.234500e+04
  %117 = tail call double @llvm.fmuladd.f64(double %116, double 9.142370e+05, double -1.300000e+01)
  %118 = fadd double %117, 1.234500e+04
  %119 = tail call double @llvm.fmuladd.f64(double %118, double 9.142370e+05, double -1.300000e+01)
  %120 = fmul double %119, 8.000000e+03
  %121 = fsub double %112, %120
  %122 = tail call double @llvm.fabs.f64(double %112)
  %123 = fcmp ogt double %122, 1.000000e-08
  %124 = select i1 %123, double %112, double 1.000000e+00
  %125 = fdiv double %121, %124
  %126 = tail call double @llvm.fabs.f64(double %125)
  %127 = fcmp olt double %126, 0x3EB0C6F7A0B5ED8D
  br i1 %127, label %132, label %128

128:                                              ; preds = %111
  %129 = load i32, ptr @current_test, align 4, !tbaa !11
  %130 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %129) #12
  %131 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %132

132:                                              ; preds = %128, %111
  %133 = phi i32 [ %13, %111 ], [ %131, %128 ]
  %134 = add nuw nsw i32 %14, 1
  %135 = icmp slt i32 %134, %133
  br i1 %135, label %12, label %136, !llvm.loop !70

136:                                              ; preds = %132, %3
  %137 = tail call i64 @clock() #15
  store i64 %137, ptr @end_time, align 8, !tbaa !23
  %138 = load i64, ptr @start_time, align 8, !tbaa !23
  %139 = sub nsw i64 %137, %138
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %141, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi3EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_Z28test_goto_loop_unroll_factorILi1EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull @temp_string) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi2EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 1)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi3EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 2)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi4EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %106

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 3
  %9 = add nsw i32 %1, -3
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %102, %7
  %13 = phi i32 [ %5, %7 ], [ %103, %102 ]
  %14 = phi i32 [ 0, %7 ], [ %104, %102 ]
  br i1 %8, label %15, label %61

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %57, %15 ], [ 0, %12 ]
  %17 = phi double [ %56, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = or i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = or i64 %16, 2
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !17
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %36, %45
  %47 = or i64 %16, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !17
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %46, %55
  %57 = add nuw nsw i64 %16, 4
  %58 = icmp slt i64 %57, %10
  br i1 %58, label %15, label %59

59:                                               ; preds = %15
  %.lcssa1 = phi double [ %56, %15 ]
  %.lcssa = phi i64 [ %57, %15 ]
  %60 = trunc i64 %.lcssa to i32
  br label %61

61:                                               ; preds = %59, %12
  %62 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %59 ]
  %63 = phi i32 [ 0, %12 ], [ %60, %59 ]
  %64 = icmp slt i32 %63, %1
  br i1 %64, label %65, label %81

65:                                               ; preds = %61
  %66 = zext i32 %63 to i64
  br label %67

67:                                               ; preds = %67, %65
  %68 = phi i64 [ %66, %65 ], [ %79, %67 ]
  %69 = phi double [ %62, %65 ], [ %78, %67 ]
  %70 = getelementptr inbounds double, ptr %0, i64 %68
  %71 = load double, ptr %70, align 8, !tbaa !17
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %75, 1.234500e+04
  %77 = tail call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %69, %77
  %79 = add nuw nsw i64 %68, 1
  %80 = icmp eq i64 %79, %11
  br i1 %80, label %81, label %67

81:                                               ; preds = %67, %61
  %82 = phi double [ %62, %61 ], [ %78, %67 ]
  %83 = load double, ptr @init_value, align 8, !tbaa !17
  %84 = fadd double %83, 1.234500e+04
  %85 = tail call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %85, 1.234500e+04
  %87 = tail call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %87, 1.234500e+04
  %89 = tail call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fmul double %89, 8.000000e+03
  %91 = fsub double %82, %90
  %92 = tail call double @llvm.fabs.f64(double %82)
  %93 = fcmp ogt double %92, 1.000000e-08
  %94 = select i1 %93, double %82, double 1.000000e+00
  %95 = fdiv double %91, %94
  %96 = tail call double @llvm.fabs.f64(double %95)
  %97 = fcmp olt double %96, 0x3EB0C6F7A0B5ED8D
  br i1 %97, label %102, label %98

98:                                               ; preds = %81
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %99) #12
  %101 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %102

102:                                              ; preds = %98, %81
  %103 = phi i32 [ %13, %81 ], [ %101, %98 ]
  %104 = add nuw nsw i32 %14, 1
  %105 = icmp slt i32 %104, %103
  br i1 %105, label %12, label %106, !llvm.loop !71

106:                                              ; preds = %102, %3
  %107 = tail call i64 @clock() #15
  store i64 %107, ptr @end_time, align 8, !tbaa !23
  %108 = load i64, ptr @start_time, align 8, !tbaa !23
  %109 = sub nsw i64 %107, %108
  %110 = sitofp i64 %109 to double
  %111 = fdiv double %110, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %111, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi5EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %116

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 4
  %9 = add nsw i32 %1, -4
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %112, %7
  %13 = phi i32 [ %5, %7 ], [ %113, %112 ]
  %14 = phi i32 [ 0, %7 ], [ %114, %112 ]
  br i1 %8, label %15, label %71

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %67, %15 ], [ 0, %12 ]
  %17 = phi double [ %66, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = add nuw nsw i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = add nuw nsw i64 %16, 2
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !17
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %36, %45
  %47 = add nuw nsw i64 %16, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !17
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %46, %55
  %57 = add nuw nsw i64 %16, 4
  %58 = getelementptr inbounds double, ptr %0, i64 %57
  %59 = load double, ptr %58, align 8, !tbaa !17
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %56, %65
  %67 = add nuw nsw i64 %16, 5
  %68 = icmp slt i64 %67, %10
  br i1 %68, label %15, label %69

69:                                               ; preds = %15
  %.lcssa1 = phi double [ %66, %15 ]
  %.lcssa = phi i64 [ %67, %15 ]
  %70 = trunc i64 %.lcssa to i32
  br label %71

71:                                               ; preds = %69, %12
  %72 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %69 ]
  %73 = phi i32 [ 0, %12 ], [ %70, %69 ]
  %74 = icmp slt i32 %73, %1
  br i1 %74, label %75, label %91

75:                                               ; preds = %71
  %76 = zext i32 %73 to i64
  br label %77

77:                                               ; preds = %77, %75
  %78 = phi i64 [ %76, %75 ], [ %89, %77 ]
  %79 = phi double [ %72, %75 ], [ %88, %77 ]
  %80 = getelementptr inbounds double, ptr %0, i64 %78
  %81 = load double, ptr %80, align 8, !tbaa !17
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %83, 1.234500e+04
  %85 = tail call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %85, 1.234500e+04
  %87 = tail call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %79, %87
  %89 = add nuw nsw i64 %78, 1
  %90 = icmp eq i64 %89, %11
  br i1 %90, label %91, label %77

91:                                               ; preds = %77, %71
  %92 = phi double [ %72, %71 ], [ %88, %77 ]
  %93 = load double, ptr @init_value, align 8, !tbaa !17
  %94 = fadd double %93, 1.234500e+04
  %95 = tail call double @llvm.fmuladd.f64(double %94, double 9.142370e+05, double -1.300000e+01)
  %96 = fadd double %95, 1.234500e+04
  %97 = tail call double @llvm.fmuladd.f64(double %96, double 9.142370e+05, double -1.300000e+01)
  %98 = fadd double %97, 1.234500e+04
  %99 = tail call double @llvm.fmuladd.f64(double %98, double 9.142370e+05, double -1.300000e+01)
  %100 = fmul double %99, 8.000000e+03
  %101 = fsub double %92, %100
  %102 = tail call double @llvm.fabs.f64(double %92)
  %103 = fcmp ogt double %102, 1.000000e-08
  %104 = select i1 %103, double %92, double 1.000000e+00
  %105 = fdiv double %101, %104
  %106 = tail call double @llvm.fabs.f64(double %105)
  %107 = fcmp olt double %106, 0x3EB0C6F7A0B5ED8D
  br i1 %107, label %112, label %108

108:                                              ; preds = %91
  %109 = load i32, ptr @current_test, align 4, !tbaa !11
  %110 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %109) #12
  %111 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %112

112:                                              ; preds = %108, %91
  %113 = phi i32 [ %13, %91 ], [ %111, %108 ]
  %114 = add nuw nsw i32 %14, 1
  %115 = icmp slt i32 %114, %113
  br i1 %115, label %12, label %116, !llvm.loop !72

116:                                              ; preds = %112, %3
  %117 = tail call i64 @clock() #15
  store i64 %117, ptr @end_time, align 8, !tbaa !23
  %118 = load i64, ptr @start_time, align 8, !tbaa !23
  %119 = sub nsw i64 %117, %118
  %120 = sitofp i64 %119 to double
  %121 = fdiv double %120, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %121, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi1EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %52

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 0
  %9 = zext i32 %1 to i64
  br label %10

10:                                               ; preds = %48, %7
  %11 = phi i32 [ %5, %7 ], [ %49, %48 ]
  %12 = phi i32 [ 0, %7 ], [ %50, %48 ]
  br i1 %8, label %13, label %27

13:                                               ; preds = %13, %10
  %14 = phi i64 [ %25, %13 ], [ 0, %10 ]
  %15 = phi double [ %24, %13 ], [ 0.000000e+00, %10 ]
  %16 = getelementptr inbounds double, ptr %0, i64 %14
  %17 = load double, ptr %16, align 8, !tbaa !17
  %18 = fadd double %17, 1.234500e+04
  %19 = tail call double @llvm.fmuladd.f64(double %18, double 9.142370e+05, double -1.300000e+01)
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %15, %23
  %25 = add nuw nsw i64 %14, 1
  %26 = icmp eq i64 %25, %9
  br i1 %26, label %27, label %13

27:                                               ; preds = %13, %10
  %28 = phi double [ 0.000000e+00, %10 ], [ %24, %13 ]
  %29 = load double, ptr @init_value, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fmul double %35, 8.000000e+03
  %37 = fsub double %28, %36
  %38 = tail call double @llvm.fabs.f64(double %28)
  %39 = fcmp ogt double %38, 1.000000e-08
  %40 = select i1 %39, double %28, double 1.000000e+00
  %41 = fdiv double %37, %40
  %42 = tail call double @llvm.fabs.f64(double %41)
  %43 = fcmp olt double %42, 0x3EB0C6F7A0B5ED8D
  br i1 %43, label %48, label %44

44:                                               ; preds = %27
  %45 = load i32, ptr @current_test, align 4, !tbaa !11
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %45) #12
  %47 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %48

48:                                               ; preds = %44, %27
  %49 = phi i32 [ %11, %27 ], [ %47, %44 ]
  %50 = add nuw nsw i32 %12, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %10, label %52, !llvm.loop !73

52:                                               ; preds = %48, %3
  %53 = tail call i64 @clock() #15
  store i64 %53, ptr @end_time, align 8, !tbaa !23
  %54 = load i64, ptr @start_time, align 8, !tbaa !23
  %55 = sub nsw i64 %53, %54
  %56 = sitofp i64 %55 to double
  %57 = fdiv double %56, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %57, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi2EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %86

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 1
  %9 = add nsw i32 %1, -1
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %82, %7
  %13 = phi i32 [ %5, %7 ], [ %83, %82 ]
  %14 = phi i32 [ 0, %7 ], [ %84, %82 ]
  br i1 %8, label %15, label %41

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %37, %15 ], [ 0, %12 ]
  %17 = phi double [ %36, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = or i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = add nuw nsw i64 %16, 2
  %38 = icmp slt i64 %37, %10
  br i1 %38, label %15, label %39

39:                                               ; preds = %15
  %.lcssa1 = phi double [ %36, %15 ]
  %.lcssa = phi i64 [ %37, %15 ]
  %40 = trunc i64 %.lcssa to i32
  br label %41

41:                                               ; preds = %39, %12
  %42 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %39 ]
  %43 = phi i32 [ 0, %12 ], [ %40, %39 ]
  %44 = icmp slt i32 %43, %1
  br i1 %44, label %45, label %61

45:                                               ; preds = %41
  %46 = zext i32 %43 to i64
  br label %47

47:                                               ; preds = %47, %45
  %48 = phi i64 [ %46, %45 ], [ %59, %47 ]
  %49 = phi double [ %42, %45 ], [ %58, %47 ]
  %50 = getelementptr inbounds double, ptr %0, i64 %48
  %51 = load double, ptr %50, align 8, !tbaa !17
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %55, 1.234500e+04
  %57 = tail call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %49, %57
  %59 = add nuw nsw i64 %48, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %47

61:                                               ; preds = %47, %41
  %62 = phi double [ %42, %41 ], [ %58, %47 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !17
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %65, 1.234500e+04
  %67 = tail call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fmul double %69, 8.000000e+03
  %71 = fsub double %62, %70
  %72 = tail call double @llvm.fabs.f64(double %62)
  %73 = fcmp ogt double %72, 1.000000e-08
  %74 = select i1 %73, double %62, double 1.000000e+00
  %75 = fdiv double %71, %74
  %76 = tail call double @llvm.fabs.f64(double %75)
  %77 = fcmp olt double %76, 0x3EB0C6F7A0B5ED8D
  br i1 %77, label %82, label %78

78:                                               ; preds = %61
  %79 = load i32, ptr @current_test, align 4, !tbaa !11
  %80 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %79) #12
  %81 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %82

82:                                               ; preds = %78, %61
  %83 = phi i32 [ %13, %61 ], [ %81, %78 ]
  %84 = add nuw nsw i32 %14, 1
  %85 = icmp slt i32 %84, %83
  br i1 %85, label %12, label %86, !llvm.loop !74

86:                                               ; preds = %82, %3
  %87 = tail call i64 @clock() #15
  store i64 %87, ptr @end_time, align 8, !tbaa !23
  %88 = load i64, ptr @start_time, align 8, !tbaa !23
  %89 = sub nsw i64 %87, %88
  %90 = sitofp i64 %89 to double
  %91 = fdiv double %90, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %91, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi3EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %96

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 2
  %9 = add nsw i32 %1, -2
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %92, %7
  %13 = phi i32 [ %5, %7 ], [ %93, %92 ]
  %14 = phi i32 [ 0, %7 ], [ %94, %92 ]
  br i1 %8, label %15, label %51

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %47, %15 ], [ 0, %12 ]
  %17 = phi double [ %46, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = add nuw nsw i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = add nuw nsw i64 %16, 2
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !17
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %36, %45
  %47 = add nuw nsw i64 %16, 3
  %48 = icmp slt i64 %47, %10
  br i1 %48, label %15, label %49

49:                                               ; preds = %15
  %.lcssa1 = phi double [ %46, %15 ]
  %.lcssa = phi i64 [ %47, %15 ]
  %50 = trunc i64 %.lcssa to i32
  br label %51

51:                                               ; preds = %49, %12
  %52 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %49 ]
  %53 = phi i32 [ 0, %12 ], [ %50, %49 ]
  %54 = icmp slt i32 %53, %1
  br i1 %54, label %55, label %71

55:                                               ; preds = %51
  %56 = zext i32 %53 to i64
  br label %57

57:                                               ; preds = %57, %55
  %58 = phi i64 [ %56, %55 ], [ %69, %57 ]
  %59 = phi double [ %52, %55 ], [ %68, %57 ]
  %60 = getelementptr inbounds double, ptr %0, i64 %58
  %61 = load double, ptr %60, align 8, !tbaa !17
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %65, 1.234500e+04
  %67 = tail call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %59, %67
  %69 = add nuw nsw i64 %58, 1
  %70 = icmp eq i64 %69, %11
  br i1 %70, label %71, label %57

71:                                               ; preds = %57, %51
  %72 = phi double [ %52, %51 ], [ %68, %57 ]
  %73 = load double, ptr @init_value, align 8, !tbaa !17
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %75, 1.234500e+04
  %77 = tail call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %77, 1.234500e+04
  %79 = tail call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fmul double %79, 8.000000e+03
  %81 = fsub double %72, %80
  %82 = tail call double @llvm.fabs.f64(double %72)
  %83 = fcmp ogt double %82, 1.000000e-08
  %84 = select i1 %83, double %72, double 1.000000e+00
  %85 = fdiv double %81, %84
  %86 = tail call double @llvm.fabs.f64(double %85)
  %87 = fcmp olt double %86, 0x3EB0C6F7A0B5ED8D
  br i1 %87, label %92, label %88

88:                                               ; preds = %71
  %89 = load i32, ptr @current_test, align 4, !tbaa !11
  %90 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %89) #12
  %91 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %92

92:                                               ; preds = %88, %71
  %93 = phi i32 [ %13, %71 ], [ %91, %88 ]
  %94 = add nuw nsw i32 %14, 1
  %95 = icmp slt i32 %94, %93
  br i1 %95, label %12, label %96, !llvm.loop !75

96:                                               ; preds = %92, %3
  %97 = tail call i64 @clock() #15
  store i64 %97, ptr @end_time, align 8, !tbaa !23
  %98 = load i64, ptr @start_time, align 8, !tbaa !23
  %99 = sub nsw i64 %97, %98
  %100 = sitofp i64 %99 to double
  %101 = fdiv double %100, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %101, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi29EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi27EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi28EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 27)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi29EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 28)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi30EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 29
  %10 = add nsw i32 %1, -29
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %82, %8
  %13 = phi i32 [ 0, %8 ], [ %83, %82 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %41

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %38, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 28
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 29
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  store double %37, ptr %4, align 8, !tbaa !17
  %38 = add nuw i64 %15, 30
  %39 = trunc i64 %38 to i32
  %40 = icmp sgt i32 %10, %39
  br i1 %40, label %14, label %41, !llvm.loop !76

41:                                               ; preds = %14, %12
  %42 = phi double [ 0.000000e+00, %12 ], [ %37, %14 ]
  %43 = phi i32 [ 0, %12 ], [ %39, %14 ]
  %44 = icmp slt i32 %43, %1
  br i1 %44, label %45, label %62

45:                                               ; preds = %41
  %46 = sext i32 %43 to i64
  br label %47

47:                                               ; preds = %47, %45
  %48 = phi i64 [ %46, %45 ], [ %59, %47 ]
  %49 = phi double [ %42, %45 ], [ %58, %47 ]
  %50 = getelementptr inbounds double, ptr %0, i64 %48
  %51 = load double, ptr %50, align 8, !tbaa !17
  %52 = fadd double %51, 1.234500e+04
  %53 = call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %49, %57
  %59 = add nsw i64 %48, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %47, !llvm.loop !77

61:                                               ; preds = %47
  %.lcssa = phi double [ %58, %47 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %62

62:                                               ; preds = %61, %41
  %63 = phi double [ %.lcssa, %61 ], [ %42, %41 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !17
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %66, 1.234500e+04
  %68 = call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fmul double %70, 8.000000e+03
  %72 = fsub double %63, %71
  %73 = call double @llvm.fabs.f64(double %63)
  %74 = fcmp ogt double %73, 1.000000e-08
  %75 = select i1 %74, double %63, double 1.000000e+00
  %76 = fdiv double %72, %75
  %77 = call double @llvm.fabs.f64(double %76)
  %78 = fcmp olt double %77, 0x3EB0C6F7A0B5ED8D
  br i1 %78, label %82, label %79

79:                                               ; preds = %62
  %80 = load i32, ptr @current_test, align 4, !tbaa !11
  %81 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %80) #12
  br label %82

82:                                               ; preds = %79, %62
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %83 = add nuw nsw i32 %13, 1
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  %85 = icmp slt i32 %83, %84
  br i1 %85, label %12, label %86, !llvm.loop !78

86:                                               ; preds = %82, %3
  %87 = call i64 @clock() #15
  store i64 %87, ptr @end_time, align 8, !tbaa !23
  %88 = load i64, ptr @start_time, align 8, !tbaa !23
  %89 = sub nsw i64 %87, %88
  %90 = sitofp i64 %89 to double
  %91 = fdiv double %90, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %91, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi31EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %96

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 30
  %10 = add nsw i32 %1, -30
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %92, %8
  %13 = phi i32 [ 0, %8 ], [ %93, %92 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %51

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %48, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 28
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 29
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = add nuw nsw i64 %15, 30
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  store double %47, ptr %4, align 8, !tbaa !17
  %48 = add nuw i64 %15, 31
  %49 = trunc i64 %48 to i32
  %50 = icmp sgt i32 %10, %49
  br i1 %50, label %14, label %51, !llvm.loop !79

51:                                               ; preds = %14, %12
  %52 = phi double [ 0.000000e+00, %12 ], [ %47, %14 ]
  %53 = phi i32 [ 0, %12 ], [ %49, %14 ]
  %54 = icmp slt i32 %53, %1
  br i1 %54, label %55, label %72

55:                                               ; preds = %51
  %56 = sext i32 %53 to i64
  br label %57

57:                                               ; preds = %57, %55
  %58 = phi i64 [ %56, %55 ], [ %69, %57 ]
  %59 = phi double [ %52, %55 ], [ %68, %57 ]
  %60 = getelementptr inbounds double, ptr %0, i64 %58
  %61 = load double, ptr %60, align 8, !tbaa !17
  %62 = fadd double %61, 1.234500e+04
  %63 = call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %65, 1.234500e+04
  %67 = call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %59, %67
  %69 = add nsw i64 %58, 1
  %70 = icmp eq i64 %69, %11
  br i1 %70, label %71, label %57, !llvm.loop !80

71:                                               ; preds = %57
  %.lcssa = phi double [ %68, %57 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %72

72:                                               ; preds = %71, %51
  %73 = phi double [ %.lcssa, %71 ], [ %52, %51 ]
  %74 = load double, ptr @init_value, align 8, !tbaa !17
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %76, 1.234500e+04
  %78 = call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fmul double %80, 8.000000e+03
  %82 = fsub double %73, %81
  %83 = call double @llvm.fabs.f64(double %73)
  %84 = fcmp ogt double %83, 1.000000e-08
  %85 = select i1 %84, double %73, double 1.000000e+00
  %86 = fdiv double %82, %85
  %87 = call double @llvm.fabs.f64(double %86)
  %88 = fcmp olt double %87, 0x3EB0C6F7A0B5ED8D
  br i1 %88, label %92, label %89

89:                                               ; preds = %72
  %90 = load i32, ptr @current_test, align 4, !tbaa !11
  %91 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %90) #12
  br label %92

92:                                               ; preds = %89, %72
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %93 = add nuw nsw i32 %13, 1
  %94 = load i32, ptr @iterations, align 4, !tbaa !11
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %12, label %96, !llvm.loop !81

96:                                               ; preds = %92, %3
  %97 = call i64 @clock() #15
  store i64 %97, ptr @end_time, align 8, !tbaa !23
  %98 = load i64, ptr @start_time, align 8, !tbaa !23
  %99 = sub nsw i64 %97, %98
  %100 = sitofp i64 %99 to double
  %101 = fdiv double %100, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %101, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi27EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi25EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi26EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 25)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi27EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 26)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi28EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %65

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 27
  %10 = add nsw i32 %1, -27
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %61, %8
  %13 = phi i32 [ 0, %8 ], [ %62, %61 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %20

14:                                               ; preds = %14, %12
  %15 = phi i32 [ %16, %14 ], [ 0, %12 ]
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %15) #12
  %16 = add nuw nsw i32 %15, 28
  %17 = icmp slt i32 %16, %10
  br i1 %17, label %14, label %18, !llvm.loop !82

18:                                               ; preds = %14
  %.lcssa = phi i32 [ %16, %14 ]
  %19 = load double, ptr %4, align 8, !tbaa !17
  br label %20

20:                                               ; preds = %18, %12
  %21 = phi double [ 0.000000e+00, %12 ], [ %19, %18 ]
  %22 = phi i32 [ 0, %12 ], [ %.lcssa, %18 ]
  %23 = icmp slt i32 %22, %1
  br i1 %23, label %24, label %41

24:                                               ; preds = %20
  %25 = sext i32 %22 to i64
  br label %26

26:                                               ; preds = %26, %24
  %27 = phi i64 [ %25, %24 ], [ %38, %26 ]
  %28 = phi double [ %21, %24 ], [ %37, %26 ]
  %29 = getelementptr inbounds double, ptr %0, i64 %27
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %28, %36
  %38 = add nsw i64 %27, 1
  %39 = icmp eq i64 %38, %11
  br i1 %39, label %40, label %26, !llvm.loop !83

40:                                               ; preds = %26
  %.lcssa1 = phi double [ %37, %26 ]
  store double %.lcssa1, ptr %4, align 8, !tbaa !17
  br label %41

41:                                               ; preds = %40, %20
  %42 = phi double [ %.lcssa1, %40 ], [ %21, %20 ]
  %43 = load double, ptr @init_value, align 8, !tbaa !17
  %44 = fadd double %43, 1.234500e+04
  %45 = call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fmul double %49, 8.000000e+03
  %51 = fsub double %42, %50
  %52 = call double @llvm.fabs.f64(double %42)
  %53 = fcmp ogt double %52, 1.000000e-08
  %54 = select i1 %53, double %42, double 1.000000e+00
  %55 = fdiv double %51, %54
  %56 = call double @llvm.fabs.f64(double %55)
  %57 = fcmp olt double %56, 0x3EB0C6F7A0B5ED8D
  br i1 %57, label %61, label %58

58:                                               ; preds = %41
  %59 = load i32, ptr @current_test, align 4, !tbaa !11
  %60 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %59) #12
  br label %61

61:                                               ; preds = %58, %41
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %62 = add nuw nsw i32 %13, 1
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  %64 = icmp slt i32 %62, %63
  br i1 %64, label %12, label %65, !llvm.loop !84

65:                                               ; preds = %61, %3
  %66 = call i64 @clock() #15
  store i64 %66, ptr @end_time, align 8, !tbaa !23
  %67 = load i64, ptr @start_time, align 8, !tbaa !23
  %68 = sub nsw i64 %66, %67
  %69 = sitofp i64 %68 to double
  %70 = fdiv double %69, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %70, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi29EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %76

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 28
  %10 = add nsw i32 %1, -28
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %72, %8
  %13 = phi i32 [ 0, %8 ], [ %73, %72 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %31

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %28, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 28
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  store double %27, ptr %4, align 8, !tbaa !17
  %28 = add nuw i64 %15, 29
  %29 = trunc i64 %28 to i32
  %30 = icmp sgt i32 %10, %29
  br i1 %30, label %14, label %31, !llvm.loop !85

31:                                               ; preds = %14, %12
  %32 = phi double [ 0.000000e+00, %12 ], [ %27, %14 ]
  %33 = phi i32 [ 0, %12 ], [ %29, %14 ]
  %34 = icmp slt i32 %33, %1
  br i1 %34, label %35, label %52

35:                                               ; preds = %31
  %36 = sext i32 %33 to i64
  br label %37

37:                                               ; preds = %37, %35
  %38 = phi i64 [ %36, %35 ], [ %49, %37 ]
  %39 = phi double [ %32, %35 ], [ %48, %37 ]
  %40 = getelementptr inbounds double, ptr %0, i64 %38
  %41 = load double, ptr %40, align 8, !tbaa !17
  %42 = fadd double %41, 1.234500e+04
  %43 = call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %39, %47
  %49 = add nsw i64 %38, 1
  %50 = icmp eq i64 %49, %11
  br i1 %50, label %51, label %37, !llvm.loop !86

51:                                               ; preds = %37
  %.lcssa = phi double [ %48, %37 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %52

52:                                               ; preds = %51, %31
  %53 = phi double [ %.lcssa, %51 ], [ %32, %31 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %56, 1.234500e+04
  %58 = call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fmul double %60, 8.000000e+03
  %62 = fsub double %53, %61
  %63 = call double @llvm.fabs.f64(double %53)
  %64 = fcmp ogt double %63, 1.000000e-08
  %65 = select i1 %64, double %53, double 1.000000e+00
  %66 = fdiv double %62, %65
  %67 = call double @llvm.fabs.f64(double %66)
  %68 = fcmp olt double %67, 0x3EB0C6F7A0B5ED8D
  br i1 %68, label %72, label %69

69:                                               ; preds = %52
  %70 = load i32, ptr @current_test, align 4, !tbaa !11
  %71 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %70) #12
  br label %72

72:                                               ; preds = %69, %52
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %73 = add nuw nsw i32 %13, 1
  %74 = load i32, ptr @iterations, align 4, !tbaa !11
  %75 = icmp slt i32 %73, %74
  br i1 %75, label %12, label %76, !llvm.loop !87

76:                                               ; preds = %72, %3
  %77 = call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi25EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi23EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi24EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 23)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi25EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 24)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi26EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %136

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 25
  %10 = add nsw i32 %1, -25
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %132, %8
  %13 = phi i32 [ 0, %8 ], [ %133, %132 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %91

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %88, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 20
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = add nuw nsw i64 %15, 21
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  %48 = add nuw nsw i64 %15, 22
  %49 = getelementptr inbounds double, ptr %0, i64 %48
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %47, %56
  %58 = add nuw nsw i64 %15, 23
  %59 = getelementptr inbounds double, ptr %0, i64 %58
  %60 = load double, ptr %59, align 8, !tbaa !17
  %61 = fadd double %60, 1.234500e+04
  %62 = call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %57, %66
  %68 = add nuw nsw i64 %15, 24
  %69 = getelementptr inbounds double, ptr %0, i64 %68
  %70 = load double, ptr %69, align 8, !tbaa !17
  %71 = fadd double %70, 1.234500e+04
  %72 = call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %67, %76
  %78 = add nuw nsw i64 %15, 25
  %79 = getelementptr inbounds double, ptr %0, i64 %78
  %80 = load double, ptr %79, align 8, !tbaa !17
  %81 = fadd double %80, 1.234500e+04
  %82 = call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %84, 1.234500e+04
  %86 = call double @llvm.fmuladd.f64(double %85, double 9.142370e+05, double -1.300000e+01)
  %87 = fadd double %77, %86
  store double %87, ptr %4, align 8, !tbaa !17
  %88 = add nuw i64 %15, 26
  %89 = trunc i64 %88 to i32
  %90 = icmp sgt i32 %10, %89
  br i1 %90, label %14, label %91, !llvm.loop !88

91:                                               ; preds = %14, %12
  %92 = phi double [ 0.000000e+00, %12 ], [ %87, %14 ]
  %93 = phi i32 [ 0, %12 ], [ %89, %14 ]
  %94 = icmp slt i32 %93, %1
  br i1 %94, label %95, label %112

95:                                               ; preds = %91
  %96 = sext i32 %93 to i64
  br label %97

97:                                               ; preds = %97, %95
  %98 = phi i64 [ %96, %95 ], [ %109, %97 ]
  %99 = phi double [ %92, %95 ], [ %108, %97 ]
  %100 = getelementptr inbounds double, ptr %0, i64 %98
  %101 = load double, ptr %100, align 8, !tbaa !17
  %102 = fadd double %101, 1.234500e+04
  %103 = call double @llvm.fmuladd.f64(double %102, double 9.142370e+05, double -1.300000e+01)
  %104 = fadd double %103, 1.234500e+04
  %105 = call double @llvm.fmuladd.f64(double %104, double 9.142370e+05, double -1.300000e+01)
  %106 = fadd double %105, 1.234500e+04
  %107 = call double @llvm.fmuladd.f64(double %106, double 9.142370e+05, double -1.300000e+01)
  %108 = fadd double %99, %107
  %109 = add nsw i64 %98, 1
  %110 = icmp eq i64 %109, %11
  br i1 %110, label %111, label %97, !llvm.loop !89

111:                                              ; preds = %97
  %.lcssa = phi double [ %108, %97 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %112

112:                                              ; preds = %111, %91
  %113 = phi double [ %.lcssa, %111 ], [ %92, %91 ]
  %114 = load double, ptr @init_value, align 8, !tbaa !17
  %115 = fadd double %114, 1.234500e+04
  %116 = call double @llvm.fmuladd.f64(double %115, double 9.142370e+05, double -1.300000e+01)
  %117 = fadd double %116, 1.234500e+04
  %118 = call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fmul double %120, 8.000000e+03
  %122 = fsub double %113, %121
  %123 = call double @llvm.fabs.f64(double %113)
  %124 = fcmp ogt double %123, 1.000000e-08
  %125 = select i1 %124, double %113, double 1.000000e+00
  %126 = fdiv double %122, %125
  %127 = call double @llvm.fabs.f64(double %126)
  %128 = fcmp olt double %127, 0x3EB0C6F7A0B5ED8D
  br i1 %128, label %132, label %129

129:                                              ; preds = %112
  %130 = load i32, ptr @current_test, align 4, !tbaa !11
  %131 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %130) #12
  br label %132

132:                                              ; preds = %129, %112
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %133 = add nuw nsw i32 %13, 1
  %134 = load i32, ptr @iterations, align 4, !tbaa !11
  %135 = icmp slt i32 %133, %134
  br i1 %135, label %12, label %136, !llvm.loop !90

136:                                              ; preds = %132, %3
  %137 = call i64 @clock() #15
  store i64 %137, ptr @end_time, align 8, !tbaa !23
  %138 = load i64, ptr @start_time, align 8, !tbaa !23
  %139 = sub nsw i64 %137, %138
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %141, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi27EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %146

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 26
  %10 = add nsw i32 %1, -26
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %142, %8
  %13 = phi i32 [ 0, %8 ], [ %143, %142 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %101

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %98, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 20
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = add nuw nsw i64 %15, 21
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  %48 = add nuw nsw i64 %15, 22
  %49 = getelementptr inbounds double, ptr %0, i64 %48
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %47, %56
  %58 = add nuw nsw i64 %15, 23
  %59 = getelementptr inbounds double, ptr %0, i64 %58
  %60 = load double, ptr %59, align 8, !tbaa !17
  %61 = fadd double %60, 1.234500e+04
  %62 = call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %57, %66
  %68 = add nuw nsw i64 %15, 24
  %69 = getelementptr inbounds double, ptr %0, i64 %68
  %70 = load double, ptr %69, align 8, !tbaa !17
  %71 = fadd double %70, 1.234500e+04
  %72 = call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %67, %76
  %78 = add nuw nsw i64 %15, 25
  %79 = getelementptr inbounds double, ptr %0, i64 %78
  %80 = load double, ptr %79, align 8, !tbaa !17
  %81 = fadd double %80, 1.234500e+04
  %82 = call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %84, 1.234500e+04
  %86 = call double @llvm.fmuladd.f64(double %85, double 9.142370e+05, double -1.300000e+01)
  %87 = fadd double %77, %86
  %88 = add nuw nsw i64 %15, 26
  %89 = getelementptr inbounds double, ptr %0, i64 %88
  %90 = load double, ptr %89, align 8, !tbaa !17
  %91 = fadd double %90, 1.234500e+04
  %92 = call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %94, 1.234500e+04
  %96 = call double @llvm.fmuladd.f64(double %95, double 9.142370e+05, double -1.300000e+01)
  %97 = fadd double %87, %96
  store double %97, ptr %4, align 8, !tbaa !17
  %98 = add nuw i64 %15, 27
  %99 = trunc i64 %98 to i32
  %100 = icmp sgt i32 %10, %99
  br i1 %100, label %14, label %101, !llvm.loop !91

101:                                              ; preds = %14, %12
  %102 = phi double [ 0.000000e+00, %12 ], [ %97, %14 ]
  %103 = phi i32 [ 0, %12 ], [ %99, %14 ]
  %104 = icmp slt i32 %103, %1
  br i1 %104, label %105, label %122

105:                                              ; preds = %101
  %106 = sext i32 %103 to i64
  br label %107

107:                                              ; preds = %107, %105
  %108 = phi i64 [ %106, %105 ], [ %119, %107 ]
  %109 = phi double [ %102, %105 ], [ %118, %107 ]
  %110 = getelementptr inbounds double, ptr %0, i64 %108
  %111 = load double, ptr %110, align 8, !tbaa !17
  %112 = fadd double %111, 1.234500e+04
  %113 = call double @llvm.fmuladd.f64(double %112, double 9.142370e+05, double -1.300000e+01)
  %114 = fadd double %113, 1.234500e+04
  %115 = call double @llvm.fmuladd.f64(double %114, double 9.142370e+05, double -1.300000e+01)
  %116 = fadd double %115, 1.234500e+04
  %117 = call double @llvm.fmuladd.f64(double %116, double 9.142370e+05, double -1.300000e+01)
  %118 = fadd double %109, %117
  %119 = add nsw i64 %108, 1
  %120 = icmp eq i64 %119, %11
  br i1 %120, label %121, label %107, !llvm.loop !92

121:                                              ; preds = %107
  %.lcssa = phi double [ %118, %107 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %122

122:                                              ; preds = %121, %101
  %123 = phi double [ %.lcssa, %121 ], [ %102, %101 ]
  %124 = load double, ptr @init_value, align 8, !tbaa !17
  %125 = fadd double %124, 1.234500e+04
  %126 = call double @llvm.fmuladd.f64(double %125, double 9.142370e+05, double -1.300000e+01)
  %127 = fadd double %126, 1.234500e+04
  %128 = call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fmul double %130, 8.000000e+03
  %132 = fsub double %123, %131
  %133 = call double @llvm.fabs.f64(double %123)
  %134 = fcmp ogt double %133, 1.000000e-08
  %135 = select i1 %134, double %123, double 1.000000e+00
  %136 = fdiv double %132, %135
  %137 = call double @llvm.fabs.f64(double %136)
  %138 = fcmp olt double %137, 0x3EB0C6F7A0B5ED8D
  br i1 %138, label %142, label %139

139:                                              ; preds = %122
  %140 = load i32, ptr @current_test, align 4, !tbaa !11
  %141 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %140) #12
  br label %142

142:                                              ; preds = %139, %122
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %143 = add nuw nsw i32 %13, 1
  %144 = load i32, ptr @iterations, align 4, !tbaa !11
  %145 = icmp slt i32 %143, %144
  br i1 %145, label %12, label %146, !llvm.loop !93

146:                                              ; preds = %142, %3
  %147 = call i64 @clock() #15
  store i64 %147, ptr @end_time, align 8, !tbaa !23
  %148 = load i64, ptr @start_time, align 8, !tbaa !23
  %149 = sub nsw i64 %147, %148
  %150 = sitofp i64 %149 to double
  %151 = fdiv double %150, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %151, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi23EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi21EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi22EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 21)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi23EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 22)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi24EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %116

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 23
  %10 = add nsw i32 %1, -23
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %112, %8
  %13 = phi i32 [ 0, %8 ], [ %113, %112 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %71

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %68, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 20
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = add nuw nsw i64 %15, 21
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  %48 = add nuw nsw i64 %15, 22
  %49 = getelementptr inbounds double, ptr %0, i64 %48
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %47, %56
  %58 = add nuw nsw i64 %15, 23
  %59 = getelementptr inbounds double, ptr %0, i64 %58
  %60 = load double, ptr %59, align 8, !tbaa !17
  %61 = fadd double %60, 1.234500e+04
  %62 = call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %57, %66
  store double %67, ptr %4, align 8, !tbaa !17
  %68 = add nuw i64 %15, 24
  %69 = trunc i64 %68 to i32
  %70 = icmp sgt i32 %10, %69
  br i1 %70, label %14, label %71, !llvm.loop !94

71:                                               ; preds = %14, %12
  %72 = phi double [ 0.000000e+00, %12 ], [ %67, %14 ]
  %73 = phi i32 [ 0, %12 ], [ %69, %14 ]
  %74 = icmp slt i32 %73, %1
  br i1 %74, label %75, label %92

75:                                               ; preds = %71
  %76 = sext i32 %73 to i64
  br label %77

77:                                               ; preds = %77, %75
  %78 = phi i64 [ %76, %75 ], [ %89, %77 ]
  %79 = phi double [ %72, %75 ], [ %88, %77 ]
  %80 = getelementptr inbounds double, ptr %0, i64 %78
  %81 = load double, ptr %80, align 8, !tbaa !17
  %82 = fadd double %81, 1.234500e+04
  %83 = call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %83, 1.234500e+04
  %85 = call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %85, 1.234500e+04
  %87 = call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %79, %87
  %89 = add nsw i64 %78, 1
  %90 = icmp eq i64 %89, %11
  br i1 %90, label %91, label %77, !llvm.loop !95

91:                                               ; preds = %77
  %.lcssa = phi double [ %88, %77 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %92

92:                                               ; preds = %91, %71
  %93 = phi double [ %.lcssa, %91 ], [ %72, %71 ]
  %94 = load double, ptr @init_value, align 8, !tbaa !17
  %95 = fadd double %94, 1.234500e+04
  %96 = call double @llvm.fmuladd.f64(double %95, double 9.142370e+05, double -1.300000e+01)
  %97 = fadd double %96, 1.234500e+04
  %98 = call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fmul double %100, 8.000000e+03
  %102 = fsub double %93, %101
  %103 = call double @llvm.fabs.f64(double %93)
  %104 = fcmp ogt double %103, 1.000000e-08
  %105 = select i1 %104, double %93, double 1.000000e+00
  %106 = fdiv double %102, %105
  %107 = call double @llvm.fabs.f64(double %106)
  %108 = fcmp olt double %107, 0x3EB0C6F7A0B5ED8D
  br i1 %108, label %112, label %109

109:                                              ; preds = %92
  %110 = load i32, ptr @current_test, align 4, !tbaa !11
  %111 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %110) #12
  br label %112

112:                                              ; preds = %109, %92
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %113 = add nuw nsw i32 %13, 1
  %114 = load i32, ptr @iterations, align 4, !tbaa !11
  %115 = icmp slt i32 %113, %114
  br i1 %115, label %12, label %116, !llvm.loop !96

116:                                              ; preds = %112, %3
  %117 = call i64 @clock() #15
  store i64 %117, ptr @end_time, align 8, !tbaa !23
  %118 = load i64, ptr @start_time, align 8, !tbaa !23
  %119 = sub nsw i64 %117, %118
  %120 = sitofp i64 %119 to double
  %121 = fdiv double %120, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %121, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi25EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %126

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 24
  %10 = add nsw i32 %1, -24
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %122, %8
  %13 = phi i32 [ 0, %8 ], [ %123, %122 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %81

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %78, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 20
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = add nuw nsw i64 %15, 21
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  %48 = add nuw nsw i64 %15, 22
  %49 = getelementptr inbounds double, ptr %0, i64 %48
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %47, %56
  %58 = add nuw nsw i64 %15, 23
  %59 = getelementptr inbounds double, ptr %0, i64 %58
  %60 = load double, ptr %59, align 8, !tbaa !17
  %61 = fadd double %60, 1.234500e+04
  %62 = call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %57, %66
  %68 = add nuw nsw i64 %15, 24
  %69 = getelementptr inbounds double, ptr %0, i64 %68
  %70 = load double, ptr %69, align 8, !tbaa !17
  %71 = fadd double %70, 1.234500e+04
  %72 = call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %67, %76
  store double %77, ptr %4, align 8, !tbaa !17
  %78 = add nuw i64 %15, 25
  %79 = trunc i64 %78 to i32
  %80 = icmp sgt i32 %10, %79
  br i1 %80, label %14, label %81, !llvm.loop !97

81:                                               ; preds = %14, %12
  %82 = phi double [ 0.000000e+00, %12 ], [ %77, %14 ]
  %83 = phi i32 [ 0, %12 ], [ %79, %14 ]
  %84 = icmp slt i32 %83, %1
  br i1 %84, label %85, label %102

85:                                               ; preds = %81
  %86 = sext i32 %83 to i64
  br label %87

87:                                               ; preds = %87, %85
  %88 = phi i64 [ %86, %85 ], [ %99, %87 ]
  %89 = phi double [ %82, %85 ], [ %98, %87 ]
  %90 = getelementptr inbounds double, ptr %0, i64 %88
  %91 = load double, ptr %90, align 8, !tbaa !17
  %92 = fadd double %91, 1.234500e+04
  %93 = call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %93, 1.234500e+04
  %95 = call double @llvm.fmuladd.f64(double %94, double 9.142370e+05, double -1.300000e+01)
  %96 = fadd double %95, 1.234500e+04
  %97 = call double @llvm.fmuladd.f64(double %96, double 9.142370e+05, double -1.300000e+01)
  %98 = fadd double %89, %97
  %99 = add nsw i64 %88, 1
  %100 = icmp eq i64 %99, %11
  br i1 %100, label %101, label %87, !llvm.loop !98

101:                                              ; preds = %87
  %.lcssa = phi double [ %98, %87 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %102

102:                                              ; preds = %101, %81
  %103 = phi double [ %.lcssa, %101 ], [ %82, %81 ]
  %104 = load double, ptr @init_value, align 8, !tbaa !17
  %105 = fadd double %104, 1.234500e+04
  %106 = call double @llvm.fmuladd.f64(double %105, double 9.142370e+05, double -1.300000e+01)
  %107 = fadd double %106, 1.234500e+04
  %108 = call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fmul double %110, 8.000000e+03
  %112 = fsub double %103, %111
  %113 = call double @llvm.fabs.f64(double %103)
  %114 = fcmp ogt double %113, 1.000000e-08
  %115 = select i1 %114, double %103, double 1.000000e+00
  %116 = fdiv double %112, %115
  %117 = call double @llvm.fabs.f64(double %116)
  %118 = fcmp olt double %117, 0x3EB0C6F7A0B5ED8D
  br i1 %118, label %122, label %119

119:                                              ; preds = %102
  %120 = load i32, ptr @current_test, align 4, !tbaa !11
  %121 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %120) #12
  br label %122

122:                                              ; preds = %119, %102
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %123 = add nuw nsw i32 %13, 1
  %124 = load i32, ptr @iterations, align 4, !tbaa !11
  %125 = icmp slt i32 %123, %124
  br i1 %125, label %12, label %126, !llvm.loop !99

126:                                              ; preds = %122, %3
  %127 = call i64 @clock() #15
  store i64 %127, ptr @end_time, align 8, !tbaa !23
  %128 = load i64, ptr @start_time, align 8, !tbaa !23
  %129 = sub nsw i64 %127, %128
  %130 = sitofp i64 %129 to double
  %131 = fdiv double %130, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %131, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi21EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi19EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi20EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 19)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi21EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 20)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi22EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %96

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 21
  %10 = add nsw i32 %1, -21
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %92, %8
  %13 = phi i32 [ 0, %8 ], [ %93, %92 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %51

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %48, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 20
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = add nuw nsw i64 %15, 21
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  store double %47, ptr %4, align 8, !tbaa !17
  %48 = add nuw i64 %15, 22
  %49 = trunc i64 %48 to i32
  %50 = icmp sgt i32 %10, %49
  br i1 %50, label %14, label %51, !llvm.loop !100

51:                                               ; preds = %14, %12
  %52 = phi double [ 0.000000e+00, %12 ], [ %47, %14 ]
  %53 = phi i32 [ 0, %12 ], [ %49, %14 ]
  %54 = icmp slt i32 %53, %1
  br i1 %54, label %55, label %72

55:                                               ; preds = %51
  %56 = sext i32 %53 to i64
  br label %57

57:                                               ; preds = %57, %55
  %58 = phi i64 [ %56, %55 ], [ %69, %57 ]
  %59 = phi double [ %52, %55 ], [ %68, %57 ]
  %60 = getelementptr inbounds double, ptr %0, i64 %58
  %61 = load double, ptr %60, align 8, !tbaa !17
  %62 = fadd double %61, 1.234500e+04
  %63 = call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %65, 1.234500e+04
  %67 = call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %59, %67
  %69 = add nsw i64 %58, 1
  %70 = icmp eq i64 %69, %11
  br i1 %70, label %71, label %57, !llvm.loop !101

71:                                               ; preds = %57
  %.lcssa = phi double [ %68, %57 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %72

72:                                               ; preds = %71, %51
  %73 = phi double [ %.lcssa, %71 ], [ %52, %51 ]
  %74 = load double, ptr @init_value, align 8, !tbaa !17
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %76, 1.234500e+04
  %78 = call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fmul double %80, 8.000000e+03
  %82 = fsub double %73, %81
  %83 = call double @llvm.fabs.f64(double %73)
  %84 = fcmp ogt double %83, 1.000000e-08
  %85 = select i1 %84, double %73, double 1.000000e+00
  %86 = fdiv double %82, %85
  %87 = call double @llvm.fabs.f64(double %86)
  %88 = fcmp olt double %87, 0x3EB0C6F7A0B5ED8D
  br i1 %88, label %92, label %89

89:                                               ; preds = %72
  %90 = load i32, ptr @current_test, align 4, !tbaa !11
  %91 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %90) #12
  br label %92

92:                                               ; preds = %89, %72
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %93 = add nuw nsw i32 %13, 1
  %94 = load i32, ptr @iterations, align 4, !tbaa !11
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %12, label %96, !llvm.loop !102

96:                                               ; preds = %92, %3
  %97 = call i64 @clock() #15
  store i64 %97, ptr @end_time, align 8, !tbaa !23
  %98 = load i64, ptr @start_time, align 8, !tbaa !23
  %99 = sub nsw i64 %97, %98
  %100 = sitofp i64 %99 to double
  %101 = fdiv double %100, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %101, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi23EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %106

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 22
  %10 = add nsw i32 %1, -22
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %102, %8
  %13 = phi i32 [ 0, %8 ], [ %103, %102 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %61

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %58, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 20
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  %38 = add nuw nsw i64 %15, 21
  %39 = getelementptr inbounds double, ptr %0, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %37, %46
  %48 = add nuw nsw i64 %15, 22
  %49 = getelementptr inbounds double, ptr %0, i64 %48
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %47, %56
  store double %57, ptr %4, align 8, !tbaa !17
  %58 = add nuw i64 %15, 23
  %59 = trunc i64 %58 to i32
  %60 = icmp sgt i32 %10, %59
  br i1 %60, label %14, label %61, !llvm.loop !103

61:                                               ; preds = %14, %12
  %62 = phi double [ 0.000000e+00, %12 ], [ %57, %14 ]
  %63 = phi i32 [ 0, %12 ], [ %59, %14 ]
  %64 = icmp slt i32 %63, %1
  br i1 %64, label %65, label %82

65:                                               ; preds = %61
  %66 = sext i32 %63 to i64
  br label %67

67:                                               ; preds = %67, %65
  %68 = phi i64 [ %66, %65 ], [ %79, %67 ]
  %69 = phi double [ %62, %65 ], [ %78, %67 ]
  %70 = getelementptr inbounds double, ptr %0, i64 %68
  %71 = load double, ptr %70, align 8, !tbaa !17
  %72 = fadd double %71, 1.234500e+04
  %73 = call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %75, 1.234500e+04
  %77 = call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %69, %77
  %79 = add nsw i64 %68, 1
  %80 = icmp eq i64 %79, %11
  br i1 %80, label %81, label %67, !llvm.loop !104

81:                                               ; preds = %67
  %.lcssa = phi double [ %78, %67 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %82

82:                                               ; preds = %81, %61
  %83 = phi double [ %.lcssa, %81 ], [ %62, %61 ]
  %84 = load double, ptr @init_value, align 8, !tbaa !17
  %85 = fadd double %84, 1.234500e+04
  %86 = call double @llvm.fmuladd.f64(double %85, double 9.142370e+05, double -1.300000e+01)
  %87 = fadd double %86, 1.234500e+04
  %88 = call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fmul double %90, 8.000000e+03
  %92 = fsub double %83, %91
  %93 = call double @llvm.fabs.f64(double %83)
  %94 = fcmp ogt double %93, 1.000000e-08
  %95 = select i1 %94, double %83, double 1.000000e+00
  %96 = fdiv double %92, %95
  %97 = call double @llvm.fabs.f64(double %96)
  %98 = fcmp olt double %97, 0x3EB0C6F7A0B5ED8D
  br i1 %98, label %102, label %99

99:                                               ; preds = %82
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  %101 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %100) #12
  br label %102

102:                                              ; preds = %99, %82
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %103 = add nuw nsw i32 %13, 1
  %104 = load i32, ptr @iterations, align 4, !tbaa !11
  %105 = icmp slt i32 %103, %104
  br i1 %105, label %12, label %106, !llvm.loop !105

106:                                              ; preds = %102, %3
  %107 = call i64 @clock() #15
  store i64 %107, ptr @end_time, align 8, !tbaa !23
  %108 = load i64, ptr @start_time, align 8, !tbaa !23
  %109 = sub nsw i64 %107, %108
  %110 = sitofp i64 %109 to double
  %111 = fdiv double %110, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %111, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi19EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi17EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi18EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 17)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi19EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 18)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi20EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %76

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 19
  %10 = add nsw i32 %1, -19
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %72, %8
  %13 = phi i32 [ 0, %8 ], [ %73, %72 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %31

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %28, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  store double %27, ptr %4, align 8, !tbaa !17
  %28 = add nuw i64 %15, 20
  %29 = trunc i64 %28 to i32
  %30 = icmp sgt i32 %10, %29
  br i1 %30, label %14, label %31, !llvm.loop !106

31:                                               ; preds = %14, %12
  %32 = phi double [ 0.000000e+00, %12 ], [ %27, %14 ]
  %33 = phi i32 [ 0, %12 ], [ %29, %14 ]
  %34 = icmp slt i32 %33, %1
  br i1 %34, label %35, label %52

35:                                               ; preds = %31
  %36 = sext i32 %33 to i64
  br label %37

37:                                               ; preds = %37, %35
  %38 = phi i64 [ %36, %35 ], [ %49, %37 ]
  %39 = phi double [ %32, %35 ], [ %48, %37 ]
  %40 = getelementptr inbounds double, ptr %0, i64 %38
  %41 = load double, ptr %40, align 8, !tbaa !17
  %42 = fadd double %41, 1.234500e+04
  %43 = call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %39, %47
  %49 = add nsw i64 %38, 1
  %50 = icmp eq i64 %49, %11
  br i1 %50, label %51, label %37, !llvm.loop !107

51:                                               ; preds = %37
  %.lcssa = phi double [ %48, %37 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %52

52:                                               ; preds = %51, %31
  %53 = phi double [ %.lcssa, %51 ], [ %32, %31 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %56, 1.234500e+04
  %58 = call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fmul double %60, 8.000000e+03
  %62 = fsub double %53, %61
  %63 = call double @llvm.fabs.f64(double %53)
  %64 = fcmp ogt double %63, 1.000000e-08
  %65 = select i1 %64, double %53, double 1.000000e+00
  %66 = fdiv double %62, %65
  %67 = call double @llvm.fabs.f64(double %66)
  %68 = fcmp olt double %67, 0x3EB0C6F7A0B5ED8D
  br i1 %68, label %72, label %69

69:                                               ; preds = %52
  %70 = load i32, ptr @current_test, align 4, !tbaa !11
  %71 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %70) #12
  br label %72

72:                                               ; preds = %69, %52
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %73 = add nuw nsw i32 %13, 1
  %74 = load i32, ptr @iterations, align 4, !tbaa !11
  %75 = icmp slt i32 %73, %74
  br i1 %75, label %12, label %76, !llvm.loop !108

76:                                               ; preds = %72, %3
  %77 = call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi21EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 20
  %10 = add nsw i32 %1, -20
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %82, %8
  %13 = phi i32 [ 0, %8 ], [ %83, %82 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %41

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %38, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 19
  %18 = getelementptr inbounds double, ptr %0, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = load double, ptr %4, align 8, !tbaa !17
  %27 = fadd double %26, %25
  %28 = add nuw nsw i64 %15, 20
  %29 = getelementptr inbounds double, ptr %0, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %27, %36
  store double %37, ptr %4, align 8, !tbaa !17
  %38 = add nuw i64 %15, 21
  %39 = trunc i64 %38 to i32
  %40 = icmp sgt i32 %10, %39
  br i1 %40, label %14, label %41, !llvm.loop !109

41:                                               ; preds = %14, %12
  %42 = phi double [ 0.000000e+00, %12 ], [ %37, %14 ]
  %43 = phi i32 [ 0, %12 ], [ %39, %14 ]
  %44 = icmp slt i32 %43, %1
  br i1 %44, label %45, label %62

45:                                               ; preds = %41
  %46 = sext i32 %43 to i64
  br label %47

47:                                               ; preds = %47, %45
  %48 = phi i64 [ %46, %45 ], [ %59, %47 ]
  %49 = phi double [ %42, %45 ], [ %58, %47 ]
  %50 = getelementptr inbounds double, ptr %0, i64 %48
  %51 = load double, ptr %50, align 8, !tbaa !17
  %52 = fadd double %51, 1.234500e+04
  %53 = call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %49, %57
  %59 = add nsw i64 %48, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %47, !llvm.loop !110

61:                                               ; preds = %47
  %.lcssa = phi double [ %58, %47 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %62

62:                                               ; preds = %61, %41
  %63 = phi double [ %.lcssa, %61 ], [ %42, %41 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !17
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %66, 1.234500e+04
  %68 = call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fmul double %70, 8.000000e+03
  %72 = fsub double %63, %71
  %73 = call double @llvm.fabs.f64(double %63)
  %74 = fcmp ogt double %73, 1.000000e-08
  %75 = select i1 %74, double %63, double 1.000000e+00
  %76 = fdiv double %72, %75
  %77 = call double @llvm.fabs.f64(double %76)
  %78 = fcmp olt double %77, 0x3EB0C6F7A0B5ED8D
  br i1 %78, label %82, label %79

79:                                               ; preds = %62
  %80 = load i32, ptr @current_test, align 4, !tbaa !11
  %81 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %80) #12
  br label %82

82:                                               ; preds = %79, %62
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %83 = add nuw nsw i32 %13, 1
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  %85 = icmp slt i32 %83, %84
  br i1 %85, label %12, label %86, !llvm.loop !111

86:                                               ; preds = %82, %3
  %87 = call i64 @clock() #15
  store i64 %87, ptr @end_time, align 8, !tbaa !23
  %88 = load i64, ptr @start_time, align 8, !tbaa !23
  %89 = sub nsw i64 %87, %88
  %90 = sitofp i64 %89 to double
  %91 = fdiv double %90, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %91, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi17EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi15EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi16EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 15)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi17EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 16)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi18EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %244

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 17
  %9 = add nsw i32 %1, -17
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %240, %7
  %13 = phi i32 [ 0, %7 ], [ %241, %240 ]
  br i1 %8, label %14, label %200

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %196, %14 ], [ 0, %12 ]
  %16 = phi double [ %195, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = or i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = add nuw nsw i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = add nuw nsw i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = add nuw nsw i64 %15, 11
  %127 = getelementptr inbounds double, ptr %0, i64 %126
  %128 = load double, ptr %127, align 8, !tbaa !17
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %125, %134
  %136 = add nuw nsw i64 %15, 12
  %137 = getelementptr inbounds double, ptr %0, i64 %136
  %138 = load double, ptr %137, align 8, !tbaa !17
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %135, %144
  %146 = add nuw nsw i64 %15, 13
  %147 = getelementptr inbounds double, ptr %0, i64 %146
  %148 = load double, ptr %147, align 8, !tbaa !17
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %145, %154
  %156 = add nuw nsw i64 %15, 14
  %157 = getelementptr inbounds double, ptr %0, i64 %156
  %158 = load double, ptr %157, align 8, !tbaa !17
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %155, %164
  %166 = add nuw nsw i64 %15, 15
  %167 = getelementptr inbounds double, ptr %0, i64 %166
  %168 = load double, ptr %167, align 8, !tbaa !17
  %169 = fadd double %168, 1.234500e+04
  %170 = tail call double @llvm.fmuladd.f64(double %169, double 9.142370e+05, double -1.300000e+01)
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %172, 1.234500e+04
  %174 = tail call double @llvm.fmuladd.f64(double %173, double 9.142370e+05, double -1.300000e+01)
  %175 = fadd double %165, %174
  %176 = add nuw nsw i64 %15, 16
  %177 = getelementptr inbounds double, ptr %0, i64 %176
  %178 = load double, ptr %177, align 8, !tbaa !17
  %179 = fadd double %178, 1.234500e+04
  %180 = tail call double @llvm.fmuladd.f64(double %179, double 9.142370e+05, double -1.300000e+01)
  %181 = fadd double %180, 1.234500e+04
  %182 = tail call double @llvm.fmuladd.f64(double %181, double 9.142370e+05, double -1.300000e+01)
  %183 = fadd double %182, 1.234500e+04
  %184 = tail call double @llvm.fmuladd.f64(double %183, double 9.142370e+05, double -1.300000e+01)
  %185 = fadd double %175, %184
  %186 = add nuw nsw i64 %15, 17
  %187 = getelementptr inbounds double, ptr %0, i64 %186
  %188 = load double, ptr %187, align 8, !tbaa !17
  %189 = fadd double %188, 1.234500e+04
  %190 = tail call double @llvm.fmuladd.f64(double %189, double 9.142370e+05, double -1.300000e+01)
  %191 = fadd double %190, 1.234500e+04
  %192 = tail call double @llvm.fmuladd.f64(double %191, double 9.142370e+05, double -1.300000e+01)
  %193 = fadd double %192, 1.234500e+04
  %194 = tail call double @llvm.fmuladd.f64(double %193, double 9.142370e+05, double -1.300000e+01)
  %195 = fadd double %185, %194
  %196 = add nuw nsw i64 %15, 18
  %197 = icmp slt i64 %196, %10
  br i1 %197, label %14, label %198, !llvm.loop !112

198:                                              ; preds = %14
  %.lcssa1 = phi double [ %195, %14 ]
  %.lcssa = phi i64 [ %196, %14 ]
  %199 = trunc i64 %.lcssa to i32
  br label %200

200:                                              ; preds = %198, %12
  %201 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %198 ]
  %202 = phi i32 [ 0, %12 ], [ %199, %198 ]
  %203 = icmp slt i32 %202, %1
  br i1 %203, label %204, label %220

204:                                              ; preds = %200
  %205 = zext i32 %202 to i64
  br label %206

206:                                              ; preds = %206, %204
  %207 = phi i64 [ %205, %204 ], [ %218, %206 ]
  %208 = phi double [ %201, %204 ], [ %217, %206 ]
  %209 = getelementptr inbounds double, ptr %0, i64 %207
  %210 = load double, ptr %209, align 8, !tbaa !17
  %211 = fadd double %210, 1.234500e+04
  %212 = tail call double @llvm.fmuladd.f64(double %211, double 9.142370e+05, double -1.300000e+01)
  %213 = fadd double %212, 1.234500e+04
  %214 = tail call double @llvm.fmuladd.f64(double %213, double 9.142370e+05, double -1.300000e+01)
  %215 = fadd double %214, 1.234500e+04
  %216 = tail call double @llvm.fmuladd.f64(double %215, double 9.142370e+05, double -1.300000e+01)
  %217 = fadd double %208, %216
  %218 = add nuw nsw i64 %207, 1
  %219 = icmp eq i64 %218, %11
  br i1 %219, label %220, label %206, !llvm.loop !113

220:                                              ; preds = %206, %200
  %221 = phi double [ %201, %200 ], [ %217, %206 ]
  %222 = load double, ptr @init_value, align 8, !tbaa !17
  %223 = fadd double %222, 1.234500e+04
  %224 = tail call double @llvm.fmuladd.f64(double %223, double 9.142370e+05, double -1.300000e+01)
  %225 = fadd double %224, 1.234500e+04
  %226 = tail call double @llvm.fmuladd.f64(double %225, double 9.142370e+05, double -1.300000e+01)
  %227 = fadd double %226, 1.234500e+04
  %228 = tail call double @llvm.fmuladd.f64(double %227, double 9.142370e+05, double -1.300000e+01)
  %229 = fmul double %228, 8.000000e+03
  %230 = fsub double %221, %229
  %231 = tail call double @llvm.fabs.f64(double %221)
  %232 = fcmp ogt double %231, 1.000000e-08
  %233 = select i1 %232, double %221, double 1.000000e+00
  %234 = fdiv double %230, %233
  %235 = tail call double @llvm.fabs.f64(double %234)
  %236 = fcmp olt double %235, 0x3EB0C6F7A0B5ED8D
  br i1 %236, label %240, label %237

237:                                              ; preds = %220
  %238 = load i32, ptr @current_test, align 4, !tbaa !11
  %239 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %238) #12
  br label %240

240:                                              ; preds = %237, %220
  %241 = add nuw nsw i32 %13, 1
  %242 = load i32, ptr @iterations, align 4, !tbaa !11
  %243 = icmp slt i32 %241, %242
  br i1 %243, label %12, label %244, !llvm.loop !114

244:                                              ; preds = %240, %3
  %245 = tail call i64 @clock() #15
  store i64 %245, ptr @end_time, align 8, !tbaa !23
  %246 = load i64, ptr @start_time, align 8, !tbaa !23
  %247 = sub nsw i64 %245, %246
  %248 = sitofp i64 %247 to double
  %249 = fdiv double %248, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %249, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi19EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %65

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 18
  %10 = add nsw i32 %1, -18
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %61, %8
  %13 = phi i32 [ 0, %8 ], [ %62, %61 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %9, label %14, label %20

14:                                               ; preds = %14, %12
  %15 = phi i32 [ %16, %14 ], [ 0, %12 ]
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %15) #12
  %16 = add nuw nsw i32 %15, 19
  %17 = icmp slt i32 %16, %10
  br i1 %17, label %14, label %18, !llvm.loop !115

18:                                               ; preds = %14
  %.lcssa = phi i32 [ %16, %14 ]
  %19 = load double, ptr %4, align 8, !tbaa !17
  br label %20

20:                                               ; preds = %18, %12
  %21 = phi double [ 0.000000e+00, %12 ], [ %19, %18 ]
  %22 = phi i32 [ 0, %12 ], [ %.lcssa, %18 ]
  %23 = icmp slt i32 %22, %1
  br i1 %23, label %24, label %41

24:                                               ; preds = %20
  %25 = sext i32 %22 to i64
  br label %26

26:                                               ; preds = %26, %24
  %27 = phi i64 [ %25, %24 ], [ %38, %26 ]
  %28 = phi double [ %21, %24 ], [ %37, %26 ]
  %29 = getelementptr inbounds double, ptr %0, i64 %27
  %30 = load double, ptr %29, align 8, !tbaa !17
  %31 = fadd double %30, 1.234500e+04
  %32 = call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %34, 1.234500e+04
  %36 = call double @llvm.fmuladd.f64(double %35, double 9.142370e+05, double -1.300000e+01)
  %37 = fadd double %28, %36
  %38 = add nsw i64 %27, 1
  %39 = icmp eq i64 %38, %11
  br i1 %39, label %40, label %26, !llvm.loop !116

40:                                               ; preds = %26
  %.lcssa1 = phi double [ %37, %26 ]
  store double %.lcssa1, ptr %4, align 8, !tbaa !17
  br label %41

41:                                               ; preds = %40, %20
  %42 = phi double [ %.lcssa1, %40 ], [ %21, %20 ]
  %43 = load double, ptr @init_value, align 8, !tbaa !17
  %44 = fadd double %43, 1.234500e+04
  %45 = call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fmul double %49, 8.000000e+03
  %51 = fsub double %42, %50
  %52 = call double @llvm.fabs.f64(double %42)
  %53 = fcmp ogt double %52, 1.000000e-08
  %54 = select i1 %53, double %42, double 1.000000e+00
  %55 = fdiv double %51, %54
  %56 = call double @llvm.fabs.f64(double %55)
  %57 = fcmp olt double %56, 0x3EB0C6F7A0B5ED8D
  br i1 %57, label %61, label %58

58:                                               ; preds = %41
  %59 = load i32, ptr @current_test, align 4, !tbaa !11
  %60 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %59) #12
  br label %61

61:                                               ; preds = %58, %41
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %62 = add nuw nsw i32 %13, 1
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  %64 = icmp slt i32 %62, %63
  br i1 %64, label %12, label %65, !llvm.loop !117

65:                                               ; preds = %61, %3
  %66 = call i64 @clock() #15
  store i64 %66, ptr @end_time, align 8, !tbaa !23
  %67 = load i64, ptr @start_time, align 8, !tbaa !23
  %68 = sub nsw i64 %66, %67
  %69 = sitofp i64 %68 to double
  %70 = fdiv double %69, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %70, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi15EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi13EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi14EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 13)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi15EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 14)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi16EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %224

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 15
  %9 = add nsw i32 %1, -15
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %220, %7
  %13 = phi i32 [ 0, %7 ], [ %221, %220 ]
  br i1 %8, label %14, label %180

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %176, %14 ], [ 0, %12 ]
  %16 = phi double [ %175, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = or i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = or i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = or i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = or i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = or i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = or i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = or i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = or i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = or i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = or i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = or i64 %15, 11
  %127 = getelementptr inbounds double, ptr %0, i64 %126
  %128 = load double, ptr %127, align 8, !tbaa !17
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %125, %134
  %136 = or i64 %15, 12
  %137 = getelementptr inbounds double, ptr %0, i64 %136
  %138 = load double, ptr %137, align 8, !tbaa !17
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %135, %144
  %146 = or i64 %15, 13
  %147 = getelementptr inbounds double, ptr %0, i64 %146
  %148 = load double, ptr %147, align 8, !tbaa !17
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %145, %154
  %156 = or i64 %15, 14
  %157 = getelementptr inbounds double, ptr %0, i64 %156
  %158 = load double, ptr %157, align 8, !tbaa !17
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %155, %164
  %166 = or i64 %15, 15
  %167 = getelementptr inbounds double, ptr %0, i64 %166
  %168 = load double, ptr %167, align 8, !tbaa !17
  %169 = fadd double %168, 1.234500e+04
  %170 = tail call double @llvm.fmuladd.f64(double %169, double 9.142370e+05, double -1.300000e+01)
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %172, 1.234500e+04
  %174 = tail call double @llvm.fmuladd.f64(double %173, double 9.142370e+05, double -1.300000e+01)
  %175 = fadd double %165, %174
  %176 = add nuw nsw i64 %15, 16
  %177 = icmp slt i64 %176, %10
  br i1 %177, label %14, label %178, !llvm.loop !118

178:                                              ; preds = %14
  %.lcssa1 = phi double [ %175, %14 ]
  %.lcssa = phi i64 [ %176, %14 ]
  %179 = trunc i64 %.lcssa to i32
  br label %180

180:                                              ; preds = %178, %12
  %181 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %178 ]
  %182 = phi i32 [ 0, %12 ], [ %179, %178 ]
  %183 = icmp slt i32 %182, %1
  br i1 %183, label %184, label %200

184:                                              ; preds = %180
  %185 = zext i32 %182 to i64
  br label %186

186:                                              ; preds = %186, %184
  %187 = phi i64 [ %185, %184 ], [ %198, %186 ]
  %188 = phi double [ %181, %184 ], [ %197, %186 ]
  %189 = getelementptr inbounds double, ptr %0, i64 %187
  %190 = load double, ptr %189, align 8, !tbaa !17
  %191 = fadd double %190, 1.234500e+04
  %192 = tail call double @llvm.fmuladd.f64(double %191, double 9.142370e+05, double -1.300000e+01)
  %193 = fadd double %192, 1.234500e+04
  %194 = tail call double @llvm.fmuladd.f64(double %193, double 9.142370e+05, double -1.300000e+01)
  %195 = fadd double %194, 1.234500e+04
  %196 = tail call double @llvm.fmuladd.f64(double %195, double 9.142370e+05, double -1.300000e+01)
  %197 = fadd double %188, %196
  %198 = add nuw nsw i64 %187, 1
  %199 = icmp eq i64 %198, %11
  br i1 %199, label %200, label %186, !llvm.loop !119

200:                                              ; preds = %186, %180
  %201 = phi double [ %181, %180 ], [ %197, %186 ]
  %202 = load double, ptr @init_value, align 8, !tbaa !17
  %203 = fadd double %202, 1.234500e+04
  %204 = tail call double @llvm.fmuladd.f64(double %203, double 9.142370e+05, double -1.300000e+01)
  %205 = fadd double %204, 1.234500e+04
  %206 = tail call double @llvm.fmuladd.f64(double %205, double 9.142370e+05, double -1.300000e+01)
  %207 = fadd double %206, 1.234500e+04
  %208 = tail call double @llvm.fmuladd.f64(double %207, double 9.142370e+05, double -1.300000e+01)
  %209 = fmul double %208, 8.000000e+03
  %210 = fsub double %201, %209
  %211 = tail call double @llvm.fabs.f64(double %201)
  %212 = fcmp ogt double %211, 1.000000e-08
  %213 = select i1 %212, double %201, double 1.000000e+00
  %214 = fdiv double %210, %213
  %215 = tail call double @llvm.fabs.f64(double %214)
  %216 = fcmp olt double %215, 0x3EB0C6F7A0B5ED8D
  br i1 %216, label %220, label %217

217:                                              ; preds = %200
  %218 = load i32, ptr @current_test, align 4, !tbaa !11
  %219 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %218) #12
  br label %220

220:                                              ; preds = %217, %200
  %221 = add nuw nsw i32 %13, 1
  %222 = load i32, ptr @iterations, align 4, !tbaa !11
  %223 = icmp slt i32 %221, %222
  br i1 %223, label %12, label %224, !llvm.loop !120

224:                                              ; preds = %220, %3
  %225 = tail call i64 @clock() #15
  store i64 %225, ptr @end_time, align 8, !tbaa !23
  %226 = load i64, ptr @start_time, align 8, !tbaa !23
  %227 = sub nsw i64 %225, %226
  %228 = sitofp i64 %227 to double
  %229 = fdiv double %228, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %229, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi17EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %234

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 16
  %9 = add nsw i32 %1, -16
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %230, %7
  %13 = phi i32 [ 0, %7 ], [ %231, %230 ]
  br i1 %8, label %14, label %190

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %186, %14 ], [ 0, %12 ]
  %16 = phi double [ %185, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = add nuw nsw i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = add nuw nsw i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = add nuw nsw i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = add nuw nsw i64 %15, 11
  %127 = getelementptr inbounds double, ptr %0, i64 %126
  %128 = load double, ptr %127, align 8, !tbaa !17
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %125, %134
  %136 = add nuw nsw i64 %15, 12
  %137 = getelementptr inbounds double, ptr %0, i64 %136
  %138 = load double, ptr %137, align 8, !tbaa !17
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %135, %144
  %146 = add nuw nsw i64 %15, 13
  %147 = getelementptr inbounds double, ptr %0, i64 %146
  %148 = load double, ptr %147, align 8, !tbaa !17
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %145, %154
  %156 = add nuw nsw i64 %15, 14
  %157 = getelementptr inbounds double, ptr %0, i64 %156
  %158 = load double, ptr %157, align 8, !tbaa !17
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %155, %164
  %166 = add nuw nsw i64 %15, 15
  %167 = getelementptr inbounds double, ptr %0, i64 %166
  %168 = load double, ptr %167, align 8, !tbaa !17
  %169 = fadd double %168, 1.234500e+04
  %170 = tail call double @llvm.fmuladd.f64(double %169, double 9.142370e+05, double -1.300000e+01)
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %172, 1.234500e+04
  %174 = tail call double @llvm.fmuladd.f64(double %173, double 9.142370e+05, double -1.300000e+01)
  %175 = fadd double %165, %174
  %176 = add nuw nsw i64 %15, 16
  %177 = getelementptr inbounds double, ptr %0, i64 %176
  %178 = load double, ptr %177, align 8, !tbaa !17
  %179 = fadd double %178, 1.234500e+04
  %180 = tail call double @llvm.fmuladd.f64(double %179, double 9.142370e+05, double -1.300000e+01)
  %181 = fadd double %180, 1.234500e+04
  %182 = tail call double @llvm.fmuladd.f64(double %181, double 9.142370e+05, double -1.300000e+01)
  %183 = fadd double %182, 1.234500e+04
  %184 = tail call double @llvm.fmuladd.f64(double %183, double 9.142370e+05, double -1.300000e+01)
  %185 = fadd double %175, %184
  %186 = add nuw nsw i64 %15, 17
  %187 = icmp slt i64 %186, %10
  br i1 %187, label %14, label %188, !llvm.loop !121

188:                                              ; preds = %14
  %.lcssa1 = phi double [ %185, %14 ]
  %.lcssa = phi i64 [ %186, %14 ]
  %189 = trunc i64 %.lcssa to i32
  br label %190

190:                                              ; preds = %188, %12
  %191 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %188 ]
  %192 = phi i32 [ 0, %12 ], [ %189, %188 ]
  %193 = icmp slt i32 %192, %1
  br i1 %193, label %194, label %210

194:                                              ; preds = %190
  %195 = zext i32 %192 to i64
  br label %196

196:                                              ; preds = %196, %194
  %197 = phi i64 [ %195, %194 ], [ %208, %196 ]
  %198 = phi double [ %191, %194 ], [ %207, %196 ]
  %199 = getelementptr inbounds double, ptr %0, i64 %197
  %200 = load double, ptr %199, align 8, !tbaa !17
  %201 = fadd double %200, 1.234500e+04
  %202 = tail call double @llvm.fmuladd.f64(double %201, double 9.142370e+05, double -1.300000e+01)
  %203 = fadd double %202, 1.234500e+04
  %204 = tail call double @llvm.fmuladd.f64(double %203, double 9.142370e+05, double -1.300000e+01)
  %205 = fadd double %204, 1.234500e+04
  %206 = tail call double @llvm.fmuladd.f64(double %205, double 9.142370e+05, double -1.300000e+01)
  %207 = fadd double %198, %206
  %208 = add nuw nsw i64 %197, 1
  %209 = icmp eq i64 %208, %11
  br i1 %209, label %210, label %196, !llvm.loop !122

210:                                              ; preds = %196, %190
  %211 = phi double [ %191, %190 ], [ %207, %196 ]
  %212 = load double, ptr @init_value, align 8, !tbaa !17
  %213 = fadd double %212, 1.234500e+04
  %214 = tail call double @llvm.fmuladd.f64(double %213, double 9.142370e+05, double -1.300000e+01)
  %215 = fadd double %214, 1.234500e+04
  %216 = tail call double @llvm.fmuladd.f64(double %215, double 9.142370e+05, double -1.300000e+01)
  %217 = fadd double %216, 1.234500e+04
  %218 = tail call double @llvm.fmuladd.f64(double %217, double 9.142370e+05, double -1.300000e+01)
  %219 = fmul double %218, 8.000000e+03
  %220 = fsub double %211, %219
  %221 = tail call double @llvm.fabs.f64(double %211)
  %222 = fcmp ogt double %221, 1.000000e-08
  %223 = select i1 %222, double %211, double 1.000000e+00
  %224 = fdiv double %220, %223
  %225 = tail call double @llvm.fabs.f64(double %224)
  %226 = fcmp olt double %225, 0x3EB0C6F7A0B5ED8D
  br i1 %226, label %230, label %227

227:                                              ; preds = %210
  %228 = load i32, ptr @current_test, align 4, !tbaa !11
  %229 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %228) #12
  br label %230

230:                                              ; preds = %227, %210
  %231 = add nuw nsw i32 %13, 1
  %232 = load i32, ptr @iterations, align 4, !tbaa !11
  %233 = icmp slt i32 %231, %232
  br i1 %233, label %12, label %234, !llvm.loop !123

234:                                              ; preds = %230, %3
  %235 = tail call i64 @clock() #15
  store i64 %235, ptr @end_time, align 8, !tbaa !23
  %236 = load i64, ptr @start_time, align 8, !tbaa !23
  %237 = sub nsw i64 %235, %236
  %238 = sitofp i64 %237 to double
  %239 = fdiv double %238, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %239, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi13EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi11EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi12EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 11)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi13EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 12)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi14EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %204

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 13
  %9 = add nsw i32 %1, -13
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %200, %7
  %13 = phi i32 [ 0, %7 ], [ %201, %200 ]
  br i1 %8, label %14, label %160

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %156, %14 ], [ 0, %12 ]
  %16 = phi double [ %155, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = or i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = add nuw nsw i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = add nuw nsw i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = add nuw nsw i64 %15, 11
  %127 = getelementptr inbounds double, ptr %0, i64 %126
  %128 = load double, ptr %127, align 8, !tbaa !17
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %125, %134
  %136 = add nuw nsw i64 %15, 12
  %137 = getelementptr inbounds double, ptr %0, i64 %136
  %138 = load double, ptr %137, align 8, !tbaa !17
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %135, %144
  %146 = add nuw nsw i64 %15, 13
  %147 = getelementptr inbounds double, ptr %0, i64 %146
  %148 = load double, ptr %147, align 8, !tbaa !17
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %145, %154
  %156 = add nuw nsw i64 %15, 14
  %157 = icmp slt i64 %156, %10
  br i1 %157, label %14, label %158, !llvm.loop !124

158:                                              ; preds = %14
  %.lcssa1 = phi double [ %155, %14 ]
  %.lcssa = phi i64 [ %156, %14 ]
  %159 = trunc i64 %.lcssa to i32
  br label %160

160:                                              ; preds = %158, %12
  %161 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %158 ]
  %162 = phi i32 [ 0, %12 ], [ %159, %158 ]
  %163 = icmp slt i32 %162, %1
  br i1 %163, label %164, label %180

164:                                              ; preds = %160
  %165 = zext i32 %162 to i64
  br label %166

166:                                              ; preds = %166, %164
  %167 = phi i64 [ %165, %164 ], [ %178, %166 ]
  %168 = phi double [ %161, %164 ], [ %177, %166 ]
  %169 = getelementptr inbounds double, ptr %0, i64 %167
  %170 = load double, ptr %169, align 8, !tbaa !17
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %172, 1.234500e+04
  %174 = tail call double @llvm.fmuladd.f64(double %173, double 9.142370e+05, double -1.300000e+01)
  %175 = fadd double %174, 1.234500e+04
  %176 = tail call double @llvm.fmuladd.f64(double %175, double 9.142370e+05, double -1.300000e+01)
  %177 = fadd double %168, %176
  %178 = add nuw nsw i64 %167, 1
  %179 = icmp eq i64 %178, %11
  br i1 %179, label %180, label %166, !llvm.loop !125

180:                                              ; preds = %166, %160
  %181 = phi double [ %161, %160 ], [ %177, %166 ]
  %182 = load double, ptr @init_value, align 8, !tbaa !17
  %183 = fadd double %182, 1.234500e+04
  %184 = tail call double @llvm.fmuladd.f64(double %183, double 9.142370e+05, double -1.300000e+01)
  %185 = fadd double %184, 1.234500e+04
  %186 = tail call double @llvm.fmuladd.f64(double %185, double 9.142370e+05, double -1.300000e+01)
  %187 = fadd double %186, 1.234500e+04
  %188 = tail call double @llvm.fmuladd.f64(double %187, double 9.142370e+05, double -1.300000e+01)
  %189 = fmul double %188, 8.000000e+03
  %190 = fsub double %181, %189
  %191 = tail call double @llvm.fabs.f64(double %181)
  %192 = fcmp ogt double %191, 1.000000e-08
  %193 = select i1 %192, double %181, double 1.000000e+00
  %194 = fdiv double %190, %193
  %195 = tail call double @llvm.fabs.f64(double %194)
  %196 = fcmp olt double %195, 0x3EB0C6F7A0B5ED8D
  br i1 %196, label %200, label %197

197:                                              ; preds = %180
  %198 = load i32, ptr @current_test, align 4, !tbaa !11
  %199 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %198) #12
  br label %200

200:                                              ; preds = %197, %180
  %201 = add nuw nsw i32 %13, 1
  %202 = load i32, ptr @iterations, align 4, !tbaa !11
  %203 = icmp slt i32 %201, %202
  br i1 %203, label %12, label %204, !llvm.loop !126

204:                                              ; preds = %200, %3
  %205 = tail call i64 @clock() #15
  store i64 %205, ptr @end_time, align 8, !tbaa !23
  %206 = load i64, ptr @start_time, align 8, !tbaa !23
  %207 = sub nsw i64 %205, %206
  %208 = sitofp i64 %207 to double
  %209 = fdiv double %208, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %209, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi15EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %214

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 14
  %9 = add nsw i32 %1, -14
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %210, %7
  %13 = phi i32 [ 0, %7 ], [ %211, %210 ]
  br i1 %8, label %14, label %170

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %166, %14 ], [ 0, %12 ]
  %16 = phi double [ %165, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = add nuw nsw i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = add nuw nsw i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = add nuw nsw i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = add nuw nsw i64 %15, 11
  %127 = getelementptr inbounds double, ptr %0, i64 %126
  %128 = load double, ptr %127, align 8, !tbaa !17
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %125, %134
  %136 = add nuw nsw i64 %15, 12
  %137 = getelementptr inbounds double, ptr %0, i64 %136
  %138 = load double, ptr %137, align 8, !tbaa !17
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %135, %144
  %146 = add nuw nsw i64 %15, 13
  %147 = getelementptr inbounds double, ptr %0, i64 %146
  %148 = load double, ptr %147, align 8, !tbaa !17
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %145, %154
  %156 = add nuw nsw i64 %15, 14
  %157 = getelementptr inbounds double, ptr %0, i64 %156
  %158 = load double, ptr %157, align 8, !tbaa !17
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %155, %164
  %166 = add nuw nsw i64 %15, 15
  %167 = icmp slt i64 %166, %10
  br i1 %167, label %14, label %168, !llvm.loop !127

168:                                              ; preds = %14
  %.lcssa1 = phi double [ %165, %14 ]
  %.lcssa = phi i64 [ %166, %14 ]
  %169 = trunc i64 %.lcssa to i32
  br label %170

170:                                              ; preds = %168, %12
  %171 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %168 ]
  %172 = phi i32 [ 0, %12 ], [ %169, %168 ]
  %173 = icmp slt i32 %172, %1
  br i1 %173, label %174, label %190

174:                                              ; preds = %170
  %175 = zext i32 %172 to i64
  br label %176

176:                                              ; preds = %176, %174
  %177 = phi i64 [ %175, %174 ], [ %188, %176 ]
  %178 = phi double [ %171, %174 ], [ %187, %176 ]
  %179 = getelementptr inbounds double, ptr %0, i64 %177
  %180 = load double, ptr %179, align 8, !tbaa !17
  %181 = fadd double %180, 1.234500e+04
  %182 = tail call double @llvm.fmuladd.f64(double %181, double 9.142370e+05, double -1.300000e+01)
  %183 = fadd double %182, 1.234500e+04
  %184 = tail call double @llvm.fmuladd.f64(double %183, double 9.142370e+05, double -1.300000e+01)
  %185 = fadd double %184, 1.234500e+04
  %186 = tail call double @llvm.fmuladd.f64(double %185, double 9.142370e+05, double -1.300000e+01)
  %187 = fadd double %178, %186
  %188 = add nuw nsw i64 %177, 1
  %189 = icmp eq i64 %188, %11
  br i1 %189, label %190, label %176, !llvm.loop !128

190:                                              ; preds = %176, %170
  %191 = phi double [ %171, %170 ], [ %187, %176 ]
  %192 = load double, ptr @init_value, align 8, !tbaa !17
  %193 = fadd double %192, 1.234500e+04
  %194 = tail call double @llvm.fmuladd.f64(double %193, double 9.142370e+05, double -1.300000e+01)
  %195 = fadd double %194, 1.234500e+04
  %196 = tail call double @llvm.fmuladd.f64(double %195, double 9.142370e+05, double -1.300000e+01)
  %197 = fadd double %196, 1.234500e+04
  %198 = tail call double @llvm.fmuladd.f64(double %197, double 9.142370e+05, double -1.300000e+01)
  %199 = fmul double %198, 8.000000e+03
  %200 = fsub double %191, %199
  %201 = tail call double @llvm.fabs.f64(double %191)
  %202 = fcmp ogt double %201, 1.000000e-08
  %203 = select i1 %202, double %191, double 1.000000e+00
  %204 = fdiv double %200, %203
  %205 = tail call double @llvm.fabs.f64(double %204)
  %206 = fcmp olt double %205, 0x3EB0C6F7A0B5ED8D
  br i1 %206, label %210, label %207

207:                                              ; preds = %190
  %208 = load i32, ptr @current_test, align 4, !tbaa !11
  %209 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %208) #12
  br label %210

210:                                              ; preds = %207, %190
  %211 = add nuw nsw i32 %13, 1
  %212 = load i32, ptr @iterations, align 4, !tbaa !11
  %213 = icmp slt i32 %211, %212
  br i1 %213, label %12, label %214, !llvm.loop !129

214:                                              ; preds = %210, %3
  %215 = tail call i64 @clock() #15
  store i64 %215, ptr @end_time, align 8, !tbaa !23
  %216 = load i64, ptr @start_time, align 8, !tbaa !23
  %217 = sub nsw i64 %215, %216
  %218 = sitofp i64 %217 to double
  %219 = fdiv double %218, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %219, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi11EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi9EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi10EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 9)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi11EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 10)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi12EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %184

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 11
  %9 = add nsw i32 %1, -11
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %180, %7
  %13 = phi i32 [ 0, %7 ], [ %181, %180 ]
  br i1 %8, label %14, label %140

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %136, %14 ], [ 0, %12 ]
  %16 = phi double [ %135, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = or i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = or i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = or i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = add nuw nsw i64 %15, 11
  %127 = getelementptr inbounds double, ptr %0, i64 %126
  %128 = load double, ptr %127, align 8, !tbaa !17
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %125, %134
  %136 = add nuw nsw i64 %15, 12
  %137 = icmp slt i64 %136, %10
  br i1 %137, label %14, label %138, !llvm.loop !130

138:                                              ; preds = %14
  %.lcssa1 = phi double [ %135, %14 ]
  %.lcssa = phi i64 [ %136, %14 ]
  %139 = trunc i64 %.lcssa to i32
  br label %140

140:                                              ; preds = %138, %12
  %141 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %138 ]
  %142 = phi i32 [ 0, %12 ], [ %139, %138 ]
  %143 = icmp slt i32 %142, %1
  br i1 %143, label %144, label %160

144:                                              ; preds = %140
  %145 = zext i32 %142 to i64
  br label %146

146:                                              ; preds = %146, %144
  %147 = phi i64 [ %145, %144 ], [ %158, %146 ]
  %148 = phi double [ %141, %144 ], [ %157, %146 ]
  %149 = getelementptr inbounds double, ptr %0, i64 %147
  %150 = load double, ptr %149, align 8, !tbaa !17
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %154, 1.234500e+04
  %156 = tail call double @llvm.fmuladd.f64(double %155, double 9.142370e+05, double -1.300000e+01)
  %157 = fadd double %148, %156
  %158 = add nuw nsw i64 %147, 1
  %159 = icmp eq i64 %158, %11
  br i1 %159, label %160, label %146, !llvm.loop !131

160:                                              ; preds = %146, %140
  %161 = phi double [ %141, %140 ], [ %157, %146 ]
  %162 = load double, ptr @init_value, align 8, !tbaa !17
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %164, 1.234500e+04
  %166 = tail call double @llvm.fmuladd.f64(double %165, double 9.142370e+05, double -1.300000e+01)
  %167 = fadd double %166, 1.234500e+04
  %168 = tail call double @llvm.fmuladd.f64(double %167, double 9.142370e+05, double -1.300000e+01)
  %169 = fmul double %168, 8.000000e+03
  %170 = fsub double %161, %169
  %171 = tail call double @llvm.fabs.f64(double %161)
  %172 = fcmp ogt double %171, 1.000000e-08
  %173 = select i1 %172, double %161, double 1.000000e+00
  %174 = fdiv double %170, %173
  %175 = tail call double @llvm.fabs.f64(double %174)
  %176 = fcmp olt double %175, 0x3EB0C6F7A0B5ED8D
  br i1 %176, label %180, label %177

177:                                              ; preds = %160
  %178 = load i32, ptr @current_test, align 4, !tbaa !11
  %179 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %178) #12
  br label %180

180:                                              ; preds = %177, %160
  %181 = add nuw nsw i32 %13, 1
  %182 = load i32, ptr @iterations, align 4, !tbaa !11
  %183 = icmp slt i32 %181, %182
  br i1 %183, label %12, label %184, !llvm.loop !132

184:                                              ; preds = %180, %3
  %185 = tail call i64 @clock() #15
  store i64 %185, ptr @end_time, align 8, !tbaa !23
  %186 = load i64, ptr @start_time, align 8, !tbaa !23
  %187 = sub nsw i64 %185, %186
  %188 = sitofp i64 %187 to double
  %189 = fdiv double %188, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %189, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi13EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %194

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 12
  %9 = add nsw i32 %1, -12
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %190, %7
  %13 = phi i32 [ 0, %7 ], [ %191, %190 ]
  br i1 %8, label %14, label %150

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %146, %14 ], [ 0, %12 ]
  %16 = phi double [ %145, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = add nuw nsw i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = add nuw nsw i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = add nuw nsw i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = add nuw nsw i64 %15, 11
  %127 = getelementptr inbounds double, ptr %0, i64 %126
  %128 = load double, ptr %127, align 8, !tbaa !17
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %125, %134
  %136 = add nuw nsw i64 %15, 12
  %137 = getelementptr inbounds double, ptr %0, i64 %136
  %138 = load double, ptr %137, align 8, !tbaa !17
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %135, %144
  %146 = add nuw nsw i64 %15, 13
  %147 = icmp slt i64 %146, %10
  br i1 %147, label %14, label %148, !llvm.loop !133

148:                                              ; preds = %14
  %.lcssa1 = phi double [ %145, %14 ]
  %.lcssa = phi i64 [ %146, %14 ]
  %149 = trunc i64 %.lcssa to i32
  br label %150

150:                                              ; preds = %148, %12
  %151 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %148 ]
  %152 = phi i32 [ 0, %12 ], [ %149, %148 ]
  %153 = icmp slt i32 %152, %1
  br i1 %153, label %154, label %170

154:                                              ; preds = %150
  %155 = zext i32 %152 to i64
  br label %156

156:                                              ; preds = %156, %154
  %157 = phi i64 [ %155, %154 ], [ %168, %156 ]
  %158 = phi double [ %151, %154 ], [ %167, %156 ]
  %159 = getelementptr inbounds double, ptr %0, i64 %157
  %160 = load double, ptr %159, align 8, !tbaa !17
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %164, 1.234500e+04
  %166 = tail call double @llvm.fmuladd.f64(double %165, double 9.142370e+05, double -1.300000e+01)
  %167 = fadd double %158, %166
  %168 = add nuw nsw i64 %157, 1
  %169 = icmp eq i64 %168, %11
  br i1 %169, label %170, label %156, !llvm.loop !134

170:                                              ; preds = %156, %150
  %171 = phi double [ %151, %150 ], [ %167, %156 ]
  %172 = load double, ptr @init_value, align 8, !tbaa !17
  %173 = fadd double %172, 1.234500e+04
  %174 = tail call double @llvm.fmuladd.f64(double %173, double 9.142370e+05, double -1.300000e+01)
  %175 = fadd double %174, 1.234500e+04
  %176 = tail call double @llvm.fmuladd.f64(double %175, double 9.142370e+05, double -1.300000e+01)
  %177 = fadd double %176, 1.234500e+04
  %178 = tail call double @llvm.fmuladd.f64(double %177, double 9.142370e+05, double -1.300000e+01)
  %179 = fmul double %178, 8.000000e+03
  %180 = fsub double %171, %179
  %181 = tail call double @llvm.fabs.f64(double %171)
  %182 = fcmp ogt double %181, 1.000000e-08
  %183 = select i1 %182, double %171, double 1.000000e+00
  %184 = fdiv double %180, %183
  %185 = tail call double @llvm.fabs.f64(double %184)
  %186 = fcmp olt double %185, 0x3EB0C6F7A0B5ED8D
  br i1 %186, label %190, label %187

187:                                              ; preds = %170
  %188 = load i32, ptr @current_test, align 4, !tbaa !11
  %189 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %188) #12
  br label %190

190:                                              ; preds = %187, %170
  %191 = add nuw nsw i32 %13, 1
  %192 = load i32, ptr @iterations, align 4, !tbaa !11
  %193 = icmp slt i32 %191, %192
  br i1 %193, label %12, label %194, !llvm.loop !135

194:                                              ; preds = %190, %3
  %195 = tail call i64 @clock() #15
  store i64 %195, ptr @end_time, align 8, !tbaa !23
  %196 = load i64, ptr @start_time, align 8, !tbaa !23
  %197 = sub nsw i64 %195, %196
  %198 = sitofp i64 %197 to double
  %199 = fdiv double %198, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %199, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi9EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi7EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi8EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 7)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi9EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 8)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi10EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %164

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 9
  %9 = add nsw i32 %1, -9
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %160, %7
  %13 = phi i32 [ 0, %7 ], [ %161, %160 ]
  br i1 %8, label %14, label %120

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %116, %14 ], [ 0, %12 ]
  %16 = phi double [ %115, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = or i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = add nuw nsw i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = add nuw nsw i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = icmp slt i64 %116, %10
  br i1 %117, label %14, label %118, !llvm.loop !136

118:                                              ; preds = %14
  %.lcssa1 = phi double [ %115, %14 ]
  %.lcssa = phi i64 [ %116, %14 ]
  %119 = trunc i64 %.lcssa to i32
  br label %120

120:                                              ; preds = %118, %12
  %121 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %118 ]
  %122 = phi i32 [ 0, %12 ], [ %119, %118 ]
  %123 = icmp slt i32 %122, %1
  br i1 %123, label %124, label %140

124:                                              ; preds = %120
  %125 = zext i32 %122 to i64
  br label %126

126:                                              ; preds = %126, %124
  %127 = phi i64 [ %125, %124 ], [ %138, %126 ]
  %128 = phi double [ %121, %124 ], [ %137, %126 ]
  %129 = getelementptr inbounds double, ptr %0, i64 %127
  %130 = load double, ptr %129, align 8, !tbaa !17
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %134, 1.234500e+04
  %136 = tail call double @llvm.fmuladd.f64(double %135, double 9.142370e+05, double -1.300000e+01)
  %137 = fadd double %128, %136
  %138 = add nuw nsw i64 %127, 1
  %139 = icmp eq i64 %138, %11
  br i1 %139, label %140, label %126, !llvm.loop !137

140:                                              ; preds = %126, %120
  %141 = phi double [ %121, %120 ], [ %137, %126 ]
  %142 = load double, ptr @init_value, align 8, !tbaa !17
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %144, 1.234500e+04
  %146 = tail call double @llvm.fmuladd.f64(double %145, double 9.142370e+05, double -1.300000e+01)
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fmul double %148, 8.000000e+03
  %150 = fsub double %141, %149
  %151 = tail call double @llvm.fabs.f64(double %141)
  %152 = fcmp ogt double %151, 1.000000e-08
  %153 = select i1 %152, double %141, double 1.000000e+00
  %154 = fdiv double %150, %153
  %155 = tail call double @llvm.fabs.f64(double %154)
  %156 = fcmp olt double %155, 0x3EB0C6F7A0B5ED8D
  br i1 %156, label %160, label %157

157:                                              ; preds = %140
  %158 = load i32, ptr @current_test, align 4, !tbaa !11
  %159 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %158) #12
  br label %160

160:                                              ; preds = %157, %140
  %161 = add nuw nsw i32 %13, 1
  %162 = load i32, ptr @iterations, align 4, !tbaa !11
  %163 = icmp slt i32 %161, %162
  br i1 %163, label %12, label %164, !llvm.loop !138

164:                                              ; preds = %160, %3
  %165 = tail call i64 @clock() #15
  store i64 %165, ptr @end_time, align 8, !tbaa !23
  %166 = load i64, ptr @start_time, align 8, !tbaa !23
  %167 = sub nsw i64 %165, %166
  %168 = sitofp i64 %167 to double
  %169 = fdiv double %168, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %169, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi11EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %174

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 10
  %9 = add nsw i32 %1, -10
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %170, %7
  %13 = phi i32 [ 0, %7 ], [ %171, %170 ]
  br i1 %8, label %14, label %130

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %126, %14 ], [ 0, %12 ]
  %16 = phi double [ %125, %14 ], [ 0.000000e+00, %12 ]
  %17 = getelementptr inbounds double, ptr %0, i64 %15
  %18 = load double, ptr %17, align 8, !tbaa !17
  %19 = fadd double %18, 1.234500e+04
  %20 = tail call double @llvm.fmuladd.f64(double %19, double 9.142370e+05, double -1.300000e+01)
  %21 = fadd double %20, 1.234500e+04
  %22 = tail call double @llvm.fmuladd.f64(double %21, double 9.142370e+05, double -1.300000e+01)
  %23 = fadd double %22, 1.234500e+04
  %24 = tail call double @llvm.fmuladd.f64(double %23, double 9.142370e+05, double -1.300000e+01)
  %25 = fadd double %16, %24
  %26 = add nuw nsw i64 %15, 1
  %27 = getelementptr inbounds double, ptr %0, i64 %26
  %28 = load double, ptr %27, align 8, !tbaa !17
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %32, 1.234500e+04
  %34 = tail call double @llvm.fmuladd.f64(double %33, double 9.142370e+05, double -1.300000e+01)
  %35 = fadd double %25, %34
  %36 = add nuw nsw i64 %15, 2
  %37 = getelementptr inbounds double, ptr %0, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !17
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = tail call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %35, %44
  %46 = add nuw nsw i64 %15, 3
  %47 = getelementptr inbounds double, ptr %0, i64 %46
  %48 = load double, ptr %47, align 8, !tbaa !17
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = tail call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %45, %54
  %56 = add nuw nsw i64 %15, 4
  %57 = getelementptr inbounds double, ptr %0, i64 %56
  %58 = load double, ptr %57, align 8, !tbaa !17
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = tail call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %55, %64
  %66 = add nuw nsw i64 %15, 5
  %67 = getelementptr inbounds double, ptr %0, i64 %66
  %68 = load double, ptr %67, align 8, !tbaa !17
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = tail call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %65, %74
  %76 = add nuw nsw i64 %15, 6
  %77 = getelementptr inbounds double, ptr %0, i64 %76
  %78 = load double, ptr %77, align 8, !tbaa !17
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = tail call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %75, %84
  %86 = add nuw nsw i64 %15, 7
  %87 = getelementptr inbounds double, ptr %0, i64 %86
  %88 = load double, ptr %87, align 8, !tbaa !17
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = tail call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %85, %94
  %96 = add nuw nsw i64 %15, 8
  %97 = getelementptr inbounds double, ptr %0, i64 %96
  %98 = load double, ptr %97, align 8, !tbaa !17
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = tail call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %95, %104
  %106 = add nuw nsw i64 %15, 9
  %107 = getelementptr inbounds double, ptr %0, i64 %106
  %108 = load double, ptr %107, align 8, !tbaa !17
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = tail call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %105, %114
  %116 = add nuw nsw i64 %15, 10
  %117 = getelementptr inbounds double, ptr %0, i64 %116
  %118 = load double, ptr %117, align 8, !tbaa !17
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %122, 1.234500e+04
  %124 = tail call double @llvm.fmuladd.f64(double %123, double 9.142370e+05, double -1.300000e+01)
  %125 = fadd double %115, %124
  %126 = add nuw nsw i64 %15, 11
  %127 = icmp slt i64 %126, %10
  br i1 %127, label %14, label %128, !llvm.loop !139

128:                                              ; preds = %14
  %.lcssa1 = phi double [ %125, %14 ]
  %.lcssa = phi i64 [ %126, %14 ]
  %129 = trunc i64 %.lcssa to i32
  br label %130

130:                                              ; preds = %128, %12
  %131 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %128 ]
  %132 = phi i32 [ 0, %12 ], [ %129, %128 ]
  %133 = icmp slt i32 %132, %1
  br i1 %133, label %134, label %150

134:                                              ; preds = %130
  %135 = zext i32 %132 to i64
  br label %136

136:                                              ; preds = %136, %134
  %137 = phi i64 [ %135, %134 ], [ %148, %136 ]
  %138 = phi double [ %131, %134 ], [ %147, %136 ]
  %139 = getelementptr inbounds double, ptr %0, i64 %137
  %140 = load double, ptr %139, align 8, !tbaa !17
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %144, 1.234500e+04
  %146 = tail call double @llvm.fmuladd.f64(double %145, double 9.142370e+05, double -1.300000e+01)
  %147 = fadd double %138, %146
  %148 = add nuw nsw i64 %137, 1
  %149 = icmp eq i64 %148, %11
  br i1 %149, label %150, label %136, !llvm.loop !140

150:                                              ; preds = %136, %130
  %151 = phi double [ %131, %130 ], [ %147, %136 ]
  %152 = load double, ptr @init_value, align 8, !tbaa !17
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %154, 1.234500e+04
  %156 = tail call double @llvm.fmuladd.f64(double %155, double 9.142370e+05, double -1.300000e+01)
  %157 = fadd double %156, 1.234500e+04
  %158 = tail call double @llvm.fmuladd.f64(double %157, double 9.142370e+05, double -1.300000e+01)
  %159 = fmul double %158, 8.000000e+03
  %160 = fsub double %151, %159
  %161 = tail call double @llvm.fabs.f64(double %151)
  %162 = fcmp ogt double %161, 1.000000e-08
  %163 = select i1 %162, double %151, double 1.000000e+00
  %164 = fdiv double %160, %163
  %165 = tail call double @llvm.fabs.f64(double %164)
  %166 = fcmp olt double %165, 0x3EB0C6F7A0B5ED8D
  br i1 %166, label %170, label %167

167:                                              ; preds = %150
  %168 = load i32, ptr @current_test, align 4, !tbaa !11
  %169 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %168) #12
  br label %170

170:                                              ; preds = %167, %150
  %171 = add nuw nsw i32 %13, 1
  %172 = load i32, ptr @iterations, align 4, !tbaa !11
  %173 = icmp slt i32 %171, %172
  br i1 %173, label %12, label %174, !llvm.loop !141

174:                                              ; preds = %170, %3
  %175 = tail call i64 @clock() #15
  store i64 %175, ptr @end_time, align 8, !tbaa !23
  %176 = load i64, ptr @start_time, align 8, !tbaa !23
  %177 = sub nsw i64 %175, %176
  %178 = sitofp i64 %177 to double
  %179 = fdiv double %178, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %179, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi7EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi5EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi6EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 5)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi7EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 6)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi8EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %146

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 7
  %9 = add nsw i32 %1, -7
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %142, %7
  %13 = phi i32 [ %5, %7 ], [ %143, %142 ]
  %14 = phi i32 [ 0, %7 ], [ %144, %142 ]
  br i1 %8, label %15, label %101

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %97, %15 ], [ 0, %12 ]
  %17 = phi double [ %96, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = or i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = or i64 %16, 2
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !17
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %36, %45
  %47 = or i64 %16, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !17
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %46, %55
  %57 = or i64 %16, 4
  %58 = getelementptr inbounds double, ptr %0, i64 %57
  %59 = load double, ptr %58, align 8, !tbaa !17
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %56, %65
  %67 = or i64 %16, 5
  %68 = getelementptr inbounds double, ptr %0, i64 %67
  %69 = load double, ptr %68, align 8, !tbaa !17
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %66, %75
  %77 = or i64 %16, 6
  %78 = getelementptr inbounds double, ptr %0, i64 %77
  %79 = load double, ptr %78, align 8, !tbaa !17
  %80 = fadd double %79, 1.234500e+04
  %81 = tail call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %83, 1.234500e+04
  %85 = tail call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %76, %85
  %87 = or i64 %16, 7
  %88 = getelementptr inbounds double, ptr %0, i64 %87
  %89 = load double, ptr %88, align 8, !tbaa !17
  %90 = fadd double %89, 1.234500e+04
  %91 = tail call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %91, 1.234500e+04
  %93 = tail call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %93, 1.234500e+04
  %95 = tail call double @llvm.fmuladd.f64(double %94, double 9.142370e+05, double -1.300000e+01)
  %96 = fadd double %86, %95
  %97 = add nuw nsw i64 %16, 8
  %98 = icmp slt i64 %97, %10
  br i1 %98, label %15, label %99, !llvm.loop !142

99:                                               ; preds = %15
  %.lcssa1 = phi double [ %96, %15 ]
  %.lcssa = phi i64 [ %97, %15 ]
  %100 = trunc i64 %.lcssa to i32
  br label %101

101:                                              ; preds = %99, %12
  %102 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %99 ]
  %103 = phi i32 [ 0, %12 ], [ %100, %99 ]
  %104 = icmp slt i32 %103, %1
  br i1 %104, label %105, label %121

105:                                              ; preds = %101
  %106 = zext i32 %103 to i64
  br label %107

107:                                              ; preds = %107, %105
  %108 = phi i64 [ %106, %105 ], [ %119, %107 ]
  %109 = phi double [ %102, %105 ], [ %118, %107 ]
  %110 = getelementptr inbounds double, ptr %0, i64 %108
  %111 = load double, ptr %110, align 8, !tbaa !17
  %112 = fadd double %111, 1.234500e+04
  %113 = tail call double @llvm.fmuladd.f64(double %112, double 9.142370e+05, double -1.300000e+01)
  %114 = fadd double %113, 1.234500e+04
  %115 = tail call double @llvm.fmuladd.f64(double %114, double 9.142370e+05, double -1.300000e+01)
  %116 = fadd double %115, 1.234500e+04
  %117 = tail call double @llvm.fmuladd.f64(double %116, double 9.142370e+05, double -1.300000e+01)
  %118 = fadd double %109, %117
  %119 = add nuw nsw i64 %108, 1
  %120 = icmp eq i64 %119, %11
  br i1 %120, label %121, label %107, !llvm.loop !143

121:                                              ; preds = %107, %101
  %122 = phi double [ %102, %101 ], [ %118, %107 ]
  %123 = load double, ptr @init_value, align 8, !tbaa !17
  %124 = fadd double %123, 1.234500e+04
  %125 = tail call double @llvm.fmuladd.f64(double %124, double 9.142370e+05, double -1.300000e+01)
  %126 = fadd double %125, 1.234500e+04
  %127 = tail call double @llvm.fmuladd.f64(double %126, double 9.142370e+05, double -1.300000e+01)
  %128 = fadd double %127, 1.234500e+04
  %129 = tail call double @llvm.fmuladd.f64(double %128, double 9.142370e+05, double -1.300000e+01)
  %130 = fmul double %129, 8.000000e+03
  %131 = fsub double %122, %130
  %132 = tail call double @llvm.fabs.f64(double %122)
  %133 = fcmp ogt double %132, 1.000000e-08
  %134 = select i1 %133, double %122, double 1.000000e+00
  %135 = fdiv double %131, %134
  %136 = tail call double @llvm.fabs.f64(double %135)
  %137 = fcmp olt double %136, 0x3EB0C6F7A0B5ED8D
  br i1 %137, label %142, label %138

138:                                              ; preds = %121
  %139 = load i32, ptr @current_test, align 4, !tbaa !11
  %140 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %139) #12
  %141 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %142

142:                                              ; preds = %138, %121
  %143 = phi i32 [ %13, %121 ], [ %141, %138 ]
  %144 = add nuw nsw i32 %14, 1
  %145 = icmp slt i32 %144, %143
  br i1 %145, label %12, label %146, !llvm.loop !144

146:                                              ; preds = %142, %3
  %147 = tail call i64 @clock() #15
  store i64 %147, ptr @end_time, align 8, !tbaa !23
  %148 = load i64, ptr @start_time, align 8, !tbaa !23
  %149 = sub nsw i64 %147, %148
  %150 = sitofp i64 %149 to double
  %151 = fdiv double %150, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %151, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi9EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %156

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 8
  %9 = add nsw i32 %1, -8
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %152, %7
  %13 = phi i32 [ %5, %7 ], [ %153, %152 ]
  %14 = phi i32 [ 0, %7 ], [ %154, %152 ]
  br i1 %8, label %15, label %111

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %107, %15 ], [ 0, %12 ]
  %17 = phi double [ %106, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = add nuw nsw i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = add nuw nsw i64 %16, 2
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !17
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %36, %45
  %47 = add nuw nsw i64 %16, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !17
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %46, %55
  %57 = add nuw nsw i64 %16, 4
  %58 = getelementptr inbounds double, ptr %0, i64 %57
  %59 = load double, ptr %58, align 8, !tbaa !17
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %56, %65
  %67 = add nuw nsw i64 %16, 5
  %68 = getelementptr inbounds double, ptr %0, i64 %67
  %69 = load double, ptr %68, align 8, !tbaa !17
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %66, %75
  %77 = add nuw nsw i64 %16, 6
  %78 = getelementptr inbounds double, ptr %0, i64 %77
  %79 = load double, ptr %78, align 8, !tbaa !17
  %80 = fadd double %79, 1.234500e+04
  %81 = tail call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %83, 1.234500e+04
  %85 = tail call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %76, %85
  %87 = add nuw nsw i64 %16, 7
  %88 = getelementptr inbounds double, ptr %0, i64 %87
  %89 = load double, ptr %88, align 8, !tbaa !17
  %90 = fadd double %89, 1.234500e+04
  %91 = tail call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %91, 1.234500e+04
  %93 = tail call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %93, 1.234500e+04
  %95 = tail call double @llvm.fmuladd.f64(double %94, double 9.142370e+05, double -1.300000e+01)
  %96 = fadd double %86, %95
  %97 = add nuw nsw i64 %16, 8
  %98 = getelementptr inbounds double, ptr %0, i64 %97
  %99 = load double, ptr %98, align 8, !tbaa !17
  %100 = fadd double %99, 1.234500e+04
  %101 = tail call double @llvm.fmuladd.f64(double %100, double 9.142370e+05, double -1.300000e+01)
  %102 = fadd double %101, 1.234500e+04
  %103 = tail call double @llvm.fmuladd.f64(double %102, double 9.142370e+05, double -1.300000e+01)
  %104 = fadd double %103, 1.234500e+04
  %105 = tail call double @llvm.fmuladd.f64(double %104, double 9.142370e+05, double -1.300000e+01)
  %106 = fadd double %96, %105
  %107 = add nuw nsw i64 %16, 9
  %108 = icmp slt i64 %107, %10
  br i1 %108, label %15, label %109, !llvm.loop !145

109:                                              ; preds = %15
  %.lcssa1 = phi double [ %106, %15 ]
  %.lcssa = phi i64 [ %107, %15 ]
  %110 = trunc i64 %.lcssa to i32
  br label %111

111:                                              ; preds = %109, %12
  %112 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %109 ]
  %113 = phi i32 [ 0, %12 ], [ %110, %109 ]
  %114 = icmp slt i32 %113, %1
  br i1 %114, label %115, label %131

115:                                              ; preds = %111
  %116 = zext i32 %113 to i64
  br label %117

117:                                              ; preds = %117, %115
  %118 = phi i64 [ %116, %115 ], [ %129, %117 ]
  %119 = phi double [ %112, %115 ], [ %128, %117 ]
  %120 = getelementptr inbounds double, ptr %0, i64 %118
  %121 = load double, ptr %120, align 8, !tbaa !17
  %122 = fadd double %121, 1.234500e+04
  %123 = tail call double @llvm.fmuladd.f64(double %122, double 9.142370e+05, double -1.300000e+01)
  %124 = fadd double %123, 1.234500e+04
  %125 = tail call double @llvm.fmuladd.f64(double %124, double 9.142370e+05, double -1.300000e+01)
  %126 = fadd double %125, 1.234500e+04
  %127 = tail call double @llvm.fmuladd.f64(double %126, double 9.142370e+05, double -1.300000e+01)
  %128 = fadd double %119, %127
  %129 = add nuw nsw i64 %118, 1
  %130 = icmp eq i64 %129, %11
  br i1 %130, label %131, label %117, !llvm.loop !146

131:                                              ; preds = %117, %111
  %132 = phi double [ %112, %111 ], [ %128, %117 ]
  %133 = load double, ptr @init_value, align 8, !tbaa !17
  %134 = fadd double %133, 1.234500e+04
  %135 = tail call double @llvm.fmuladd.f64(double %134, double 9.142370e+05, double -1.300000e+01)
  %136 = fadd double %135, 1.234500e+04
  %137 = tail call double @llvm.fmuladd.f64(double %136, double 9.142370e+05, double -1.300000e+01)
  %138 = fadd double %137, 1.234500e+04
  %139 = tail call double @llvm.fmuladd.f64(double %138, double 9.142370e+05, double -1.300000e+01)
  %140 = fmul double %139, 8.000000e+03
  %141 = fsub double %132, %140
  %142 = tail call double @llvm.fabs.f64(double %132)
  %143 = fcmp ogt double %142, 1.000000e-08
  %144 = select i1 %143, double %132, double 1.000000e+00
  %145 = fdiv double %141, %144
  %146 = tail call double @llvm.fabs.f64(double %145)
  %147 = fcmp olt double %146, 0x3EB0C6F7A0B5ED8D
  br i1 %147, label %152, label %148

148:                                              ; preds = %131
  %149 = load i32, ptr @current_test, align 4, !tbaa !11
  %150 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %149) #12
  %151 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %152

152:                                              ; preds = %148, %131
  %153 = phi i32 [ %13, %131 ], [ %151, %148 ]
  %154 = add nuw nsw i32 %14, 1
  %155 = icmp slt i32 %154, %153
  br i1 %155, label %12, label %156, !llvm.loop !147

156:                                              ; preds = %152, %3
  %157 = tail call i64 @clock() #15
  store i64 %157, ptr @end_time, align 8, !tbaa !23
  %158 = load i64, ptr @start_time, align 8, !tbaa !23
  %159 = sub nsw i64 %157, %158
  %160 = sitofp i64 %159 to double
  %161 = fdiv double %160, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %161, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi5EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi3EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi4EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 3)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi5EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 4)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi6EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %126

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 5
  %9 = add nsw i32 %1, -5
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %122, %7
  %13 = phi i32 [ %5, %7 ], [ %123, %122 ]
  %14 = phi i32 [ 0, %7 ], [ %124, %122 ]
  br i1 %8, label %15, label %81

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %77, %15 ], [ 0, %12 ]
  %17 = phi double [ %76, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = or i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = add nuw nsw i64 %16, 2
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !17
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %36, %45
  %47 = add nuw nsw i64 %16, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !17
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %46, %55
  %57 = add nuw nsw i64 %16, 4
  %58 = getelementptr inbounds double, ptr %0, i64 %57
  %59 = load double, ptr %58, align 8, !tbaa !17
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %56, %65
  %67 = add nuw nsw i64 %16, 5
  %68 = getelementptr inbounds double, ptr %0, i64 %67
  %69 = load double, ptr %68, align 8, !tbaa !17
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %66, %75
  %77 = add nuw nsw i64 %16, 6
  %78 = icmp slt i64 %77, %10
  br i1 %78, label %15, label %79, !llvm.loop !148

79:                                               ; preds = %15
  %.lcssa1 = phi double [ %76, %15 ]
  %.lcssa = phi i64 [ %77, %15 ]
  %80 = trunc i64 %.lcssa to i32
  br label %81

81:                                               ; preds = %79, %12
  %82 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %79 ]
  %83 = phi i32 [ 0, %12 ], [ %80, %79 ]
  %84 = icmp slt i32 %83, %1
  br i1 %84, label %85, label %101

85:                                               ; preds = %81
  %86 = zext i32 %83 to i64
  br label %87

87:                                               ; preds = %87, %85
  %88 = phi i64 [ %86, %85 ], [ %99, %87 ]
  %89 = phi double [ %82, %85 ], [ %98, %87 ]
  %90 = getelementptr inbounds double, ptr %0, i64 %88
  %91 = load double, ptr %90, align 8, !tbaa !17
  %92 = fadd double %91, 1.234500e+04
  %93 = tail call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %93, 1.234500e+04
  %95 = tail call double @llvm.fmuladd.f64(double %94, double 9.142370e+05, double -1.300000e+01)
  %96 = fadd double %95, 1.234500e+04
  %97 = tail call double @llvm.fmuladd.f64(double %96, double 9.142370e+05, double -1.300000e+01)
  %98 = fadd double %89, %97
  %99 = add nuw nsw i64 %88, 1
  %100 = icmp eq i64 %99, %11
  br i1 %100, label %101, label %87, !llvm.loop !149

101:                                              ; preds = %87, %81
  %102 = phi double [ %82, %81 ], [ %98, %87 ]
  %103 = load double, ptr @init_value, align 8, !tbaa !17
  %104 = fadd double %103, 1.234500e+04
  %105 = tail call double @llvm.fmuladd.f64(double %104, double 9.142370e+05, double -1.300000e+01)
  %106 = fadd double %105, 1.234500e+04
  %107 = tail call double @llvm.fmuladd.f64(double %106, double 9.142370e+05, double -1.300000e+01)
  %108 = fadd double %107, 1.234500e+04
  %109 = tail call double @llvm.fmuladd.f64(double %108, double 9.142370e+05, double -1.300000e+01)
  %110 = fmul double %109, 8.000000e+03
  %111 = fsub double %102, %110
  %112 = tail call double @llvm.fabs.f64(double %102)
  %113 = fcmp ogt double %112, 1.000000e-08
  %114 = select i1 %113, double %102, double 1.000000e+00
  %115 = fdiv double %111, %114
  %116 = tail call double @llvm.fabs.f64(double %115)
  %117 = fcmp olt double %116, 0x3EB0C6F7A0B5ED8D
  br i1 %117, label %122, label %118

118:                                              ; preds = %101
  %119 = load i32, ptr @current_test, align 4, !tbaa !11
  %120 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %119) #12
  %121 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %122

122:                                              ; preds = %118, %101
  %123 = phi i32 [ %13, %101 ], [ %121, %118 ]
  %124 = add nuw nsw i32 %14, 1
  %125 = icmp slt i32 %124, %123
  br i1 %125, label %12, label %126, !llvm.loop !150

126:                                              ; preds = %122, %3
  %127 = tail call i64 @clock() #15
  store i64 %127, ptr @end_time, align 8, !tbaa !23
  %128 = load i64, ptr @start_time, align 8, !tbaa !23
  %129 = sub nsw i64 %127, %128
  %130 = sitofp i64 %129 to double
  %131 = fdiv double %130, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %131, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi7EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %136

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 6
  %9 = add nsw i32 %1, -6
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %132, %7
  %13 = phi i32 [ %5, %7 ], [ %133, %132 ]
  %14 = phi i32 [ 0, %7 ], [ %134, %132 ]
  br i1 %8, label %15, label %91

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %87, %15 ], [ 0, %12 ]
  %17 = phi double [ %86, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = add nuw nsw i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = add nuw nsw i64 %16, 2
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !17
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %36, %45
  %47 = add nuw nsw i64 %16, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !17
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %46, %55
  %57 = add nuw nsw i64 %16, 4
  %58 = getelementptr inbounds double, ptr %0, i64 %57
  %59 = load double, ptr %58, align 8, !tbaa !17
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %56, %65
  %67 = add nuw nsw i64 %16, 5
  %68 = getelementptr inbounds double, ptr %0, i64 %67
  %69 = load double, ptr %68, align 8, !tbaa !17
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %66, %75
  %77 = add nuw nsw i64 %16, 6
  %78 = getelementptr inbounds double, ptr %0, i64 %77
  %79 = load double, ptr %78, align 8, !tbaa !17
  %80 = fadd double %79, 1.234500e+04
  %81 = tail call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %83, 1.234500e+04
  %85 = tail call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %76, %85
  %87 = add nuw nsw i64 %16, 7
  %88 = icmp slt i64 %87, %10
  br i1 %88, label %15, label %89, !llvm.loop !151

89:                                               ; preds = %15
  %.lcssa1 = phi double [ %86, %15 ]
  %.lcssa = phi i64 [ %87, %15 ]
  %90 = trunc i64 %.lcssa to i32
  br label %91

91:                                               ; preds = %89, %12
  %92 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %89 ]
  %93 = phi i32 [ 0, %12 ], [ %90, %89 ]
  %94 = icmp slt i32 %93, %1
  br i1 %94, label %95, label %111

95:                                               ; preds = %91
  %96 = zext i32 %93 to i64
  br label %97

97:                                               ; preds = %97, %95
  %98 = phi i64 [ %96, %95 ], [ %109, %97 ]
  %99 = phi double [ %92, %95 ], [ %108, %97 ]
  %100 = getelementptr inbounds double, ptr %0, i64 %98
  %101 = load double, ptr %100, align 8, !tbaa !17
  %102 = fadd double %101, 1.234500e+04
  %103 = tail call double @llvm.fmuladd.f64(double %102, double 9.142370e+05, double -1.300000e+01)
  %104 = fadd double %103, 1.234500e+04
  %105 = tail call double @llvm.fmuladd.f64(double %104, double 9.142370e+05, double -1.300000e+01)
  %106 = fadd double %105, 1.234500e+04
  %107 = tail call double @llvm.fmuladd.f64(double %106, double 9.142370e+05, double -1.300000e+01)
  %108 = fadd double %99, %107
  %109 = add nuw nsw i64 %98, 1
  %110 = icmp eq i64 %109, %11
  br i1 %110, label %111, label %97, !llvm.loop !152

111:                                              ; preds = %97, %91
  %112 = phi double [ %92, %91 ], [ %108, %97 ]
  %113 = load double, ptr @init_value, align 8, !tbaa !17
  %114 = fadd double %113, 1.234500e+04
  %115 = tail call double @llvm.fmuladd.f64(double %114, double 9.142370e+05, double -1.300000e+01)
  %116 = fadd double %115, 1.234500e+04
  %117 = tail call double @llvm.fmuladd.f64(double %116, double 9.142370e+05, double -1.300000e+01)
  %118 = fadd double %117, 1.234500e+04
  %119 = tail call double @llvm.fmuladd.f64(double %118, double 9.142370e+05, double -1.300000e+01)
  %120 = fmul double %119, 8.000000e+03
  %121 = fsub double %112, %120
  %122 = tail call double @llvm.fabs.f64(double %112)
  %123 = fcmp ogt double %122, 1.000000e-08
  %124 = select i1 %123, double %112, double 1.000000e+00
  %125 = fdiv double %121, %124
  %126 = tail call double @llvm.fabs.f64(double %125)
  %127 = fcmp olt double %126, 0x3EB0C6F7A0B5ED8D
  br i1 %127, label %132, label %128

128:                                              ; preds = %111
  %129 = load i32, ptr @current_test, align 4, !tbaa !11
  %130 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %129) #12
  %131 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %132

132:                                              ; preds = %128, %111
  %133 = phi i32 [ %13, %111 ], [ %131, %128 ]
  %134 = add nuw nsw i32 %14, 1
  %135 = icmp slt i32 %134, %133
  br i1 %135, label %12, label %136, !llvm.loop !153

136:                                              ; preds = %132, %3
  %137 = tail call i64 @clock() #15
  store i64 %137, ptr @end_time, align 8, !tbaa !23
  %138 = load i64, ptr @start_time, align 8, !tbaa !23
  %139 = sub nsw i64 %137, %138
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %141, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi3EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_Z26test_do_loop_unroll_factorILi1EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull @temp_string) #12
  tail call void @_Z26test_do_loop_unroll_factorILi2EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 1)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi3EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 2)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi4EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %106

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 3
  %9 = add nsw i32 %1, -3
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %102, %7
  %13 = phi i32 [ %5, %7 ], [ %103, %102 ]
  %14 = phi i32 [ 0, %7 ], [ %104, %102 ]
  br i1 %8, label %15, label %61

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %57, %15 ], [ 0, %12 ]
  %17 = phi double [ %56, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = or i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = or i64 %16, 2
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !17
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %36, %45
  %47 = or i64 %16, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !17
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %46, %55
  %57 = add nuw nsw i64 %16, 4
  %58 = icmp slt i64 %57, %10
  br i1 %58, label %15, label %59, !llvm.loop !154

59:                                               ; preds = %15
  %.lcssa1 = phi double [ %56, %15 ]
  %.lcssa = phi i64 [ %57, %15 ]
  %60 = trunc i64 %.lcssa to i32
  br label %61

61:                                               ; preds = %59, %12
  %62 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %59 ]
  %63 = phi i32 [ 0, %12 ], [ %60, %59 ]
  %64 = icmp slt i32 %63, %1
  br i1 %64, label %65, label %81

65:                                               ; preds = %61
  %66 = zext i32 %63 to i64
  br label %67

67:                                               ; preds = %67, %65
  %68 = phi i64 [ %66, %65 ], [ %79, %67 ]
  %69 = phi double [ %62, %65 ], [ %78, %67 ]
  %70 = getelementptr inbounds double, ptr %0, i64 %68
  %71 = load double, ptr %70, align 8, !tbaa !17
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %75, 1.234500e+04
  %77 = tail call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %69, %77
  %79 = add nuw nsw i64 %68, 1
  %80 = icmp eq i64 %79, %11
  br i1 %80, label %81, label %67, !llvm.loop !155

81:                                               ; preds = %67, %61
  %82 = phi double [ %62, %61 ], [ %78, %67 ]
  %83 = load double, ptr @init_value, align 8, !tbaa !17
  %84 = fadd double %83, 1.234500e+04
  %85 = tail call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %85, 1.234500e+04
  %87 = tail call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %87, 1.234500e+04
  %89 = tail call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fmul double %89, 8.000000e+03
  %91 = fsub double %82, %90
  %92 = tail call double @llvm.fabs.f64(double %82)
  %93 = fcmp ogt double %92, 1.000000e-08
  %94 = select i1 %93, double %82, double 1.000000e+00
  %95 = fdiv double %91, %94
  %96 = tail call double @llvm.fabs.f64(double %95)
  %97 = fcmp olt double %96, 0x3EB0C6F7A0B5ED8D
  br i1 %97, label %102, label %98

98:                                               ; preds = %81
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %99) #12
  %101 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %102

102:                                              ; preds = %98, %81
  %103 = phi i32 [ %13, %81 ], [ %101, %98 ]
  %104 = add nuw nsw i32 %14, 1
  %105 = icmp slt i32 %104, %103
  br i1 %105, label %12, label %106, !llvm.loop !156

106:                                              ; preds = %102, %3
  %107 = tail call i64 @clock() #15
  store i64 %107, ptr @end_time, align 8, !tbaa !23
  %108 = load i64, ptr @start_time, align 8, !tbaa !23
  %109 = sub nsw i64 %107, %108
  %110 = sitofp i64 %109 to double
  %111 = fdiv double %110, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %111, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi5EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %116

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 4
  %9 = add nsw i32 %1, -4
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %112, %7
  %13 = phi i32 [ %5, %7 ], [ %113, %112 ]
  %14 = phi i32 [ 0, %7 ], [ %114, %112 ]
  br i1 %8, label %15, label %71

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %67, %15 ], [ 0, %12 ]
  %17 = phi double [ %66, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = add nuw nsw i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = add nuw nsw i64 %16, 2
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !17
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %36, %45
  %47 = add nuw nsw i64 %16, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !17
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %46, %55
  %57 = add nuw nsw i64 %16, 4
  %58 = getelementptr inbounds double, ptr %0, i64 %57
  %59 = load double, ptr %58, align 8, !tbaa !17
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %56, %65
  %67 = add nuw nsw i64 %16, 5
  %68 = icmp slt i64 %67, %10
  br i1 %68, label %15, label %69, !llvm.loop !157

69:                                               ; preds = %15
  %.lcssa1 = phi double [ %66, %15 ]
  %.lcssa = phi i64 [ %67, %15 ]
  %70 = trunc i64 %.lcssa to i32
  br label %71

71:                                               ; preds = %69, %12
  %72 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %69 ]
  %73 = phi i32 [ 0, %12 ], [ %70, %69 ]
  %74 = icmp slt i32 %73, %1
  br i1 %74, label %75, label %91

75:                                               ; preds = %71
  %76 = zext i32 %73 to i64
  br label %77

77:                                               ; preds = %77, %75
  %78 = phi i64 [ %76, %75 ], [ %89, %77 ]
  %79 = phi double [ %72, %75 ], [ %88, %77 ]
  %80 = getelementptr inbounds double, ptr %0, i64 %78
  %81 = load double, ptr %80, align 8, !tbaa !17
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %83, 1.234500e+04
  %85 = tail call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %85, 1.234500e+04
  %87 = tail call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %79, %87
  %89 = add nuw nsw i64 %78, 1
  %90 = icmp eq i64 %89, %11
  br i1 %90, label %91, label %77, !llvm.loop !158

91:                                               ; preds = %77, %71
  %92 = phi double [ %72, %71 ], [ %88, %77 ]
  %93 = load double, ptr @init_value, align 8, !tbaa !17
  %94 = fadd double %93, 1.234500e+04
  %95 = tail call double @llvm.fmuladd.f64(double %94, double 9.142370e+05, double -1.300000e+01)
  %96 = fadd double %95, 1.234500e+04
  %97 = tail call double @llvm.fmuladd.f64(double %96, double 9.142370e+05, double -1.300000e+01)
  %98 = fadd double %97, 1.234500e+04
  %99 = tail call double @llvm.fmuladd.f64(double %98, double 9.142370e+05, double -1.300000e+01)
  %100 = fmul double %99, 8.000000e+03
  %101 = fsub double %92, %100
  %102 = tail call double @llvm.fabs.f64(double %92)
  %103 = fcmp ogt double %102, 1.000000e-08
  %104 = select i1 %103, double %92, double 1.000000e+00
  %105 = fdiv double %101, %104
  %106 = tail call double @llvm.fabs.f64(double %105)
  %107 = fcmp olt double %106, 0x3EB0C6F7A0B5ED8D
  br i1 %107, label %112, label %108

108:                                              ; preds = %91
  %109 = load i32, ptr @current_test, align 4, !tbaa !11
  %110 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %109) #12
  %111 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %112

112:                                              ; preds = %108, %91
  %113 = phi i32 [ %13, %91 ], [ %111, %108 ]
  %114 = add nuw nsw i32 %14, 1
  %115 = icmp slt i32 %114, %113
  br i1 %115, label %12, label %116, !llvm.loop !159

116:                                              ; preds = %112, %3
  %117 = tail call i64 @clock() #15
  store i64 %117, ptr @end_time, align 8, !tbaa !23
  %118 = load i64, ptr @start_time, align 8, !tbaa !23
  %119 = sub nsw i64 %117, %118
  %120 = sitofp i64 %119 to double
  %121 = fdiv double %120, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %121, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi1EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %52

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 0
  %9 = zext i32 %1 to i64
  br label %10

10:                                               ; preds = %48, %7
  %11 = phi i32 [ %5, %7 ], [ %49, %48 ]
  %12 = phi i32 [ 0, %7 ], [ %50, %48 ]
  br i1 %8, label %13, label %27

13:                                               ; preds = %13, %10
  %14 = phi i64 [ %25, %13 ], [ 0, %10 ]
  %15 = phi double [ %24, %13 ], [ 0.000000e+00, %10 ]
  %16 = getelementptr inbounds double, ptr %0, i64 %14
  %17 = load double, ptr %16, align 8, !tbaa !17
  %18 = fadd double %17, 1.234500e+04
  %19 = tail call double @llvm.fmuladd.f64(double %18, double 9.142370e+05, double -1.300000e+01)
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %15, %23
  %25 = add nuw nsw i64 %14, 1
  %26 = icmp eq i64 %25, %9
  br i1 %26, label %27, label %13, !llvm.loop !160

27:                                               ; preds = %13, %10
  %28 = phi double [ 0.000000e+00, %10 ], [ %24, %13 ]
  %29 = load double, ptr @init_value, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fmul double %35, 8.000000e+03
  %37 = fsub double %28, %36
  %38 = tail call double @llvm.fabs.f64(double %28)
  %39 = fcmp ogt double %38, 1.000000e-08
  %40 = select i1 %39, double %28, double 1.000000e+00
  %41 = fdiv double %37, %40
  %42 = tail call double @llvm.fabs.f64(double %41)
  %43 = fcmp olt double %42, 0x3EB0C6F7A0B5ED8D
  br i1 %43, label %48, label %44

44:                                               ; preds = %27
  %45 = load i32, ptr @current_test, align 4, !tbaa !11
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %45) #12
  %47 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %48

48:                                               ; preds = %44, %27
  %49 = phi i32 [ %11, %27 ], [ %47, %44 ]
  %50 = add nuw nsw i32 %12, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %10, label %52, !llvm.loop !161

52:                                               ; preds = %48, %3
  %53 = tail call i64 @clock() #15
  store i64 %53, ptr @end_time, align 8, !tbaa !23
  %54 = load i64, ptr @start_time, align 8, !tbaa !23
  %55 = sub nsw i64 %53, %54
  %56 = sitofp i64 %55 to double
  %57 = fdiv double %56, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %57, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi2EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %86

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 1
  %9 = add nsw i32 %1, -1
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %82, %7
  %13 = phi i32 [ %5, %7 ], [ %83, %82 ]
  %14 = phi i32 [ 0, %7 ], [ %84, %82 ]
  br i1 %8, label %15, label %41

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %37, %15 ], [ 0, %12 ]
  %17 = phi double [ %36, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = or i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = add nuw nsw i64 %16, 2
  %38 = icmp slt i64 %37, %10
  br i1 %38, label %15, label %39, !llvm.loop !162

39:                                               ; preds = %15
  %.lcssa1 = phi double [ %36, %15 ]
  %.lcssa = phi i64 [ %37, %15 ]
  %40 = trunc i64 %.lcssa to i32
  br label %41

41:                                               ; preds = %39, %12
  %42 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %39 ]
  %43 = phi i32 [ 0, %12 ], [ %40, %39 ]
  %44 = icmp slt i32 %43, %1
  br i1 %44, label %45, label %61

45:                                               ; preds = %41
  %46 = zext i32 %43 to i64
  br label %47

47:                                               ; preds = %47, %45
  %48 = phi i64 [ %46, %45 ], [ %59, %47 ]
  %49 = phi double [ %42, %45 ], [ %58, %47 ]
  %50 = getelementptr inbounds double, ptr %0, i64 %48
  %51 = load double, ptr %50, align 8, !tbaa !17
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %55, 1.234500e+04
  %57 = tail call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %49, %57
  %59 = add nuw nsw i64 %48, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %47, !llvm.loop !163

61:                                               ; preds = %47, %41
  %62 = phi double [ %42, %41 ], [ %58, %47 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !17
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %65, 1.234500e+04
  %67 = tail call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fmul double %69, 8.000000e+03
  %71 = fsub double %62, %70
  %72 = tail call double @llvm.fabs.f64(double %62)
  %73 = fcmp ogt double %72, 1.000000e-08
  %74 = select i1 %73, double %62, double 1.000000e+00
  %75 = fdiv double %71, %74
  %76 = tail call double @llvm.fabs.f64(double %75)
  %77 = fcmp olt double %76, 0x3EB0C6F7A0B5ED8D
  br i1 %77, label %82, label %78

78:                                               ; preds = %61
  %79 = load i32, ptr @current_test, align 4, !tbaa !11
  %80 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %79) #12
  %81 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %82

82:                                               ; preds = %78, %61
  %83 = phi i32 [ %13, %61 ], [ %81, %78 ]
  %84 = add nuw nsw i32 %14, 1
  %85 = icmp slt i32 %84, %83
  br i1 %85, label %12, label %86, !llvm.loop !164

86:                                               ; preds = %82, %3
  %87 = tail call i64 @clock() #15
  store i64 %87, ptr @end_time, align 8, !tbaa !23
  %88 = load i64, ptr @start_time, align 8, !tbaa !23
  %89 = sub nsw i64 %87, %88
  %90 = sitofp i64 %89 to double
  %91 = fdiv double %90, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %91, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi3EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %96

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 2
  %9 = add nsw i32 %1, -2
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %92, %7
  %13 = phi i32 [ %5, %7 ], [ %93, %92 ]
  %14 = phi i32 [ 0, %7 ], [ %94, %92 ]
  br i1 %8, label %15, label %51

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %47, %15 ], [ 0, %12 ]
  %17 = phi double [ %46, %15 ], [ 0.000000e+00, %12 ]
  %18 = getelementptr inbounds double, ptr %0, i64 %16
  %19 = load double, ptr %18, align 8, !tbaa !17
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %23, 1.234500e+04
  %25 = tail call double @llvm.fmuladd.f64(double %24, double 9.142370e+05, double -1.300000e+01)
  %26 = fadd double %17, %25
  %27 = add nuw nsw i64 %16, 1
  %28 = getelementptr inbounds double, ptr %0, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %26, %35
  %37 = add nuw nsw i64 %16, 2
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !17
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %43, 1.234500e+04
  %45 = tail call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %36, %45
  %47 = add nuw nsw i64 %16, 3
  %48 = icmp slt i64 %47, %10
  br i1 %48, label %15, label %49, !llvm.loop !165

49:                                               ; preds = %15
  %.lcssa1 = phi double [ %46, %15 ]
  %.lcssa = phi i64 [ %47, %15 ]
  %50 = trunc i64 %.lcssa to i32
  br label %51

51:                                               ; preds = %49, %12
  %52 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %49 ]
  %53 = phi i32 [ 0, %12 ], [ %50, %49 ]
  %54 = icmp slt i32 %53, %1
  br i1 %54, label %55, label %71

55:                                               ; preds = %51
  %56 = zext i32 %53 to i64
  br label %57

57:                                               ; preds = %57, %55
  %58 = phi i64 [ %56, %55 ], [ %69, %57 ]
  %59 = phi double [ %52, %55 ], [ %68, %57 ]
  %60 = getelementptr inbounds double, ptr %0, i64 %58
  %61 = load double, ptr %60, align 8, !tbaa !17
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %65, 1.234500e+04
  %67 = tail call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %59, %67
  %69 = add nuw nsw i64 %58, 1
  %70 = icmp eq i64 %69, %11
  br i1 %70, label %71, label %57, !llvm.loop !166

71:                                               ; preds = %57, %51
  %72 = phi double [ %52, %51 ], [ %68, %57 ]
  %73 = load double, ptr @init_value, align 8, !tbaa !17
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %75, 1.234500e+04
  %77 = tail call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %77, 1.234500e+04
  %79 = tail call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fmul double %79, 8.000000e+03
  %81 = fsub double %72, %80
  %82 = tail call double @llvm.fabs.f64(double %72)
  %83 = fcmp ogt double %82, 1.000000e-08
  %84 = select i1 %83, double %72, double 1.000000e+00
  %85 = fdiv double %81, %84
  %86 = tail call double @llvm.fabs.f64(double %85)
  %87 = fcmp olt double %86, 0x3EB0C6F7A0B5ED8D
  br i1 %87, label %92, label %88

88:                                               ; preds = %71
  %89 = load i32, ptr @current_test, align 4, !tbaa !11
  %90 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %89) #12
  %91 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %92

92:                                               ; preds = %88, %71
  %93 = phi i32 [ %13, %71 ], [ %91, %88 ]
  %94 = add nuw nsw i32 %14, 1
  %95 = icmp slt i32 %94, %93
  br i1 %95, label %12, label %96, !llvm.loop !167

96:                                               ; preds = %92, %3
  %97 = tail call i64 @clock() #15
  store i64 %97, ptr @end_time, align 8, !tbaa !23
  %98 = load i64, ptr @start_time, align 8, !tbaa !23
  %99 = sub nsw i64 %97, %98
  %100 = sitofp i64 %99 to double
  %101 = fdiv double %100, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %101, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi29EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi27EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi28EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 27)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi29EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 28)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi30EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -29
  %10 = icmp sgt i32 %1, 29
  br label %11

11:                                               ; preds = %82, %8
  %12 = phi i32 [ 0, %8 ], [ %83, %82 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %42, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %44, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %62

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %46

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %43, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 28
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 29
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  store double %42, ptr %4, align 8, !tbaa !17
  %43 = add nuw i64 %20, 30
  %44 = trunc i64 %43 to i32
  %45 = icmp sgt i32 %9, %44
  br i1 %45, label %19, label %13, !llvm.loop !168

46:                                               ; preds = %46, %17
  %47 = phi i64 [ %18, %17 ], [ %58, %46 ]
  %48 = phi double [ %14, %17 ], [ %57, %46 ]
  %49 = getelementptr inbounds double, ptr %0, i64 %47
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %48, %56
  %58 = add nuw nsw i64 %47, 1
  %59 = trunc i64 %58 to i32
  %60 = icmp slt i32 %59, %1
  br i1 %60, label %46, label %61, !llvm.loop !169

61:                                               ; preds = %46
  %.lcssa = phi double [ %57, %46 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %62

62:                                               ; preds = %61, %13
  %63 = phi double [ %.lcssa, %61 ], [ %14, %13 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !17
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %66, 1.234500e+04
  %68 = call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fmul double %70, 8.000000e+03
  %72 = fsub double %63, %71
  %73 = call double @llvm.fabs.f64(double %63)
  %74 = fcmp ogt double %73, 1.000000e-08
  %75 = select i1 %74, double %63, double 1.000000e+00
  %76 = fdiv double %72, %75
  %77 = call double @llvm.fabs.f64(double %76)
  %78 = fcmp olt double %77, 0x3EB0C6F7A0B5ED8D
  br i1 %78, label %82, label %79

79:                                               ; preds = %62
  %80 = load i32, ptr @current_test, align 4, !tbaa !11
  %81 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %80) #12
  br label %82

82:                                               ; preds = %79, %62
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %83 = add nuw nsw i32 %12, 1
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  %85 = icmp slt i32 %83, %84
  br i1 %85, label %11, label %86, !llvm.loop !170

86:                                               ; preds = %82, %3
  %87 = call i64 @clock() #15
  store i64 %87, ptr @end_time, align 8, !tbaa !23
  %88 = load i64, ptr @start_time, align 8, !tbaa !23
  %89 = sub nsw i64 %87, %88
  %90 = sitofp i64 %89 to double
  %91 = fdiv double %90, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %91, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi31EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %96

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -30
  %10 = icmp sgt i32 %1, 30
  br label %11

11:                                               ; preds = %92, %8
  %12 = phi i32 [ 0, %8 ], [ %93, %92 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %52, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %54, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %72

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %56

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %53, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 28
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 29
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = add nuw nsw i64 %20, 30
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  store double %52, ptr %4, align 8, !tbaa !17
  %53 = add nuw i64 %20, 31
  %54 = trunc i64 %53 to i32
  %55 = icmp sgt i32 %9, %54
  br i1 %55, label %19, label %13, !llvm.loop !171

56:                                               ; preds = %56, %17
  %57 = phi i64 [ %18, %17 ], [ %68, %56 ]
  %58 = phi double [ %14, %17 ], [ %67, %56 ]
  %59 = getelementptr inbounds double, ptr %0, i64 %57
  %60 = load double, ptr %59, align 8, !tbaa !17
  %61 = fadd double %60, 1.234500e+04
  %62 = call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %58, %66
  %68 = add nuw nsw i64 %57, 1
  %69 = trunc i64 %68 to i32
  %70 = icmp slt i32 %69, %1
  br i1 %70, label %56, label %71, !llvm.loop !172

71:                                               ; preds = %56
  %.lcssa = phi double [ %67, %56 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %72

72:                                               ; preds = %71, %13
  %73 = phi double [ %.lcssa, %71 ], [ %14, %13 ]
  %74 = load double, ptr @init_value, align 8, !tbaa !17
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %76, 1.234500e+04
  %78 = call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fmul double %80, 8.000000e+03
  %82 = fsub double %73, %81
  %83 = call double @llvm.fabs.f64(double %73)
  %84 = fcmp ogt double %83, 1.000000e-08
  %85 = select i1 %84, double %73, double 1.000000e+00
  %86 = fdiv double %82, %85
  %87 = call double @llvm.fabs.f64(double %86)
  %88 = fcmp olt double %87, 0x3EB0C6F7A0B5ED8D
  br i1 %88, label %92, label %89

89:                                               ; preds = %72
  %90 = load i32, ptr @current_test, align 4, !tbaa !11
  %91 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %90) #12
  br label %92

92:                                               ; preds = %89, %72
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %93 = add nuw nsw i32 %12, 1
  %94 = load i32, ptr @iterations, align 4, !tbaa !11
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %11, label %96, !llvm.loop !173

96:                                               ; preds = %92, %3
  %97 = call i64 @clock() #15
  store i64 %97, ptr @end_time, align 8, !tbaa !23
  %98 = load i64, ptr @start_time, align 8, !tbaa !23
  %99 = sub nsw i64 %97, %98
  %100 = sitofp i64 %99 to double
  %101 = fdiv double %100, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %101, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi27EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi25EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi26EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 25)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi27EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 26)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi28EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %65

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -27
  %10 = icmp sgt i32 %1, 27
  br label %11

11:                                               ; preds = %61, %8
  %12 = phi i32 [ 0, %8 ], [ %62, %61 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %21, label %15

13:                                               ; preds = %21
  %.lcssa = phi i32 [ %23, %21 ]
  %14 = load double, ptr %4, align 8, !tbaa !17
  br label %15

15:                                               ; preds = %13, %11
  %16 = phi double [ 0.000000e+00, %11 ], [ %14, %13 ]
  %17 = phi i32 [ 0, %11 ], [ %.lcssa, %13 ]
  %18 = icmp slt i32 %17, %1
  br i1 %18, label %19, label %41

19:                                               ; preds = %15
  %20 = zext i32 %17 to i64
  br label %25

21:                                               ; preds = %21, %11
  %22 = phi i32 [ %23, %21 ], [ 0, %11 ]
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %22) #12
  %23 = add nuw nsw i32 %22, 28
  %24 = icmp slt i32 %23, %9
  br i1 %24, label %21, label %13, !llvm.loop !174

25:                                               ; preds = %25, %19
  %26 = phi i64 [ %20, %19 ], [ %37, %25 ]
  %27 = phi double [ %16, %19 ], [ %36, %25 ]
  %28 = getelementptr inbounds double, ptr %0, i64 %26
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %27, %35
  %37 = add nuw nsw i64 %26, 1
  %38 = trunc i64 %37 to i32
  %39 = icmp eq i32 %38, %1
  br i1 %39, label %40, label %25, !llvm.loop !175

40:                                               ; preds = %25
  %.lcssa1 = phi double [ %36, %25 ]
  store double %.lcssa1, ptr %4, align 8, !tbaa !17
  br label %41

41:                                               ; preds = %40, %15
  %42 = phi double [ %.lcssa1, %40 ], [ %16, %15 ]
  %43 = load double, ptr @init_value, align 8, !tbaa !17
  %44 = fadd double %43, 1.234500e+04
  %45 = call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fmul double %49, 8.000000e+03
  %51 = fsub double %42, %50
  %52 = call double @llvm.fabs.f64(double %42)
  %53 = fcmp ogt double %52, 1.000000e-08
  %54 = select i1 %53, double %42, double 1.000000e+00
  %55 = fdiv double %51, %54
  %56 = call double @llvm.fabs.f64(double %55)
  %57 = fcmp olt double %56, 0x3EB0C6F7A0B5ED8D
  br i1 %57, label %61, label %58

58:                                               ; preds = %41
  %59 = load i32, ptr @current_test, align 4, !tbaa !11
  %60 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %59) #12
  br label %61

61:                                               ; preds = %58, %41
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %62 = add nuw nsw i32 %12, 1
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  %64 = icmp slt i32 %62, %63
  br i1 %64, label %11, label %65, !llvm.loop !176

65:                                               ; preds = %61, %3
  %66 = call i64 @clock() #15
  store i64 %66, ptr @end_time, align 8, !tbaa !23
  %67 = load i64, ptr @start_time, align 8, !tbaa !23
  %68 = sub nsw i64 %66, %67
  %69 = sitofp i64 %68 to double
  %70 = fdiv double %69, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %70, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi29EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %76

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -28
  %10 = icmp sgt i32 %1, 28
  br label %11

11:                                               ; preds = %72, %8
  %12 = phi i32 [ 0, %8 ], [ %73, %72 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %32, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %34, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %52

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %36

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %33, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 28
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  store double %32, ptr %4, align 8, !tbaa !17
  %33 = add nuw i64 %20, 29
  %34 = trunc i64 %33 to i32
  %35 = icmp sgt i32 %9, %34
  br i1 %35, label %19, label %13, !llvm.loop !177

36:                                               ; preds = %36, %17
  %37 = phi i64 [ %18, %17 ], [ %48, %36 ]
  %38 = phi double [ %14, %17 ], [ %47, %36 ]
  %39 = getelementptr inbounds double, ptr %0, i64 %37
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %38, %46
  %48 = add nuw nsw i64 %37, 1
  %49 = trunc i64 %48 to i32
  %50 = icmp slt i32 %49, %1
  br i1 %50, label %36, label %51, !llvm.loop !178

51:                                               ; preds = %36
  %.lcssa = phi double [ %47, %36 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %52

52:                                               ; preds = %51, %13
  %53 = phi double [ %.lcssa, %51 ], [ %14, %13 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %56, 1.234500e+04
  %58 = call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fmul double %60, 8.000000e+03
  %62 = fsub double %53, %61
  %63 = call double @llvm.fabs.f64(double %53)
  %64 = fcmp ogt double %63, 1.000000e-08
  %65 = select i1 %64, double %53, double 1.000000e+00
  %66 = fdiv double %62, %65
  %67 = call double @llvm.fabs.f64(double %66)
  %68 = fcmp olt double %67, 0x3EB0C6F7A0B5ED8D
  br i1 %68, label %72, label %69

69:                                               ; preds = %52
  %70 = load i32, ptr @current_test, align 4, !tbaa !11
  %71 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %70) #12
  br label %72

72:                                               ; preds = %69, %52
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %73 = add nuw nsw i32 %12, 1
  %74 = load i32, ptr @iterations, align 4, !tbaa !11
  %75 = icmp slt i32 %73, %74
  br i1 %75, label %11, label %76, !llvm.loop !179

76:                                               ; preds = %72, %3
  %77 = call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi25EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi23EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi24EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 23)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi25EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 24)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi26EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %136

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -25
  %10 = icmp sgt i32 %1, 25
  br label %11

11:                                               ; preds = %132, %8
  %12 = phi i32 [ 0, %8 ], [ %133, %132 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %92, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %94, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %112

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %96

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %93, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 20
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = add nuw nsw i64 %20, 21
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  %53 = add nuw nsw i64 %20, 22
  %54 = getelementptr inbounds double, ptr %0, i64 %53
  %55 = load double, ptr %54, align 8, !tbaa !17
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %57, 1.234500e+04
  %59 = call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %52, %61
  %63 = add nuw nsw i64 %20, 23
  %64 = getelementptr inbounds double, ptr %0, i64 %63
  %65 = load double, ptr %64, align 8, !tbaa !17
  %66 = fadd double %65, 1.234500e+04
  %67 = call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %67, 1.234500e+04
  %69 = call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %62, %71
  %73 = add nuw nsw i64 %20, 24
  %74 = getelementptr inbounds double, ptr %0, i64 %73
  %75 = load double, ptr %74, align 8, !tbaa !17
  %76 = fadd double %75, 1.234500e+04
  %77 = call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %77, 1.234500e+04
  %79 = call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fadd double %79, 1.234500e+04
  %81 = call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %72, %81
  %83 = add nuw nsw i64 %20, 25
  %84 = getelementptr inbounds double, ptr %0, i64 %83
  %85 = load double, ptr %84, align 8, !tbaa !17
  %86 = fadd double %85, 1.234500e+04
  %87 = call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %87, 1.234500e+04
  %89 = call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fadd double %89, 1.234500e+04
  %91 = call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %82, %91
  store double %92, ptr %4, align 8, !tbaa !17
  %93 = add nuw i64 %20, 26
  %94 = trunc i64 %93 to i32
  %95 = icmp sgt i32 %9, %94
  br i1 %95, label %19, label %13, !llvm.loop !180

96:                                               ; preds = %96, %17
  %97 = phi i64 [ %18, %17 ], [ %108, %96 ]
  %98 = phi double [ %14, %17 ], [ %107, %96 ]
  %99 = getelementptr inbounds double, ptr %0, i64 %97
  %100 = load double, ptr %99, align 8, !tbaa !17
  %101 = fadd double %100, 1.234500e+04
  %102 = call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %104, 1.234500e+04
  %106 = call double @llvm.fmuladd.f64(double %105, double 9.142370e+05, double -1.300000e+01)
  %107 = fadd double %98, %106
  %108 = add nuw nsw i64 %97, 1
  %109 = trunc i64 %108 to i32
  %110 = icmp slt i32 %109, %1
  br i1 %110, label %96, label %111, !llvm.loop !181

111:                                              ; preds = %96
  %.lcssa = phi double [ %107, %96 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %112

112:                                              ; preds = %111, %13
  %113 = phi double [ %.lcssa, %111 ], [ %14, %13 ]
  %114 = load double, ptr @init_value, align 8, !tbaa !17
  %115 = fadd double %114, 1.234500e+04
  %116 = call double @llvm.fmuladd.f64(double %115, double 9.142370e+05, double -1.300000e+01)
  %117 = fadd double %116, 1.234500e+04
  %118 = call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fmul double %120, 8.000000e+03
  %122 = fsub double %113, %121
  %123 = call double @llvm.fabs.f64(double %113)
  %124 = fcmp ogt double %123, 1.000000e-08
  %125 = select i1 %124, double %113, double 1.000000e+00
  %126 = fdiv double %122, %125
  %127 = call double @llvm.fabs.f64(double %126)
  %128 = fcmp olt double %127, 0x3EB0C6F7A0B5ED8D
  br i1 %128, label %132, label %129

129:                                              ; preds = %112
  %130 = load i32, ptr @current_test, align 4, !tbaa !11
  %131 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %130) #12
  br label %132

132:                                              ; preds = %129, %112
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %133 = add nuw nsw i32 %12, 1
  %134 = load i32, ptr @iterations, align 4, !tbaa !11
  %135 = icmp slt i32 %133, %134
  br i1 %135, label %11, label %136, !llvm.loop !182

136:                                              ; preds = %132, %3
  %137 = call i64 @clock() #15
  store i64 %137, ptr @end_time, align 8, !tbaa !23
  %138 = load i64, ptr @start_time, align 8, !tbaa !23
  %139 = sub nsw i64 %137, %138
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %141, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi27EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %146

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -26
  %10 = icmp sgt i32 %1, 26
  br label %11

11:                                               ; preds = %142, %8
  %12 = phi i32 [ 0, %8 ], [ %143, %142 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %102, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %104, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %122

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %106

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %103, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 20
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = add nuw nsw i64 %20, 21
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  %53 = add nuw nsw i64 %20, 22
  %54 = getelementptr inbounds double, ptr %0, i64 %53
  %55 = load double, ptr %54, align 8, !tbaa !17
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %57, 1.234500e+04
  %59 = call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %52, %61
  %63 = add nuw nsw i64 %20, 23
  %64 = getelementptr inbounds double, ptr %0, i64 %63
  %65 = load double, ptr %64, align 8, !tbaa !17
  %66 = fadd double %65, 1.234500e+04
  %67 = call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %67, 1.234500e+04
  %69 = call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %62, %71
  %73 = add nuw nsw i64 %20, 24
  %74 = getelementptr inbounds double, ptr %0, i64 %73
  %75 = load double, ptr %74, align 8, !tbaa !17
  %76 = fadd double %75, 1.234500e+04
  %77 = call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %77, 1.234500e+04
  %79 = call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fadd double %79, 1.234500e+04
  %81 = call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %72, %81
  %83 = add nuw nsw i64 %20, 25
  %84 = getelementptr inbounds double, ptr %0, i64 %83
  %85 = load double, ptr %84, align 8, !tbaa !17
  %86 = fadd double %85, 1.234500e+04
  %87 = call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %87, 1.234500e+04
  %89 = call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fadd double %89, 1.234500e+04
  %91 = call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %82, %91
  %93 = add nuw nsw i64 %20, 26
  %94 = getelementptr inbounds double, ptr %0, i64 %93
  %95 = load double, ptr %94, align 8, !tbaa !17
  %96 = fadd double %95, 1.234500e+04
  %97 = call double @llvm.fmuladd.f64(double %96, double 9.142370e+05, double -1.300000e+01)
  %98 = fadd double %97, 1.234500e+04
  %99 = call double @llvm.fmuladd.f64(double %98, double 9.142370e+05, double -1.300000e+01)
  %100 = fadd double %99, 1.234500e+04
  %101 = call double @llvm.fmuladd.f64(double %100, double 9.142370e+05, double -1.300000e+01)
  %102 = fadd double %92, %101
  store double %102, ptr %4, align 8, !tbaa !17
  %103 = add nuw i64 %20, 27
  %104 = trunc i64 %103 to i32
  %105 = icmp sgt i32 %9, %104
  br i1 %105, label %19, label %13, !llvm.loop !183

106:                                              ; preds = %106, %17
  %107 = phi i64 [ %18, %17 ], [ %118, %106 ]
  %108 = phi double [ %14, %17 ], [ %117, %106 ]
  %109 = getelementptr inbounds double, ptr %0, i64 %107
  %110 = load double, ptr %109, align 8, !tbaa !17
  %111 = fadd double %110, 1.234500e+04
  %112 = call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %114, 1.234500e+04
  %116 = call double @llvm.fmuladd.f64(double %115, double 9.142370e+05, double -1.300000e+01)
  %117 = fadd double %108, %116
  %118 = add nuw nsw i64 %107, 1
  %119 = trunc i64 %118 to i32
  %120 = icmp slt i32 %119, %1
  br i1 %120, label %106, label %121, !llvm.loop !184

121:                                              ; preds = %106
  %.lcssa = phi double [ %117, %106 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %122

122:                                              ; preds = %121, %13
  %123 = phi double [ %.lcssa, %121 ], [ %14, %13 ]
  %124 = load double, ptr @init_value, align 8, !tbaa !17
  %125 = fadd double %124, 1.234500e+04
  %126 = call double @llvm.fmuladd.f64(double %125, double 9.142370e+05, double -1.300000e+01)
  %127 = fadd double %126, 1.234500e+04
  %128 = call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fmul double %130, 8.000000e+03
  %132 = fsub double %123, %131
  %133 = call double @llvm.fabs.f64(double %123)
  %134 = fcmp ogt double %133, 1.000000e-08
  %135 = select i1 %134, double %123, double 1.000000e+00
  %136 = fdiv double %132, %135
  %137 = call double @llvm.fabs.f64(double %136)
  %138 = fcmp olt double %137, 0x3EB0C6F7A0B5ED8D
  br i1 %138, label %142, label %139

139:                                              ; preds = %122
  %140 = load i32, ptr @current_test, align 4, !tbaa !11
  %141 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %140) #12
  br label %142

142:                                              ; preds = %139, %122
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %143 = add nuw nsw i32 %12, 1
  %144 = load i32, ptr @iterations, align 4, !tbaa !11
  %145 = icmp slt i32 %143, %144
  br i1 %145, label %11, label %146, !llvm.loop !185

146:                                              ; preds = %142, %3
  %147 = call i64 @clock() #15
  store i64 %147, ptr @end_time, align 8, !tbaa !23
  %148 = load i64, ptr @start_time, align 8, !tbaa !23
  %149 = sub nsw i64 %147, %148
  %150 = sitofp i64 %149 to double
  %151 = fdiv double %150, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %151, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi23EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi21EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi22EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 21)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi23EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 22)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi24EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %116

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -23
  %10 = icmp sgt i32 %1, 23
  br label %11

11:                                               ; preds = %112, %8
  %12 = phi i32 [ 0, %8 ], [ %113, %112 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %72, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %74, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %92

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %76

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %73, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 20
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = add nuw nsw i64 %20, 21
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  %53 = add nuw nsw i64 %20, 22
  %54 = getelementptr inbounds double, ptr %0, i64 %53
  %55 = load double, ptr %54, align 8, !tbaa !17
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %57, 1.234500e+04
  %59 = call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %52, %61
  %63 = add nuw nsw i64 %20, 23
  %64 = getelementptr inbounds double, ptr %0, i64 %63
  %65 = load double, ptr %64, align 8, !tbaa !17
  %66 = fadd double %65, 1.234500e+04
  %67 = call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %67, 1.234500e+04
  %69 = call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %62, %71
  store double %72, ptr %4, align 8, !tbaa !17
  %73 = add nuw i64 %20, 24
  %74 = trunc i64 %73 to i32
  %75 = icmp sgt i32 %9, %74
  br i1 %75, label %19, label %13, !llvm.loop !186

76:                                               ; preds = %76, %17
  %77 = phi i64 [ %18, %17 ], [ %88, %76 ]
  %78 = phi double [ %14, %17 ], [ %87, %76 ]
  %79 = getelementptr inbounds double, ptr %0, i64 %77
  %80 = load double, ptr %79, align 8, !tbaa !17
  %81 = fadd double %80, 1.234500e+04
  %82 = call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %84, 1.234500e+04
  %86 = call double @llvm.fmuladd.f64(double %85, double 9.142370e+05, double -1.300000e+01)
  %87 = fadd double %78, %86
  %88 = add nuw nsw i64 %77, 1
  %89 = trunc i64 %88 to i32
  %90 = icmp slt i32 %89, %1
  br i1 %90, label %76, label %91, !llvm.loop !187

91:                                               ; preds = %76
  %.lcssa = phi double [ %87, %76 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %92

92:                                               ; preds = %91, %13
  %93 = phi double [ %.lcssa, %91 ], [ %14, %13 ]
  %94 = load double, ptr @init_value, align 8, !tbaa !17
  %95 = fadd double %94, 1.234500e+04
  %96 = call double @llvm.fmuladd.f64(double %95, double 9.142370e+05, double -1.300000e+01)
  %97 = fadd double %96, 1.234500e+04
  %98 = call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fmul double %100, 8.000000e+03
  %102 = fsub double %93, %101
  %103 = call double @llvm.fabs.f64(double %93)
  %104 = fcmp ogt double %103, 1.000000e-08
  %105 = select i1 %104, double %93, double 1.000000e+00
  %106 = fdiv double %102, %105
  %107 = call double @llvm.fabs.f64(double %106)
  %108 = fcmp olt double %107, 0x3EB0C6F7A0B5ED8D
  br i1 %108, label %112, label %109

109:                                              ; preds = %92
  %110 = load i32, ptr @current_test, align 4, !tbaa !11
  %111 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %110) #12
  br label %112

112:                                              ; preds = %109, %92
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %113 = add nuw nsw i32 %12, 1
  %114 = load i32, ptr @iterations, align 4, !tbaa !11
  %115 = icmp slt i32 %113, %114
  br i1 %115, label %11, label %116, !llvm.loop !188

116:                                              ; preds = %112, %3
  %117 = call i64 @clock() #15
  store i64 %117, ptr @end_time, align 8, !tbaa !23
  %118 = load i64, ptr @start_time, align 8, !tbaa !23
  %119 = sub nsw i64 %117, %118
  %120 = sitofp i64 %119 to double
  %121 = fdiv double %120, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %121, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi25EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %126

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -24
  %10 = icmp sgt i32 %1, 24
  br label %11

11:                                               ; preds = %122, %8
  %12 = phi i32 [ 0, %8 ], [ %123, %122 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %82, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %84, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %102

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %86

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %83, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 20
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = add nuw nsw i64 %20, 21
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  %53 = add nuw nsw i64 %20, 22
  %54 = getelementptr inbounds double, ptr %0, i64 %53
  %55 = load double, ptr %54, align 8, !tbaa !17
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %57, 1.234500e+04
  %59 = call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %52, %61
  %63 = add nuw nsw i64 %20, 23
  %64 = getelementptr inbounds double, ptr %0, i64 %63
  %65 = load double, ptr %64, align 8, !tbaa !17
  %66 = fadd double %65, 1.234500e+04
  %67 = call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %67, 1.234500e+04
  %69 = call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %62, %71
  %73 = add nuw nsw i64 %20, 24
  %74 = getelementptr inbounds double, ptr %0, i64 %73
  %75 = load double, ptr %74, align 8, !tbaa !17
  %76 = fadd double %75, 1.234500e+04
  %77 = call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %77, 1.234500e+04
  %79 = call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fadd double %79, 1.234500e+04
  %81 = call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %72, %81
  store double %82, ptr %4, align 8, !tbaa !17
  %83 = add nuw i64 %20, 25
  %84 = trunc i64 %83 to i32
  %85 = icmp sgt i32 %9, %84
  br i1 %85, label %19, label %13, !llvm.loop !189

86:                                               ; preds = %86, %17
  %87 = phi i64 [ %18, %17 ], [ %98, %86 ]
  %88 = phi double [ %14, %17 ], [ %97, %86 ]
  %89 = getelementptr inbounds double, ptr %0, i64 %87
  %90 = load double, ptr %89, align 8, !tbaa !17
  %91 = fadd double %90, 1.234500e+04
  %92 = call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %94, 1.234500e+04
  %96 = call double @llvm.fmuladd.f64(double %95, double 9.142370e+05, double -1.300000e+01)
  %97 = fadd double %88, %96
  %98 = add nuw nsw i64 %87, 1
  %99 = trunc i64 %98 to i32
  %100 = icmp slt i32 %99, %1
  br i1 %100, label %86, label %101, !llvm.loop !190

101:                                              ; preds = %86
  %.lcssa = phi double [ %97, %86 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %102

102:                                              ; preds = %101, %13
  %103 = phi double [ %.lcssa, %101 ], [ %14, %13 ]
  %104 = load double, ptr @init_value, align 8, !tbaa !17
  %105 = fadd double %104, 1.234500e+04
  %106 = call double @llvm.fmuladd.f64(double %105, double 9.142370e+05, double -1.300000e+01)
  %107 = fadd double %106, 1.234500e+04
  %108 = call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fmul double %110, 8.000000e+03
  %112 = fsub double %103, %111
  %113 = call double @llvm.fabs.f64(double %103)
  %114 = fcmp ogt double %113, 1.000000e-08
  %115 = select i1 %114, double %103, double 1.000000e+00
  %116 = fdiv double %112, %115
  %117 = call double @llvm.fabs.f64(double %116)
  %118 = fcmp olt double %117, 0x3EB0C6F7A0B5ED8D
  br i1 %118, label %122, label %119

119:                                              ; preds = %102
  %120 = load i32, ptr @current_test, align 4, !tbaa !11
  %121 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %120) #12
  br label %122

122:                                              ; preds = %119, %102
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %123 = add nuw nsw i32 %12, 1
  %124 = load i32, ptr @iterations, align 4, !tbaa !11
  %125 = icmp slt i32 %123, %124
  br i1 %125, label %11, label %126, !llvm.loop !191

126:                                              ; preds = %122, %3
  %127 = call i64 @clock() #15
  store i64 %127, ptr @end_time, align 8, !tbaa !23
  %128 = load i64, ptr @start_time, align 8, !tbaa !23
  %129 = sub nsw i64 %127, %128
  %130 = sitofp i64 %129 to double
  %131 = fdiv double %130, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %131, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi21EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi19EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi20EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 19)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi21EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 20)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi22EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %96

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -21
  %10 = icmp sgt i32 %1, 21
  br label %11

11:                                               ; preds = %92, %8
  %12 = phi i32 [ 0, %8 ], [ %93, %92 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %52, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %54, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %72

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %56

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %53, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 20
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = add nuw nsw i64 %20, 21
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  store double %52, ptr %4, align 8, !tbaa !17
  %53 = add nuw i64 %20, 22
  %54 = trunc i64 %53 to i32
  %55 = icmp sgt i32 %9, %54
  br i1 %55, label %19, label %13, !llvm.loop !192

56:                                               ; preds = %56, %17
  %57 = phi i64 [ %18, %17 ], [ %68, %56 ]
  %58 = phi double [ %14, %17 ], [ %67, %56 ]
  %59 = getelementptr inbounds double, ptr %0, i64 %57
  %60 = load double, ptr %59, align 8, !tbaa !17
  %61 = fadd double %60, 1.234500e+04
  %62 = call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %58, %66
  %68 = add nuw nsw i64 %57, 1
  %69 = trunc i64 %68 to i32
  %70 = icmp slt i32 %69, %1
  br i1 %70, label %56, label %71, !llvm.loop !193

71:                                               ; preds = %56
  %.lcssa = phi double [ %67, %56 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %72

72:                                               ; preds = %71, %13
  %73 = phi double [ %.lcssa, %71 ], [ %14, %13 ]
  %74 = load double, ptr @init_value, align 8, !tbaa !17
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %76, 1.234500e+04
  %78 = call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fmul double %80, 8.000000e+03
  %82 = fsub double %73, %81
  %83 = call double @llvm.fabs.f64(double %73)
  %84 = fcmp ogt double %83, 1.000000e-08
  %85 = select i1 %84, double %73, double 1.000000e+00
  %86 = fdiv double %82, %85
  %87 = call double @llvm.fabs.f64(double %86)
  %88 = fcmp olt double %87, 0x3EB0C6F7A0B5ED8D
  br i1 %88, label %92, label %89

89:                                               ; preds = %72
  %90 = load i32, ptr @current_test, align 4, !tbaa !11
  %91 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %90) #12
  br label %92

92:                                               ; preds = %89, %72
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %93 = add nuw nsw i32 %12, 1
  %94 = load i32, ptr @iterations, align 4, !tbaa !11
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %11, label %96, !llvm.loop !194

96:                                               ; preds = %92, %3
  %97 = call i64 @clock() #15
  store i64 %97, ptr @end_time, align 8, !tbaa !23
  %98 = load i64, ptr @start_time, align 8, !tbaa !23
  %99 = sub nsw i64 %97, %98
  %100 = sitofp i64 %99 to double
  %101 = fdiv double %100, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %101, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi23EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %106

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -22
  %10 = icmp sgt i32 %1, 22
  br label %11

11:                                               ; preds = %102, %8
  %12 = phi i32 [ 0, %8 ], [ %103, %102 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %62, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %64, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %82

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %66

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %63, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 20
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = add nuw nsw i64 %20, 21
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  %53 = add nuw nsw i64 %20, 22
  %54 = getelementptr inbounds double, ptr %0, i64 %53
  %55 = load double, ptr %54, align 8, !tbaa !17
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %57, 1.234500e+04
  %59 = call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %52, %61
  store double %62, ptr %4, align 8, !tbaa !17
  %63 = add nuw i64 %20, 23
  %64 = trunc i64 %63 to i32
  %65 = icmp sgt i32 %9, %64
  br i1 %65, label %19, label %13, !llvm.loop !195

66:                                               ; preds = %66, %17
  %67 = phi i64 [ %18, %17 ], [ %78, %66 ]
  %68 = phi double [ %14, %17 ], [ %77, %66 ]
  %69 = getelementptr inbounds double, ptr %0, i64 %67
  %70 = load double, ptr %69, align 8, !tbaa !17
  %71 = fadd double %70, 1.234500e+04
  %72 = call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %68, %76
  %78 = add nuw nsw i64 %67, 1
  %79 = trunc i64 %78 to i32
  %80 = icmp slt i32 %79, %1
  br i1 %80, label %66, label %81, !llvm.loop !196

81:                                               ; preds = %66
  %.lcssa = phi double [ %77, %66 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %82

82:                                               ; preds = %81, %13
  %83 = phi double [ %.lcssa, %81 ], [ %14, %13 ]
  %84 = load double, ptr @init_value, align 8, !tbaa !17
  %85 = fadd double %84, 1.234500e+04
  %86 = call double @llvm.fmuladd.f64(double %85, double 9.142370e+05, double -1.300000e+01)
  %87 = fadd double %86, 1.234500e+04
  %88 = call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fmul double %90, 8.000000e+03
  %92 = fsub double %83, %91
  %93 = call double @llvm.fabs.f64(double %83)
  %94 = fcmp ogt double %93, 1.000000e-08
  %95 = select i1 %94, double %83, double 1.000000e+00
  %96 = fdiv double %92, %95
  %97 = call double @llvm.fabs.f64(double %96)
  %98 = fcmp olt double %97, 0x3EB0C6F7A0B5ED8D
  br i1 %98, label %102, label %99

99:                                               ; preds = %82
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  %101 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %100) #12
  br label %102

102:                                              ; preds = %99, %82
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %103 = add nuw nsw i32 %12, 1
  %104 = load i32, ptr @iterations, align 4, !tbaa !11
  %105 = icmp slt i32 %103, %104
  br i1 %105, label %11, label %106, !llvm.loop !197

106:                                              ; preds = %102, %3
  %107 = call i64 @clock() #15
  store i64 %107, ptr @end_time, align 8, !tbaa !23
  %108 = load i64, ptr @start_time, align 8, !tbaa !23
  %109 = sub nsw i64 %107, %108
  %110 = sitofp i64 %109 to double
  %111 = fdiv double %110, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %111, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi19EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi17EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi18EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 17)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi19EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 18)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi20EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %76

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -19
  %10 = icmp sgt i32 %1, 19
  br label %11

11:                                               ; preds = %72, %8
  %12 = phi i32 [ 0, %8 ], [ %73, %72 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %32, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %34, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %52

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %36

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %33, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  store double %32, ptr %4, align 8, !tbaa !17
  %33 = add nuw i64 %20, 20
  %34 = trunc i64 %33 to i32
  %35 = icmp sgt i32 %9, %34
  br i1 %35, label %19, label %13, !llvm.loop !198

36:                                               ; preds = %36, %17
  %37 = phi i64 [ %18, %17 ], [ %48, %36 ]
  %38 = phi double [ %14, %17 ], [ %47, %36 ]
  %39 = getelementptr inbounds double, ptr %0, i64 %37
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %38, %46
  %48 = add nuw nsw i64 %37, 1
  %49 = trunc i64 %48 to i32
  %50 = icmp slt i32 %49, %1
  br i1 %50, label %36, label %51, !llvm.loop !199

51:                                               ; preds = %36
  %.lcssa = phi double [ %47, %36 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %52

52:                                               ; preds = %51, %13
  %53 = phi double [ %.lcssa, %51 ], [ %14, %13 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %56, 1.234500e+04
  %58 = call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fmul double %60, 8.000000e+03
  %62 = fsub double %53, %61
  %63 = call double @llvm.fabs.f64(double %53)
  %64 = fcmp ogt double %63, 1.000000e-08
  %65 = select i1 %64, double %53, double 1.000000e+00
  %66 = fdiv double %62, %65
  %67 = call double @llvm.fabs.f64(double %66)
  %68 = fcmp olt double %67, 0x3EB0C6F7A0B5ED8D
  br i1 %68, label %72, label %69

69:                                               ; preds = %52
  %70 = load i32, ptr @current_test, align 4, !tbaa !11
  %71 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %70) #12
  br label %72

72:                                               ; preds = %69, %52
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %73 = add nuw nsw i32 %12, 1
  %74 = load i32, ptr @iterations, align 4, !tbaa !11
  %75 = icmp slt i32 %73, %74
  br i1 %75, label %11, label %76, !llvm.loop !200

76:                                               ; preds = %72, %3
  %77 = call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi21EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -20
  %10 = icmp sgt i32 %1, 20
  br label %11

11:                                               ; preds = %82, %8
  %12 = phi i32 [ 0, %8 ], [ %83, %82 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %42, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %44, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %62

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %46

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %43, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 20
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  store double %42, ptr %4, align 8, !tbaa !17
  %43 = add nuw i64 %20, 21
  %44 = trunc i64 %43 to i32
  %45 = icmp sgt i32 %9, %44
  br i1 %45, label %19, label %13, !llvm.loop !201

46:                                               ; preds = %46, %17
  %47 = phi i64 [ %18, %17 ], [ %58, %46 ]
  %48 = phi double [ %14, %17 ], [ %57, %46 ]
  %49 = getelementptr inbounds double, ptr %0, i64 %47
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %48, %56
  %58 = add nuw nsw i64 %47, 1
  %59 = trunc i64 %58 to i32
  %60 = icmp slt i32 %59, %1
  br i1 %60, label %46, label %61, !llvm.loop !202

61:                                               ; preds = %46
  %.lcssa = phi double [ %57, %46 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %62

62:                                               ; preds = %61, %13
  %63 = phi double [ %.lcssa, %61 ], [ %14, %13 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !17
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %66, 1.234500e+04
  %68 = call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fmul double %70, 8.000000e+03
  %72 = fsub double %63, %71
  %73 = call double @llvm.fabs.f64(double %63)
  %74 = fcmp ogt double %73, 1.000000e-08
  %75 = select i1 %74, double %63, double 1.000000e+00
  %76 = fdiv double %72, %75
  %77 = call double @llvm.fabs.f64(double %76)
  %78 = fcmp olt double %77, 0x3EB0C6F7A0B5ED8D
  br i1 %78, label %82, label %79

79:                                               ; preds = %62
  %80 = load i32, ptr @current_test, align 4, !tbaa !11
  %81 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %80) #12
  br label %82

82:                                               ; preds = %79, %62
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %83 = add nuw nsw i32 %12, 1
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  %85 = icmp slt i32 %83, %84
  br i1 %85, label %11, label %86, !llvm.loop !203

86:                                               ; preds = %82, %3
  %87 = call i64 @clock() #15
  store i64 %87, ptr @end_time, align 8, !tbaa !23
  %88 = load i64, ptr @start_time, align 8, !tbaa !23
  %89 = sub nsw i64 %87, %88
  %90 = sitofp i64 %89 to double
  %91 = fdiv double %90, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %91, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi17EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi15EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi16EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 15)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi17EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 16)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi18EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %244

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -17
  %9 = icmp sgt i32 %1, 17
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %240, %7
  %13 = phi i32 [ 0, %7 ], [ %241, %240 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %203, %22 ]
  %.lcssa = phi i64 [ %204, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %220

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %206

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %204, %22 ], [ 0, %12 ]
  %24 = phi double [ %203, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = or i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = add nuw nsw i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = add nuw nsw i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = add nuw nsw i64 %23, 11
  %135 = getelementptr inbounds double, ptr %0, i64 %134
  %136 = load double, ptr %135, align 8, !tbaa !17
  %137 = fadd double %136, 1.234500e+04
  %138 = tail call double @llvm.fmuladd.f64(double %137, double 9.142370e+05, double -1.300000e+01)
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %133, %142
  %144 = add nuw nsw i64 %23, 12
  %145 = getelementptr inbounds double, ptr %0, i64 %144
  %146 = load double, ptr %145, align 8, !tbaa !17
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %143, %152
  %154 = add nuw nsw i64 %23, 13
  %155 = getelementptr inbounds double, ptr %0, i64 %154
  %156 = load double, ptr %155, align 8, !tbaa !17
  %157 = fadd double %156, 1.234500e+04
  %158 = tail call double @llvm.fmuladd.f64(double %157, double 9.142370e+05, double -1.300000e+01)
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %153, %162
  %164 = add nuw nsw i64 %23, 14
  %165 = getelementptr inbounds double, ptr %0, i64 %164
  %166 = load double, ptr %165, align 8, !tbaa !17
  %167 = fadd double %166, 1.234500e+04
  %168 = tail call double @llvm.fmuladd.f64(double %167, double 9.142370e+05, double -1.300000e+01)
  %169 = fadd double %168, 1.234500e+04
  %170 = tail call double @llvm.fmuladd.f64(double %169, double 9.142370e+05, double -1.300000e+01)
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %163, %172
  %174 = add nuw nsw i64 %23, 15
  %175 = getelementptr inbounds double, ptr %0, i64 %174
  %176 = load double, ptr %175, align 8, !tbaa !17
  %177 = fadd double %176, 1.234500e+04
  %178 = tail call double @llvm.fmuladd.f64(double %177, double 9.142370e+05, double -1.300000e+01)
  %179 = fadd double %178, 1.234500e+04
  %180 = tail call double @llvm.fmuladd.f64(double %179, double 9.142370e+05, double -1.300000e+01)
  %181 = fadd double %180, 1.234500e+04
  %182 = tail call double @llvm.fmuladd.f64(double %181, double 9.142370e+05, double -1.300000e+01)
  %183 = fadd double %173, %182
  %184 = add nuw nsw i64 %23, 16
  %185 = getelementptr inbounds double, ptr %0, i64 %184
  %186 = load double, ptr %185, align 8, !tbaa !17
  %187 = fadd double %186, 1.234500e+04
  %188 = tail call double @llvm.fmuladd.f64(double %187, double 9.142370e+05, double -1.300000e+01)
  %189 = fadd double %188, 1.234500e+04
  %190 = tail call double @llvm.fmuladd.f64(double %189, double 9.142370e+05, double -1.300000e+01)
  %191 = fadd double %190, 1.234500e+04
  %192 = tail call double @llvm.fmuladd.f64(double %191, double 9.142370e+05, double -1.300000e+01)
  %193 = fadd double %183, %192
  %194 = add nuw nsw i64 %23, 17
  %195 = getelementptr inbounds double, ptr %0, i64 %194
  %196 = load double, ptr %195, align 8, !tbaa !17
  %197 = fadd double %196, 1.234500e+04
  %198 = tail call double @llvm.fmuladd.f64(double %197, double 9.142370e+05, double -1.300000e+01)
  %199 = fadd double %198, 1.234500e+04
  %200 = tail call double @llvm.fmuladd.f64(double %199, double 9.142370e+05, double -1.300000e+01)
  %201 = fadd double %200, 1.234500e+04
  %202 = tail call double @llvm.fmuladd.f64(double %201, double 9.142370e+05, double -1.300000e+01)
  %203 = fadd double %193, %202
  %204 = add nuw nsw i64 %23, 18
  %205 = icmp slt i64 %204, %10
  br i1 %205, label %22, label %14, !llvm.loop !204

206:                                              ; preds = %206, %20
  %207 = phi i64 [ %21, %20 ], [ %218, %206 ]
  %208 = phi double [ %17, %20 ], [ %217, %206 ]
  %209 = getelementptr inbounds double, ptr %0, i64 %207
  %210 = load double, ptr %209, align 8, !tbaa !17
  %211 = fadd double %210, 1.234500e+04
  %212 = tail call double @llvm.fmuladd.f64(double %211, double 9.142370e+05, double -1.300000e+01)
  %213 = fadd double %212, 1.234500e+04
  %214 = tail call double @llvm.fmuladd.f64(double %213, double 9.142370e+05, double -1.300000e+01)
  %215 = fadd double %214, 1.234500e+04
  %216 = tail call double @llvm.fmuladd.f64(double %215, double 9.142370e+05, double -1.300000e+01)
  %217 = fadd double %208, %216
  %218 = add nuw nsw i64 %207, 1
  %219 = icmp eq i64 %218, %11
  br i1 %219, label %220, label %206, !llvm.loop !205

220:                                              ; preds = %206, %16
  %221 = phi double [ %17, %16 ], [ %217, %206 ]
  %222 = load double, ptr @init_value, align 8, !tbaa !17
  %223 = fadd double %222, 1.234500e+04
  %224 = tail call double @llvm.fmuladd.f64(double %223, double 9.142370e+05, double -1.300000e+01)
  %225 = fadd double %224, 1.234500e+04
  %226 = tail call double @llvm.fmuladd.f64(double %225, double 9.142370e+05, double -1.300000e+01)
  %227 = fadd double %226, 1.234500e+04
  %228 = tail call double @llvm.fmuladd.f64(double %227, double 9.142370e+05, double -1.300000e+01)
  %229 = fmul double %228, 8.000000e+03
  %230 = fsub double %221, %229
  %231 = tail call double @llvm.fabs.f64(double %221)
  %232 = fcmp ogt double %231, 1.000000e-08
  %233 = select i1 %232, double %221, double 1.000000e+00
  %234 = fdiv double %230, %233
  %235 = tail call double @llvm.fabs.f64(double %234)
  %236 = fcmp olt double %235, 0x3EB0C6F7A0B5ED8D
  br i1 %236, label %240, label %237

237:                                              ; preds = %220
  %238 = load i32, ptr @current_test, align 4, !tbaa !11
  %239 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %238) #12
  br label %240

240:                                              ; preds = %237, %220
  %241 = add nuw nsw i32 %13, 1
  %242 = load i32, ptr @iterations, align 4, !tbaa !11
  %243 = icmp slt i32 %241, %242
  br i1 %243, label %12, label %244, !llvm.loop !206

244:                                              ; preds = %240, %3
  %245 = tail call i64 @clock() #15
  store i64 %245, ptr @end_time, align 8, !tbaa !23
  %246 = load i64, ptr @start_time, align 8, !tbaa !23
  %247 = sub nsw i64 %245, %246
  %248 = sitofp i64 %247 to double
  %249 = fdiv double %248, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %249, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi19EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %65

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -18
  %10 = icmp sgt i32 %1, 18
  br label %11

11:                                               ; preds = %61, %8
  %12 = phi i32 [ 0, %8 ], [ %62, %61 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %21, label %15

13:                                               ; preds = %21
  %.lcssa = phi i32 [ %23, %21 ]
  %14 = load double, ptr %4, align 8, !tbaa !17
  br label %15

15:                                               ; preds = %13, %11
  %16 = phi double [ 0.000000e+00, %11 ], [ %14, %13 ]
  %17 = phi i32 [ 0, %11 ], [ %.lcssa, %13 ]
  %18 = icmp slt i32 %17, %1
  br i1 %18, label %19, label %41

19:                                               ; preds = %15
  %20 = zext i32 %17 to i64
  br label %25

21:                                               ; preds = %21, %11
  %22 = phi i32 [ %23, %21 ], [ 0, %11 ]
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %22) #12
  %23 = add nuw nsw i32 %22, 19
  %24 = icmp slt i32 %23, %9
  br i1 %24, label %21, label %13, !llvm.loop !207

25:                                               ; preds = %25, %19
  %26 = phi i64 [ %20, %19 ], [ %37, %25 ]
  %27 = phi double [ %16, %19 ], [ %36, %25 ]
  %28 = getelementptr inbounds double, ptr %0, i64 %26
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %27, %35
  %37 = add nuw nsw i64 %26, 1
  %38 = trunc i64 %37 to i32
  %39 = icmp eq i32 %38, %1
  br i1 %39, label %40, label %25, !llvm.loop !208

40:                                               ; preds = %25
  %.lcssa1 = phi double [ %36, %25 ]
  store double %.lcssa1, ptr %4, align 8, !tbaa !17
  br label %41

41:                                               ; preds = %40, %15
  %42 = phi double [ %.lcssa1, %40 ], [ %16, %15 ]
  %43 = load double, ptr @init_value, align 8, !tbaa !17
  %44 = fadd double %43, 1.234500e+04
  %45 = call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fmul double %49, 8.000000e+03
  %51 = fsub double %42, %50
  %52 = call double @llvm.fabs.f64(double %42)
  %53 = fcmp ogt double %52, 1.000000e-08
  %54 = select i1 %53, double %42, double 1.000000e+00
  %55 = fdiv double %51, %54
  %56 = call double @llvm.fabs.f64(double %55)
  %57 = fcmp olt double %56, 0x3EB0C6F7A0B5ED8D
  br i1 %57, label %61, label %58

58:                                               ; preds = %41
  %59 = load i32, ptr @current_test, align 4, !tbaa !11
  %60 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %59) #12
  br label %61

61:                                               ; preds = %58, %41
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %62 = add nuw nsw i32 %12, 1
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  %64 = icmp slt i32 %62, %63
  br i1 %64, label %11, label %65, !llvm.loop !209

65:                                               ; preds = %61, %3
  %66 = call i64 @clock() #15
  store i64 %66, ptr @end_time, align 8, !tbaa !23
  %67 = load i64, ptr @start_time, align 8, !tbaa !23
  %68 = sub nsw i64 %66, %67
  %69 = sitofp i64 %68 to double
  %70 = fdiv double %69, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %70, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi15EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi13EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi14EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 13)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi15EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 14)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi16EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %224

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -15
  %9 = icmp sgt i32 %1, 15
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %220, %7
  %13 = phi i32 [ 0, %7 ], [ %221, %220 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %183, %22 ]
  %.lcssa = phi i64 [ %184, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %200

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %186

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %184, %22 ], [ 0, %12 ]
  %24 = phi double [ %183, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = or i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = or i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = or i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = or i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = or i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = or i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = or i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = or i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = or i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = or i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = or i64 %23, 11
  %135 = getelementptr inbounds double, ptr %0, i64 %134
  %136 = load double, ptr %135, align 8, !tbaa !17
  %137 = fadd double %136, 1.234500e+04
  %138 = tail call double @llvm.fmuladd.f64(double %137, double 9.142370e+05, double -1.300000e+01)
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %133, %142
  %144 = or i64 %23, 12
  %145 = getelementptr inbounds double, ptr %0, i64 %144
  %146 = load double, ptr %145, align 8, !tbaa !17
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %143, %152
  %154 = or i64 %23, 13
  %155 = getelementptr inbounds double, ptr %0, i64 %154
  %156 = load double, ptr %155, align 8, !tbaa !17
  %157 = fadd double %156, 1.234500e+04
  %158 = tail call double @llvm.fmuladd.f64(double %157, double 9.142370e+05, double -1.300000e+01)
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %153, %162
  %164 = or i64 %23, 14
  %165 = getelementptr inbounds double, ptr %0, i64 %164
  %166 = load double, ptr %165, align 8, !tbaa !17
  %167 = fadd double %166, 1.234500e+04
  %168 = tail call double @llvm.fmuladd.f64(double %167, double 9.142370e+05, double -1.300000e+01)
  %169 = fadd double %168, 1.234500e+04
  %170 = tail call double @llvm.fmuladd.f64(double %169, double 9.142370e+05, double -1.300000e+01)
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %163, %172
  %174 = or i64 %23, 15
  %175 = getelementptr inbounds double, ptr %0, i64 %174
  %176 = load double, ptr %175, align 8, !tbaa !17
  %177 = fadd double %176, 1.234500e+04
  %178 = tail call double @llvm.fmuladd.f64(double %177, double 9.142370e+05, double -1.300000e+01)
  %179 = fadd double %178, 1.234500e+04
  %180 = tail call double @llvm.fmuladd.f64(double %179, double 9.142370e+05, double -1.300000e+01)
  %181 = fadd double %180, 1.234500e+04
  %182 = tail call double @llvm.fmuladd.f64(double %181, double 9.142370e+05, double -1.300000e+01)
  %183 = fadd double %173, %182
  %184 = add nuw nsw i64 %23, 16
  %185 = icmp slt i64 %184, %10
  br i1 %185, label %22, label %14, !llvm.loop !210

186:                                              ; preds = %186, %20
  %187 = phi i64 [ %21, %20 ], [ %198, %186 ]
  %188 = phi double [ %17, %20 ], [ %197, %186 ]
  %189 = getelementptr inbounds double, ptr %0, i64 %187
  %190 = load double, ptr %189, align 8, !tbaa !17
  %191 = fadd double %190, 1.234500e+04
  %192 = tail call double @llvm.fmuladd.f64(double %191, double 9.142370e+05, double -1.300000e+01)
  %193 = fadd double %192, 1.234500e+04
  %194 = tail call double @llvm.fmuladd.f64(double %193, double 9.142370e+05, double -1.300000e+01)
  %195 = fadd double %194, 1.234500e+04
  %196 = tail call double @llvm.fmuladd.f64(double %195, double 9.142370e+05, double -1.300000e+01)
  %197 = fadd double %188, %196
  %198 = add nuw nsw i64 %187, 1
  %199 = icmp eq i64 %198, %11
  br i1 %199, label %200, label %186, !llvm.loop !211

200:                                              ; preds = %186, %16
  %201 = phi double [ %17, %16 ], [ %197, %186 ]
  %202 = load double, ptr @init_value, align 8, !tbaa !17
  %203 = fadd double %202, 1.234500e+04
  %204 = tail call double @llvm.fmuladd.f64(double %203, double 9.142370e+05, double -1.300000e+01)
  %205 = fadd double %204, 1.234500e+04
  %206 = tail call double @llvm.fmuladd.f64(double %205, double 9.142370e+05, double -1.300000e+01)
  %207 = fadd double %206, 1.234500e+04
  %208 = tail call double @llvm.fmuladd.f64(double %207, double 9.142370e+05, double -1.300000e+01)
  %209 = fmul double %208, 8.000000e+03
  %210 = fsub double %201, %209
  %211 = tail call double @llvm.fabs.f64(double %201)
  %212 = fcmp ogt double %211, 1.000000e-08
  %213 = select i1 %212, double %201, double 1.000000e+00
  %214 = fdiv double %210, %213
  %215 = tail call double @llvm.fabs.f64(double %214)
  %216 = fcmp olt double %215, 0x3EB0C6F7A0B5ED8D
  br i1 %216, label %220, label %217

217:                                              ; preds = %200
  %218 = load i32, ptr @current_test, align 4, !tbaa !11
  %219 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %218) #12
  br label %220

220:                                              ; preds = %217, %200
  %221 = add nuw nsw i32 %13, 1
  %222 = load i32, ptr @iterations, align 4, !tbaa !11
  %223 = icmp slt i32 %221, %222
  br i1 %223, label %12, label %224, !llvm.loop !212

224:                                              ; preds = %220, %3
  %225 = tail call i64 @clock() #15
  store i64 %225, ptr @end_time, align 8, !tbaa !23
  %226 = load i64, ptr @start_time, align 8, !tbaa !23
  %227 = sub nsw i64 %225, %226
  %228 = sitofp i64 %227 to double
  %229 = fdiv double %228, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %229, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi17EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %234

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -16
  %9 = icmp sgt i32 %1, 16
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %230, %7
  %13 = phi i32 [ 0, %7 ], [ %231, %230 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %193, %22 ]
  %.lcssa = phi i64 [ %194, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %210

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %196

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %194, %22 ], [ 0, %12 ]
  %24 = phi double [ %193, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = add nuw nsw i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = add nuw nsw i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = add nuw nsw i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = add nuw nsw i64 %23, 11
  %135 = getelementptr inbounds double, ptr %0, i64 %134
  %136 = load double, ptr %135, align 8, !tbaa !17
  %137 = fadd double %136, 1.234500e+04
  %138 = tail call double @llvm.fmuladd.f64(double %137, double 9.142370e+05, double -1.300000e+01)
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %133, %142
  %144 = add nuw nsw i64 %23, 12
  %145 = getelementptr inbounds double, ptr %0, i64 %144
  %146 = load double, ptr %145, align 8, !tbaa !17
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %143, %152
  %154 = add nuw nsw i64 %23, 13
  %155 = getelementptr inbounds double, ptr %0, i64 %154
  %156 = load double, ptr %155, align 8, !tbaa !17
  %157 = fadd double %156, 1.234500e+04
  %158 = tail call double @llvm.fmuladd.f64(double %157, double 9.142370e+05, double -1.300000e+01)
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %153, %162
  %164 = add nuw nsw i64 %23, 14
  %165 = getelementptr inbounds double, ptr %0, i64 %164
  %166 = load double, ptr %165, align 8, !tbaa !17
  %167 = fadd double %166, 1.234500e+04
  %168 = tail call double @llvm.fmuladd.f64(double %167, double 9.142370e+05, double -1.300000e+01)
  %169 = fadd double %168, 1.234500e+04
  %170 = tail call double @llvm.fmuladd.f64(double %169, double 9.142370e+05, double -1.300000e+01)
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %163, %172
  %174 = add nuw nsw i64 %23, 15
  %175 = getelementptr inbounds double, ptr %0, i64 %174
  %176 = load double, ptr %175, align 8, !tbaa !17
  %177 = fadd double %176, 1.234500e+04
  %178 = tail call double @llvm.fmuladd.f64(double %177, double 9.142370e+05, double -1.300000e+01)
  %179 = fadd double %178, 1.234500e+04
  %180 = tail call double @llvm.fmuladd.f64(double %179, double 9.142370e+05, double -1.300000e+01)
  %181 = fadd double %180, 1.234500e+04
  %182 = tail call double @llvm.fmuladd.f64(double %181, double 9.142370e+05, double -1.300000e+01)
  %183 = fadd double %173, %182
  %184 = add nuw nsw i64 %23, 16
  %185 = getelementptr inbounds double, ptr %0, i64 %184
  %186 = load double, ptr %185, align 8, !tbaa !17
  %187 = fadd double %186, 1.234500e+04
  %188 = tail call double @llvm.fmuladd.f64(double %187, double 9.142370e+05, double -1.300000e+01)
  %189 = fadd double %188, 1.234500e+04
  %190 = tail call double @llvm.fmuladd.f64(double %189, double 9.142370e+05, double -1.300000e+01)
  %191 = fadd double %190, 1.234500e+04
  %192 = tail call double @llvm.fmuladd.f64(double %191, double 9.142370e+05, double -1.300000e+01)
  %193 = fadd double %183, %192
  %194 = add nuw nsw i64 %23, 17
  %195 = icmp slt i64 %194, %10
  br i1 %195, label %22, label %14, !llvm.loop !213

196:                                              ; preds = %196, %20
  %197 = phi i64 [ %21, %20 ], [ %208, %196 ]
  %198 = phi double [ %17, %20 ], [ %207, %196 ]
  %199 = getelementptr inbounds double, ptr %0, i64 %197
  %200 = load double, ptr %199, align 8, !tbaa !17
  %201 = fadd double %200, 1.234500e+04
  %202 = tail call double @llvm.fmuladd.f64(double %201, double 9.142370e+05, double -1.300000e+01)
  %203 = fadd double %202, 1.234500e+04
  %204 = tail call double @llvm.fmuladd.f64(double %203, double 9.142370e+05, double -1.300000e+01)
  %205 = fadd double %204, 1.234500e+04
  %206 = tail call double @llvm.fmuladd.f64(double %205, double 9.142370e+05, double -1.300000e+01)
  %207 = fadd double %198, %206
  %208 = add nuw nsw i64 %197, 1
  %209 = icmp eq i64 %208, %11
  br i1 %209, label %210, label %196, !llvm.loop !214

210:                                              ; preds = %196, %16
  %211 = phi double [ %17, %16 ], [ %207, %196 ]
  %212 = load double, ptr @init_value, align 8, !tbaa !17
  %213 = fadd double %212, 1.234500e+04
  %214 = tail call double @llvm.fmuladd.f64(double %213, double 9.142370e+05, double -1.300000e+01)
  %215 = fadd double %214, 1.234500e+04
  %216 = tail call double @llvm.fmuladd.f64(double %215, double 9.142370e+05, double -1.300000e+01)
  %217 = fadd double %216, 1.234500e+04
  %218 = tail call double @llvm.fmuladd.f64(double %217, double 9.142370e+05, double -1.300000e+01)
  %219 = fmul double %218, 8.000000e+03
  %220 = fsub double %211, %219
  %221 = tail call double @llvm.fabs.f64(double %211)
  %222 = fcmp ogt double %221, 1.000000e-08
  %223 = select i1 %222, double %211, double 1.000000e+00
  %224 = fdiv double %220, %223
  %225 = tail call double @llvm.fabs.f64(double %224)
  %226 = fcmp olt double %225, 0x3EB0C6F7A0B5ED8D
  br i1 %226, label %230, label %227

227:                                              ; preds = %210
  %228 = load i32, ptr @current_test, align 4, !tbaa !11
  %229 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %228) #12
  br label %230

230:                                              ; preds = %227, %210
  %231 = add nuw nsw i32 %13, 1
  %232 = load i32, ptr @iterations, align 4, !tbaa !11
  %233 = icmp slt i32 %231, %232
  br i1 %233, label %12, label %234, !llvm.loop !215

234:                                              ; preds = %230, %3
  %235 = tail call i64 @clock() #15
  store i64 %235, ptr @end_time, align 8, !tbaa !23
  %236 = load i64, ptr @start_time, align 8, !tbaa !23
  %237 = sub nsw i64 %235, %236
  %238 = sitofp i64 %237 to double
  %239 = fdiv double %238, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %239, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi13EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi11EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi12EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 11)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi13EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 12)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi14EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %204

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -13
  %9 = icmp sgt i32 %1, 13
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %200, %7
  %13 = phi i32 [ 0, %7 ], [ %201, %200 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %163, %22 ]
  %.lcssa = phi i64 [ %164, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %180

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %166

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %164, %22 ], [ 0, %12 ]
  %24 = phi double [ %163, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = or i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = add nuw nsw i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = add nuw nsw i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = add nuw nsw i64 %23, 11
  %135 = getelementptr inbounds double, ptr %0, i64 %134
  %136 = load double, ptr %135, align 8, !tbaa !17
  %137 = fadd double %136, 1.234500e+04
  %138 = tail call double @llvm.fmuladd.f64(double %137, double 9.142370e+05, double -1.300000e+01)
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %133, %142
  %144 = add nuw nsw i64 %23, 12
  %145 = getelementptr inbounds double, ptr %0, i64 %144
  %146 = load double, ptr %145, align 8, !tbaa !17
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %143, %152
  %154 = add nuw nsw i64 %23, 13
  %155 = getelementptr inbounds double, ptr %0, i64 %154
  %156 = load double, ptr %155, align 8, !tbaa !17
  %157 = fadd double %156, 1.234500e+04
  %158 = tail call double @llvm.fmuladd.f64(double %157, double 9.142370e+05, double -1.300000e+01)
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %153, %162
  %164 = add nuw nsw i64 %23, 14
  %165 = icmp slt i64 %164, %10
  br i1 %165, label %22, label %14, !llvm.loop !216

166:                                              ; preds = %166, %20
  %167 = phi i64 [ %21, %20 ], [ %178, %166 ]
  %168 = phi double [ %17, %20 ], [ %177, %166 ]
  %169 = getelementptr inbounds double, ptr %0, i64 %167
  %170 = load double, ptr %169, align 8, !tbaa !17
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %172, 1.234500e+04
  %174 = tail call double @llvm.fmuladd.f64(double %173, double 9.142370e+05, double -1.300000e+01)
  %175 = fadd double %174, 1.234500e+04
  %176 = tail call double @llvm.fmuladd.f64(double %175, double 9.142370e+05, double -1.300000e+01)
  %177 = fadd double %168, %176
  %178 = add nuw nsw i64 %167, 1
  %179 = icmp eq i64 %178, %11
  br i1 %179, label %180, label %166, !llvm.loop !217

180:                                              ; preds = %166, %16
  %181 = phi double [ %17, %16 ], [ %177, %166 ]
  %182 = load double, ptr @init_value, align 8, !tbaa !17
  %183 = fadd double %182, 1.234500e+04
  %184 = tail call double @llvm.fmuladd.f64(double %183, double 9.142370e+05, double -1.300000e+01)
  %185 = fadd double %184, 1.234500e+04
  %186 = tail call double @llvm.fmuladd.f64(double %185, double 9.142370e+05, double -1.300000e+01)
  %187 = fadd double %186, 1.234500e+04
  %188 = tail call double @llvm.fmuladd.f64(double %187, double 9.142370e+05, double -1.300000e+01)
  %189 = fmul double %188, 8.000000e+03
  %190 = fsub double %181, %189
  %191 = tail call double @llvm.fabs.f64(double %181)
  %192 = fcmp ogt double %191, 1.000000e-08
  %193 = select i1 %192, double %181, double 1.000000e+00
  %194 = fdiv double %190, %193
  %195 = tail call double @llvm.fabs.f64(double %194)
  %196 = fcmp olt double %195, 0x3EB0C6F7A0B5ED8D
  br i1 %196, label %200, label %197

197:                                              ; preds = %180
  %198 = load i32, ptr @current_test, align 4, !tbaa !11
  %199 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %198) #12
  br label %200

200:                                              ; preds = %197, %180
  %201 = add nuw nsw i32 %13, 1
  %202 = load i32, ptr @iterations, align 4, !tbaa !11
  %203 = icmp slt i32 %201, %202
  br i1 %203, label %12, label %204, !llvm.loop !218

204:                                              ; preds = %200, %3
  %205 = tail call i64 @clock() #15
  store i64 %205, ptr @end_time, align 8, !tbaa !23
  %206 = load i64, ptr @start_time, align 8, !tbaa !23
  %207 = sub nsw i64 %205, %206
  %208 = sitofp i64 %207 to double
  %209 = fdiv double %208, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %209, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi15EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %214

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -14
  %9 = icmp sgt i32 %1, 14
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %210, %7
  %13 = phi i32 [ 0, %7 ], [ %211, %210 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %173, %22 ]
  %.lcssa = phi i64 [ %174, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %190

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %176

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %174, %22 ], [ 0, %12 ]
  %24 = phi double [ %173, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = add nuw nsw i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = add nuw nsw i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = add nuw nsw i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = add nuw nsw i64 %23, 11
  %135 = getelementptr inbounds double, ptr %0, i64 %134
  %136 = load double, ptr %135, align 8, !tbaa !17
  %137 = fadd double %136, 1.234500e+04
  %138 = tail call double @llvm.fmuladd.f64(double %137, double 9.142370e+05, double -1.300000e+01)
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %133, %142
  %144 = add nuw nsw i64 %23, 12
  %145 = getelementptr inbounds double, ptr %0, i64 %144
  %146 = load double, ptr %145, align 8, !tbaa !17
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %143, %152
  %154 = add nuw nsw i64 %23, 13
  %155 = getelementptr inbounds double, ptr %0, i64 %154
  %156 = load double, ptr %155, align 8, !tbaa !17
  %157 = fadd double %156, 1.234500e+04
  %158 = tail call double @llvm.fmuladd.f64(double %157, double 9.142370e+05, double -1.300000e+01)
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %153, %162
  %164 = add nuw nsw i64 %23, 14
  %165 = getelementptr inbounds double, ptr %0, i64 %164
  %166 = load double, ptr %165, align 8, !tbaa !17
  %167 = fadd double %166, 1.234500e+04
  %168 = tail call double @llvm.fmuladd.f64(double %167, double 9.142370e+05, double -1.300000e+01)
  %169 = fadd double %168, 1.234500e+04
  %170 = tail call double @llvm.fmuladd.f64(double %169, double 9.142370e+05, double -1.300000e+01)
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %163, %172
  %174 = add nuw nsw i64 %23, 15
  %175 = icmp slt i64 %174, %10
  br i1 %175, label %22, label %14, !llvm.loop !219

176:                                              ; preds = %176, %20
  %177 = phi i64 [ %21, %20 ], [ %188, %176 ]
  %178 = phi double [ %17, %20 ], [ %187, %176 ]
  %179 = getelementptr inbounds double, ptr %0, i64 %177
  %180 = load double, ptr %179, align 8, !tbaa !17
  %181 = fadd double %180, 1.234500e+04
  %182 = tail call double @llvm.fmuladd.f64(double %181, double 9.142370e+05, double -1.300000e+01)
  %183 = fadd double %182, 1.234500e+04
  %184 = tail call double @llvm.fmuladd.f64(double %183, double 9.142370e+05, double -1.300000e+01)
  %185 = fadd double %184, 1.234500e+04
  %186 = tail call double @llvm.fmuladd.f64(double %185, double 9.142370e+05, double -1.300000e+01)
  %187 = fadd double %178, %186
  %188 = add nuw nsw i64 %177, 1
  %189 = icmp eq i64 %188, %11
  br i1 %189, label %190, label %176, !llvm.loop !220

190:                                              ; preds = %176, %16
  %191 = phi double [ %17, %16 ], [ %187, %176 ]
  %192 = load double, ptr @init_value, align 8, !tbaa !17
  %193 = fadd double %192, 1.234500e+04
  %194 = tail call double @llvm.fmuladd.f64(double %193, double 9.142370e+05, double -1.300000e+01)
  %195 = fadd double %194, 1.234500e+04
  %196 = tail call double @llvm.fmuladd.f64(double %195, double 9.142370e+05, double -1.300000e+01)
  %197 = fadd double %196, 1.234500e+04
  %198 = tail call double @llvm.fmuladd.f64(double %197, double 9.142370e+05, double -1.300000e+01)
  %199 = fmul double %198, 8.000000e+03
  %200 = fsub double %191, %199
  %201 = tail call double @llvm.fabs.f64(double %191)
  %202 = fcmp ogt double %201, 1.000000e-08
  %203 = select i1 %202, double %191, double 1.000000e+00
  %204 = fdiv double %200, %203
  %205 = tail call double @llvm.fabs.f64(double %204)
  %206 = fcmp olt double %205, 0x3EB0C6F7A0B5ED8D
  br i1 %206, label %210, label %207

207:                                              ; preds = %190
  %208 = load i32, ptr @current_test, align 4, !tbaa !11
  %209 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %208) #12
  br label %210

210:                                              ; preds = %207, %190
  %211 = add nuw nsw i32 %13, 1
  %212 = load i32, ptr @iterations, align 4, !tbaa !11
  %213 = icmp slt i32 %211, %212
  br i1 %213, label %12, label %214, !llvm.loop !221

214:                                              ; preds = %210, %3
  %215 = tail call i64 @clock() #15
  store i64 %215, ptr @end_time, align 8, !tbaa !23
  %216 = load i64, ptr @start_time, align 8, !tbaa !23
  %217 = sub nsw i64 %215, %216
  %218 = sitofp i64 %217 to double
  %219 = fdiv double %218, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %219, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi11EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi9EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi10EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 9)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi11EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 10)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi12EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %184

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -11
  %9 = icmp sgt i32 %1, 11
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %180, %7
  %13 = phi i32 [ 0, %7 ], [ %181, %180 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %143, %22 ]
  %.lcssa = phi i64 [ %144, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %160

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %146

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %144, %22 ], [ 0, %12 ]
  %24 = phi double [ %143, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = or i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = or i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = or i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = add nuw nsw i64 %23, 11
  %135 = getelementptr inbounds double, ptr %0, i64 %134
  %136 = load double, ptr %135, align 8, !tbaa !17
  %137 = fadd double %136, 1.234500e+04
  %138 = tail call double @llvm.fmuladd.f64(double %137, double 9.142370e+05, double -1.300000e+01)
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %133, %142
  %144 = add nuw nsw i64 %23, 12
  %145 = icmp slt i64 %144, %10
  br i1 %145, label %22, label %14, !llvm.loop !222

146:                                              ; preds = %146, %20
  %147 = phi i64 [ %21, %20 ], [ %158, %146 ]
  %148 = phi double [ %17, %20 ], [ %157, %146 ]
  %149 = getelementptr inbounds double, ptr %0, i64 %147
  %150 = load double, ptr %149, align 8, !tbaa !17
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %154, 1.234500e+04
  %156 = tail call double @llvm.fmuladd.f64(double %155, double 9.142370e+05, double -1.300000e+01)
  %157 = fadd double %148, %156
  %158 = add nuw nsw i64 %147, 1
  %159 = icmp eq i64 %158, %11
  br i1 %159, label %160, label %146, !llvm.loop !223

160:                                              ; preds = %146, %16
  %161 = phi double [ %17, %16 ], [ %157, %146 ]
  %162 = load double, ptr @init_value, align 8, !tbaa !17
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %164, 1.234500e+04
  %166 = tail call double @llvm.fmuladd.f64(double %165, double 9.142370e+05, double -1.300000e+01)
  %167 = fadd double %166, 1.234500e+04
  %168 = tail call double @llvm.fmuladd.f64(double %167, double 9.142370e+05, double -1.300000e+01)
  %169 = fmul double %168, 8.000000e+03
  %170 = fsub double %161, %169
  %171 = tail call double @llvm.fabs.f64(double %161)
  %172 = fcmp ogt double %171, 1.000000e-08
  %173 = select i1 %172, double %161, double 1.000000e+00
  %174 = fdiv double %170, %173
  %175 = tail call double @llvm.fabs.f64(double %174)
  %176 = fcmp olt double %175, 0x3EB0C6F7A0B5ED8D
  br i1 %176, label %180, label %177

177:                                              ; preds = %160
  %178 = load i32, ptr @current_test, align 4, !tbaa !11
  %179 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %178) #12
  br label %180

180:                                              ; preds = %177, %160
  %181 = add nuw nsw i32 %13, 1
  %182 = load i32, ptr @iterations, align 4, !tbaa !11
  %183 = icmp slt i32 %181, %182
  br i1 %183, label %12, label %184, !llvm.loop !224

184:                                              ; preds = %180, %3
  %185 = tail call i64 @clock() #15
  store i64 %185, ptr @end_time, align 8, !tbaa !23
  %186 = load i64, ptr @start_time, align 8, !tbaa !23
  %187 = sub nsw i64 %185, %186
  %188 = sitofp i64 %187 to double
  %189 = fdiv double %188, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %189, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi13EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %194

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -12
  %9 = icmp sgt i32 %1, 12
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %190, %7
  %13 = phi i32 [ 0, %7 ], [ %191, %190 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %153, %22 ]
  %.lcssa = phi i64 [ %154, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %170

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %156

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %154, %22 ], [ 0, %12 ]
  %24 = phi double [ %153, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = add nuw nsw i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = add nuw nsw i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = add nuw nsw i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = add nuw nsw i64 %23, 11
  %135 = getelementptr inbounds double, ptr %0, i64 %134
  %136 = load double, ptr %135, align 8, !tbaa !17
  %137 = fadd double %136, 1.234500e+04
  %138 = tail call double @llvm.fmuladd.f64(double %137, double 9.142370e+05, double -1.300000e+01)
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %133, %142
  %144 = add nuw nsw i64 %23, 12
  %145 = getelementptr inbounds double, ptr %0, i64 %144
  %146 = load double, ptr %145, align 8, !tbaa !17
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %143, %152
  %154 = add nuw nsw i64 %23, 13
  %155 = icmp slt i64 %154, %10
  br i1 %155, label %22, label %14, !llvm.loop !225

156:                                              ; preds = %156, %20
  %157 = phi i64 [ %21, %20 ], [ %168, %156 ]
  %158 = phi double [ %17, %20 ], [ %167, %156 ]
  %159 = getelementptr inbounds double, ptr %0, i64 %157
  %160 = load double, ptr %159, align 8, !tbaa !17
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %164, 1.234500e+04
  %166 = tail call double @llvm.fmuladd.f64(double %165, double 9.142370e+05, double -1.300000e+01)
  %167 = fadd double %158, %166
  %168 = add nuw nsw i64 %157, 1
  %169 = icmp eq i64 %168, %11
  br i1 %169, label %170, label %156, !llvm.loop !226

170:                                              ; preds = %156, %16
  %171 = phi double [ %17, %16 ], [ %167, %156 ]
  %172 = load double, ptr @init_value, align 8, !tbaa !17
  %173 = fadd double %172, 1.234500e+04
  %174 = tail call double @llvm.fmuladd.f64(double %173, double 9.142370e+05, double -1.300000e+01)
  %175 = fadd double %174, 1.234500e+04
  %176 = tail call double @llvm.fmuladd.f64(double %175, double 9.142370e+05, double -1.300000e+01)
  %177 = fadd double %176, 1.234500e+04
  %178 = tail call double @llvm.fmuladd.f64(double %177, double 9.142370e+05, double -1.300000e+01)
  %179 = fmul double %178, 8.000000e+03
  %180 = fsub double %171, %179
  %181 = tail call double @llvm.fabs.f64(double %171)
  %182 = fcmp ogt double %181, 1.000000e-08
  %183 = select i1 %182, double %171, double 1.000000e+00
  %184 = fdiv double %180, %183
  %185 = tail call double @llvm.fabs.f64(double %184)
  %186 = fcmp olt double %185, 0x3EB0C6F7A0B5ED8D
  br i1 %186, label %190, label %187

187:                                              ; preds = %170
  %188 = load i32, ptr @current_test, align 4, !tbaa !11
  %189 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %188) #12
  br label %190

190:                                              ; preds = %187, %170
  %191 = add nuw nsw i32 %13, 1
  %192 = load i32, ptr @iterations, align 4, !tbaa !11
  %193 = icmp slt i32 %191, %192
  br i1 %193, label %12, label %194, !llvm.loop !227

194:                                              ; preds = %190, %3
  %195 = tail call i64 @clock() #15
  store i64 %195, ptr @end_time, align 8, !tbaa !23
  %196 = load i64, ptr @start_time, align 8, !tbaa !23
  %197 = sub nsw i64 %195, %196
  %198 = sitofp i64 %197 to double
  %199 = fdiv double %198, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %199, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi9EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi7EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi8EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 7)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi9EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 8)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi10EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %164

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -9
  %9 = icmp sgt i32 %1, 9
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %160, %7
  %13 = phi i32 [ 0, %7 ], [ %161, %160 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %123, %22 ]
  %.lcssa = phi i64 [ %124, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %140

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %126

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %124, %22 ], [ 0, %12 ]
  %24 = phi double [ %123, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = or i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = add nuw nsw i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = add nuw nsw i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = icmp slt i64 %124, %10
  br i1 %125, label %22, label %14, !llvm.loop !228

126:                                              ; preds = %126, %20
  %127 = phi i64 [ %21, %20 ], [ %138, %126 ]
  %128 = phi double [ %17, %20 ], [ %137, %126 ]
  %129 = getelementptr inbounds double, ptr %0, i64 %127
  %130 = load double, ptr %129, align 8, !tbaa !17
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %134, 1.234500e+04
  %136 = tail call double @llvm.fmuladd.f64(double %135, double 9.142370e+05, double -1.300000e+01)
  %137 = fadd double %128, %136
  %138 = add nuw nsw i64 %127, 1
  %139 = icmp eq i64 %138, %11
  br i1 %139, label %140, label %126, !llvm.loop !229

140:                                              ; preds = %126, %16
  %141 = phi double [ %17, %16 ], [ %137, %126 ]
  %142 = load double, ptr @init_value, align 8, !tbaa !17
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %144, 1.234500e+04
  %146 = tail call double @llvm.fmuladd.f64(double %145, double 9.142370e+05, double -1.300000e+01)
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fmul double %148, 8.000000e+03
  %150 = fsub double %141, %149
  %151 = tail call double @llvm.fabs.f64(double %141)
  %152 = fcmp ogt double %151, 1.000000e-08
  %153 = select i1 %152, double %141, double 1.000000e+00
  %154 = fdiv double %150, %153
  %155 = tail call double @llvm.fabs.f64(double %154)
  %156 = fcmp olt double %155, 0x3EB0C6F7A0B5ED8D
  br i1 %156, label %160, label %157

157:                                              ; preds = %140
  %158 = load i32, ptr @current_test, align 4, !tbaa !11
  %159 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %158) #12
  br label %160

160:                                              ; preds = %157, %140
  %161 = add nuw nsw i32 %13, 1
  %162 = load i32, ptr @iterations, align 4, !tbaa !11
  %163 = icmp slt i32 %161, %162
  br i1 %163, label %12, label %164, !llvm.loop !230

164:                                              ; preds = %160, %3
  %165 = tail call i64 @clock() #15
  store i64 %165, ptr @end_time, align 8, !tbaa !23
  %166 = load i64, ptr @start_time, align 8, !tbaa !23
  %167 = sub nsw i64 %165, %166
  %168 = sitofp i64 %167 to double
  %169 = fdiv double %168, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %169, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi11EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %174

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -10
  %9 = icmp sgt i32 %1, 10
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %170, %7
  %13 = phi i32 [ 0, %7 ], [ %171, %170 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %133, %22 ]
  %.lcssa = phi i64 [ %134, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %150

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %136

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %134, %22 ], [ 0, %12 ]
  %24 = phi double [ %133, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = add nuw nsw i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = add nuw nsw i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = add nuw nsw i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = add nuw nsw i64 %23, 11
  %135 = icmp slt i64 %134, %10
  br i1 %135, label %22, label %14, !llvm.loop !231

136:                                              ; preds = %136, %20
  %137 = phi i64 [ %21, %20 ], [ %148, %136 ]
  %138 = phi double [ %17, %20 ], [ %147, %136 ]
  %139 = getelementptr inbounds double, ptr %0, i64 %137
  %140 = load double, ptr %139, align 8, !tbaa !17
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %144, 1.234500e+04
  %146 = tail call double @llvm.fmuladd.f64(double %145, double 9.142370e+05, double -1.300000e+01)
  %147 = fadd double %138, %146
  %148 = add nuw nsw i64 %137, 1
  %149 = icmp eq i64 %148, %11
  br i1 %149, label %150, label %136, !llvm.loop !232

150:                                              ; preds = %136, %16
  %151 = phi double [ %17, %16 ], [ %147, %136 ]
  %152 = load double, ptr @init_value, align 8, !tbaa !17
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %154, 1.234500e+04
  %156 = tail call double @llvm.fmuladd.f64(double %155, double 9.142370e+05, double -1.300000e+01)
  %157 = fadd double %156, 1.234500e+04
  %158 = tail call double @llvm.fmuladd.f64(double %157, double 9.142370e+05, double -1.300000e+01)
  %159 = fmul double %158, 8.000000e+03
  %160 = fsub double %151, %159
  %161 = tail call double @llvm.fabs.f64(double %151)
  %162 = fcmp ogt double %161, 1.000000e-08
  %163 = select i1 %162, double %151, double 1.000000e+00
  %164 = fdiv double %160, %163
  %165 = tail call double @llvm.fabs.f64(double %164)
  %166 = fcmp olt double %165, 0x3EB0C6F7A0B5ED8D
  br i1 %166, label %170, label %167

167:                                              ; preds = %150
  %168 = load i32, ptr @current_test, align 4, !tbaa !11
  %169 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %168) #12
  br label %170

170:                                              ; preds = %167, %150
  %171 = add nuw nsw i32 %13, 1
  %172 = load i32, ptr @iterations, align 4, !tbaa !11
  %173 = icmp slt i32 %171, %172
  br i1 %173, label %12, label %174, !llvm.loop !233

174:                                              ; preds = %170, %3
  %175 = tail call i64 @clock() #15
  store i64 %175, ptr @end_time, align 8, !tbaa !23
  %176 = load i64, ptr @start_time, align 8, !tbaa !23
  %177 = sub nsw i64 %175, %176
  %178 = sitofp i64 %177 to double
  %179 = fdiv double %178, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %179, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi7EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi5EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi6EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 5)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi7EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 6)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi8EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %146

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -7
  %9 = icmp sgt i32 %1, 7
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %142, %7
  %13 = phi i32 [ %5, %7 ], [ %143, %142 ]
  %14 = phi i32 [ 0, %7 ], [ %144, %142 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %104, %23 ]
  %.lcssa = phi i64 [ %105, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %121

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %107

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %105, %23 ], [ 0, %12 ]
  %25 = phi double [ %104, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = or i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = or i64 %24, 2
  %46 = getelementptr inbounds double, ptr %0, i64 %45
  %47 = load double, ptr %46, align 8, !tbaa !17
  %48 = fadd double %47, 1.234500e+04
  %49 = tail call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %44, %53
  %55 = or i64 %24, 3
  %56 = getelementptr inbounds double, ptr %0, i64 %55
  %57 = load double, ptr %56, align 8, !tbaa !17
  %58 = fadd double %57, 1.234500e+04
  %59 = tail call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %54, %63
  %65 = or i64 %24, 4
  %66 = getelementptr inbounds double, ptr %0, i64 %65
  %67 = load double, ptr %66, align 8, !tbaa !17
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %64, %73
  %75 = or i64 %24, 5
  %76 = getelementptr inbounds double, ptr %0, i64 %75
  %77 = load double, ptr %76, align 8, !tbaa !17
  %78 = fadd double %77, 1.234500e+04
  %79 = tail call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fadd double %79, 1.234500e+04
  %81 = tail call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %74, %83
  %85 = or i64 %24, 6
  %86 = getelementptr inbounds double, ptr %0, i64 %85
  %87 = load double, ptr %86, align 8, !tbaa !17
  %88 = fadd double %87, 1.234500e+04
  %89 = tail call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fadd double %89, 1.234500e+04
  %91 = tail call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %91, 1.234500e+04
  %93 = tail call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %84, %93
  %95 = or i64 %24, 7
  %96 = getelementptr inbounds double, ptr %0, i64 %95
  %97 = load double, ptr %96, align 8, !tbaa !17
  %98 = fadd double %97, 1.234500e+04
  %99 = tail call double @llvm.fmuladd.f64(double %98, double 9.142370e+05, double -1.300000e+01)
  %100 = fadd double %99, 1.234500e+04
  %101 = tail call double @llvm.fmuladd.f64(double %100, double 9.142370e+05, double -1.300000e+01)
  %102 = fadd double %101, 1.234500e+04
  %103 = tail call double @llvm.fmuladd.f64(double %102, double 9.142370e+05, double -1.300000e+01)
  %104 = fadd double %94, %103
  %105 = add nuw nsw i64 %24, 8
  %106 = icmp slt i64 %105, %10
  br i1 %106, label %23, label %15, !llvm.loop !234

107:                                              ; preds = %107, %21
  %108 = phi i64 [ %22, %21 ], [ %119, %107 ]
  %109 = phi double [ %18, %21 ], [ %118, %107 ]
  %110 = getelementptr inbounds double, ptr %0, i64 %108
  %111 = load double, ptr %110, align 8, !tbaa !17
  %112 = fadd double %111, 1.234500e+04
  %113 = tail call double @llvm.fmuladd.f64(double %112, double 9.142370e+05, double -1.300000e+01)
  %114 = fadd double %113, 1.234500e+04
  %115 = tail call double @llvm.fmuladd.f64(double %114, double 9.142370e+05, double -1.300000e+01)
  %116 = fadd double %115, 1.234500e+04
  %117 = tail call double @llvm.fmuladd.f64(double %116, double 9.142370e+05, double -1.300000e+01)
  %118 = fadd double %109, %117
  %119 = add nuw nsw i64 %108, 1
  %120 = icmp eq i64 %119, %11
  br i1 %120, label %121, label %107, !llvm.loop !235

121:                                              ; preds = %107, %17
  %122 = phi double [ %18, %17 ], [ %118, %107 ]
  %123 = load double, ptr @init_value, align 8, !tbaa !17
  %124 = fadd double %123, 1.234500e+04
  %125 = tail call double @llvm.fmuladd.f64(double %124, double 9.142370e+05, double -1.300000e+01)
  %126 = fadd double %125, 1.234500e+04
  %127 = tail call double @llvm.fmuladd.f64(double %126, double 9.142370e+05, double -1.300000e+01)
  %128 = fadd double %127, 1.234500e+04
  %129 = tail call double @llvm.fmuladd.f64(double %128, double 9.142370e+05, double -1.300000e+01)
  %130 = fmul double %129, 8.000000e+03
  %131 = fsub double %122, %130
  %132 = tail call double @llvm.fabs.f64(double %122)
  %133 = fcmp ogt double %132, 1.000000e-08
  %134 = select i1 %133, double %122, double 1.000000e+00
  %135 = fdiv double %131, %134
  %136 = tail call double @llvm.fabs.f64(double %135)
  %137 = fcmp olt double %136, 0x3EB0C6F7A0B5ED8D
  br i1 %137, label %142, label %138

138:                                              ; preds = %121
  %139 = load i32, ptr @current_test, align 4, !tbaa !11
  %140 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %139) #12
  %141 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %142

142:                                              ; preds = %138, %121
  %143 = phi i32 [ %13, %121 ], [ %141, %138 ]
  %144 = add nuw nsw i32 %14, 1
  %145 = icmp slt i32 %144, %143
  br i1 %145, label %12, label %146, !llvm.loop !236

146:                                              ; preds = %142, %3
  %147 = tail call i64 @clock() #15
  store i64 %147, ptr @end_time, align 8, !tbaa !23
  %148 = load i64, ptr @start_time, align 8, !tbaa !23
  %149 = sub nsw i64 %147, %148
  %150 = sitofp i64 %149 to double
  %151 = fdiv double %150, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %151, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi9EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %156

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -8
  %9 = icmp sgt i32 %1, 8
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %152, %7
  %13 = phi i32 [ %5, %7 ], [ %153, %152 ]
  %14 = phi i32 [ 0, %7 ], [ %154, %152 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %114, %23 ]
  %.lcssa = phi i64 [ %115, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %131

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %117

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %115, %23 ], [ 0, %12 ]
  %25 = phi double [ %114, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = add nuw nsw i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = add nuw nsw i64 %24, 2
  %46 = getelementptr inbounds double, ptr %0, i64 %45
  %47 = load double, ptr %46, align 8, !tbaa !17
  %48 = fadd double %47, 1.234500e+04
  %49 = tail call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %44, %53
  %55 = add nuw nsw i64 %24, 3
  %56 = getelementptr inbounds double, ptr %0, i64 %55
  %57 = load double, ptr %56, align 8, !tbaa !17
  %58 = fadd double %57, 1.234500e+04
  %59 = tail call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %54, %63
  %65 = add nuw nsw i64 %24, 4
  %66 = getelementptr inbounds double, ptr %0, i64 %65
  %67 = load double, ptr %66, align 8, !tbaa !17
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %64, %73
  %75 = add nuw nsw i64 %24, 5
  %76 = getelementptr inbounds double, ptr %0, i64 %75
  %77 = load double, ptr %76, align 8, !tbaa !17
  %78 = fadd double %77, 1.234500e+04
  %79 = tail call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fadd double %79, 1.234500e+04
  %81 = tail call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %74, %83
  %85 = add nuw nsw i64 %24, 6
  %86 = getelementptr inbounds double, ptr %0, i64 %85
  %87 = load double, ptr %86, align 8, !tbaa !17
  %88 = fadd double %87, 1.234500e+04
  %89 = tail call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fadd double %89, 1.234500e+04
  %91 = tail call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %91, 1.234500e+04
  %93 = tail call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %84, %93
  %95 = add nuw nsw i64 %24, 7
  %96 = getelementptr inbounds double, ptr %0, i64 %95
  %97 = load double, ptr %96, align 8, !tbaa !17
  %98 = fadd double %97, 1.234500e+04
  %99 = tail call double @llvm.fmuladd.f64(double %98, double 9.142370e+05, double -1.300000e+01)
  %100 = fadd double %99, 1.234500e+04
  %101 = tail call double @llvm.fmuladd.f64(double %100, double 9.142370e+05, double -1.300000e+01)
  %102 = fadd double %101, 1.234500e+04
  %103 = tail call double @llvm.fmuladd.f64(double %102, double 9.142370e+05, double -1.300000e+01)
  %104 = fadd double %94, %103
  %105 = add nuw nsw i64 %24, 8
  %106 = getelementptr inbounds double, ptr %0, i64 %105
  %107 = load double, ptr %106, align 8, !tbaa !17
  %108 = fadd double %107, 1.234500e+04
  %109 = tail call double @llvm.fmuladd.f64(double %108, double 9.142370e+05, double -1.300000e+01)
  %110 = fadd double %109, 1.234500e+04
  %111 = tail call double @llvm.fmuladd.f64(double %110, double 9.142370e+05, double -1.300000e+01)
  %112 = fadd double %111, 1.234500e+04
  %113 = tail call double @llvm.fmuladd.f64(double %112, double 9.142370e+05, double -1.300000e+01)
  %114 = fadd double %104, %113
  %115 = add nuw nsw i64 %24, 9
  %116 = icmp slt i64 %115, %10
  br i1 %116, label %23, label %15, !llvm.loop !237

117:                                              ; preds = %117, %21
  %118 = phi i64 [ %22, %21 ], [ %129, %117 ]
  %119 = phi double [ %18, %21 ], [ %128, %117 ]
  %120 = getelementptr inbounds double, ptr %0, i64 %118
  %121 = load double, ptr %120, align 8, !tbaa !17
  %122 = fadd double %121, 1.234500e+04
  %123 = tail call double @llvm.fmuladd.f64(double %122, double 9.142370e+05, double -1.300000e+01)
  %124 = fadd double %123, 1.234500e+04
  %125 = tail call double @llvm.fmuladd.f64(double %124, double 9.142370e+05, double -1.300000e+01)
  %126 = fadd double %125, 1.234500e+04
  %127 = tail call double @llvm.fmuladd.f64(double %126, double 9.142370e+05, double -1.300000e+01)
  %128 = fadd double %119, %127
  %129 = add nuw nsw i64 %118, 1
  %130 = icmp eq i64 %129, %11
  br i1 %130, label %131, label %117, !llvm.loop !238

131:                                              ; preds = %117, %17
  %132 = phi double [ %18, %17 ], [ %128, %117 ]
  %133 = load double, ptr @init_value, align 8, !tbaa !17
  %134 = fadd double %133, 1.234500e+04
  %135 = tail call double @llvm.fmuladd.f64(double %134, double 9.142370e+05, double -1.300000e+01)
  %136 = fadd double %135, 1.234500e+04
  %137 = tail call double @llvm.fmuladd.f64(double %136, double 9.142370e+05, double -1.300000e+01)
  %138 = fadd double %137, 1.234500e+04
  %139 = tail call double @llvm.fmuladd.f64(double %138, double 9.142370e+05, double -1.300000e+01)
  %140 = fmul double %139, 8.000000e+03
  %141 = fsub double %132, %140
  %142 = tail call double @llvm.fabs.f64(double %132)
  %143 = fcmp ogt double %142, 1.000000e-08
  %144 = select i1 %143, double %132, double 1.000000e+00
  %145 = fdiv double %141, %144
  %146 = tail call double @llvm.fabs.f64(double %145)
  %147 = fcmp olt double %146, 0x3EB0C6F7A0B5ED8D
  br i1 %147, label %152, label %148

148:                                              ; preds = %131
  %149 = load i32, ptr @current_test, align 4, !tbaa !11
  %150 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %149) #12
  %151 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %152

152:                                              ; preds = %148, %131
  %153 = phi i32 [ %13, %131 ], [ %151, %148 ]
  %154 = add nuw nsw i32 %14, 1
  %155 = icmp slt i32 %154, %153
  br i1 %155, label %12, label %156, !llvm.loop !239

156:                                              ; preds = %152, %3
  %157 = tail call i64 @clock() #15
  store i64 %157, ptr @end_time, align 8, !tbaa !23
  %158 = load i64, ptr @start_time, align 8, !tbaa !23
  %159 = sub nsw i64 %157, %158
  %160 = sitofp i64 %159 to double
  %161 = fdiv double %160, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %161, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi5EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi3EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi4EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 3)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi5EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 4)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi6EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %126

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -5
  %9 = icmp sgt i32 %1, 5
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %122, %7
  %13 = phi i32 [ %5, %7 ], [ %123, %122 ]
  %14 = phi i32 [ 0, %7 ], [ %124, %122 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %84, %23 ]
  %.lcssa = phi i64 [ %85, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %101

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %87

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %85, %23 ], [ 0, %12 ]
  %25 = phi double [ %84, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = or i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = add nuw nsw i64 %24, 2
  %46 = getelementptr inbounds double, ptr %0, i64 %45
  %47 = load double, ptr %46, align 8, !tbaa !17
  %48 = fadd double %47, 1.234500e+04
  %49 = tail call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %44, %53
  %55 = add nuw nsw i64 %24, 3
  %56 = getelementptr inbounds double, ptr %0, i64 %55
  %57 = load double, ptr %56, align 8, !tbaa !17
  %58 = fadd double %57, 1.234500e+04
  %59 = tail call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %54, %63
  %65 = add nuw nsw i64 %24, 4
  %66 = getelementptr inbounds double, ptr %0, i64 %65
  %67 = load double, ptr %66, align 8, !tbaa !17
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %64, %73
  %75 = add nuw nsw i64 %24, 5
  %76 = getelementptr inbounds double, ptr %0, i64 %75
  %77 = load double, ptr %76, align 8, !tbaa !17
  %78 = fadd double %77, 1.234500e+04
  %79 = tail call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fadd double %79, 1.234500e+04
  %81 = tail call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %74, %83
  %85 = add nuw nsw i64 %24, 6
  %86 = icmp slt i64 %85, %10
  br i1 %86, label %23, label %15, !llvm.loop !240

87:                                               ; preds = %87, %21
  %88 = phi i64 [ %22, %21 ], [ %99, %87 ]
  %89 = phi double [ %18, %21 ], [ %98, %87 ]
  %90 = getelementptr inbounds double, ptr %0, i64 %88
  %91 = load double, ptr %90, align 8, !tbaa !17
  %92 = fadd double %91, 1.234500e+04
  %93 = tail call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %93, 1.234500e+04
  %95 = tail call double @llvm.fmuladd.f64(double %94, double 9.142370e+05, double -1.300000e+01)
  %96 = fadd double %95, 1.234500e+04
  %97 = tail call double @llvm.fmuladd.f64(double %96, double 9.142370e+05, double -1.300000e+01)
  %98 = fadd double %89, %97
  %99 = add nuw nsw i64 %88, 1
  %100 = icmp eq i64 %99, %11
  br i1 %100, label %101, label %87, !llvm.loop !241

101:                                              ; preds = %87, %17
  %102 = phi double [ %18, %17 ], [ %98, %87 ]
  %103 = load double, ptr @init_value, align 8, !tbaa !17
  %104 = fadd double %103, 1.234500e+04
  %105 = tail call double @llvm.fmuladd.f64(double %104, double 9.142370e+05, double -1.300000e+01)
  %106 = fadd double %105, 1.234500e+04
  %107 = tail call double @llvm.fmuladd.f64(double %106, double 9.142370e+05, double -1.300000e+01)
  %108 = fadd double %107, 1.234500e+04
  %109 = tail call double @llvm.fmuladd.f64(double %108, double 9.142370e+05, double -1.300000e+01)
  %110 = fmul double %109, 8.000000e+03
  %111 = fsub double %102, %110
  %112 = tail call double @llvm.fabs.f64(double %102)
  %113 = fcmp ogt double %112, 1.000000e-08
  %114 = select i1 %113, double %102, double 1.000000e+00
  %115 = fdiv double %111, %114
  %116 = tail call double @llvm.fabs.f64(double %115)
  %117 = fcmp olt double %116, 0x3EB0C6F7A0B5ED8D
  br i1 %117, label %122, label %118

118:                                              ; preds = %101
  %119 = load i32, ptr @current_test, align 4, !tbaa !11
  %120 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %119) #12
  %121 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %122

122:                                              ; preds = %118, %101
  %123 = phi i32 [ %13, %101 ], [ %121, %118 ]
  %124 = add nuw nsw i32 %14, 1
  %125 = icmp slt i32 %124, %123
  br i1 %125, label %12, label %126, !llvm.loop !242

126:                                              ; preds = %122, %3
  %127 = tail call i64 @clock() #15
  store i64 %127, ptr @end_time, align 8, !tbaa !23
  %128 = load i64, ptr @start_time, align 8, !tbaa !23
  %129 = sub nsw i64 %127, %128
  %130 = sitofp i64 %129 to double
  %131 = fdiv double %130, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %131, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi7EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %136

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -6
  %9 = icmp sgt i32 %1, 6
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %132, %7
  %13 = phi i32 [ %5, %7 ], [ %133, %132 ]
  %14 = phi i32 [ 0, %7 ], [ %134, %132 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %94, %23 ]
  %.lcssa = phi i64 [ %95, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %111

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %97

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %95, %23 ], [ 0, %12 ]
  %25 = phi double [ %94, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = add nuw nsw i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = add nuw nsw i64 %24, 2
  %46 = getelementptr inbounds double, ptr %0, i64 %45
  %47 = load double, ptr %46, align 8, !tbaa !17
  %48 = fadd double %47, 1.234500e+04
  %49 = tail call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %44, %53
  %55 = add nuw nsw i64 %24, 3
  %56 = getelementptr inbounds double, ptr %0, i64 %55
  %57 = load double, ptr %56, align 8, !tbaa !17
  %58 = fadd double %57, 1.234500e+04
  %59 = tail call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %54, %63
  %65 = add nuw nsw i64 %24, 4
  %66 = getelementptr inbounds double, ptr %0, i64 %65
  %67 = load double, ptr %66, align 8, !tbaa !17
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %64, %73
  %75 = add nuw nsw i64 %24, 5
  %76 = getelementptr inbounds double, ptr %0, i64 %75
  %77 = load double, ptr %76, align 8, !tbaa !17
  %78 = fadd double %77, 1.234500e+04
  %79 = tail call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fadd double %79, 1.234500e+04
  %81 = tail call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %74, %83
  %85 = add nuw nsw i64 %24, 6
  %86 = getelementptr inbounds double, ptr %0, i64 %85
  %87 = load double, ptr %86, align 8, !tbaa !17
  %88 = fadd double %87, 1.234500e+04
  %89 = tail call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fadd double %89, 1.234500e+04
  %91 = tail call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %91, 1.234500e+04
  %93 = tail call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %84, %93
  %95 = add nuw nsw i64 %24, 7
  %96 = icmp slt i64 %95, %10
  br i1 %96, label %23, label %15, !llvm.loop !243

97:                                               ; preds = %97, %21
  %98 = phi i64 [ %22, %21 ], [ %109, %97 ]
  %99 = phi double [ %18, %21 ], [ %108, %97 ]
  %100 = getelementptr inbounds double, ptr %0, i64 %98
  %101 = load double, ptr %100, align 8, !tbaa !17
  %102 = fadd double %101, 1.234500e+04
  %103 = tail call double @llvm.fmuladd.f64(double %102, double 9.142370e+05, double -1.300000e+01)
  %104 = fadd double %103, 1.234500e+04
  %105 = tail call double @llvm.fmuladd.f64(double %104, double 9.142370e+05, double -1.300000e+01)
  %106 = fadd double %105, 1.234500e+04
  %107 = tail call double @llvm.fmuladd.f64(double %106, double 9.142370e+05, double -1.300000e+01)
  %108 = fadd double %99, %107
  %109 = add nuw nsw i64 %98, 1
  %110 = icmp eq i64 %109, %11
  br i1 %110, label %111, label %97, !llvm.loop !244

111:                                              ; preds = %97, %17
  %112 = phi double [ %18, %17 ], [ %108, %97 ]
  %113 = load double, ptr @init_value, align 8, !tbaa !17
  %114 = fadd double %113, 1.234500e+04
  %115 = tail call double @llvm.fmuladd.f64(double %114, double 9.142370e+05, double -1.300000e+01)
  %116 = fadd double %115, 1.234500e+04
  %117 = tail call double @llvm.fmuladd.f64(double %116, double 9.142370e+05, double -1.300000e+01)
  %118 = fadd double %117, 1.234500e+04
  %119 = tail call double @llvm.fmuladd.f64(double %118, double 9.142370e+05, double -1.300000e+01)
  %120 = fmul double %119, 8.000000e+03
  %121 = fsub double %112, %120
  %122 = tail call double @llvm.fabs.f64(double %112)
  %123 = fcmp ogt double %122, 1.000000e-08
  %124 = select i1 %123, double %112, double 1.000000e+00
  %125 = fdiv double %121, %124
  %126 = tail call double @llvm.fabs.f64(double %125)
  %127 = fcmp olt double %126, 0x3EB0C6F7A0B5ED8D
  br i1 %127, label %132, label %128

128:                                              ; preds = %111
  %129 = load i32, ptr @current_test, align 4, !tbaa !11
  %130 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %129) #12
  %131 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %132

132:                                              ; preds = %128, %111
  %133 = phi i32 [ %13, %111 ], [ %131, %128 ]
  %134 = add nuw nsw i32 %14, 1
  %135 = icmp slt i32 %134, %133
  br i1 %135, label %12, label %136, !llvm.loop !245

136:                                              ; preds = %132, %3
  %137 = tail call i64 @clock() #15
  store i64 %137, ptr @end_time, align 8, !tbaa !23
  %138 = load i64, ptr @start_time, align 8, !tbaa !23
  %139 = sub nsw i64 %137, %138
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %141, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi3EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_Z29test_while_loop_unroll_factorILi1EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull @temp_string) #12
  tail call void @_Z29test_while_loop_unroll_factorILi2EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 1)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi3EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 2)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi4EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %106

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -3
  %9 = icmp sgt i32 %1, 3
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %102, %7
  %13 = phi i32 [ %5, %7 ], [ %103, %102 ]
  %14 = phi i32 [ 0, %7 ], [ %104, %102 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %64, %23 ]
  %.lcssa = phi i64 [ %65, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %81

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %67

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %65, %23 ], [ 0, %12 ]
  %25 = phi double [ %64, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = or i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = or i64 %24, 2
  %46 = getelementptr inbounds double, ptr %0, i64 %45
  %47 = load double, ptr %46, align 8, !tbaa !17
  %48 = fadd double %47, 1.234500e+04
  %49 = tail call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %44, %53
  %55 = or i64 %24, 3
  %56 = getelementptr inbounds double, ptr %0, i64 %55
  %57 = load double, ptr %56, align 8, !tbaa !17
  %58 = fadd double %57, 1.234500e+04
  %59 = tail call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %54, %63
  %65 = add nuw nsw i64 %24, 4
  %66 = icmp slt i64 %65, %10
  br i1 %66, label %23, label %15, !llvm.loop !246

67:                                               ; preds = %67, %21
  %68 = phi i64 [ %22, %21 ], [ %79, %67 ]
  %69 = phi double [ %18, %21 ], [ %78, %67 ]
  %70 = getelementptr inbounds double, ptr %0, i64 %68
  %71 = load double, ptr %70, align 8, !tbaa !17
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %75, 1.234500e+04
  %77 = tail call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %69, %77
  %79 = add nuw nsw i64 %68, 1
  %80 = icmp eq i64 %79, %11
  br i1 %80, label %81, label %67, !llvm.loop !247

81:                                               ; preds = %67, %17
  %82 = phi double [ %18, %17 ], [ %78, %67 ]
  %83 = load double, ptr @init_value, align 8, !tbaa !17
  %84 = fadd double %83, 1.234500e+04
  %85 = tail call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %85, 1.234500e+04
  %87 = tail call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %87, 1.234500e+04
  %89 = tail call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fmul double %89, 8.000000e+03
  %91 = fsub double %82, %90
  %92 = tail call double @llvm.fabs.f64(double %82)
  %93 = fcmp ogt double %92, 1.000000e-08
  %94 = select i1 %93, double %82, double 1.000000e+00
  %95 = fdiv double %91, %94
  %96 = tail call double @llvm.fabs.f64(double %95)
  %97 = fcmp olt double %96, 0x3EB0C6F7A0B5ED8D
  br i1 %97, label %102, label %98

98:                                               ; preds = %81
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %99) #12
  %101 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %102

102:                                              ; preds = %98, %81
  %103 = phi i32 [ %13, %81 ], [ %101, %98 ]
  %104 = add nuw nsw i32 %14, 1
  %105 = icmp slt i32 %104, %103
  br i1 %105, label %12, label %106, !llvm.loop !248

106:                                              ; preds = %102, %3
  %107 = tail call i64 @clock() #15
  store i64 %107, ptr @end_time, align 8, !tbaa !23
  %108 = load i64, ptr @start_time, align 8, !tbaa !23
  %109 = sub nsw i64 %107, %108
  %110 = sitofp i64 %109 to double
  %111 = fdiv double %110, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %111, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi5EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %116

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -4
  %9 = icmp sgt i32 %1, 4
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %112, %7
  %13 = phi i32 [ %5, %7 ], [ %113, %112 ]
  %14 = phi i32 [ 0, %7 ], [ %114, %112 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %74, %23 ]
  %.lcssa = phi i64 [ %75, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %91

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %77

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %75, %23 ], [ 0, %12 ]
  %25 = phi double [ %74, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = add nuw nsw i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = add nuw nsw i64 %24, 2
  %46 = getelementptr inbounds double, ptr %0, i64 %45
  %47 = load double, ptr %46, align 8, !tbaa !17
  %48 = fadd double %47, 1.234500e+04
  %49 = tail call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %44, %53
  %55 = add nuw nsw i64 %24, 3
  %56 = getelementptr inbounds double, ptr %0, i64 %55
  %57 = load double, ptr %56, align 8, !tbaa !17
  %58 = fadd double %57, 1.234500e+04
  %59 = tail call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %54, %63
  %65 = add nuw nsw i64 %24, 4
  %66 = getelementptr inbounds double, ptr %0, i64 %65
  %67 = load double, ptr %66, align 8, !tbaa !17
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %64, %73
  %75 = add nuw nsw i64 %24, 5
  %76 = icmp slt i64 %75, %10
  br i1 %76, label %23, label %15, !llvm.loop !249

77:                                               ; preds = %77, %21
  %78 = phi i64 [ %22, %21 ], [ %89, %77 ]
  %79 = phi double [ %18, %21 ], [ %88, %77 ]
  %80 = getelementptr inbounds double, ptr %0, i64 %78
  %81 = load double, ptr %80, align 8, !tbaa !17
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %83, 1.234500e+04
  %85 = tail call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %85, 1.234500e+04
  %87 = tail call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %79, %87
  %89 = add nuw nsw i64 %78, 1
  %90 = icmp eq i64 %89, %11
  br i1 %90, label %91, label %77, !llvm.loop !250

91:                                               ; preds = %77, %17
  %92 = phi double [ %18, %17 ], [ %88, %77 ]
  %93 = load double, ptr @init_value, align 8, !tbaa !17
  %94 = fadd double %93, 1.234500e+04
  %95 = tail call double @llvm.fmuladd.f64(double %94, double 9.142370e+05, double -1.300000e+01)
  %96 = fadd double %95, 1.234500e+04
  %97 = tail call double @llvm.fmuladd.f64(double %96, double 9.142370e+05, double -1.300000e+01)
  %98 = fadd double %97, 1.234500e+04
  %99 = tail call double @llvm.fmuladd.f64(double %98, double 9.142370e+05, double -1.300000e+01)
  %100 = fmul double %99, 8.000000e+03
  %101 = fsub double %92, %100
  %102 = tail call double @llvm.fabs.f64(double %92)
  %103 = fcmp ogt double %102, 1.000000e-08
  %104 = select i1 %103, double %92, double 1.000000e+00
  %105 = fdiv double %101, %104
  %106 = tail call double @llvm.fabs.f64(double %105)
  %107 = fcmp olt double %106, 0x3EB0C6F7A0B5ED8D
  br i1 %107, label %112, label %108

108:                                              ; preds = %91
  %109 = load i32, ptr @current_test, align 4, !tbaa !11
  %110 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %109) #12
  %111 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %112

112:                                              ; preds = %108, %91
  %113 = phi i32 [ %13, %91 ], [ %111, %108 ]
  %114 = add nuw nsw i32 %14, 1
  %115 = icmp slt i32 %114, %113
  br i1 %115, label %12, label %116, !llvm.loop !251

116:                                              ; preds = %112, %3
  %117 = tail call i64 @clock() #15
  store i64 %117, ptr @end_time, align 8, !tbaa !23
  %118 = load i64, ptr @start_time, align 8, !tbaa !23
  %119 = sub nsw i64 %117, %118
  %120 = sitofp i64 %119 to double
  %121 = fdiv double %120, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %121, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi1EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %52

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 0
  %9 = zext i32 %1 to i64
  br label %10

10:                                               ; preds = %48, %7
  %11 = phi i32 [ %5, %7 ], [ %49, %48 ]
  %12 = phi i32 [ 0, %7 ], [ %50, %48 ]
  br i1 %8, label %13, label %27

13:                                               ; preds = %13, %10
  %14 = phi i64 [ %25, %13 ], [ 0, %10 ]
  %15 = phi double [ %24, %13 ], [ 0.000000e+00, %10 ]
  %16 = getelementptr inbounds double, ptr %0, i64 %14
  %17 = load double, ptr %16, align 8, !tbaa !17
  %18 = fadd double %17, 1.234500e+04
  %19 = tail call double @llvm.fmuladd.f64(double %18, double 9.142370e+05, double -1.300000e+01)
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %15, %23
  %25 = add nuw nsw i64 %14, 1
  %26 = icmp eq i64 %25, %9
  br i1 %26, label %27, label %13, !llvm.loop !252

27:                                               ; preds = %13, %10
  %28 = phi double [ 0.000000e+00, %10 ], [ %24, %13 ]
  %29 = load double, ptr @init_value, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fmul double %35, 8.000000e+03
  %37 = fsub double %28, %36
  %38 = tail call double @llvm.fabs.f64(double %28)
  %39 = fcmp ogt double %38, 1.000000e-08
  %40 = select i1 %39, double %28, double 1.000000e+00
  %41 = fdiv double %37, %40
  %42 = tail call double @llvm.fabs.f64(double %41)
  %43 = fcmp olt double %42, 0x3EB0C6F7A0B5ED8D
  br i1 %43, label %48, label %44

44:                                               ; preds = %27
  %45 = load i32, ptr @current_test, align 4, !tbaa !11
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %45) #12
  %47 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %48

48:                                               ; preds = %44, %27
  %49 = phi i32 [ %11, %27 ], [ %47, %44 ]
  %50 = add nuw nsw i32 %12, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %10, label %52, !llvm.loop !253

52:                                               ; preds = %48, %3
  %53 = tail call i64 @clock() #15
  store i64 %53, ptr @end_time, align 8, !tbaa !23
  %54 = load i64, ptr @start_time, align 8, !tbaa !23
  %55 = sub nsw i64 %53, %54
  %56 = sitofp i64 %55 to double
  %57 = fdiv double %56, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %57, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi2EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %86

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -1
  %9 = icmp sgt i32 %1, 1
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %82, %7
  %13 = phi i32 [ %5, %7 ], [ %83, %82 ]
  %14 = phi i32 [ 0, %7 ], [ %84, %82 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %44, %23 ]
  %.lcssa = phi i64 [ %45, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %61

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %47

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %45, %23 ], [ 0, %12 ]
  %25 = phi double [ %44, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = or i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = add nuw nsw i64 %24, 2
  %46 = icmp slt i64 %45, %10
  br i1 %46, label %23, label %15, !llvm.loop !254

47:                                               ; preds = %47, %21
  %48 = phi i64 [ %22, %21 ], [ %59, %47 ]
  %49 = phi double [ %18, %21 ], [ %58, %47 ]
  %50 = getelementptr inbounds double, ptr %0, i64 %48
  %51 = load double, ptr %50, align 8, !tbaa !17
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %55, 1.234500e+04
  %57 = tail call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %49, %57
  %59 = add nuw nsw i64 %48, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %47, !llvm.loop !255

61:                                               ; preds = %47, %17
  %62 = phi double [ %18, %17 ], [ %58, %47 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !17
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %65, 1.234500e+04
  %67 = tail call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fmul double %69, 8.000000e+03
  %71 = fsub double %62, %70
  %72 = tail call double @llvm.fabs.f64(double %62)
  %73 = fcmp ogt double %72, 1.000000e-08
  %74 = select i1 %73, double %62, double 1.000000e+00
  %75 = fdiv double %71, %74
  %76 = tail call double @llvm.fabs.f64(double %75)
  %77 = fcmp olt double %76, 0x3EB0C6F7A0B5ED8D
  br i1 %77, label %82, label %78

78:                                               ; preds = %61
  %79 = load i32, ptr @current_test, align 4, !tbaa !11
  %80 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %79) #12
  %81 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %82

82:                                               ; preds = %78, %61
  %83 = phi i32 [ %13, %61 ], [ %81, %78 ]
  %84 = add nuw nsw i32 %14, 1
  %85 = icmp slt i32 %84, %83
  br i1 %85, label %12, label %86, !llvm.loop !256

86:                                               ; preds = %82, %3
  %87 = tail call i64 @clock() #15
  store i64 %87, ptr @end_time, align 8, !tbaa !23
  %88 = load i64, ptr @start_time, align 8, !tbaa !23
  %89 = sub nsw i64 %87, %88
  %90 = sitofp i64 %89 to double
  %91 = fdiv double %90, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %91, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi3EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %96

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -2
  %9 = icmp sgt i32 %1, 2
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %92, %7
  %13 = phi i32 [ %5, %7 ], [ %93, %92 ]
  %14 = phi i32 [ 0, %7 ], [ %94, %92 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %54, %23 ]
  %.lcssa = phi i64 [ %55, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %71

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %57

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %55, %23 ], [ 0, %12 ]
  %25 = phi double [ %54, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = add nuw nsw i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = add nuw nsw i64 %24, 2
  %46 = getelementptr inbounds double, ptr %0, i64 %45
  %47 = load double, ptr %46, align 8, !tbaa !17
  %48 = fadd double %47, 1.234500e+04
  %49 = tail call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %44, %53
  %55 = add nuw nsw i64 %24, 3
  %56 = icmp slt i64 %55, %10
  br i1 %56, label %23, label %15, !llvm.loop !257

57:                                               ; preds = %57, %21
  %58 = phi i64 [ %22, %21 ], [ %69, %57 ]
  %59 = phi double [ %18, %21 ], [ %68, %57 ]
  %60 = getelementptr inbounds double, ptr %0, i64 %58
  %61 = load double, ptr %60, align 8, !tbaa !17
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %65, 1.234500e+04
  %67 = tail call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %59, %67
  %69 = add nuw nsw i64 %58, 1
  %70 = icmp eq i64 %69, %11
  br i1 %70, label %71, label %57, !llvm.loop !258

71:                                               ; preds = %57, %17
  %72 = phi double [ %18, %17 ], [ %68, %57 ]
  %73 = load double, ptr @init_value, align 8, !tbaa !17
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %75, 1.234500e+04
  %77 = tail call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %77, 1.234500e+04
  %79 = tail call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fmul double %79, 8.000000e+03
  %81 = fsub double %72, %80
  %82 = tail call double @llvm.fabs.f64(double %72)
  %83 = fcmp ogt double %82, 1.000000e-08
  %84 = select i1 %83, double %72, double 1.000000e+00
  %85 = fdiv double %81, %84
  %86 = tail call double @llvm.fabs.f64(double %85)
  %87 = fcmp olt double %86, 0x3EB0C6F7A0B5ED8D
  br i1 %87, label %92, label %88

88:                                               ; preds = %71
  %89 = load i32, ptr @current_test, align 4, !tbaa !11
  %90 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %89) #12
  %91 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %92

92:                                               ; preds = %88, %71
  %93 = phi i32 [ %13, %71 ], [ %91, %88 ]
  %94 = add nuw nsw i32 %14, 1
  %95 = icmp slt i32 %94, %93
  br i1 %95, label %12, label %96, !llvm.loop !259

96:                                               ; preds = %92, %3
  %97 = tail call i64 @clock() #15
  store i64 %97, ptr @end_time, align 8, !tbaa !23
  %98 = load i64, ptr @start_time, align 8, !tbaa !23
  %99 = sub nsw i64 %97, %98
  %100 = sitofp i64 %99 to double
  %101 = fdiv double %100, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %101, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi29EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi27EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi28EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 27)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi29EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 28)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi30EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -29
  %10 = icmp sgt i32 %1, 29
  br label %11

11:                                               ; preds = %82, %8
  %12 = phi i32 [ 0, %8 ], [ %83, %82 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %42, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %44, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %62

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %46

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %43, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 28
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 29
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  store double %42, ptr %4, align 8, !tbaa !17
  %43 = add nuw i64 %20, 30
  %44 = trunc i64 %43 to i32
  %45 = icmp sgt i32 %9, %44
  br i1 %45, label %19, label %13, !llvm.loop !260

46:                                               ; preds = %46, %17
  %47 = phi i64 [ %18, %17 ], [ %58, %46 ]
  %48 = phi double [ %14, %17 ], [ %57, %46 ]
  %49 = getelementptr inbounds double, ptr %0, i64 %47
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %48, %56
  %58 = add nuw nsw i64 %47, 1
  %59 = trunc i64 %58 to i32
  %60 = icmp slt i32 %59, %1
  br i1 %60, label %46, label %61, !llvm.loop !261

61:                                               ; preds = %46
  %.lcssa = phi double [ %57, %46 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %62

62:                                               ; preds = %61, %13
  %63 = phi double [ %.lcssa, %61 ], [ %14, %13 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !17
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %66, 1.234500e+04
  %68 = call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fmul double %70, 8.000000e+03
  %72 = fsub double %63, %71
  %73 = call double @llvm.fabs.f64(double %63)
  %74 = fcmp ogt double %73, 1.000000e-08
  %75 = select i1 %74, double %63, double 1.000000e+00
  %76 = fdiv double %72, %75
  %77 = call double @llvm.fabs.f64(double %76)
  %78 = fcmp olt double %77, 0x3EB0C6F7A0B5ED8D
  br i1 %78, label %82, label %79

79:                                               ; preds = %62
  %80 = load i32, ptr @current_test, align 4, !tbaa !11
  %81 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %80) #12
  br label %82

82:                                               ; preds = %79, %62
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %83 = add nuw nsw i32 %12, 1
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  %85 = icmp slt i32 %83, %84
  br i1 %85, label %11, label %86, !llvm.loop !262

86:                                               ; preds = %82, %3
  %87 = call i64 @clock() #15
  store i64 %87, ptr @end_time, align 8, !tbaa !23
  %88 = load i64, ptr @start_time, align 8, !tbaa !23
  %89 = sub nsw i64 %87, %88
  %90 = sitofp i64 %89 to double
  %91 = fdiv double %90, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %91, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi31EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %96

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -30
  %10 = icmp sgt i32 %1, 30
  br label %11

11:                                               ; preds = %92, %8
  %12 = phi i32 [ 0, %8 ], [ %93, %92 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %52, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %54, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %72

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %56

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %53, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 28
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 29
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = add nuw nsw i64 %20, 30
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  store double %52, ptr %4, align 8, !tbaa !17
  %53 = add nuw i64 %20, 31
  %54 = trunc i64 %53 to i32
  %55 = icmp sgt i32 %9, %54
  br i1 %55, label %19, label %13, !llvm.loop !263

56:                                               ; preds = %56, %17
  %57 = phi i64 [ %18, %17 ], [ %68, %56 ]
  %58 = phi double [ %14, %17 ], [ %67, %56 ]
  %59 = getelementptr inbounds double, ptr %0, i64 %57
  %60 = load double, ptr %59, align 8, !tbaa !17
  %61 = fadd double %60, 1.234500e+04
  %62 = call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %58, %66
  %68 = add nuw nsw i64 %57, 1
  %69 = trunc i64 %68 to i32
  %70 = icmp slt i32 %69, %1
  br i1 %70, label %56, label %71, !llvm.loop !264

71:                                               ; preds = %56
  %.lcssa = phi double [ %67, %56 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %72

72:                                               ; preds = %71, %13
  %73 = phi double [ %.lcssa, %71 ], [ %14, %13 ]
  %74 = load double, ptr @init_value, align 8, !tbaa !17
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %76, 1.234500e+04
  %78 = call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fmul double %80, 8.000000e+03
  %82 = fsub double %73, %81
  %83 = call double @llvm.fabs.f64(double %73)
  %84 = fcmp ogt double %83, 1.000000e-08
  %85 = select i1 %84, double %73, double 1.000000e+00
  %86 = fdiv double %82, %85
  %87 = call double @llvm.fabs.f64(double %86)
  %88 = fcmp olt double %87, 0x3EB0C6F7A0B5ED8D
  br i1 %88, label %92, label %89

89:                                               ; preds = %72
  %90 = load i32, ptr @current_test, align 4, !tbaa !11
  %91 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %90) #12
  br label %92

92:                                               ; preds = %89, %72
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %93 = add nuw nsw i32 %12, 1
  %94 = load i32, ptr @iterations, align 4, !tbaa !11
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %11, label %96, !llvm.loop !265

96:                                               ; preds = %92, %3
  %97 = call i64 @clock() #15
  store i64 %97, ptr @end_time, align 8, !tbaa !23
  %98 = load i64, ptr @start_time, align 8, !tbaa !23
  %99 = sub nsw i64 %97, %98
  %100 = sitofp i64 %99 to double
  %101 = fdiv double %100, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %101, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi27EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi25EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi26EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 25)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi27EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 26)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi28EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %65

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -27
  %10 = icmp sgt i32 %1, 27
  br label %11

11:                                               ; preds = %61, %8
  %12 = phi i32 [ 0, %8 ], [ %62, %61 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %21, label %15

13:                                               ; preds = %21
  %.lcssa = phi i32 [ %23, %21 ]
  %14 = load double, ptr %4, align 8, !tbaa !17
  br label %15

15:                                               ; preds = %13, %11
  %16 = phi double [ 0.000000e+00, %11 ], [ %14, %13 ]
  %17 = phi i32 [ 0, %11 ], [ %.lcssa, %13 ]
  %18 = icmp slt i32 %17, %1
  br i1 %18, label %19, label %41

19:                                               ; preds = %15
  %20 = zext i32 %17 to i64
  br label %25

21:                                               ; preds = %21, %11
  %22 = phi i32 [ %23, %21 ], [ 0, %11 ]
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %22) #12
  %23 = add nuw nsw i32 %22, 28
  %24 = icmp slt i32 %23, %9
  br i1 %24, label %21, label %13, !llvm.loop !266

25:                                               ; preds = %25, %19
  %26 = phi i64 [ %20, %19 ], [ %37, %25 ]
  %27 = phi double [ %16, %19 ], [ %36, %25 ]
  %28 = getelementptr inbounds double, ptr %0, i64 %26
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %27, %35
  %37 = add nuw nsw i64 %26, 1
  %38 = trunc i64 %37 to i32
  %39 = icmp eq i32 %38, %1
  br i1 %39, label %40, label %25, !llvm.loop !267

40:                                               ; preds = %25
  %.lcssa1 = phi double [ %36, %25 ]
  store double %.lcssa1, ptr %4, align 8, !tbaa !17
  br label %41

41:                                               ; preds = %40, %15
  %42 = phi double [ %.lcssa1, %40 ], [ %16, %15 ]
  %43 = load double, ptr @init_value, align 8, !tbaa !17
  %44 = fadd double %43, 1.234500e+04
  %45 = call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fmul double %49, 8.000000e+03
  %51 = fsub double %42, %50
  %52 = call double @llvm.fabs.f64(double %42)
  %53 = fcmp ogt double %52, 1.000000e-08
  %54 = select i1 %53, double %42, double 1.000000e+00
  %55 = fdiv double %51, %54
  %56 = call double @llvm.fabs.f64(double %55)
  %57 = fcmp olt double %56, 0x3EB0C6F7A0B5ED8D
  br i1 %57, label %61, label %58

58:                                               ; preds = %41
  %59 = load i32, ptr @current_test, align 4, !tbaa !11
  %60 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %59) #12
  br label %61

61:                                               ; preds = %58, %41
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %62 = add nuw nsw i32 %12, 1
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  %64 = icmp slt i32 %62, %63
  br i1 %64, label %11, label %65, !llvm.loop !268

65:                                               ; preds = %61, %3
  %66 = call i64 @clock() #15
  store i64 %66, ptr @end_time, align 8, !tbaa !23
  %67 = load i64, ptr @start_time, align 8, !tbaa !23
  %68 = sub nsw i64 %66, %67
  %69 = sitofp i64 %68 to double
  %70 = fdiv double %69, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %70, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi29EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %76

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -28
  %10 = icmp sgt i32 %1, 28
  br label %11

11:                                               ; preds = %72, %8
  %12 = phi i32 [ 0, %8 ], [ %73, %72 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %32, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %34, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %52

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %36

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %33, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi28EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 28
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  store double %32, ptr %4, align 8, !tbaa !17
  %33 = add nuw i64 %20, 29
  %34 = trunc i64 %33 to i32
  %35 = icmp sgt i32 %9, %34
  br i1 %35, label %19, label %13, !llvm.loop !269

36:                                               ; preds = %36, %17
  %37 = phi i64 [ %18, %17 ], [ %48, %36 ]
  %38 = phi double [ %14, %17 ], [ %47, %36 ]
  %39 = getelementptr inbounds double, ptr %0, i64 %37
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %38, %46
  %48 = add nuw nsw i64 %37, 1
  %49 = trunc i64 %48 to i32
  %50 = icmp slt i32 %49, %1
  br i1 %50, label %36, label %51, !llvm.loop !270

51:                                               ; preds = %36
  %.lcssa = phi double [ %47, %36 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %52

52:                                               ; preds = %51, %13
  %53 = phi double [ %.lcssa, %51 ], [ %14, %13 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %56, 1.234500e+04
  %58 = call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fmul double %60, 8.000000e+03
  %62 = fsub double %53, %61
  %63 = call double @llvm.fabs.f64(double %53)
  %64 = fcmp ogt double %63, 1.000000e-08
  %65 = select i1 %64, double %53, double 1.000000e+00
  %66 = fdiv double %62, %65
  %67 = call double @llvm.fabs.f64(double %66)
  %68 = fcmp olt double %67, 0x3EB0C6F7A0B5ED8D
  br i1 %68, label %72, label %69

69:                                               ; preds = %52
  %70 = load i32, ptr @current_test, align 4, !tbaa !11
  %71 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %70) #12
  br label %72

72:                                               ; preds = %69, %52
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %73 = add nuw nsw i32 %12, 1
  %74 = load i32, ptr @iterations, align 4, !tbaa !11
  %75 = icmp slt i32 %73, %74
  br i1 %75, label %11, label %76, !llvm.loop !271

76:                                               ; preds = %72, %3
  %77 = call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi25EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi23EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi24EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 23)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi25EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 24)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi26EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %136

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -25
  %10 = icmp sgt i32 %1, 25
  br label %11

11:                                               ; preds = %132, %8
  %12 = phi i32 [ 0, %8 ], [ %133, %132 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %92, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %94, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %112

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %96

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %93, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 20
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = add nuw nsw i64 %20, 21
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  %53 = add nuw nsw i64 %20, 22
  %54 = getelementptr inbounds double, ptr %0, i64 %53
  %55 = load double, ptr %54, align 8, !tbaa !17
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %57, 1.234500e+04
  %59 = call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %52, %61
  %63 = add nuw nsw i64 %20, 23
  %64 = getelementptr inbounds double, ptr %0, i64 %63
  %65 = load double, ptr %64, align 8, !tbaa !17
  %66 = fadd double %65, 1.234500e+04
  %67 = call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %67, 1.234500e+04
  %69 = call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %62, %71
  %73 = add nuw nsw i64 %20, 24
  %74 = getelementptr inbounds double, ptr %0, i64 %73
  %75 = load double, ptr %74, align 8, !tbaa !17
  %76 = fadd double %75, 1.234500e+04
  %77 = call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %77, 1.234500e+04
  %79 = call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fadd double %79, 1.234500e+04
  %81 = call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %72, %81
  %83 = add nuw nsw i64 %20, 25
  %84 = getelementptr inbounds double, ptr %0, i64 %83
  %85 = load double, ptr %84, align 8, !tbaa !17
  %86 = fadd double %85, 1.234500e+04
  %87 = call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %87, 1.234500e+04
  %89 = call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fadd double %89, 1.234500e+04
  %91 = call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %82, %91
  store double %92, ptr %4, align 8, !tbaa !17
  %93 = add nuw i64 %20, 26
  %94 = trunc i64 %93 to i32
  %95 = icmp sgt i32 %9, %94
  br i1 %95, label %19, label %13, !llvm.loop !272

96:                                               ; preds = %96, %17
  %97 = phi i64 [ %18, %17 ], [ %108, %96 ]
  %98 = phi double [ %14, %17 ], [ %107, %96 ]
  %99 = getelementptr inbounds double, ptr %0, i64 %97
  %100 = load double, ptr %99, align 8, !tbaa !17
  %101 = fadd double %100, 1.234500e+04
  %102 = call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %102, 1.234500e+04
  %104 = call double @llvm.fmuladd.f64(double %103, double 9.142370e+05, double -1.300000e+01)
  %105 = fadd double %104, 1.234500e+04
  %106 = call double @llvm.fmuladd.f64(double %105, double 9.142370e+05, double -1.300000e+01)
  %107 = fadd double %98, %106
  %108 = add nuw nsw i64 %97, 1
  %109 = trunc i64 %108 to i32
  %110 = icmp slt i32 %109, %1
  br i1 %110, label %96, label %111, !llvm.loop !273

111:                                              ; preds = %96
  %.lcssa = phi double [ %107, %96 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %112

112:                                              ; preds = %111, %13
  %113 = phi double [ %.lcssa, %111 ], [ %14, %13 ]
  %114 = load double, ptr @init_value, align 8, !tbaa !17
  %115 = fadd double %114, 1.234500e+04
  %116 = call double @llvm.fmuladd.f64(double %115, double 9.142370e+05, double -1.300000e+01)
  %117 = fadd double %116, 1.234500e+04
  %118 = call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fmul double %120, 8.000000e+03
  %122 = fsub double %113, %121
  %123 = call double @llvm.fabs.f64(double %113)
  %124 = fcmp ogt double %123, 1.000000e-08
  %125 = select i1 %124, double %113, double 1.000000e+00
  %126 = fdiv double %122, %125
  %127 = call double @llvm.fabs.f64(double %126)
  %128 = fcmp olt double %127, 0x3EB0C6F7A0B5ED8D
  br i1 %128, label %132, label %129

129:                                              ; preds = %112
  %130 = load i32, ptr @current_test, align 4, !tbaa !11
  %131 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %130) #12
  br label %132

132:                                              ; preds = %129, %112
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %133 = add nuw nsw i32 %12, 1
  %134 = load i32, ptr @iterations, align 4, !tbaa !11
  %135 = icmp slt i32 %133, %134
  br i1 %135, label %11, label %136, !llvm.loop !274

136:                                              ; preds = %132, %3
  %137 = call i64 @clock() #15
  store i64 %137, ptr @end_time, align 8, !tbaa !23
  %138 = load i64, ptr @start_time, align 8, !tbaa !23
  %139 = sub nsw i64 %137, %138
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %141, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi27EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %146

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -26
  %10 = icmp sgt i32 %1, 26
  br label %11

11:                                               ; preds = %142, %8
  %12 = phi i32 [ 0, %8 ], [ %143, %142 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %102, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %104, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %122

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %106

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %103, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 20
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = add nuw nsw i64 %20, 21
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  %53 = add nuw nsw i64 %20, 22
  %54 = getelementptr inbounds double, ptr %0, i64 %53
  %55 = load double, ptr %54, align 8, !tbaa !17
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %57, 1.234500e+04
  %59 = call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %52, %61
  %63 = add nuw nsw i64 %20, 23
  %64 = getelementptr inbounds double, ptr %0, i64 %63
  %65 = load double, ptr %64, align 8, !tbaa !17
  %66 = fadd double %65, 1.234500e+04
  %67 = call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %67, 1.234500e+04
  %69 = call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %62, %71
  %73 = add nuw nsw i64 %20, 24
  %74 = getelementptr inbounds double, ptr %0, i64 %73
  %75 = load double, ptr %74, align 8, !tbaa !17
  %76 = fadd double %75, 1.234500e+04
  %77 = call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %77, 1.234500e+04
  %79 = call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fadd double %79, 1.234500e+04
  %81 = call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %72, %81
  %83 = add nuw nsw i64 %20, 25
  %84 = getelementptr inbounds double, ptr %0, i64 %83
  %85 = load double, ptr %84, align 8, !tbaa !17
  %86 = fadd double %85, 1.234500e+04
  %87 = call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %87, 1.234500e+04
  %89 = call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fadd double %89, 1.234500e+04
  %91 = call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %82, %91
  %93 = add nuw nsw i64 %20, 26
  %94 = getelementptr inbounds double, ptr %0, i64 %93
  %95 = load double, ptr %94, align 8, !tbaa !17
  %96 = fadd double %95, 1.234500e+04
  %97 = call double @llvm.fmuladd.f64(double %96, double 9.142370e+05, double -1.300000e+01)
  %98 = fadd double %97, 1.234500e+04
  %99 = call double @llvm.fmuladd.f64(double %98, double 9.142370e+05, double -1.300000e+01)
  %100 = fadd double %99, 1.234500e+04
  %101 = call double @llvm.fmuladd.f64(double %100, double 9.142370e+05, double -1.300000e+01)
  %102 = fadd double %92, %101
  store double %102, ptr %4, align 8, !tbaa !17
  %103 = add nuw i64 %20, 27
  %104 = trunc i64 %103 to i32
  %105 = icmp sgt i32 %9, %104
  br i1 %105, label %19, label %13, !llvm.loop !275

106:                                              ; preds = %106, %17
  %107 = phi i64 [ %18, %17 ], [ %118, %106 ]
  %108 = phi double [ %14, %17 ], [ %117, %106 ]
  %109 = getelementptr inbounds double, ptr %0, i64 %107
  %110 = load double, ptr %109, align 8, !tbaa !17
  %111 = fadd double %110, 1.234500e+04
  %112 = call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %112, 1.234500e+04
  %114 = call double @llvm.fmuladd.f64(double %113, double 9.142370e+05, double -1.300000e+01)
  %115 = fadd double %114, 1.234500e+04
  %116 = call double @llvm.fmuladd.f64(double %115, double 9.142370e+05, double -1.300000e+01)
  %117 = fadd double %108, %116
  %118 = add nuw nsw i64 %107, 1
  %119 = trunc i64 %118 to i32
  %120 = icmp slt i32 %119, %1
  br i1 %120, label %106, label %121, !llvm.loop !276

121:                                              ; preds = %106
  %.lcssa = phi double [ %117, %106 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %122

122:                                              ; preds = %121, %13
  %123 = phi double [ %.lcssa, %121 ], [ %14, %13 ]
  %124 = load double, ptr @init_value, align 8, !tbaa !17
  %125 = fadd double %124, 1.234500e+04
  %126 = call double @llvm.fmuladd.f64(double %125, double 9.142370e+05, double -1.300000e+01)
  %127 = fadd double %126, 1.234500e+04
  %128 = call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fmul double %130, 8.000000e+03
  %132 = fsub double %123, %131
  %133 = call double @llvm.fabs.f64(double %123)
  %134 = fcmp ogt double %133, 1.000000e-08
  %135 = select i1 %134, double %123, double 1.000000e+00
  %136 = fdiv double %132, %135
  %137 = call double @llvm.fabs.f64(double %136)
  %138 = fcmp olt double %137, 0x3EB0C6F7A0B5ED8D
  br i1 %138, label %142, label %139

139:                                              ; preds = %122
  %140 = load i32, ptr @current_test, align 4, !tbaa !11
  %141 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %140) #12
  br label %142

142:                                              ; preds = %139, %122
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %143 = add nuw nsw i32 %12, 1
  %144 = load i32, ptr @iterations, align 4, !tbaa !11
  %145 = icmp slt i32 %143, %144
  br i1 %145, label %11, label %146, !llvm.loop !277

146:                                              ; preds = %142, %3
  %147 = call i64 @clock() #15
  store i64 %147, ptr @end_time, align 8, !tbaa !23
  %148 = load i64, ptr @start_time, align 8, !tbaa !23
  %149 = sub nsw i64 %147, %148
  %150 = sitofp i64 %149 to double
  %151 = fdiv double %150, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %151, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi23EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi21EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi22EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 21)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi23EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 22)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi24EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %116

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -23
  %10 = icmp sgt i32 %1, 23
  br label %11

11:                                               ; preds = %112, %8
  %12 = phi i32 [ 0, %8 ], [ %113, %112 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %72, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %74, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %92

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %76

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %73, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 20
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = add nuw nsw i64 %20, 21
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  %53 = add nuw nsw i64 %20, 22
  %54 = getelementptr inbounds double, ptr %0, i64 %53
  %55 = load double, ptr %54, align 8, !tbaa !17
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %57, 1.234500e+04
  %59 = call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %52, %61
  %63 = add nuw nsw i64 %20, 23
  %64 = getelementptr inbounds double, ptr %0, i64 %63
  %65 = load double, ptr %64, align 8, !tbaa !17
  %66 = fadd double %65, 1.234500e+04
  %67 = call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %67, 1.234500e+04
  %69 = call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %62, %71
  store double %72, ptr %4, align 8, !tbaa !17
  %73 = add nuw i64 %20, 24
  %74 = trunc i64 %73 to i32
  %75 = icmp sgt i32 %9, %74
  br i1 %75, label %19, label %13, !llvm.loop !278

76:                                               ; preds = %76, %17
  %77 = phi i64 [ %18, %17 ], [ %88, %76 ]
  %78 = phi double [ %14, %17 ], [ %87, %76 ]
  %79 = getelementptr inbounds double, ptr %0, i64 %77
  %80 = load double, ptr %79, align 8, !tbaa !17
  %81 = fadd double %80, 1.234500e+04
  %82 = call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %82, 1.234500e+04
  %84 = call double @llvm.fmuladd.f64(double %83, double 9.142370e+05, double -1.300000e+01)
  %85 = fadd double %84, 1.234500e+04
  %86 = call double @llvm.fmuladd.f64(double %85, double 9.142370e+05, double -1.300000e+01)
  %87 = fadd double %78, %86
  %88 = add nuw nsw i64 %77, 1
  %89 = trunc i64 %88 to i32
  %90 = icmp slt i32 %89, %1
  br i1 %90, label %76, label %91, !llvm.loop !279

91:                                               ; preds = %76
  %.lcssa = phi double [ %87, %76 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %92

92:                                               ; preds = %91, %13
  %93 = phi double [ %.lcssa, %91 ], [ %14, %13 ]
  %94 = load double, ptr @init_value, align 8, !tbaa !17
  %95 = fadd double %94, 1.234500e+04
  %96 = call double @llvm.fmuladd.f64(double %95, double 9.142370e+05, double -1.300000e+01)
  %97 = fadd double %96, 1.234500e+04
  %98 = call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fmul double %100, 8.000000e+03
  %102 = fsub double %93, %101
  %103 = call double @llvm.fabs.f64(double %93)
  %104 = fcmp ogt double %103, 1.000000e-08
  %105 = select i1 %104, double %93, double 1.000000e+00
  %106 = fdiv double %102, %105
  %107 = call double @llvm.fabs.f64(double %106)
  %108 = fcmp olt double %107, 0x3EB0C6F7A0B5ED8D
  br i1 %108, label %112, label %109

109:                                              ; preds = %92
  %110 = load i32, ptr @current_test, align 4, !tbaa !11
  %111 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %110) #12
  br label %112

112:                                              ; preds = %109, %92
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %113 = add nuw nsw i32 %12, 1
  %114 = load i32, ptr @iterations, align 4, !tbaa !11
  %115 = icmp slt i32 %113, %114
  br i1 %115, label %11, label %116, !llvm.loop !280

116:                                              ; preds = %112, %3
  %117 = call i64 @clock() #15
  store i64 %117, ptr @end_time, align 8, !tbaa !23
  %118 = load i64, ptr @start_time, align 8, !tbaa !23
  %119 = sub nsw i64 %117, %118
  %120 = sitofp i64 %119 to double
  %121 = fdiv double %120, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %121, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi25EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %126

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -24
  %10 = icmp sgt i32 %1, 24
  br label %11

11:                                               ; preds = %122, %8
  %12 = phi i32 [ 0, %8 ], [ %123, %122 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %82, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %84, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %102

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %86

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %83, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 20
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = add nuw nsw i64 %20, 21
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  %53 = add nuw nsw i64 %20, 22
  %54 = getelementptr inbounds double, ptr %0, i64 %53
  %55 = load double, ptr %54, align 8, !tbaa !17
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %57, 1.234500e+04
  %59 = call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %52, %61
  %63 = add nuw nsw i64 %20, 23
  %64 = getelementptr inbounds double, ptr %0, i64 %63
  %65 = load double, ptr %64, align 8, !tbaa !17
  %66 = fadd double %65, 1.234500e+04
  %67 = call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %67, 1.234500e+04
  %69 = call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %62, %71
  %73 = add nuw nsw i64 %20, 24
  %74 = getelementptr inbounds double, ptr %0, i64 %73
  %75 = load double, ptr %74, align 8, !tbaa !17
  %76 = fadd double %75, 1.234500e+04
  %77 = call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %77, 1.234500e+04
  %79 = call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fadd double %79, 1.234500e+04
  %81 = call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %72, %81
  store double %82, ptr %4, align 8, !tbaa !17
  %83 = add nuw i64 %20, 25
  %84 = trunc i64 %83 to i32
  %85 = icmp sgt i32 %9, %84
  br i1 %85, label %19, label %13, !llvm.loop !281

86:                                               ; preds = %86, %17
  %87 = phi i64 [ %18, %17 ], [ %98, %86 ]
  %88 = phi double [ %14, %17 ], [ %97, %86 ]
  %89 = getelementptr inbounds double, ptr %0, i64 %87
  %90 = load double, ptr %89, align 8, !tbaa !17
  %91 = fadd double %90, 1.234500e+04
  %92 = call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %92, 1.234500e+04
  %94 = call double @llvm.fmuladd.f64(double %93, double 9.142370e+05, double -1.300000e+01)
  %95 = fadd double %94, 1.234500e+04
  %96 = call double @llvm.fmuladd.f64(double %95, double 9.142370e+05, double -1.300000e+01)
  %97 = fadd double %88, %96
  %98 = add nuw nsw i64 %87, 1
  %99 = trunc i64 %98 to i32
  %100 = icmp slt i32 %99, %1
  br i1 %100, label %86, label %101, !llvm.loop !282

101:                                              ; preds = %86
  %.lcssa = phi double [ %97, %86 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %102

102:                                              ; preds = %101, %13
  %103 = phi double [ %.lcssa, %101 ], [ %14, %13 ]
  %104 = load double, ptr @init_value, align 8, !tbaa !17
  %105 = fadd double %104, 1.234500e+04
  %106 = call double @llvm.fmuladd.f64(double %105, double 9.142370e+05, double -1.300000e+01)
  %107 = fadd double %106, 1.234500e+04
  %108 = call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fmul double %110, 8.000000e+03
  %112 = fsub double %103, %111
  %113 = call double @llvm.fabs.f64(double %103)
  %114 = fcmp ogt double %113, 1.000000e-08
  %115 = select i1 %114, double %103, double 1.000000e+00
  %116 = fdiv double %112, %115
  %117 = call double @llvm.fabs.f64(double %116)
  %118 = fcmp olt double %117, 0x3EB0C6F7A0B5ED8D
  br i1 %118, label %122, label %119

119:                                              ; preds = %102
  %120 = load i32, ptr @current_test, align 4, !tbaa !11
  %121 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %120) #12
  br label %122

122:                                              ; preds = %119, %102
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %123 = add nuw nsw i32 %12, 1
  %124 = load i32, ptr @iterations, align 4, !tbaa !11
  %125 = icmp slt i32 %123, %124
  br i1 %125, label %11, label %126, !llvm.loop !283

126:                                              ; preds = %122, %3
  %127 = call i64 @clock() #15
  store i64 %127, ptr @end_time, align 8, !tbaa !23
  %128 = load i64, ptr @start_time, align 8, !tbaa !23
  %129 = sub nsw i64 %127, %128
  %130 = sitofp i64 %129 to double
  %131 = fdiv double %130, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %131, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi21EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi19EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi20EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 19)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi21EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 20)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi22EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %96

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -21
  %10 = icmp sgt i32 %1, 21
  br label %11

11:                                               ; preds = %92, %8
  %12 = phi i32 [ 0, %8 ], [ %93, %92 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %52, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %54, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %72

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %56

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %53, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 20
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = add nuw nsw i64 %20, 21
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  store double %52, ptr %4, align 8, !tbaa !17
  %53 = add nuw i64 %20, 22
  %54 = trunc i64 %53 to i32
  %55 = icmp sgt i32 %9, %54
  br i1 %55, label %19, label %13, !llvm.loop !284

56:                                               ; preds = %56, %17
  %57 = phi i64 [ %18, %17 ], [ %68, %56 ]
  %58 = phi double [ %14, %17 ], [ %67, %56 ]
  %59 = getelementptr inbounds double, ptr %0, i64 %57
  %60 = load double, ptr %59, align 8, !tbaa !17
  %61 = fadd double %60, 1.234500e+04
  %62 = call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %62, 1.234500e+04
  %64 = call double @llvm.fmuladd.f64(double %63, double 9.142370e+05, double -1.300000e+01)
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %58, %66
  %68 = add nuw nsw i64 %57, 1
  %69 = trunc i64 %68 to i32
  %70 = icmp slt i32 %69, %1
  br i1 %70, label %56, label %71, !llvm.loop !285

71:                                               ; preds = %56
  %.lcssa = phi double [ %67, %56 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %72

72:                                               ; preds = %71, %13
  %73 = phi double [ %.lcssa, %71 ], [ %14, %13 ]
  %74 = load double, ptr @init_value, align 8, !tbaa !17
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %76, 1.234500e+04
  %78 = call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fmul double %80, 8.000000e+03
  %82 = fsub double %73, %81
  %83 = call double @llvm.fabs.f64(double %73)
  %84 = fcmp ogt double %83, 1.000000e-08
  %85 = select i1 %84, double %73, double 1.000000e+00
  %86 = fdiv double %82, %85
  %87 = call double @llvm.fabs.f64(double %86)
  %88 = fcmp olt double %87, 0x3EB0C6F7A0B5ED8D
  br i1 %88, label %92, label %89

89:                                               ; preds = %72
  %90 = load i32, ptr @current_test, align 4, !tbaa !11
  %91 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %90) #12
  br label %92

92:                                               ; preds = %89, %72
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %93 = add nuw nsw i32 %12, 1
  %94 = load i32, ptr @iterations, align 4, !tbaa !11
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %11, label %96, !llvm.loop !286

96:                                               ; preds = %92, %3
  %97 = call i64 @clock() #15
  store i64 %97, ptr @end_time, align 8, !tbaa !23
  %98 = load i64, ptr @start_time, align 8, !tbaa !23
  %99 = sub nsw i64 %97, %98
  %100 = sitofp i64 %99 to double
  %101 = fdiv double %100, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %101, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi23EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %106

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -22
  %10 = icmp sgt i32 %1, 22
  br label %11

11:                                               ; preds = %102, %8
  %12 = phi i32 [ 0, %8 ], [ %103, %102 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %62, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %64, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %82

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %66

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %63, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 20
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  %43 = add nuw nsw i64 %20, 21
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !17
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %42, %51
  %53 = add nuw nsw i64 %20, 22
  %54 = getelementptr inbounds double, ptr %0, i64 %53
  %55 = load double, ptr %54, align 8, !tbaa !17
  %56 = fadd double %55, 1.234500e+04
  %57 = call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %57, 1.234500e+04
  %59 = call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %52, %61
  store double %62, ptr %4, align 8, !tbaa !17
  %63 = add nuw i64 %20, 23
  %64 = trunc i64 %63 to i32
  %65 = icmp sgt i32 %9, %64
  br i1 %65, label %19, label %13, !llvm.loop !287

66:                                               ; preds = %66, %17
  %67 = phi i64 [ %18, %17 ], [ %78, %66 ]
  %68 = phi double [ %14, %17 ], [ %77, %66 ]
  %69 = getelementptr inbounds double, ptr %0, i64 %67
  %70 = load double, ptr %69, align 8, !tbaa !17
  %71 = fadd double %70, 1.234500e+04
  %72 = call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %72, 1.234500e+04
  %74 = call double @llvm.fmuladd.f64(double %73, double 9.142370e+05, double -1.300000e+01)
  %75 = fadd double %74, 1.234500e+04
  %76 = call double @llvm.fmuladd.f64(double %75, double 9.142370e+05, double -1.300000e+01)
  %77 = fadd double %68, %76
  %78 = add nuw nsw i64 %67, 1
  %79 = trunc i64 %78 to i32
  %80 = icmp slt i32 %79, %1
  br i1 %80, label %66, label %81, !llvm.loop !288

81:                                               ; preds = %66
  %.lcssa = phi double [ %77, %66 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %82

82:                                               ; preds = %81, %13
  %83 = phi double [ %.lcssa, %81 ], [ %14, %13 ]
  %84 = load double, ptr @init_value, align 8, !tbaa !17
  %85 = fadd double %84, 1.234500e+04
  %86 = call double @llvm.fmuladd.f64(double %85, double 9.142370e+05, double -1.300000e+01)
  %87 = fadd double %86, 1.234500e+04
  %88 = call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fmul double %90, 8.000000e+03
  %92 = fsub double %83, %91
  %93 = call double @llvm.fabs.f64(double %83)
  %94 = fcmp ogt double %93, 1.000000e-08
  %95 = select i1 %94, double %83, double 1.000000e+00
  %96 = fdiv double %92, %95
  %97 = call double @llvm.fabs.f64(double %96)
  %98 = fcmp olt double %97, 0x3EB0C6F7A0B5ED8D
  br i1 %98, label %102, label %99

99:                                               ; preds = %82
  %100 = load i32, ptr @current_test, align 4, !tbaa !11
  %101 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %100) #12
  br label %102

102:                                              ; preds = %99, %82
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %103 = add nuw nsw i32 %12, 1
  %104 = load i32, ptr @iterations, align 4, !tbaa !11
  %105 = icmp slt i32 %103, %104
  br i1 %105, label %11, label %106, !llvm.loop !289

106:                                              ; preds = %102, %3
  %107 = call i64 @clock() #15
  store i64 %107, ptr @end_time, align 8, !tbaa !23
  %108 = load i64, ptr @start_time, align 8, !tbaa !23
  %109 = sub nsw i64 %107, %108
  %110 = sitofp i64 %109 to double
  %111 = fdiv double %110, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %111, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi19EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi17EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi18EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 17)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi19EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 18)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi20EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %76

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -19
  %10 = icmp sgt i32 %1, 19
  br label %11

11:                                               ; preds = %72, %8
  %12 = phi i32 [ 0, %8 ], [ %73, %72 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %32, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %34, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %52

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %36

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %33, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  store double %32, ptr %4, align 8, !tbaa !17
  %33 = add nuw i64 %20, 20
  %34 = trunc i64 %33 to i32
  %35 = icmp sgt i32 %9, %34
  br i1 %35, label %19, label %13, !llvm.loop !290

36:                                               ; preds = %36, %17
  %37 = phi i64 [ %18, %17 ], [ %48, %36 ]
  %38 = phi double [ %14, %17 ], [ %47, %36 ]
  %39 = getelementptr inbounds double, ptr %0, i64 %37
  %40 = load double, ptr %39, align 8, !tbaa !17
  %41 = fadd double %40, 1.234500e+04
  %42 = call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %42, 1.234500e+04
  %44 = call double @llvm.fmuladd.f64(double %43, double 9.142370e+05, double -1.300000e+01)
  %45 = fadd double %44, 1.234500e+04
  %46 = call double @llvm.fmuladd.f64(double %45, double 9.142370e+05, double -1.300000e+01)
  %47 = fadd double %38, %46
  %48 = add nuw nsw i64 %37, 1
  %49 = trunc i64 %48 to i32
  %50 = icmp slt i32 %49, %1
  br i1 %50, label %36, label %51, !llvm.loop !291

51:                                               ; preds = %36
  %.lcssa = phi double [ %47, %36 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %52

52:                                               ; preds = %51, %13
  %53 = phi double [ %.lcssa, %51 ], [ %14, %13 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %56, 1.234500e+04
  %58 = call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fmul double %60, 8.000000e+03
  %62 = fsub double %53, %61
  %63 = call double @llvm.fabs.f64(double %53)
  %64 = fcmp ogt double %63, 1.000000e-08
  %65 = select i1 %64, double %53, double 1.000000e+00
  %66 = fdiv double %62, %65
  %67 = call double @llvm.fabs.f64(double %66)
  %68 = fcmp olt double %67, 0x3EB0C6F7A0B5ED8D
  br i1 %68, label %72, label %69

69:                                               ; preds = %52
  %70 = load i32, ptr @current_test, align 4, !tbaa !11
  %71 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %70) #12
  br label %72

72:                                               ; preds = %69, %52
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %73 = add nuw nsw i32 %12, 1
  %74 = load i32, ptr @iterations, align 4, !tbaa !11
  %75 = icmp slt i32 %73, %74
  br i1 %75, label %11, label %76, !llvm.loop !292

76:                                               ; preds = %72, %3
  %77 = call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi21EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -20
  %10 = icmp sgt i32 %1, 20
  br label %11

11:                                               ; preds = %82, %8
  %12 = phi i32 [ 0, %8 ], [ %83, %82 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi double [ 0.000000e+00, %11 ], [ %42, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %44, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %62

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %46

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %43, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 19
  %23 = getelementptr inbounds double, ptr %0, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !17
  %25 = fadd double %24, 1.234500e+04
  %26 = call double @llvm.fmuladd.f64(double %25, double 9.142370e+05, double -1.300000e+01)
  %27 = fadd double %26, 1.234500e+04
  %28 = call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = load double, ptr %4, align 8, !tbaa !17
  %32 = fadd double %31, %30
  %33 = add nuw nsw i64 %20, 20
  %34 = getelementptr inbounds double, ptr %0, i64 %33
  %35 = load double, ptr %34, align 8, !tbaa !17
  %36 = fadd double %35, 1.234500e+04
  %37 = call double @llvm.fmuladd.f64(double %36, double 9.142370e+05, double -1.300000e+01)
  %38 = fadd double %37, 1.234500e+04
  %39 = call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %32, %41
  store double %42, ptr %4, align 8, !tbaa !17
  %43 = add nuw i64 %20, 21
  %44 = trunc i64 %43 to i32
  %45 = icmp sgt i32 %9, %44
  br i1 %45, label %19, label %13, !llvm.loop !293

46:                                               ; preds = %46, %17
  %47 = phi i64 [ %18, %17 ], [ %58, %46 ]
  %48 = phi double [ %14, %17 ], [ %57, %46 ]
  %49 = getelementptr inbounds double, ptr %0, i64 %47
  %50 = load double, ptr %49, align 8, !tbaa !17
  %51 = fadd double %50, 1.234500e+04
  %52 = call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %52, 1.234500e+04
  %54 = call double @llvm.fmuladd.f64(double %53, double 9.142370e+05, double -1.300000e+01)
  %55 = fadd double %54, 1.234500e+04
  %56 = call double @llvm.fmuladd.f64(double %55, double 9.142370e+05, double -1.300000e+01)
  %57 = fadd double %48, %56
  %58 = add nuw nsw i64 %47, 1
  %59 = trunc i64 %58 to i32
  %60 = icmp slt i32 %59, %1
  br i1 %60, label %46, label %61, !llvm.loop !294

61:                                               ; preds = %46
  %.lcssa = phi double [ %57, %46 ]
  store double %.lcssa, ptr %4, align 8, !tbaa !17
  br label %62

62:                                               ; preds = %61, %13
  %63 = phi double [ %.lcssa, %61 ], [ %14, %13 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !17
  %65 = fadd double %64, 1.234500e+04
  %66 = call double @llvm.fmuladd.f64(double %65, double 9.142370e+05, double -1.300000e+01)
  %67 = fadd double %66, 1.234500e+04
  %68 = call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fmul double %70, 8.000000e+03
  %72 = fsub double %63, %71
  %73 = call double @llvm.fabs.f64(double %63)
  %74 = fcmp ogt double %73, 1.000000e-08
  %75 = select i1 %74, double %63, double 1.000000e+00
  %76 = fdiv double %72, %75
  %77 = call double @llvm.fabs.f64(double %76)
  %78 = fcmp olt double %77, 0x3EB0C6F7A0B5ED8D
  br i1 %78, label %82, label %79

79:                                               ; preds = %62
  %80 = load i32, ptr @current_test, align 4, !tbaa !11
  %81 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %80) #12
  br label %82

82:                                               ; preds = %79, %62
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %83 = add nuw nsw i32 %12, 1
  %84 = load i32, ptr @iterations, align 4, !tbaa !11
  %85 = icmp slt i32 %83, %84
  br i1 %85, label %11, label %86, !llvm.loop !295

86:                                               ; preds = %82, %3
  %87 = call i64 @clock() #15
  store i64 %87, ptr @end_time, align 8, !tbaa !23
  %88 = load i64, ptr @start_time, align 8, !tbaa !23
  %89 = sub nsw i64 %87, %88
  %90 = sitofp i64 %89 to double
  %91 = fdiv double %90, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %91, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi17EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi15EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi16EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 15)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi17EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 16)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi18EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %244

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -17
  %9 = icmp sgt i32 %1, 17
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %240, %7
  %13 = phi i32 [ 0, %7 ], [ %241, %240 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %203, %22 ]
  %.lcssa = phi i64 [ %204, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %220

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %206

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %204, %22 ], [ 0, %12 ]
  %24 = phi double [ %203, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = or i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = add nuw nsw i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = add nuw nsw i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = add nuw nsw i64 %23, 11
  %135 = getelementptr inbounds double, ptr %0, i64 %134
  %136 = load double, ptr %135, align 8, !tbaa !17
  %137 = fadd double %136, 1.234500e+04
  %138 = tail call double @llvm.fmuladd.f64(double %137, double 9.142370e+05, double -1.300000e+01)
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %133, %142
  %144 = add nuw nsw i64 %23, 12
  %145 = getelementptr inbounds double, ptr %0, i64 %144
  %146 = load double, ptr %145, align 8, !tbaa !17
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %143, %152
  %154 = add nuw nsw i64 %23, 13
  %155 = getelementptr inbounds double, ptr %0, i64 %154
  %156 = load double, ptr %155, align 8, !tbaa !17
  %157 = fadd double %156, 1.234500e+04
  %158 = tail call double @llvm.fmuladd.f64(double %157, double 9.142370e+05, double -1.300000e+01)
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %153, %162
  %164 = add nuw nsw i64 %23, 14
  %165 = getelementptr inbounds double, ptr %0, i64 %164
  %166 = load double, ptr %165, align 8, !tbaa !17
  %167 = fadd double %166, 1.234500e+04
  %168 = tail call double @llvm.fmuladd.f64(double %167, double 9.142370e+05, double -1.300000e+01)
  %169 = fadd double %168, 1.234500e+04
  %170 = tail call double @llvm.fmuladd.f64(double %169, double 9.142370e+05, double -1.300000e+01)
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %163, %172
  %174 = add nuw nsw i64 %23, 15
  %175 = getelementptr inbounds double, ptr %0, i64 %174
  %176 = load double, ptr %175, align 8, !tbaa !17
  %177 = fadd double %176, 1.234500e+04
  %178 = tail call double @llvm.fmuladd.f64(double %177, double 9.142370e+05, double -1.300000e+01)
  %179 = fadd double %178, 1.234500e+04
  %180 = tail call double @llvm.fmuladd.f64(double %179, double 9.142370e+05, double -1.300000e+01)
  %181 = fadd double %180, 1.234500e+04
  %182 = tail call double @llvm.fmuladd.f64(double %181, double 9.142370e+05, double -1.300000e+01)
  %183 = fadd double %173, %182
  %184 = add nuw nsw i64 %23, 16
  %185 = getelementptr inbounds double, ptr %0, i64 %184
  %186 = load double, ptr %185, align 8, !tbaa !17
  %187 = fadd double %186, 1.234500e+04
  %188 = tail call double @llvm.fmuladd.f64(double %187, double 9.142370e+05, double -1.300000e+01)
  %189 = fadd double %188, 1.234500e+04
  %190 = tail call double @llvm.fmuladd.f64(double %189, double 9.142370e+05, double -1.300000e+01)
  %191 = fadd double %190, 1.234500e+04
  %192 = tail call double @llvm.fmuladd.f64(double %191, double 9.142370e+05, double -1.300000e+01)
  %193 = fadd double %183, %192
  %194 = add nuw nsw i64 %23, 17
  %195 = getelementptr inbounds double, ptr %0, i64 %194
  %196 = load double, ptr %195, align 8, !tbaa !17
  %197 = fadd double %196, 1.234500e+04
  %198 = tail call double @llvm.fmuladd.f64(double %197, double 9.142370e+05, double -1.300000e+01)
  %199 = fadd double %198, 1.234500e+04
  %200 = tail call double @llvm.fmuladd.f64(double %199, double 9.142370e+05, double -1.300000e+01)
  %201 = fadd double %200, 1.234500e+04
  %202 = tail call double @llvm.fmuladd.f64(double %201, double 9.142370e+05, double -1.300000e+01)
  %203 = fadd double %193, %202
  %204 = add nuw nsw i64 %23, 18
  %205 = icmp slt i64 %204, %10
  br i1 %205, label %22, label %14, !llvm.loop !296

206:                                              ; preds = %206, %20
  %207 = phi i64 [ %21, %20 ], [ %218, %206 ]
  %208 = phi double [ %17, %20 ], [ %217, %206 ]
  %209 = getelementptr inbounds double, ptr %0, i64 %207
  %210 = load double, ptr %209, align 8, !tbaa !17
  %211 = fadd double %210, 1.234500e+04
  %212 = tail call double @llvm.fmuladd.f64(double %211, double 9.142370e+05, double -1.300000e+01)
  %213 = fadd double %212, 1.234500e+04
  %214 = tail call double @llvm.fmuladd.f64(double %213, double 9.142370e+05, double -1.300000e+01)
  %215 = fadd double %214, 1.234500e+04
  %216 = tail call double @llvm.fmuladd.f64(double %215, double 9.142370e+05, double -1.300000e+01)
  %217 = fadd double %208, %216
  %218 = add nuw nsw i64 %207, 1
  %219 = icmp eq i64 %218, %11
  br i1 %219, label %220, label %206, !llvm.loop !297

220:                                              ; preds = %206, %16
  %221 = phi double [ %17, %16 ], [ %217, %206 ]
  %222 = load double, ptr @init_value, align 8, !tbaa !17
  %223 = fadd double %222, 1.234500e+04
  %224 = tail call double @llvm.fmuladd.f64(double %223, double 9.142370e+05, double -1.300000e+01)
  %225 = fadd double %224, 1.234500e+04
  %226 = tail call double @llvm.fmuladd.f64(double %225, double 9.142370e+05, double -1.300000e+01)
  %227 = fadd double %226, 1.234500e+04
  %228 = tail call double @llvm.fmuladd.f64(double %227, double 9.142370e+05, double -1.300000e+01)
  %229 = fmul double %228, 8.000000e+03
  %230 = fsub double %221, %229
  %231 = tail call double @llvm.fabs.f64(double %221)
  %232 = fcmp ogt double %231, 1.000000e-08
  %233 = select i1 %232, double %221, double 1.000000e+00
  %234 = fdiv double %230, %233
  %235 = tail call double @llvm.fabs.f64(double %234)
  %236 = fcmp olt double %235, 0x3EB0C6F7A0B5ED8D
  br i1 %236, label %240, label %237

237:                                              ; preds = %220
  %238 = load i32, ptr @current_test, align 4, !tbaa !11
  %239 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %238) #12
  br label %240

240:                                              ; preds = %237, %220
  %241 = add nuw nsw i32 %13, 1
  %242 = load i32, ptr @iterations, align 4, !tbaa !11
  %243 = icmp slt i32 %241, %242
  br i1 %243, label %12, label %244, !llvm.loop !298

244:                                              ; preds = %240, %3
  %245 = tail call i64 @clock() #15
  store i64 %245, ptr @end_time, align 8, !tbaa !23
  %246 = load i64, ptr @start_time, align 8, !tbaa !23
  %247 = sub nsw i64 %245, %246
  %248 = sitofp i64 %247 to double
  %249 = fdiv double %248, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %249, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi19EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca double, align 8
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %65

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -18
  %10 = icmp sgt i32 %1, 18
  br label %11

11:                                               ; preds = %61, %8
  %12 = phi i32 [ 0, %8 ], [ %62, %61 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #16
  store double 0.000000e+00, ptr %4, align 8, !tbaa !17
  br i1 %10, label %21, label %15

13:                                               ; preds = %21
  %.lcssa = phi i32 [ %23, %21 ]
  %14 = load double, ptr %4, align 8, !tbaa !17
  br label %15

15:                                               ; preds = %13, %11
  %16 = phi double [ 0.000000e+00, %11 ], [ %14, %13 ]
  %17 = phi i32 [ 0, %11 ], [ %.lcssa, %13 ]
  %18 = icmp slt i32 %17, %1
  br i1 %18, label %19, label %41

19:                                               ; preds = %15
  %20 = zext i32 %17 to i64
  br label %25

21:                                               ; preds = %21, %11
  %22 = phi i32 [ %23, %21 ], [ 0, %11 ]
  call void @_ZN15loop_inner_bodyILi19EdE7do_workERdPKdi(ptr noundef nonnull align 8 dereferenceable(8) %4, ptr noundef %0, i32 noundef %22) #12
  %23 = add nuw nsw i32 %22, 19
  %24 = icmp slt i32 %23, %9
  br i1 %24, label %21, label %13, !llvm.loop !299

25:                                               ; preds = %25, %19
  %26 = phi i64 [ %20, %19 ], [ %37, %25 ]
  %27 = phi double [ %16, %19 ], [ %36, %25 ]
  %28 = getelementptr inbounds double, ptr %0, i64 %26
  %29 = load double, ptr %28, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fadd double %27, %35
  %37 = add nuw nsw i64 %26, 1
  %38 = trunc i64 %37 to i32
  %39 = icmp eq i32 %38, %1
  br i1 %39, label %40, label %25, !llvm.loop !300

40:                                               ; preds = %25
  %.lcssa1 = phi double [ %36, %25 ]
  store double %.lcssa1, ptr %4, align 8, !tbaa !17
  br label %41

41:                                               ; preds = %40, %15
  %42 = phi double [ %.lcssa1, %40 ], [ %16, %15 ]
  %43 = load double, ptr @init_value, align 8, !tbaa !17
  %44 = fadd double %43, 1.234500e+04
  %45 = call double @llvm.fmuladd.f64(double %44, double 9.142370e+05, double -1.300000e+01)
  %46 = fadd double %45, 1.234500e+04
  %47 = call double @llvm.fmuladd.f64(double %46, double 9.142370e+05, double -1.300000e+01)
  %48 = fadd double %47, 1.234500e+04
  %49 = call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fmul double %49, 8.000000e+03
  %51 = fsub double %42, %50
  %52 = call double @llvm.fabs.f64(double %42)
  %53 = fcmp ogt double %52, 1.000000e-08
  %54 = select i1 %53, double %42, double 1.000000e+00
  %55 = fdiv double %51, %54
  %56 = call double @llvm.fabs.f64(double %55)
  %57 = fcmp olt double %56, 0x3EB0C6F7A0B5ED8D
  br i1 %57, label %61, label %58

58:                                               ; preds = %41
  %59 = load i32, ptr @current_test, align 4, !tbaa !11
  %60 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %59) #12
  br label %61

61:                                               ; preds = %58, %41
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #16
  %62 = add nuw nsw i32 %12, 1
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  %64 = icmp slt i32 %62, %63
  br i1 %64, label %11, label %65, !llvm.loop !301

65:                                               ; preds = %61, %3
  %66 = call i64 @clock() #15
  store i64 %66, ptr @end_time, align 8, !tbaa !23
  %67 = load i64, ptr @start_time, align 8, !tbaa !23
  %68 = sub nsw i64 %66, %67
  %69 = sitofp i64 %68 to double
  %70 = fdiv double %69, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %70, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi15EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi13EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi14EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 13)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi15EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 14)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi16EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %224

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -15
  %9 = icmp sgt i32 %1, 15
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %220, %7
  %13 = phi i32 [ 0, %7 ], [ %221, %220 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %183, %22 ]
  %.lcssa = phi i64 [ %184, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %200

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %186

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %184, %22 ], [ 0, %12 ]
  %24 = phi double [ %183, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = or i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = or i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = or i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = or i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = or i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = or i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = or i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = or i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = or i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = or i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = or i64 %23, 11
  %135 = getelementptr inbounds double, ptr %0, i64 %134
  %136 = load double, ptr %135, align 8, !tbaa !17
  %137 = fadd double %136, 1.234500e+04
  %138 = tail call double @llvm.fmuladd.f64(double %137, double 9.142370e+05, double -1.300000e+01)
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %133, %142
  %144 = or i64 %23, 12
  %145 = getelementptr inbounds double, ptr %0, i64 %144
  %146 = load double, ptr %145, align 8, !tbaa !17
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %143, %152
  %154 = or i64 %23, 13
  %155 = getelementptr inbounds double, ptr %0, i64 %154
  %156 = load double, ptr %155, align 8, !tbaa !17
  %157 = fadd double %156, 1.234500e+04
  %158 = tail call double @llvm.fmuladd.f64(double %157, double 9.142370e+05, double -1.300000e+01)
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %153, %162
  %164 = or i64 %23, 14
  %165 = getelementptr inbounds double, ptr %0, i64 %164
  %166 = load double, ptr %165, align 8, !tbaa !17
  %167 = fadd double %166, 1.234500e+04
  %168 = tail call double @llvm.fmuladd.f64(double %167, double 9.142370e+05, double -1.300000e+01)
  %169 = fadd double %168, 1.234500e+04
  %170 = tail call double @llvm.fmuladd.f64(double %169, double 9.142370e+05, double -1.300000e+01)
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %163, %172
  %174 = or i64 %23, 15
  %175 = getelementptr inbounds double, ptr %0, i64 %174
  %176 = load double, ptr %175, align 8, !tbaa !17
  %177 = fadd double %176, 1.234500e+04
  %178 = tail call double @llvm.fmuladd.f64(double %177, double 9.142370e+05, double -1.300000e+01)
  %179 = fadd double %178, 1.234500e+04
  %180 = tail call double @llvm.fmuladd.f64(double %179, double 9.142370e+05, double -1.300000e+01)
  %181 = fadd double %180, 1.234500e+04
  %182 = tail call double @llvm.fmuladd.f64(double %181, double 9.142370e+05, double -1.300000e+01)
  %183 = fadd double %173, %182
  %184 = add nuw nsw i64 %23, 16
  %185 = icmp slt i64 %184, %10
  br i1 %185, label %22, label %14, !llvm.loop !302

186:                                              ; preds = %186, %20
  %187 = phi i64 [ %21, %20 ], [ %198, %186 ]
  %188 = phi double [ %17, %20 ], [ %197, %186 ]
  %189 = getelementptr inbounds double, ptr %0, i64 %187
  %190 = load double, ptr %189, align 8, !tbaa !17
  %191 = fadd double %190, 1.234500e+04
  %192 = tail call double @llvm.fmuladd.f64(double %191, double 9.142370e+05, double -1.300000e+01)
  %193 = fadd double %192, 1.234500e+04
  %194 = tail call double @llvm.fmuladd.f64(double %193, double 9.142370e+05, double -1.300000e+01)
  %195 = fadd double %194, 1.234500e+04
  %196 = tail call double @llvm.fmuladd.f64(double %195, double 9.142370e+05, double -1.300000e+01)
  %197 = fadd double %188, %196
  %198 = add nuw nsw i64 %187, 1
  %199 = icmp eq i64 %198, %11
  br i1 %199, label %200, label %186, !llvm.loop !303

200:                                              ; preds = %186, %16
  %201 = phi double [ %17, %16 ], [ %197, %186 ]
  %202 = load double, ptr @init_value, align 8, !tbaa !17
  %203 = fadd double %202, 1.234500e+04
  %204 = tail call double @llvm.fmuladd.f64(double %203, double 9.142370e+05, double -1.300000e+01)
  %205 = fadd double %204, 1.234500e+04
  %206 = tail call double @llvm.fmuladd.f64(double %205, double 9.142370e+05, double -1.300000e+01)
  %207 = fadd double %206, 1.234500e+04
  %208 = tail call double @llvm.fmuladd.f64(double %207, double 9.142370e+05, double -1.300000e+01)
  %209 = fmul double %208, 8.000000e+03
  %210 = fsub double %201, %209
  %211 = tail call double @llvm.fabs.f64(double %201)
  %212 = fcmp ogt double %211, 1.000000e-08
  %213 = select i1 %212, double %201, double 1.000000e+00
  %214 = fdiv double %210, %213
  %215 = tail call double @llvm.fabs.f64(double %214)
  %216 = fcmp olt double %215, 0x3EB0C6F7A0B5ED8D
  br i1 %216, label %220, label %217

217:                                              ; preds = %200
  %218 = load i32, ptr @current_test, align 4, !tbaa !11
  %219 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %218) #12
  br label %220

220:                                              ; preds = %217, %200
  %221 = add nuw nsw i32 %13, 1
  %222 = load i32, ptr @iterations, align 4, !tbaa !11
  %223 = icmp slt i32 %221, %222
  br i1 %223, label %12, label %224, !llvm.loop !304

224:                                              ; preds = %220, %3
  %225 = tail call i64 @clock() #15
  store i64 %225, ptr @end_time, align 8, !tbaa !23
  %226 = load i64, ptr @start_time, align 8, !tbaa !23
  %227 = sub nsw i64 %225, %226
  %228 = sitofp i64 %227 to double
  %229 = fdiv double %228, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %229, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi17EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %234

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -16
  %9 = icmp sgt i32 %1, 16
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %230, %7
  %13 = phi i32 [ 0, %7 ], [ %231, %230 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %193, %22 ]
  %.lcssa = phi i64 [ %194, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %210

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %196

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %194, %22 ], [ 0, %12 ]
  %24 = phi double [ %193, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = add nuw nsw i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = add nuw nsw i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = add nuw nsw i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = add nuw nsw i64 %23, 11
  %135 = getelementptr inbounds double, ptr %0, i64 %134
  %136 = load double, ptr %135, align 8, !tbaa !17
  %137 = fadd double %136, 1.234500e+04
  %138 = tail call double @llvm.fmuladd.f64(double %137, double 9.142370e+05, double -1.300000e+01)
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %133, %142
  %144 = add nuw nsw i64 %23, 12
  %145 = getelementptr inbounds double, ptr %0, i64 %144
  %146 = load double, ptr %145, align 8, !tbaa !17
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %143, %152
  %154 = add nuw nsw i64 %23, 13
  %155 = getelementptr inbounds double, ptr %0, i64 %154
  %156 = load double, ptr %155, align 8, !tbaa !17
  %157 = fadd double %156, 1.234500e+04
  %158 = tail call double @llvm.fmuladd.f64(double %157, double 9.142370e+05, double -1.300000e+01)
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %153, %162
  %164 = add nuw nsw i64 %23, 14
  %165 = getelementptr inbounds double, ptr %0, i64 %164
  %166 = load double, ptr %165, align 8, !tbaa !17
  %167 = fadd double %166, 1.234500e+04
  %168 = tail call double @llvm.fmuladd.f64(double %167, double 9.142370e+05, double -1.300000e+01)
  %169 = fadd double %168, 1.234500e+04
  %170 = tail call double @llvm.fmuladd.f64(double %169, double 9.142370e+05, double -1.300000e+01)
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %163, %172
  %174 = add nuw nsw i64 %23, 15
  %175 = getelementptr inbounds double, ptr %0, i64 %174
  %176 = load double, ptr %175, align 8, !tbaa !17
  %177 = fadd double %176, 1.234500e+04
  %178 = tail call double @llvm.fmuladd.f64(double %177, double 9.142370e+05, double -1.300000e+01)
  %179 = fadd double %178, 1.234500e+04
  %180 = tail call double @llvm.fmuladd.f64(double %179, double 9.142370e+05, double -1.300000e+01)
  %181 = fadd double %180, 1.234500e+04
  %182 = tail call double @llvm.fmuladd.f64(double %181, double 9.142370e+05, double -1.300000e+01)
  %183 = fadd double %173, %182
  %184 = add nuw nsw i64 %23, 16
  %185 = getelementptr inbounds double, ptr %0, i64 %184
  %186 = load double, ptr %185, align 8, !tbaa !17
  %187 = fadd double %186, 1.234500e+04
  %188 = tail call double @llvm.fmuladd.f64(double %187, double 9.142370e+05, double -1.300000e+01)
  %189 = fadd double %188, 1.234500e+04
  %190 = tail call double @llvm.fmuladd.f64(double %189, double 9.142370e+05, double -1.300000e+01)
  %191 = fadd double %190, 1.234500e+04
  %192 = tail call double @llvm.fmuladd.f64(double %191, double 9.142370e+05, double -1.300000e+01)
  %193 = fadd double %183, %192
  %194 = add nuw nsw i64 %23, 17
  %195 = icmp slt i64 %194, %10
  br i1 %195, label %22, label %14, !llvm.loop !305

196:                                              ; preds = %196, %20
  %197 = phi i64 [ %21, %20 ], [ %208, %196 ]
  %198 = phi double [ %17, %20 ], [ %207, %196 ]
  %199 = getelementptr inbounds double, ptr %0, i64 %197
  %200 = load double, ptr %199, align 8, !tbaa !17
  %201 = fadd double %200, 1.234500e+04
  %202 = tail call double @llvm.fmuladd.f64(double %201, double 9.142370e+05, double -1.300000e+01)
  %203 = fadd double %202, 1.234500e+04
  %204 = tail call double @llvm.fmuladd.f64(double %203, double 9.142370e+05, double -1.300000e+01)
  %205 = fadd double %204, 1.234500e+04
  %206 = tail call double @llvm.fmuladd.f64(double %205, double 9.142370e+05, double -1.300000e+01)
  %207 = fadd double %198, %206
  %208 = add nuw nsw i64 %197, 1
  %209 = icmp eq i64 %208, %11
  br i1 %209, label %210, label %196, !llvm.loop !306

210:                                              ; preds = %196, %16
  %211 = phi double [ %17, %16 ], [ %207, %196 ]
  %212 = load double, ptr @init_value, align 8, !tbaa !17
  %213 = fadd double %212, 1.234500e+04
  %214 = tail call double @llvm.fmuladd.f64(double %213, double 9.142370e+05, double -1.300000e+01)
  %215 = fadd double %214, 1.234500e+04
  %216 = tail call double @llvm.fmuladd.f64(double %215, double 9.142370e+05, double -1.300000e+01)
  %217 = fadd double %216, 1.234500e+04
  %218 = tail call double @llvm.fmuladd.f64(double %217, double 9.142370e+05, double -1.300000e+01)
  %219 = fmul double %218, 8.000000e+03
  %220 = fsub double %211, %219
  %221 = tail call double @llvm.fabs.f64(double %211)
  %222 = fcmp ogt double %221, 1.000000e-08
  %223 = select i1 %222, double %211, double 1.000000e+00
  %224 = fdiv double %220, %223
  %225 = tail call double @llvm.fabs.f64(double %224)
  %226 = fcmp olt double %225, 0x3EB0C6F7A0B5ED8D
  br i1 %226, label %230, label %227

227:                                              ; preds = %210
  %228 = load i32, ptr @current_test, align 4, !tbaa !11
  %229 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %228) #12
  br label %230

230:                                              ; preds = %227, %210
  %231 = add nuw nsw i32 %13, 1
  %232 = load i32, ptr @iterations, align 4, !tbaa !11
  %233 = icmp slt i32 %231, %232
  br i1 %233, label %12, label %234, !llvm.loop !307

234:                                              ; preds = %230, %3
  %235 = tail call i64 @clock() #15
  store i64 %235, ptr @end_time, align 8, !tbaa !23
  %236 = load i64, ptr @start_time, align 8, !tbaa !23
  %237 = sub nsw i64 %235, %236
  %238 = sitofp i64 %237 to double
  %239 = fdiv double %238, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %239, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi13EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi11EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi12EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 11)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi13EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 12)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi14EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %204

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -13
  %9 = icmp sgt i32 %1, 13
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %200, %7
  %13 = phi i32 [ 0, %7 ], [ %201, %200 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %163, %22 ]
  %.lcssa = phi i64 [ %164, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %180

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %166

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %164, %22 ], [ 0, %12 ]
  %24 = phi double [ %163, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = or i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = add nuw nsw i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = add nuw nsw i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = add nuw nsw i64 %23, 11
  %135 = getelementptr inbounds double, ptr %0, i64 %134
  %136 = load double, ptr %135, align 8, !tbaa !17
  %137 = fadd double %136, 1.234500e+04
  %138 = tail call double @llvm.fmuladd.f64(double %137, double 9.142370e+05, double -1.300000e+01)
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %133, %142
  %144 = add nuw nsw i64 %23, 12
  %145 = getelementptr inbounds double, ptr %0, i64 %144
  %146 = load double, ptr %145, align 8, !tbaa !17
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %143, %152
  %154 = add nuw nsw i64 %23, 13
  %155 = getelementptr inbounds double, ptr %0, i64 %154
  %156 = load double, ptr %155, align 8, !tbaa !17
  %157 = fadd double %156, 1.234500e+04
  %158 = tail call double @llvm.fmuladd.f64(double %157, double 9.142370e+05, double -1.300000e+01)
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %153, %162
  %164 = add nuw nsw i64 %23, 14
  %165 = icmp slt i64 %164, %10
  br i1 %165, label %22, label %14, !llvm.loop !308

166:                                              ; preds = %166, %20
  %167 = phi i64 [ %21, %20 ], [ %178, %166 ]
  %168 = phi double [ %17, %20 ], [ %177, %166 ]
  %169 = getelementptr inbounds double, ptr %0, i64 %167
  %170 = load double, ptr %169, align 8, !tbaa !17
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %172, 1.234500e+04
  %174 = tail call double @llvm.fmuladd.f64(double %173, double 9.142370e+05, double -1.300000e+01)
  %175 = fadd double %174, 1.234500e+04
  %176 = tail call double @llvm.fmuladd.f64(double %175, double 9.142370e+05, double -1.300000e+01)
  %177 = fadd double %168, %176
  %178 = add nuw nsw i64 %167, 1
  %179 = icmp eq i64 %178, %11
  br i1 %179, label %180, label %166, !llvm.loop !309

180:                                              ; preds = %166, %16
  %181 = phi double [ %17, %16 ], [ %177, %166 ]
  %182 = load double, ptr @init_value, align 8, !tbaa !17
  %183 = fadd double %182, 1.234500e+04
  %184 = tail call double @llvm.fmuladd.f64(double %183, double 9.142370e+05, double -1.300000e+01)
  %185 = fadd double %184, 1.234500e+04
  %186 = tail call double @llvm.fmuladd.f64(double %185, double 9.142370e+05, double -1.300000e+01)
  %187 = fadd double %186, 1.234500e+04
  %188 = tail call double @llvm.fmuladd.f64(double %187, double 9.142370e+05, double -1.300000e+01)
  %189 = fmul double %188, 8.000000e+03
  %190 = fsub double %181, %189
  %191 = tail call double @llvm.fabs.f64(double %181)
  %192 = fcmp ogt double %191, 1.000000e-08
  %193 = select i1 %192, double %181, double 1.000000e+00
  %194 = fdiv double %190, %193
  %195 = tail call double @llvm.fabs.f64(double %194)
  %196 = fcmp olt double %195, 0x3EB0C6F7A0B5ED8D
  br i1 %196, label %200, label %197

197:                                              ; preds = %180
  %198 = load i32, ptr @current_test, align 4, !tbaa !11
  %199 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %198) #12
  br label %200

200:                                              ; preds = %197, %180
  %201 = add nuw nsw i32 %13, 1
  %202 = load i32, ptr @iterations, align 4, !tbaa !11
  %203 = icmp slt i32 %201, %202
  br i1 %203, label %12, label %204, !llvm.loop !310

204:                                              ; preds = %200, %3
  %205 = tail call i64 @clock() #15
  store i64 %205, ptr @end_time, align 8, !tbaa !23
  %206 = load i64, ptr @start_time, align 8, !tbaa !23
  %207 = sub nsw i64 %205, %206
  %208 = sitofp i64 %207 to double
  %209 = fdiv double %208, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %209, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi15EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %214

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -14
  %9 = icmp sgt i32 %1, 14
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %210, %7
  %13 = phi i32 [ 0, %7 ], [ %211, %210 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %173, %22 ]
  %.lcssa = phi i64 [ %174, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %190

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %176

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %174, %22 ], [ 0, %12 ]
  %24 = phi double [ %173, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = add nuw nsw i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = add nuw nsw i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = add nuw nsw i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = add nuw nsw i64 %23, 11
  %135 = getelementptr inbounds double, ptr %0, i64 %134
  %136 = load double, ptr %135, align 8, !tbaa !17
  %137 = fadd double %136, 1.234500e+04
  %138 = tail call double @llvm.fmuladd.f64(double %137, double 9.142370e+05, double -1.300000e+01)
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %133, %142
  %144 = add nuw nsw i64 %23, 12
  %145 = getelementptr inbounds double, ptr %0, i64 %144
  %146 = load double, ptr %145, align 8, !tbaa !17
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %143, %152
  %154 = add nuw nsw i64 %23, 13
  %155 = getelementptr inbounds double, ptr %0, i64 %154
  %156 = load double, ptr %155, align 8, !tbaa !17
  %157 = fadd double %156, 1.234500e+04
  %158 = tail call double @llvm.fmuladd.f64(double %157, double 9.142370e+05, double -1.300000e+01)
  %159 = fadd double %158, 1.234500e+04
  %160 = tail call double @llvm.fmuladd.f64(double %159, double 9.142370e+05, double -1.300000e+01)
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %153, %162
  %164 = add nuw nsw i64 %23, 14
  %165 = getelementptr inbounds double, ptr %0, i64 %164
  %166 = load double, ptr %165, align 8, !tbaa !17
  %167 = fadd double %166, 1.234500e+04
  %168 = tail call double @llvm.fmuladd.f64(double %167, double 9.142370e+05, double -1.300000e+01)
  %169 = fadd double %168, 1.234500e+04
  %170 = tail call double @llvm.fmuladd.f64(double %169, double 9.142370e+05, double -1.300000e+01)
  %171 = fadd double %170, 1.234500e+04
  %172 = tail call double @llvm.fmuladd.f64(double %171, double 9.142370e+05, double -1.300000e+01)
  %173 = fadd double %163, %172
  %174 = add nuw nsw i64 %23, 15
  %175 = icmp slt i64 %174, %10
  br i1 %175, label %22, label %14, !llvm.loop !311

176:                                              ; preds = %176, %20
  %177 = phi i64 [ %21, %20 ], [ %188, %176 ]
  %178 = phi double [ %17, %20 ], [ %187, %176 ]
  %179 = getelementptr inbounds double, ptr %0, i64 %177
  %180 = load double, ptr %179, align 8, !tbaa !17
  %181 = fadd double %180, 1.234500e+04
  %182 = tail call double @llvm.fmuladd.f64(double %181, double 9.142370e+05, double -1.300000e+01)
  %183 = fadd double %182, 1.234500e+04
  %184 = tail call double @llvm.fmuladd.f64(double %183, double 9.142370e+05, double -1.300000e+01)
  %185 = fadd double %184, 1.234500e+04
  %186 = tail call double @llvm.fmuladd.f64(double %185, double 9.142370e+05, double -1.300000e+01)
  %187 = fadd double %178, %186
  %188 = add nuw nsw i64 %177, 1
  %189 = icmp eq i64 %188, %11
  br i1 %189, label %190, label %176, !llvm.loop !312

190:                                              ; preds = %176, %16
  %191 = phi double [ %17, %16 ], [ %187, %176 ]
  %192 = load double, ptr @init_value, align 8, !tbaa !17
  %193 = fadd double %192, 1.234500e+04
  %194 = tail call double @llvm.fmuladd.f64(double %193, double 9.142370e+05, double -1.300000e+01)
  %195 = fadd double %194, 1.234500e+04
  %196 = tail call double @llvm.fmuladd.f64(double %195, double 9.142370e+05, double -1.300000e+01)
  %197 = fadd double %196, 1.234500e+04
  %198 = tail call double @llvm.fmuladd.f64(double %197, double 9.142370e+05, double -1.300000e+01)
  %199 = fmul double %198, 8.000000e+03
  %200 = fsub double %191, %199
  %201 = tail call double @llvm.fabs.f64(double %191)
  %202 = fcmp ogt double %201, 1.000000e-08
  %203 = select i1 %202, double %191, double 1.000000e+00
  %204 = fdiv double %200, %203
  %205 = tail call double @llvm.fabs.f64(double %204)
  %206 = fcmp olt double %205, 0x3EB0C6F7A0B5ED8D
  br i1 %206, label %210, label %207

207:                                              ; preds = %190
  %208 = load i32, ptr @current_test, align 4, !tbaa !11
  %209 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %208) #12
  br label %210

210:                                              ; preds = %207, %190
  %211 = add nuw nsw i32 %13, 1
  %212 = load i32, ptr @iterations, align 4, !tbaa !11
  %213 = icmp slt i32 %211, %212
  br i1 %213, label %12, label %214, !llvm.loop !313

214:                                              ; preds = %210, %3
  %215 = tail call i64 @clock() #15
  store i64 %215, ptr @end_time, align 8, !tbaa !23
  %216 = load i64, ptr @start_time, align 8, !tbaa !23
  %217 = sub nsw i64 %215, %216
  %218 = sitofp i64 %217 to double
  %219 = fdiv double %218, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %219, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi11EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi9EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi10EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 9)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi11EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 10)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi12EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %184

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -11
  %9 = icmp sgt i32 %1, 11
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %180, %7
  %13 = phi i32 [ 0, %7 ], [ %181, %180 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %143, %22 ]
  %.lcssa = phi i64 [ %144, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %160

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %146

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %144, %22 ], [ 0, %12 ]
  %24 = phi double [ %143, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = or i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = or i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = or i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = add nuw nsw i64 %23, 11
  %135 = getelementptr inbounds double, ptr %0, i64 %134
  %136 = load double, ptr %135, align 8, !tbaa !17
  %137 = fadd double %136, 1.234500e+04
  %138 = tail call double @llvm.fmuladd.f64(double %137, double 9.142370e+05, double -1.300000e+01)
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %133, %142
  %144 = add nuw nsw i64 %23, 12
  %145 = icmp slt i64 %144, %10
  br i1 %145, label %22, label %14, !llvm.loop !314

146:                                              ; preds = %146, %20
  %147 = phi i64 [ %21, %20 ], [ %158, %146 ]
  %148 = phi double [ %17, %20 ], [ %157, %146 ]
  %149 = getelementptr inbounds double, ptr %0, i64 %147
  %150 = load double, ptr %149, align 8, !tbaa !17
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %154, 1.234500e+04
  %156 = tail call double @llvm.fmuladd.f64(double %155, double 9.142370e+05, double -1.300000e+01)
  %157 = fadd double %148, %156
  %158 = add nuw nsw i64 %147, 1
  %159 = icmp eq i64 %158, %11
  br i1 %159, label %160, label %146, !llvm.loop !315

160:                                              ; preds = %146, %16
  %161 = phi double [ %17, %16 ], [ %157, %146 ]
  %162 = load double, ptr @init_value, align 8, !tbaa !17
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %164, 1.234500e+04
  %166 = tail call double @llvm.fmuladd.f64(double %165, double 9.142370e+05, double -1.300000e+01)
  %167 = fadd double %166, 1.234500e+04
  %168 = tail call double @llvm.fmuladd.f64(double %167, double 9.142370e+05, double -1.300000e+01)
  %169 = fmul double %168, 8.000000e+03
  %170 = fsub double %161, %169
  %171 = tail call double @llvm.fabs.f64(double %161)
  %172 = fcmp ogt double %171, 1.000000e-08
  %173 = select i1 %172, double %161, double 1.000000e+00
  %174 = fdiv double %170, %173
  %175 = tail call double @llvm.fabs.f64(double %174)
  %176 = fcmp olt double %175, 0x3EB0C6F7A0B5ED8D
  br i1 %176, label %180, label %177

177:                                              ; preds = %160
  %178 = load i32, ptr @current_test, align 4, !tbaa !11
  %179 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %178) #12
  br label %180

180:                                              ; preds = %177, %160
  %181 = add nuw nsw i32 %13, 1
  %182 = load i32, ptr @iterations, align 4, !tbaa !11
  %183 = icmp slt i32 %181, %182
  br i1 %183, label %12, label %184, !llvm.loop !316

184:                                              ; preds = %180, %3
  %185 = tail call i64 @clock() #15
  store i64 %185, ptr @end_time, align 8, !tbaa !23
  %186 = load i64, ptr @start_time, align 8, !tbaa !23
  %187 = sub nsw i64 %185, %186
  %188 = sitofp i64 %187 to double
  %189 = fdiv double %188, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %189, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi13EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %194

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -12
  %9 = icmp sgt i32 %1, 12
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %190, %7
  %13 = phi i32 [ 0, %7 ], [ %191, %190 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %153, %22 ]
  %.lcssa = phi i64 [ %154, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %170

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %156

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %154, %22 ], [ 0, %12 ]
  %24 = phi double [ %153, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = add nuw nsw i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = add nuw nsw i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = add nuw nsw i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = add nuw nsw i64 %23, 11
  %135 = getelementptr inbounds double, ptr %0, i64 %134
  %136 = load double, ptr %135, align 8, !tbaa !17
  %137 = fadd double %136, 1.234500e+04
  %138 = tail call double @llvm.fmuladd.f64(double %137, double 9.142370e+05, double -1.300000e+01)
  %139 = fadd double %138, 1.234500e+04
  %140 = tail call double @llvm.fmuladd.f64(double %139, double 9.142370e+05, double -1.300000e+01)
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %133, %142
  %144 = add nuw nsw i64 %23, 12
  %145 = getelementptr inbounds double, ptr %0, i64 %144
  %146 = load double, ptr %145, align 8, !tbaa !17
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fadd double %148, 1.234500e+04
  %150 = tail call double @llvm.fmuladd.f64(double %149, double 9.142370e+05, double -1.300000e+01)
  %151 = fadd double %150, 1.234500e+04
  %152 = tail call double @llvm.fmuladd.f64(double %151, double 9.142370e+05, double -1.300000e+01)
  %153 = fadd double %143, %152
  %154 = add nuw nsw i64 %23, 13
  %155 = icmp slt i64 %154, %10
  br i1 %155, label %22, label %14, !llvm.loop !317

156:                                              ; preds = %156, %20
  %157 = phi i64 [ %21, %20 ], [ %168, %156 ]
  %158 = phi double [ %17, %20 ], [ %167, %156 ]
  %159 = getelementptr inbounds double, ptr %0, i64 %157
  %160 = load double, ptr %159, align 8, !tbaa !17
  %161 = fadd double %160, 1.234500e+04
  %162 = tail call double @llvm.fmuladd.f64(double %161, double 9.142370e+05, double -1.300000e+01)
  %163 = fadd double %162, 1.234500e+04
  %164 = tail call double @llvm.fmuladd.f64(double %163, double 9.142370e+05, double -1.300000e+01)
  %165 = fadd double %164, 1.234500e+04
  %166 = tail call double @llvm.fmuladd.f64(double %165, double 9.142370e+05, double -1.300000e+01)
  %167 = fadd double %158, %166
  %168 = add nuw nsw i64 %157, 1
  %169 = icmp eq i64 %168, %11
  br i1 %169, label %170, label %156, !llvm.loop !318

170:                                              ; preds = %156, %16
  %171 = phi double [ %17, %16 ], [ %167, %156 ]
  %172 = load double, ptr @init_value, align 8, !tbaa !17
  %173 = fadd double %172, 1.234500e+04
  %174 = tail call double @llvm.fmuladd.f64(double %173, double 9.142370e+05, double -1.300000e+01)
  %175 = fadd double %174, 1.234500e+04
  %176 = tail call double @llvm.fmuladd.f64(double %175, double 9.142370e+05, double -1.300000e+01)
  %177 = fadd double %176, 1.234500e+04
  %178 = tail call double @llvm.fmuladd.f64(double %177, double 9.142370e+05, double -1.300000e+01)
  %179 = fmul double %178, 8.000000e+03
  %180 = fsub double %171, %179
  %181 = tail call double @llvm.fabs.f64(double %171)
  %182 = fcmp ogt double %181, 1.000000e-08
  %183 = select i1 %182, double %171, double 1.000000e+00
  %184 = fdiv double %180, %183
  %185 = tail call double @llvm.fabs.f64(double %184)
  %186 = fcmp olt double %185, 0x3EB0C6F7A0B5ED8D
  br i1 %186, label %190, label %187

187:                                              ; preds = %170
  %188 = load i32, ptr @current_test, align 4, !tbaa !11
  %189 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %188) #12
  br label %190

190:                                              ; preds = %187, %170
  %191 = add nuw nsw i32 %13, 1
  %192 = load i32, ptr @iterations, align 4, !tbaa !11
  %193 = icmp slt i32 %191, %192
  br i1 %193, label %12, label %194, !llvm.loop !319

194:                                              ; preds = %190, %3
  %195 = tail call i64 @clock() #15
  store i64 %195, ptr @end_time, align 8, !tbaa !23
  %196 = load i64, ptr @start_time, align 8, !tbaa !23
  %197 = sub nsw i64 %195, %196
  %198 = sitofp i64 %197 to double
  %199 = fdiv double %198, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %199, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi9EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi7EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi8EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 7)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi9EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 8)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi10EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %164

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -9
  %9 = icmp sgt i32 %1, 9
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %160, %7
  %13 = phi i32 [ 0, %7 ], [ %161, %160 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %123, %22 ]
  %.lcssa = phi i64 [ %124, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %140

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %126

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %124, %22 ], [ 0, %12 ]
  %24 = phi double [ %123, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = or i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = add nuw nsw i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = add nuw nsw i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = icmp slt i64 %124, %10
  br i1 %125, label %22, label %14, !llvm.loop !320

126:                                              ; preds = %126, %20
  %127 = phi i64 [ %21, %20 ], [ %138, %126 ]
  %128 = phi double [ %17, %20 ], [ %137, %126 ]
  %129 = getelementptr inbounds double, ptr %0, i64 %127
  %130 = load double, ptr %129, align 8, !tbaa !17
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %132, 1.234500e+04
  %134 = tail call double @llvm.fmuladd.f64(double %133, double 9.142370e+05, double -1.300000e+01)
  %135 = fadd double %134, 1.234500e+04
  %136 = tail call double @llvm.fmuladd.f64(double %135, double 9.142370e+05, double -1.300000e+01)
  %137 = fadd double %128, %136
  %138 = add nuw nsw i64 %127, 1
  %139 = icmp eq i64 %138, %11
  br i1 %139, label %140, label %126, !llvm.loop !321

140:                                              ; preds = %126, %16
  %141 = phi double [ %17, %16 ], [ %137, %126 ]
  %142 = load double, ptr @init_value, align 8, !tbaa !17
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %144, 1.234500e+04
  %146 = tail call double @llvm.fmuladd.f64(double %145, double 9.142370e+05, double -1.300000e+01)
  %147 = fadd double %146, 1.234500e+04
  %148 = tail call double @llvm.fmuladd.f64(double %147, double 9.142370e+05, double -1.300000e+01)
  %149 = fmul double %148, 8.000000e+03
  %150 = fsub double %141, %149
  %151 = tail call double @llvm.fabs.f64(double %141)
  %152 = fcmp ogt double %151, 1.000000e-08
  %153 = select i1 %152, double %141, double 1.000000e+00
  %154 = fdiv double %150, %153
  %155 = tail call double @llvm.fabs.f64(double %154)
  %156 = fcmp olt double %155, 0x3EB0C6F7A0B5ED8D
  br i1 %156, label %160, label %157

157:                                              ; preds = %140
  %158 = load i32, ptr @current_test, align 4, !tbaa !11
  %159 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %158) #12
  br label %160

160:                                              ; preds = %157, %140
  %161 = add nuw nsw i32 %13, 1
  %162 = load i32, ptr @iterations, align 4, !tbaa !11
  %163 = icmp slt i32 %161, %162
  br i1 %163, label %12, label %164, !llvm.loop !322

164:                                              ; preds = %160, %3
  %165 = tail call i64 @clock() #15
  store i64 %165, ptr @end_time, align 8, !tbaa !23
  %166 = load i64, ptr @start_time, align 8, !tbaa !23
  %167 = sub nsw i64 %165, %166
  %168 = sitofp i64 %167 to double
  %169 = fdiv double %168, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %169, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi11EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %174

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -10
  %9 = icmp sgt i32 %1, 10
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %170, %7
  %13 = phi i32 [ 0, %7 ], [ %171, %170 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi double [ %133, %22 ]
  %.lcssa = phi i64 [ %134, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %150

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %136

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %134, %22 ], [ 0, %12 ]
  %24 = phi double [ %133, %22 ], [ 0.000000e+00, %12 ]
  %25 = getelementptr inbounds double, ptr %0, i64 %23
  %26 = load double, ptr %25, align 8, !tbaa !17
  %27 = fadd double %26, 1.234500e+04
  %28 = tail call double @llvm.fmuladd.f64(double %27, double 9.142370e+05, double -1.300000e+01)
  %29 = fadd double %28, 1.234500e+04
  %30 = tail call double @llvm.fmuladd.f64(double %29, double 9.142370e+05, double -1.300000e+01)
  %31 = fadd double %30, 1.234500e+04
  %32 = tail call double @llvm.fmuladd.f64(double %31, double 9.142370e+05, double -1.300000e+01)
  %33 = fadd double %24, %32
  %34 = add nuw nsw i64 %23, 1
  %35 = getelementptr inbounds double, ptr %0, i64 %34
  %36 = load double, ptr %35, align 8, !tbaa !17
  %37 = fadd double %36, 1.234500e+04
  %38 = tail call double @llvm.fmuladd.f64(double %37, double 9.142370e+05, double -1.300000e+01)
  %39 = fadd double %38, 1.234500e+04
  %40 = tail call double @llvm.fmuladd.f64(double %39, double 9.142370e+05, double -1.300000e+01)
  %41 = fadd double %40, 1.234500e+04
  %42 = tail call double @llvm.fmuladd.f64(double %41, double 9.142370e+05, double -1.300000e+01)
  %43 = fadd double %33, %42
  %44 = add nuw nsw i64 %23, 2
  %45 = getelementptr inbounds double, ptr %0, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !17
  %47 = fadd double %46, 1.234500e+04
  %48 = tail call double @llvm.fmuladd.f64(double %47, double 9.142370e+05, double -1.300000e+01)
  %49 = fadd double %48, 1.234500e+04
  %50 = tail call double @llvm.fmuladd.f64(double %49, double 9.142370e+05, double -1.300000e+01)
  %51 = fadd double %50, 1.234500e+04
  %52 = tail call double @llvm.fmuladd.f64(double %51, double 9.142370e+05, double -1.300000e+01)
  %53 = fadd double %43, %52
  %54 = add nuw nsw i64 %23, 3
  %55 = getelementptr inbounds double, ptr %0, i64 %54
  %56 = load double, ptr %55, align 8, !tbaa !17
  %57 = fadd double %56, 1.234500e+04
  %58 = tail call double @llvm.fmuladd.f64(double %57, double 9.142370e+05, double -1.300000e+01)
  %59 = fadd double %58, 1.234500e+04
  %60 = tail call double @llvm.fmuladd.f64(double %59, double 9.142370e+05, double -1.300000e+01)
  %61 = fadd double %60, 1.234500e+04
  %62 = tail call double @llvm.fmuladd.f64(double %61, double 9.142370e+05, double -1.300000e+01)
  %63 = fadd double %53, %62
  %64 = add nuw nsw i64 %23, 4
  %65 = getelementptr inbounds double, ptr %0, i64 %64
  %66 = load double, ptr %65, align 8, !tbaa !17
  %67 = fadd double %66, 1.234500e+04
  %68 = tail call double @llvm.fmuladd.f64(double %67, double 9.142370e+05, double -1.300000e+01)
  %69 = fadd double %68, 1.234500e+04
  %70 = tail call double @llvm.fmuladd.f64(double %69, double 9.142370e+05, double -1.300000e+01)
  %71 = fadd double %70, 1.234500e+04
  %72 = tail call double @llvm.fmuladd.f64(double %71, double 9.142370e+05, double -1.300000e+01)
  %73 = fadd double %63, %72
  %74 = add nuw nsw i64 %23, 5
  %75 = getelementptr inbounds double, ptr %0, i64 %74
  %76 = load double, ptr %75, align 8, !tbaa !17
  %77 = fadd double %76, 1.234500e+04
  %78 = tail call double @llvm.fmuladd.f64(double %77, double 9.142370e+05, double -1.300000e+01)
  %79 = fadd double %78, 1.234500e+04
  %80 = tail call double @llvm.fmuladd.f64(double %79, double 9.142370e+05, double -1.300000e+01)
  %81 = fadd double %80, 1.234500e+04
  %82 = tail call double @llvm.fmuladd.f64(double %81, double 9.142370e+05, double -1.300000e+01)
  %83 = fadd double %73, %82
  %84 = add nuw nsw i64 %23, 6
  %85 = getelementptr inbounds double, ptr %0, i64 %84
  %86 = load double, ptr %85, align 8, !tbaa !17
  %87 = fadd double %86, 1.234500e+04
  %88 = tail call double @llvm.fmuladd.f64(double %87, double 9.142370e+05, double -1.300000e+01)
  %89 = fadd double %88, 1.234500e+04
  %90 = tail call double @llvm.fmuladd.f64(double %89, double 9.142370e+05, double -1.300000e+01)
  %91 = fadd double %90, 1.234500e+04
  %92 = tail call double @llvm.fmuladd.f64(double %91, double 9.142370e+05, double -1.300000e+01)
  %93 = fadd double %83, %92
  %94 = add nuw nsw i64 %23, 7
  %95 = getelementptr inbounds double, ptr %0, i64 %94
  %96 = load double, ptr %95, align 8, !tbaa !17
  %97 = fadd double %96, 1.234500e+04
  %98 = tail call double @llvm.fmuladd.f64(double %97, double 9.142370e+05, double -1.300000e+01)
  %99 = fadd double %98, 1.234500e+04
  %100 = tail call double @llvm.fmuladd.f64(double %99, double 9.142370e+05, double -1.300000e+01)
  %101 = fadd double %100, 1.234500e+04
  %102 = tail call double @llvm.fmuladd.f64(double %101, double 9.142370e+05, double -1.300000e+01)
  %103 = fadd double %93, %102
  %104 = add nuw nsw i64 %23, 8
  %105 = getelementptr inbounds double, ptr %0, i64 %104
  %106 = load double, ptr %105, align 8, !tbaa !17
  %107 = fadd double %106, 1.234500e+04
  %108 = tail call double @llvm.fmuladd.f64(double %107, double 9.142370e+05, double -1.300000e+01)
  %109 = fadd double %108, 1.234500e+04
  %110 = tail call double @llvm.fmuladd.f64(double %109, double 9.142370e+05, double -1.300000e+01)
  %111 = fadd double %110, 1.234500e+04
  %112 = tail call double @llvm.fmuladd.f64(double %111, double 9.142370e+05, double -1.300000e+01)
  %113 = fadd double %103, %112
  %114 = add nuw nsw i64 %23, 9
  %115 = getelementptr inbounds double, ptr %0, i64 %114
  %116 = load double, ptr %115, align 8, !tbaa !17
  %117 = fadd double %116, 1.234500e+04
  %118 = tail call double @llvm.fmuladd.f64(double %117, double 9.142370e+05, double -1.300000e+01)
  %119 = fadd double %118, 1.234500e+04
  %120 = tail call double @llvm.fmuladd.f64(double %119, double 9.142370e+05, double -1.300000e+01)
  %121 = fadd double %120, 1.234500e+04
  %122 = tail call double @llvm.fmuladd.f64(double %121, double 9.142370e+05, double -1.300000e+01)
  %123 = fadd double %113, %122
  %124 = add nuw nsw i64 %23, 10
  %125 = getelementptr inbounds double, ptr %0, i64 %124
  %126 = load double, ptr %125, align 8, !tbaa !17
  %127 = fadd double %126, 1.234500e+04
  %128 = tail call double @llvm.fmuladd.f64(double %127, double 9.142370e+05, double -1.300000e+01)
  %129 = fadd double %128, 1.234500e+04
  %130 = tail call double @llvm.fmuladd.f64(double %129, double 9.142370e+05, double -1.300000e+01)
  %131 = fadd double %130, 1.234500e+04
  %132 = tail call double @llvm.fmuladd.f64(double %131, double 9.142370e+05, double -1.300000e+01)
  %133 = fadd double %123, %132
  %134 = add nuw nsw i64 %23, 11
  %135 = icmp slt i64 %134, %10
  br i1 %135, label %22, label %14, !llvm.loop !323

136:                                              ; preds = %136, %20
  %137 = phi i64 [ %21, %20 ], [ %148, %136 ]
  %138 = phi double [ %17, %20 ], [ %147, %136 ]
  %139 = getelementptr inbounds double, ptr %0, i64 %137
  %140 = load double, ptr %139, align 8, !tbaa !17
  %141 = fadd double %140, 1.234500e+04
  %142 = tail call double @llvm.fmuladd.f64(double %141, double 9.142370e+05, double -1.300000e+01)
  %143 = fadd double %142, 1.234500e+04
  %144 = tail call double @llvm.fmuladd.f64(double %143, double 9.142370e+05, double -1.300000e+01)
  %145 = fadd double %144, 1.234500e+04
  %146 = tail call double @llvm.fmuladd.f64(double %145, double 9.142370e+05, double -1.300000e+01)
  %147 = fadd double %138, %146
  %148 = add nuw nsw i64 %137, 1
  %149 = icmp eq i64 %148, %11
  br i1 %149, label %150, label %136, !llvm.loop !324

150:                                              ; preds = %136, %16
  %151 = phi double [ %17, %16 ], [ %147, %136 ]
  %152 = load double, ptr @init_value, align 8, !tbaa !17
  %153 = fadd double %152, 1.234500e+04
  %154 = tail call double @llvm.fmuladd.f64(double %153, double 9.142370e+05, double -1.300000e+01)
  %155 = fadd double %154, 1.234500e+04
  %156 = tail call double @llvm.fmuladd.f64(double %155, double 9.142370e+05, double -1.300000e+01)
  %157 = fadd double %156, 1.234500e+04
  %158 = tail call double @llvm.fmuladd.f64(double %157, double 9.142370e+05, double -1.300000e+01)
  %159 = fmul double %158, 8.000000e+03
  %160 = fsub double %151, %159
  %161 = tail call double @llvm.fabs.f64(double %151)
  %162 = fcmp ogt double %161, 1.000000e-08
  %163 = select i1 %162, double %151, double 1.000000e+00
  %164 = fdiv double %160, %163
  %165 = tail call double @llvm.fabs.f64(double %164)
  %166 = fcmp olt double %165, 0x3EB0C6F7A0B5ED8D
  br i1 %166, label %170, label %167

167:                                              ; preds = %150
  %168 = load i32, ptr @current_test, align 4, !tbaa !11
  %169 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %168) #12
  br label %170

170:                                              ; preds = %167, %150
  %171 = add nuw nsw i32 %13, 1
  %172 = load i32, ptr @iterations, align 4, !tbaa !11
  %173 = icmp slt i32 %171, %172
  br i1 %173, label %12, label %174, !llvm.loop !325

174:                                              ; preds = %170, %3
  %175 = tail call i64 @clock() #15
  store i64 %175, ptr @end_time, align 8, !tbaa !23
  %176 = load i64, ptr @start_time, align 8, !tbaa !23
  %177 = sub nsw i64 %175, %176
  %178 = sitofp i64 %177 to double
  %179 = fdiv double %178, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %179, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi7EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi5EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi6EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 5)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi7EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 6)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi8EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %146

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -7
  %9 = icmp sgt i32 %1, 7
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %142, %7
  %13 = phi i32 [ %5, %7 ], [ %143, %142 ]
  %14 = phi i32 [ 0, %7 ], [ %144, %142 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %104, %23 ]
  %.lcssa = phi i64 [ %105, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %121

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %107

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %105, %23 ], [ 0, %12 ]
  %25 = phi double [ %104, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = or i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = or i64 %24, 2
  %46 = getelementptr inbounds double, ptr %0, i64 %45
  %47 = load double, ptr %46, align 8, !tbaa !17
  %48 = fadd double %47, 1.234500e+04
  %49 = tail call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %44, %53
  %55 = or i64 %24, 3
  %56 = getelementptr inbounds double, ptr %0, i64 %55
  %57 = load double, ptr %56, align 8, !tbaa !17
  %58 = fadd double %57, 1.234500e+04
  %59 = tail call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %54, %63
  %65 = or i64 %24, 4
  %66 = getelementptr inbounds double, ptr %0, i64 %65
  %67 = load double, ptr %66, align 8, !tbaa !17
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %64, %73
  %75 = or i64 %24, 5
  %76 = getelementptr inbounds double, ptr %0, i64 %75
  %77 = load double, ptr %76, align 8, !tbaa !17
  %78 = fadd double %77, 1.234500e+04
  %79 = tail call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fadd double %79, 1.234500e+04
  %81 = tail call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %74, %83
  %85 = or i64 %24, 6
  %86 = getelementptr inbounds double, ptr %0, i64 %85
  %87 = load double, ptr %86, align 8, !tbaa !17
  %88 = fadd double %87, 1.234500e+04
  %89 = tail call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fadd double %89, 1.234500e+04
  %91 = tail call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %91, 1.234500e+04
  %93 = tail call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %84, %93
  %95 = or i64 %24, 7
  %96 = getelementptr inbounds double, ptr %0, i64 %95
  %97 = load double, ptr %96, align 8, !tbaa !17
  %98 = fadd double %97, 1.234500e+04
  %99 = tail call double @llvm.fmuladd.f64(double %98, double 9.142370e+05, double -1.300000e+01)
  %100 = fadd double %99, 1.234500e+04
  %101 = tail call double @llvm.fmuladd.f64(double %100, double 9.142370e+05, double -1.300000e+01)
  %102 = fadd double %101, 1.234500e+04
  %103 = tail call double @llvm.fmuladd.f64(double %102, double 9.142370e+05, double -1.300000e+01)
  %104 = fadd double %94, %103
  %105 = add nuw nsw i64 %24, 8
  %106 = icmp slt i64 %105, %10
  br i1 %106, label %23, label %15, !llvm.loop !326

107:                                              ; preds = %107, %21
  %108 = phi i64 [ %22, %21 ], [ %119, %107 ]
  %109 = phi double [ %18, %21 ], [ %118, %107 ]
  %110 = getelementptr inbounds double, ptr %0, i64 %108
  %111 = load double, ptr %110, align 8, !tbaa !17
  %112 = fadd double %111, 1.234500e+04
  %113 = tail call double @llvm.fmuladd.f64(double %112, double 9.142370e+05, double -1.300000e+01)
  %114 = fadd double %113, 1.234500e+04
  %115 = tail call double @llvm.fmuladd.f64(double %114, double 9.142370e+05, double -1.300000e+01)
  %116 = fadd double %115, 1.234500e+04
  %117 = tail call double @llvm.fmuladd.f64(double %116, double 9.142370e+05, double -1.300000e+01)
  %118 = fadd double %109, %117
  %119 = add nuw nsw i64 %108, 1
  %120 = icmp eq i64 %119, %11
  br i1 %120, label %121, label %107, !llvm.loop !327

121:                                              ; preds = %107, %17
  %122 = phi double [ %18, %17 ], [ %118, %107 ]
  %123 = load double, ptr @init_value, align 8, !tbaa !17
  %124 = fadd double %123, 1.234500e+04
  %125 = tail call double @llvm.fmuladd.f64(double %124, double 9.142370e+05, double -1.300000e+01)
  %126 = fadd double %125, 1.234500e+04
  %127 = tail call double @llvm.fmuladd.f64(double %126, double 9.142370e+05, double -1.300000e+01)
  %128 = fadd double %127, 1.234500e+04
  %129 = tail call double @llvm.fmuladd.f64(double %128, double 9.142370e+05, double -1.300000e+01)
  %130 = fmul double %129, 8.000000e+03
  %131 = fsub double %122, %130
  %132 = tail call double @llvm.fabs.f64(double %122)
  %133 = fcmp ogt double %132, 1.000000e-08
  %134 = select i1 %133, double %122, double 1.000000e+00
  %135 = fdiv double %131, %134
  %136 = tail call double @llvm.fabs.f64(double %135)
  %137 = fcmp olt double %136, 0x3EB0C6F7A0B5ED8D
  br i1 %137, label %142, label %138

138:                                              ; preds = %121
  %139 = load i32, ptr @current_test, align 4, !tbaa !11
  %140 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %139) #12
  %141 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %142

142:                                              ; preds = %138, %121
  %143 = phi i32 [ %13, %121 ], [ %141, %138 ]
  %144 = add nuw nsw i32 %14, 1
  %145 = icmp slt i32 %144, %143
  br i1 %145, label %12, label %146, !llvm.loop !328

146:                                              ; preds = %142, %3
  %147 = tail call i64 @clock() #15
  store i64 %147, ptr @end_time, align 8, !tbaa !23
  %148 = load i64, ptr @start_time, align 8, !tbaa !23
  %149 = sub nsw i64 %147, %148
  %150 = sitofp i64 %149 to double
  %151 = fdiv double %150, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %151, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi9EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %156

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -8
  %9 = icmp sgt i32 %1, 8
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %152, %7
  %13 = phi i32 [ %5, %7 ], [ %153, %152 ]
  %14 = phi i32 [ 0, %7 ], [ %154, %152 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %114, %23 ]
  %.lcssa = phi i64 [ %115, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %131

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %117

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %115, %23 ], [ 0, %12 ]
  %25 = phi double [ %114, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = add nuw nsw i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = add nuw nsw i64 %24, 2
  %46 = getelementptr inbounds double, ptr %0, i64 %45
  %47 = load double, ptr %46, align 8, !tbaa !17
  %48 = fadd double %47, 1.234500e+04
  %49 = tail call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %44, %53
  %55 = add nuw nsw i64 %24, 3
  %56 = getelementptr inbounds double, ptr %0, i64 %55
  %57 = load double, ptr %56, align 8, !tbaa !17
  %58 = fadd double %57, 1.234500e+04
  %59 = tail call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %54, %63
  %65 = add nuw nsw i64 %24, 4
  %66 = getelementptr inbounds double, ptr %0, i64 %65
  %67 = load double, ptr %66, align 8, !tbaa !17
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %64, %73
  %75 = add nuw nsw i64 %24, 5
  %76 = getelementptr inbounds double, ptr %0, i64 %75
  %77 = load double, ptr %76, align 8, !tbaa !17
  %78 = fadd double %77, 1.234500e+04
  %79 = tail call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fadd double %79, 1.234500e+04
  %81 = tail call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %74, %83
  %85 = add nuw nsw i64 %24, 6
  %86 = getelementptr inbounds double, ptr %0, i64 %85
  %87 = load double, ptr %86, align 8, !tbaa !17
  %88 = fadd double %87, 1.234500e+04
  %89 = tail call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fadd double %89, 1.234500e+04
  %91 = tail call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %91, 1.234500e+04
  %93 = tail call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %84, %93
  %95 = add nuw nsw i64 %24, 7
  %96 = getelementptr inbounds double, ptr %0, i64 %95
  %97 = load double, ptr %96, align 8, !tbaa !17
  %98 = fadd double %97, 1.234500e+04
  %99 = tail call double @llvm.fmuladd.f64(double %98, double 9.142370e+05, double -1.300000e+01)
  %100 = fadd double %99, 1.234500e+04
  %101 = tail call double @llvm.fmuladd.f64(double %100, double 9.142370e+05, double -1.300000e+01)
  %102 = fadd double %101, 1.234500e+04
  %103 = tail call double @llvm.fmuladd.f64(double %102, double 9.142370e+05, double -1.300000e+01)
  %104 = fadd double %94, %103
  %105 = add nuw nsw i64 %24, 8
  %106 = getelementptr inbounds double, ptr %0, i64 %105
  %107 = load double, ptr %106, align 8, !tbaa !17
  %108 = fadd double %107, 1.234500e+04
  %109 = tail call double @llvm.fmuladd.f64(double %108, double 9.142370e+05, double -1.300000e+01)
  %110 = fadd double %109, 1.234500e+04
  %111 = tail call double @llvm.fmuladd.f64(double %110, double 9.142370e+05, double -1.300000e+01)
  %112 = fadd double %111, 1.234500e+04
  %113 = tail call double @llvm.fmuladd.f64(double %112, double 9.142370e+05, double -1.300000e+01)
  %114 = fadd double %104, %113
  %115 = add nuw nsw i64 %24, 9
  %116 = icmp slt i64 %115, %10
  br i1 %116, label %23, label %15, !llvm.loop !329

117:                                              ; preds = %117, %21
  %118 = phi i64 [ %22, %21 ], [ %129, %117 ]
  %119 = phi double [ %18, %21 ], [ %128, %117 ]
  %120 = getelementptr inbounds double, ptr %0, i64 %118
  %121 = load double, ptr %120, align 8, !tbaa !17
  %122 = fadd double %121, 1.234500e+04
  %123 = tail call double @llvm.fmuladd.f64(double %122, double 9.142370e+05, double -1.300000e+01)
  %124 = fadd double %123, 1.234500e+04
  %125 = tail call double @llvm.fmuladd.f64(double %124, double 9.142370e+05, double -1.300000e+01)
  %126 = fadd double %125, 1.234500e+04
  %127 = tail call double @llvm.fmuladd.f64(double %126, double 9.142370e+05, double -1.300000e+01)
  %128 = fadd double %119, %127
  %129 = add nuw nsw i64 %118, 1
  %130 = icmp eq i64 %129, %11
  br i1 %130, label %131, label %117, !llvm.loop !330

131:                                              ; preds = %117, %17
  %132 = phi double [ %18, %17 ], [ %128, %117 ]
  %133 = load double, ptr @init_value, align 8, !tbaa !17
  %134 = fadd double %133, 1.234500e+04
  %135 = tail call double @llvm.fmuladd.f64(double %134, double 9.142370e+05, double -1.300000e+01)
  %136 = fadd double %135, 1.234500e+04
  %137 = tail call double @llvm.fmuladd.f64(double %136, double 9.142370e+05, double -1.300000e+01)
  %138 = fadd double %137, 1.234500e+04
  %139 = tail call double @llvm.fmuladd.f64(double %138, double 9.142370e+05, double -1.300000e+01)
  %140 = fmul double %139, 8.000000e+03
  %141 = fsub double %132, %140
  %142 = tail call double @llvm.fabs.f64(double %132)
  %143 = fcmp ogt double %142, 1.000000e-08
  %144 = select i1 %143, double %132, double 1.000000e+00
  %145 = fdiv double %141, %144
  %146 = tail call double @llvm.fabs.f64(double %145)
  %147 = fcmp olt double %146, 0x3EB0C6F7A0B5ED8D
  br i1 %147, label %152, label %148

148:                                              ; preds = %131
  %149 = load i32, ptr @current_test, align 4, !tbaa !11
  %150 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %149) #12
  %151 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %152

152:                                              ; preds = %148, %131
  %153 = phi i32 [ %13, %131 ], [ %151, %148 ]
  %154 = add nuw nsw i32 %14, 1
  %155 = icmp slt i32 %154, %153
  br i1 %155, label %12, label %156, !llvm.loop !331

156:                                              ; preds = %152, %3
  %157 = tail call i64 @clock() #15
  store i64 %157, ptr @end_time, align 8, !tbaa !23
  %158 = load i64, ptr @start_time, align 8, !tbaa !23
  %159 = sub nsw i64 %157, %158
  %160 = sitofp i64 %159 to double
  %161 = fdiv double %160, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %161, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi5EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi3EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi4EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 3)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi5EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 4)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi6EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %126

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -5
  %9 = icmp sgt i32 %1, 5
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %122, %7
  %13 = phi i32 [ %5, %7 ], [ %123, %122 ]
  %14 = phi i32 [ 0, %7 ], [ %124, %122 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %84, %23 ]
  %.lcssa = phi i64 [ %85, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %101

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %87

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %85, %23 ], [ 0, %12 ]
  %25 = phi double [ %84, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = or i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = add nuw nsw i64 %24, 2
  %46 = getelementptr inbounds double, ptr %0, i64 %45
  %47 = load double, ptr %46, align 8, !tbaa !17
  %48 = fadd double %47, 1.234500e+04
  %49 = tail call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %44, %53
  %55 = add nuw nsw i64 %24, 3
  %56 = getelementptr inbounds double, ptr %0, i64 %55
  %57 = load double, ptr %56, align 8, !tbaa !17
  %58 = fadd double %57, 1.234500e+04
  %59 = tail call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %54, %63
  %65 = add nuw nsw i64 %24, 4
  %66 = getelementptr inbounds double, ptr %0, i64 %65
  %67 = load double, ptr %66, align 8, !tbaa !17
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %64, %73
  %75 = add nuw nsw i64 %24, 5
  %76 = getelementptr inbounds double, ptr %0, i64 %75
  %77 = load double, ptr %76, align 8, !tbaa !17
  %78 = fadd double %77, 1.234500e+04
  %79 = tail call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fadd double %79, 1.234500e+04
  %81 = tail call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %74, %83
  %85 = add nuw nsw i64 %24, 6
  %86 = icmp slt i64 %85, %10
  br i1 %86, label %23, label %15, !llvm.loop !332

87:                                               ; preds = %87, %21
  %88 = phi i64 [ %22, %21 ], [ %99, %87 ]
  %89 = phi double [ %18, %21 ], [ %98, %87 ]
  %90 = getelementptr inbounds double, ptr %0, i64 %88
  %91 = load double, ptr %90, align 8, !tbaa !17
  %92 = fadd double %91, 1.234500e+04
  %93 = tail call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %93, 1.234500e+04
  %95 = tail call double @llvm.fmuladd.f64(double %94, double 9.142370e+05, double -1.300000e+01)
  %96 = fadd double %95, 1.234500e+04
  %97 = tail call double @llvm.fmuladd.f64(double %96, double 9.142370e+05, double -1.300000e+01)
  %98 = fadd double %89, %97
  %99 = add nuw nsw i64 %88, 1
  %100 = icmp eq i64 %99, %11
  br i1 %100, label %101, label %87, !llvm.loop !333

101:                                              ; preds = %87, %17
  %102 = phi double [ %18, %17 ], [ %98, %87 ]
  %103 = load double, ptr @init_value, align 8, !tbaa !17
  %104 = fadd double %103, 1.234500e+04
  %105 = tail call double @llvm.fmuladd.f64(double %104, double 9.142370e+05, double -1.300000e+01)
  %106 = fadd double %105, 1.234500e+04
  %107 = tail call double @llvm.fmuladd.f64(double %106, double 9.142370e+05, double -1.300000e+01)
  %108 = fadd double %107, 1.234500e+04
  %109 = tail call double @llvm.fmuladd.f64(double %108, double 9.142370e+05, double -1.300000e+01)
  %110 = fmul double %109, 8.000000e+03
  %111 = fsub double %102, %110
  %112 = tail call double @llvm.fabs.f64(double %102)
  %113 = fcmp ogt double %112, 1.000000e-08
  %114 = select i1 %113, double %102, double 1.000000e+00
  %115 = fdiv double %111, %114
  %116 = tail call double @llvm.fabs.f64(double %115)
  %117 = fcmp olt double %116, 0x3EB0C6F7A0B5ED8D
  br i1 %117, label %122, label %118

118:                                              ; preds = %101
  %119 = load i32, ptr @current_test, align 4, !tbaa !11
  %120 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %119) #12
  %121 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %122

122:                                              ; preds = %118, %101
  %123 = phi i32 [ %13, %101 ], [ %121, %118 ]
  %124 = add nuw nsw i32 %14, 1
  %125 = icmp slt i32 %124, %123
  br i1 %125, label %12, label %126, !llvm.loop !334

126:                                              ; preds = %122, %3
  %127 = tail call i64 @clock() #15
  store i64 %127, ptr @end_time, align 8, !tbaa !23
  %128 = load i64, ptr @start_time, align 8, !tbaa !23
  %129 = sub nsw i64 %127, %128
  %130 = sitofp i64 %129 to double
  %131 = fdiv double %130, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %131, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi7EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %136

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -6
  %9 = icmp sgt i32 %1, 6
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %132, %7
  %13 = phi i32 [ %5, %7 ], [ %133, %132 ]
  %14 = phi i32 [ 0, %7 ], [ %134, %132 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %94, %23 ]
  %.lcssa = phi i64 [ %95, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %111

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %97

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %95, %23 ], [ 0, %12 ]
  %25 = phi double [ %94, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = add nuw nsw i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = add nuw nsw i64 %24, 2
  %46 = getelementptr inbounds double, ptr %0, i64 %45
  %47 = load double, ptr %46, align 8, !tbaa !17
  %48 = fadd double %47, 1.234500e+04
  %49 = tail call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %44, %53
  %55 = add nuw nsw i64 %24, 3
  %56 = getelementptr inbounds double, ptr %0, i64 %55
  %57 = load double, ptr %56, align 8, !tbaa !17
  %58 = fadd double %57, 1.234500e+04
  %59 = tail call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %54, %63
  %65 = add nuw nsw i64 %24, 4
  %66 = getelementptr inbounds double, ptr %0, i64 %65
  %67 = load double, ptr %66, align 8, !tbaa !17
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %64, %73
  %75 = add nuw nsw i64 %24, 5
  %76 = getelementptr inbounds double, ptr %0, i64 %75
  %77 = load double, ptr %76, align 8, !tbaa !17
  %78 = fadd double %77, 1.234500e+04
  %79 = tail call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fadd double %79, 1.234500e+04
  %81 = tail call double @llvm.fmuladd.f64(double %80, double 9.142370e+05, double -1.300000e+01)
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %74, %83
  %85 = add nuw nsw i64 %24, 6
  %86 = getelementptr inbounds double, ptr %0, i64 %85
  %87 = load double, ptr %86, align 8, !tbaa !17
  %88 = fadd double %87, 1.234500e+04
  %89 = tail call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fadd double %89, 1.234500e+04
  %91 = tail call double @llvm.fmuladd.f64(double %90, double 9.142370e+05, double -1.300000e+01)
  %92 = fadd double %91, 1.234500e+04
  %93 = tail call double @llvm.fmuladd.f64(double %92, double 9.142370e+05, double -1.300000e+01)
  %94 = fadd double %84, %93
  %95 = add nuw nsw i64 %24, 7
  %96 = icmp slt i64 %95, %10
  br i1 %96, label %23, label %15, !llvm.loop !335

97:                                               ; preds = %97, %21
  %98 = phi i64 [ %22, %21 ], [ %109, %97 ]
  %99 = phi double [ %18, %21 ], [ %108, %97 ]
  %100 = getelementptr inbounds double, ptr %0, i64 %98
  %101 = load double, ptr %100, align 8, !tbaa !17
  %102 = fadd double %101, 1.234500e+04
  %103 = tail call double @llvm.fmuladd.f64(double %102, double 9.142370e+05, double -1.300000e+01)
  %104 = fadd double %103, 1.234500e+04
  %105 = tail call double @llvm.fmuladd.f64(double %104, double 9.142370e+05, double -1.300000e+01)
  %106 = fadd double %105, 1.234500e+04
  %107 = tail call double @llvm.fmuladd.f64(double %106, double 9.142370e+05, double -1.300000e+01)
  %108 = fadd double %99, %107
  %109 = add nuw nsw i64 %98, 1
  %110 = icmp eq i64 %109, %11
  br i1 %110, label %111, label %97, !llvm.loop !336

111:                                              ; preds = %97, %17
  %112 = phi double [ %18, %17 ], [ %108, %97 ]
  %113 = load double, ptr @init_value, align 8, !tbaa !17
  %114 = fadd double %113, 1.234500e+04
  %115 = tail call double @llvm.fmuladd.f64(double %114, double 9.142370e+05, double -1.300000e+01)
  %116 = fadd double %115, 1.234500e+04
  %117 = tail call double @llvm.fmuladd.f64(double %116, double 9.142370e+05, double -1.300000e+01)
  %118 = fadd double %117, 1.234500e+04
  %119 = tail call double @llvm.fmuladd.f64(double %118, double 9.142370e+05, double -1.300000e+01)
  %120 = fmul double %119, 8.000000e+03
  %121 = fsub double %112, %120
  %122 = tail call double @llvm.fabs.f64(double %112)
  %123 = fcmp ogt double %122, 1.000000e-08
  %124 = select i1 %123, double %112, double 1.000000e+00
  %125 = fdiv double %121, %124
  %126 = tail call double @llvm.fabs.f64(double %125)
  %127 = fcmp olt double %126, 0x3EB0C6F7A0B5ED8D
  br i1 %127, label %132, label %128

128:                                              ; preds = %111
  %129 = load i32, ptr @current_test, align 4, !tbaa !11
  %130 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %129) #12
  %131 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %132

132:                                              ; preds = %128, %111
  %133 = phi i32 [ %13, %111 ], [ %131, %128 ]
  %134 = add nuw nsw i32 %14, 1
  %135 = icmp slt i32 %134, %133
  br i1 %135, label %12, label %136, !llvm.loop !337

136:                                              ; preds = %132, %3
  %137 = tail call i64 @clock() #15
  store i64 %137, ptr @end_time, align 8, !tbaa !23
  %138 = load i64, ptr @start_time, align 8, !tbaa !23
  %139 = sub nsw i64 %137, %138
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %141, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi3EdE7do_testEPKdPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_Z27test_for_loop_unroll_factorILi1EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull @temp_string) #12
  tail call void @_Z27test_for_loop_unroll_factorILi2EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 1)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi3EdEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 2)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi4EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %106

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -3
  %9 = icmp sgt i32 %1, 3
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %102, %7
  %13 = phi i32 [ %5, %7 ], [ %103, %102 ]
  %14 = phi i32 [ 0, %7 ], [ %104, %102 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %64, %23 ]
  %.lcssa = phi i64 [ %65, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %81

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %67

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %65, %23 ], [ 0, %12 ]
  %25 = phi double [ %64, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = or i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = or i64 %24, 2
  %46 = getelementptr inbounds double, ptr %0, i64 %45
  %47 = load double, ptr %46, align 8, !tbaa !17
  %48 = fadd double %47, 1.234500e+04
  %49 = tail call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %44, %53
  %55 = or i64 %24, 3
  %56 = getelementptr inbounds double, ptr %0, i64 %55
  %57 = load double, ptr %56, align 8, !tbaa !17
  %58 = fadd double %57, 1.234500e+04
  %59 = tail call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %54, %63
  %65 = add nuw nsw i64 %24, 4
  %66 = icmp slt i64 %65, %10
  br i1 %66, label %23, label %15, !llvm.loop !338

67:                                               ; preds = %67, %21
  %68 = phi i64 [ %22, %21 ], [ %79, %67 ]
  %69 = phi double [ %18, %21 ], [ %78, %67 ]
  %70 = getelementptr inbounds double, ptr %0, i64 %68
  %71 = load double, ptr %70, align 8, !tbaa !17
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %75, 1.234500e+04
  %77 = tail call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %69, %77
  %79 = add nuw nsw i64 %68, 1
  %80 = icmp eq i64 %79, %11
  br i1 %80, label %81, label %67, !llvm.loop !339

81:                                               ; preds = %67, %17
  %82 = phi double [ %18, %17 ], [ %78, %67 ]
  %83 = load double, ptr @init_value, align 8, !tbaa !17
  %84 = fadd double %83, 1.234500e+04
  %85 = tail call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %85, 1.234500e+04
  %87 = tail call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %87, 1.234500e+04
  %89 = tail call double @llvm.fmuladd.f64(double %88, double 9.142370e+05, double -1.300000e+01)
  %90 = fmul double %89, 8.000000e+03
  %91 = fsub double %82, %90
  %92 = tail call double @llvm.fabs.f64(double %82)
  %93 = fcmp ogt double %92, 1.000000e-08
  %94 = select i1 %93, double %82, double 1.000000e+00
  %95 = fdiv double %91, %94
  %96 = tail call double @llvm.fabs.f64(double %95)
  %97 = fcmp olt double %96, 0x3EB0C6F7A0B5ED8D
  br i1 %97, label %102, label %98

98:                                               ; preds = %81
  %99 = load i32, ptr @current_test, align 4, !tbaa !11
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %99) #12
  %101 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %102

102:                                              ; preds = %98, %81
  %103 = phi i32 [ %13, %81 ], [ %101, %98 ]
  %104 = add nuw nsw i32 %14, 1
  %105 = icmp slt i32 %104, %103
  br i1 %105, label %12, label %106, !llvm.loop !340

106:                                              ; preds = %102, %3
  %107 = tail call i64 @clock() #15
  store i64 %107, ptr @end_time, align 8, !tbaa !23
  %108 = load i64, ptr @start_time, align 8, !tbaa !23
  %109 = sub nsw i64 %107, %108
  %110 = sitofp i64 %109 to double
  %111 = fdiv double %110, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %111, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi5EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %116

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -4
  %9 = icmp sgt i32 %1, 4
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %112, %7
  %13 = phi i32 [ %5, %7 ], [ %113, %112 ]
  %14 = phi i32 [ 0, %7 ], [ %114, %112 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %74, %23 ]
  %.lcssa = phi i64 [ %75, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %91

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %77

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %75, %23 ], [ 0, %12 ]
  %25 = phi double [ %74, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = add nuw nsw i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = add nuw nsw i64 %24, 2
  %46 = getelementptr inbounds double, ptr %0, i64 %45
  %47 = load double, ptr %46, align 8, !tbaa !17
  %48 = fadd double %47, 1.234500e+04
  %49 = tail call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %44, %53
  %55 = add nuw nsw i64 %24, 3
  %56 = getelementptr inbounds double, ptr %0, i64 %55
  %57 = load double, ptr %56, align 8, !tbaa !17
  %58 = fadd double %57, 1.234500e+04
  %59 = tail call double @llvm.fmuladd.f64(double %58, double 9.142370e+05, double -1.300000e+01)
  %60 = fadd double %59, 1.234500e+04
  %61 = tail call double @llvm.fmuladd.f64(double %60, double 9.142370e+05, double -1.300000e+01)
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %54, %63
  %65 = add nuw nsw i64 %24, 4
  %66 = getelementptr inbounds double, ptr %0, i64 %65
  %67 = load double, ptr %66, align 8, !tbaa !17
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fadd double %69, 1.234500e+04
  %71 = tail call double @llvm.fmuladd.f64(double %70, double 9.142370e+05, double -1.300000e+01)
  %72 = fadd double %71, 1.234500e+04
  %73 = tail call double @llvm.fmuladd.f64(double %72, double 9.142370e+05, double -1.300000e+01)
  %74 = fadd double %64, %73
  %75 = add nuw nsw i64 %24, 5
  %76 = icmp slt i64 %75, %10
  br i1 %76, label %23, label %15, !llvm.loop !341

77:                                               ; preds = %77, %21
  %78 = phi i64 [ %22, %21 ], [ %89, %77 ]
  %79 = phi double [ %18, %21 ], [ %88, %77 ]
  %80 = getelementptr inbounds double, ptr %0, i64 %78
  %81 = load double, ptr %80, align 8, !tbaa !17
  %82 = fadd double %81, 1.234500e+04
  %83 = tail call double @llvm.fmuladd.f64(double %82, double 9.142370e+05, double -1.300000e+01)
  %84 = fadd double %83, 1.234500e+04
  %85 = tail call double @llvm.fmuladd.f64(double %84, double 9.142370e+05, double -1.300000e+01)
  %86 = fadd double %85, 1.234500e+04
  %87 = tail call double @llvm.fmuladd.f64(double %86, double 9.142370e+05, double -1.300000e+01)
  %88 = fadd double %79, %87
  %89 = add nuw nsw i64 %78, 1
  %90 = icmp eq i64 %89, %11
  br i1 %90, label %91, label %77, !llvm.loop !342

91:                                               ; preds = %77, %17
  %92 = phi double [ %18, %17 ], [ %88, %77 ]
  %93 = load double, ptr @init_value, align 8, !tbaa !17
  %94 = fadd double %93, 1.234500e+04
  %95 = tail call double @llvm.fmuladd.f64(double %94, double 9.142370e+05, double -1.300000e+01)
  %96 = fadd double %95, 1.234500e+04
  %97 = tail call double @llvm.fmuladd.f64(double %96, double 9.142370e+05, double -1.300000e+01)
  %98 = fadd double %97, 1.234500e+04
  %99 = tail call double @llvm.fmuladd.f64(double %98, double 9.142370e+05, double -1.300000e+01)
  %100 = fmul double %99, 8.000000e+03
  %101 = fsub double %92, %100
  %102 = tail call double @llvm.fabs.f64(double %92)
  %103 = fcmp ogt double %102, 1.000000e-08
  %104 = select i1 %103, double %92, double 1.000000e+00
  %105 = fdiv double %101, %104
  %106 = tail call double @llvm.fabs.f64(double %105)
  %107 = fcmp olt double %106, 0x3EB0C6F7A0B5ED8D
  br i1 %107, label %112, label %108

108:                                              ; preds = %91
  %109 = load i32, ptr @current_test, align 4, !tbaa !11
  %110 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %109) #12
  %111 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %112

112:                                              ; preds = %108, %91
  %113 = phi i32 [ %13, %91 ], [ %111, %108 ]
  %114 = add nuw nsw i32 %14, 1
  %115 = icmp slt i32 %114, %113
  br i1 %115, label %12, label %116, !llvm.loop !343

116:                                              ; preds = %112, %3
  %117 = tail call i64 @clock() #15
  store i64 %117, ptr @end_time, align 8, !tbaa !23
  %118 = load i64, ptr @start_time, align 8, !tbaa !23
  %119 = sub nsw i64 %117, %118
  %120 = sitofp i64 %119 to double
  %121 = fdiv double %120, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %121, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi1EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %52

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 0
  %9 = zext i32 %1 to i64
  br label %10

10:                                               ; preds = %48, %7
  %11 = phi i32 [ %5, %7 ], [ %49, %48 ]
  %12 = phi i32 [ 0, %7 ], [ %50, %48 ]
  br i1 %8, label %13, label %27

13:                                               ; preds = %13, %10
  %14 = phi i64 [ %25, %13 ], [ 0, %10 ]
  %15 = phi double [ %24, %13 ], [ 0.000000e+00, %10 ]
  %16 = getelementptr inbounds double, ptr %0, i64 %14
  %17 = load double, ptr %16, align 8, !tbaa !17
  %18 = fadd double %17, 1.234500e+04
  %19 = tail call double @llvm.fmuladd.f64(double %18, double 9.142370e+05, double -1.300000e+01)
  %20 = fadd double %19, 1.234500e+04
  %21 = tail call double @llvm.fmuladd.f64(double %20, double 9.142370e+05, double -1.300000e+01)
  %22 = fadd double %21, 1.234500e+04
  %23 = tail call double @llvm.fmuladd.f64(double %22, double 9.142370e+05, double -1.300000e+01)
  %24 = fadd double %15, %23
  %25 = add nuw nsw i64 %14, 1
  %26 = icmp eq i64 %25, %9
  br i1 %26, label %27, label %13, !llvm.loop !344

27:                                               ; preds = %13, %10
  %28 = phi double [ 0.000000e+00, %10 ], [ %24, %13 ]
  %29 = load double, ptr @init_value, align 8, !tbaa !17
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %33, 1.234500e+04
  %35 = tail call double @llvm.fmuladd.f64(double %34, double 9.142370e+05, double -1.300000e+01)
  %36 = fmul double %35, 8.000000e+03
  %37 = fsub double %28, %36
  %38 = tail call double @llvm.fabs.f64(double %28)
  %39 = fcmp ogt double %38, 1.000000e-08
  %40 = select i1 %39, double %28, double 1.000000e+00
  %41 = fdiv double %37, %40
  %42 = tail call double @llvm.fabs.f64(double %41)
  %43 = fcmp olt double %42, 0x3EB0C6F7A0B5ED8D
  br i1 %43, label %48, label %44

44:                                               ; preds = %27
  %45 = load i32, ptr @current_test, align 4, !tbaa !11
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %45) #12
  %47 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %48

48:                                               ; preds = %44, %27
  %49 = phi i32 [ %11, %27 ], [ %47, %44 ]
  %50 = add nuw nsw i32 %12, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %10, label %52, !llvm.loop !345

52:                                               ; preds = %48, %3
  %53 = tail call i64 @clock() #15
  store i64 %53, ptr @end_time, align 8, !tbaa !23
  %54 = load i64, ptr @start_time, align 8, !tbaa !23
  %55 = sub nsw i64 %53, %54
  %56 = sitofp i64 %55 to double
  %57 = fdiv double %56, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %57, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi2EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %86

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -1
  %9 = icmp sgt i32 %1, 1
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %82, %7
  %13 = phi i32 [ %5, %7 ], [ %83, %82 ]
  %14 = phi i32 [ 0, %7 ], [ %84, %82 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %44, %23 ]
  %.lcssa = phi i64 [ %45, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %61

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %47

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %45, %23 ], [ 0, %12 ]
  %25 = phi double [ %44, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = or i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = add nuw nsw i64 %24, 2
  %46 = icmp slt i64 %45, %10
  br i1 %46, label %23, label %15, !llvm.loop !346

47:                                               ; preds = %47, %21
  %48 = phi i64 [ %22, %21 ], [ %59, %47 ]
  %49 = phi double [ %18, %21 ], [ %58, %47 ]
  %50 = getelementptr inbounds double, ptr %0, i64 %48
  %51 = load double, ptr %50, align 8, !tbaa !17
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %53, 1.234500e+04
  %55 = tail call double @llvm.fmuladd.f64(double %54, double 9.142370e+05, double -1.300000e+01)
  %56 = fadd double %55, 1.234500e+04
  %57 = tail call double @llvm.fmuladd.f64(double %56, double 9.142370e+05, double -1.300000e+01)
  %58 = fadd double %49, %57
  %59 = add nuw nsw i64 %48, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %47, !llvm.loop !347

61:                                               ; preds = %47, %17
  %62 = phi double [ %18, %17 ], [ %58, %47 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !17
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %65, 1.234500e+04
  %67 = tail call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %67, 1.234500e+04
  %69 = tail call double @llvm.fmuladd.f64(double %68, double 9.142370e+05, double -1.300000e+01)
  %70 = fmul double %69, 8.000000e+03
  %71 = fsub double %62, %70
  %72 = tail call double @llvm.fabs.f64(double %62)
  %73 = fcmp ogt double %72, 1.000000e-08
  %74 = select i1 %73, double %62, double 1.000000e+00
  %75 = fdiv double %71, %74
  %76 = tail call double @llvm.fabs.f64(double %75)
  %77 = fcmp olt double %76, 0x3EB0C6F7A0B5ED8D
  br i1 %77, label %82, label %78

78:                                               ; preds = %61
  %79 = load i32, ptr @current_test, align 4, !tbaa !11
  %80 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %79) #12
  %81 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %82

82:                                               ; preds = %78, %61
  %83 = phi i32 [ %13, %61 ], [ %81, %78 ]
  %84 = add nuw nsw i32 %14, 1
  %85 = icmp slt i32 %84, %83
  br i1 %85, label %12, label %86, !llvm.loop !348

86:                                               ; preds = %82, %3
  %87 = tail call i64 @clock() #15
  store i64 %87, ptr @end_time, align 8, !tbaa !23
  %88 = load i64, ptr @start_time, align 8, !tbaa !23
  %89 = sub nsw i64 %87, %88
  %90 = sitofp i64 %89 to double
  %91 = fdiv double %90, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %91, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi3EdEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %96

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -2
  %9 = icmp sgt i32 %1, 2
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %92, %7
  %13 = phi i32 [ %5, %7 ], [ %93, %92 ]
  %14 = phi i32 [ 0, %7 ], [ %94, %92 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi double [ %54, %23 ]
  %.lcssa = phi i64 [ %55, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi double [ 0.000000e+00, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %71

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %57

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %55, %23 ], [ 0, %12 ]
  %25 = phi double [ %54, %23 ], [ 0.000000e+00, %12 ]
  %26 = getelementptr inbounds double, ptr %0, i64 %24
  %27 = load double, ptr %26, align 8, !tbaa !17
  %28 = fadd double %27, 1.234500e+04
  %29 = tail call double @llvm.fmuladd.f64(double %28, double 9.142370e+05, double -1.300000e+01)
  %30 = fadd double %29, 1.234500e+04
  %31 = tail call double @llvm.fmuladd.f64(double %30, double 9.142370e+05, double -1.300000e+01)
  %32 = fadd double %31, 1.234500e+04
  %33 = tail call double @llvm.fmuladd.f64(double %32, double 9.142370e+05, double -1.300000e+01)
  %34 = fadd double %25, %33
  %35 = add nuw nsw i64 %24, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !17
  %38 = fadd double %37, 1.234500e+04
  %39 = tail call double @llvm.fmuladd.f64(double %38, double 9.142370e+05, double -1.300000e+01)
  %40 = fadd double %39, 1.234500e+04
  %41 = tail call double @llvm.fmuladd.f64(double %40, double 9.142370e+05, double -1.300000e+01)
  %42 = fadd double %41, 1.234500e+04
  %43 = tail call double @llvm.fmuladd.f64(double %42, double 9.142370e+05, double -1.300000e+01)
  %44 = fadd double %34, %43
  %45 = add nuw nsw i64 %24, 2
  %46 = getelementptr inbounds double, ptr %0, i64 %45
  %47 = load double, ptr %46, align 8, !tbaa !17
  %48 = fadd double %47, 1.234500e+04
  %49 = tail call double @llvm.fmuladd.f64(double %48, double 9.142370e+05, double -1.300000e+01)
  %50 = fadd double %49, 1.234500e+04
  %51 = tail call double @llvm.fmuladd.f64(double %50, double 9.142370e+05, double -1.300000e+01)
  %52 = fadd double %51, 1.234500e+04
  %53 = tail call double @llvm.fmuladd.f64(double %52, double 9.142370e+05, double -1.300000e+01)
  %54 = fadd double %44, %53
  %55 = add nuw nsw i64 %24, 3
  %56 = icmp slt i64 %55, %10
  br i1 %56, label %23, label %15, !llvm.loop !349

57:                                               ; preds = %57, %21
  %58 = phi i64 [ %22, %21 ], [ %69, %57 ]
  %59 = phi double [ %18, %21 ], [ %68, %57 ]
  %60 = getelementptr inbounds double, ptr %0, i64 %58
  %61 = load double, ptr %60, align 8, !tbaa !17
  %62 = fadd double %61, 1.234500e+04
  %63 = tail call double @llvm.fmuladd.f64(double %62, double 9.142370e+05, double -1.300000e+01)
  %64 = fadd double %63, 1.234500e+04
  %65 = tail call double @llvm.fmuladd.f64(double %64, double 9.142370e+05, double -1.300000e+01)
  %66 = fadd double %65, 1.234500e+04
  %67 = tail call double @llvm.fmuladd.f64(double %66, double 9.142370e+05, double -1.300000e+01)
  %68 = fadd double %59, %67
  %69 = add nuw nsw i64 %58, 1
  %70 = icmp eq i64 %69, %11
  br i1 %70, label %71, label %57, !llvm.loop !350

71:                                               ; preds = %57, %17
  %72 = phi double [ %18, %17 ], [ %68, %57 ]
  %73 = load double, ptr @init_value, align 8, !tbaa !17
  %74 = fadd double %73, 1.234500e+04
  %75 = tail call double @llvm.fmuladd.f64(double %74, double 9.142370e+05, double -1.300000e+01)
  %76 = fadd double %75, 1.234500e+04
  %77 = tail call double @llvm.fmuladd.f64(double %76, double 9.142370e+05, double -1.300000e+01)
  %78 = fadd double %77, 1.234500e+04
  %79 = tail call double @llvm.fmuladd.f64(double %78, double 9.142370e+05, double -1.300000e+01)
  %80 = fmul double %79, 8.000000e+03
  %81 = fsub double %72, %80
  %82 = tail call double @llvm.fabs.f64(double %72)
  %83 = fcmp ogt double %82, 1.000000e-08
  %84 = select i1 %83, double %72, double 1.000000e+00
  %85 = fdiv double %81, %84
  %86 = tail call double @llvm.fabs.f64(double %85)
  %87 = fcmp olt double %86, 0x3EB0C6F7A0B5ED8D
  br i1 %87, label %92, label %88

88:                                               ; preds = %71
  %89 = load i32, ptr @current_test, align 4, !tbaa !11
  %90 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %89) #12
  %91 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %92

92:                                               ; preds = %88, %71
  %93 = phi i32 [ %13, %71 ], [ %91, %88 ]
  %94 = add nuw nsw i32 %14, 1
  %95 = icmp slt i32 %94, %93
  br i1 %95, label %12, label %96, !llvm.loop !351

96:                                               ; preds = %92, %3
  %97 = tail call i64 @clock() #15
  store i64 %97, ptr @end_time, align 8, !tbaa !23
  %98 = load i64, ptr @start_time, align 8, !tbaa !23
  %99 = sub nsw i64 %97, %98
  %100 = sitofp i64 %99 to double
  %101 = fdiv double %100, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %101, ptr noundef %2) #12
  ret void
}

; Function Attrs: inlinehint mustprogress optsize uwtable
define internal void @_ZN15loop_inner_bodyILi30EiE7do_workERiPKii(ptr noundef nonnull align 4 dereferenceable(4) %0, ptr noundef %1, i32 noundef %2) #9 comdat align 2 {
  tail call void @_ZN15loop_inner_bodyILi16EiE7do_workERiPKii(ptr noundef nonnull align 4 dereferenceable(4) %0, ptr noundef %1, i32 noundef %2) #12
  %4 = add nsw i32 %2, 16
  %5 = sext i32 %4 to i64
  %6 = getelementptr inbounds i32, ptr %1, i64 %5
  %7 = load i32, ptr %6, align 4, !tbaa !11
  %8 = mul i32 %7, 269850533
  %9 = add i32 %8, -1138325064
  %10 = load i32, ptr %0, align 4, !tbaa !11
  %11 = add nsw i32 %9, %10
  store i32 %11, ptr %0, align 4, !tbaa !11
  %12 = add nsw i32 %2, 17
  %13 = sext i32 %12 to i64
  %14 = getelementptr inbounds i32, ptr %1, i64 %13
  %15 = load i32, ptr %14, align 4, !tbaa !11
  %16 = mul i32 %15, 269850533
  %17 = add i32 %11, -1138325064
  %18 = add i32 %17, %16
  store i32 %18, ptr %0, align 4, !tbaa !11
  %19 = add nsw i32 %2, 18
  %20 = sext i32 %19 to i64
  %21 = getelementptr inbounds i32, ptr %1, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = mul i32 %22, 269850533
  %24 = add i32 %18, -1138325064
  %25 = add i32 %24, %23
  store i32 %25, ptr %0, align 4, !tbaa !11
  %26 = add nsw i32 %2, 19
  %27 = sext i32 %26 to i64
  %28 = getelementptr inbounds i32, ptr %1, i64 %27
  %29 = load i32, ptr %28, align 4, !tbaa !11
  %30 = mul i32 %29, 269850533
  %31 = add i32 %25, -1138325064
  %32 = add i32 %31, %30
  store i32 %32, ptr %0, align 4, !tbaa !11
  %33 = add nsw i32 %2, 20
  %34 = sext i32 %33 to i64
  %35 = getelementptr inbounds i32, ptr %1, i64 %34
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = mul i32 %36, 269850533
  %38 = add i32 %32, -1138325064
  %39 = add i32 %38, %37
  store i32 %39, ptr %0, align 4, !tbaa !11
  %40 = add nsw i32 %2, 21
  %41 = sext i32 %40 to i64
  %42 = getelementptr inbounds i32, ptr %1, i64 %41
  %43 = load i32, ptr %42, align 4, !tbaa !11
  %44 = mul i32 %43, 269850533
  %45 = add i32 %39, -1138325064
  %46 = add i32 %45, %44
  store i32 %46, ptr %0, align 4, !tbaa !11
  %47 = add nsw i32 %2, 22
  %48 = sext i32 %47 to i64
  %49 = getelementptr inbounds i32, ptr %1, i64 %48
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %46, -1138325064
  %53 = add i32 %52, %51
  store i32 %53, ptr %0, align 4, !tbaa !11
  %54 = add nsw i32 %2, 23
  %55 = sext i32 %54 to i64
  %56 = getelementptr inbounds i32, ptr %1, i64 %55
  %57 = load i32, ptr %56, align 4, !tbaa !11
  %58 = mul i32 %57, 269850533
  %59 = add i32 %53, -1138325064
  %60 = add i32 %59, %58
  store i32 %60, ptr %0, align 4, !tbaa !11
  %61 = add nsw i32 %2, 24
  %62 = sext i32 %61 to i64
  %63 = getelementptr inbounds i32, ptr %1, i64 %62
  %64 = load i32, ptr %63, align 4, !tbaa !11
  %65 = mul i32 %64, 269850533
  %66 = add i32 %60, -1138325064
  %67 = add i32 %66, %65
  store i32 %67, ptr %0, align 4, !tbaa !11
  %68 = add nsw i32 %2, 25
  %69 = sext i32 %68 to i64
  %70 = getelementptr inbounds i32, ptr %1, i64 %69
  %71 = load i32, ptr %70, align 4, !tbaa !11
  %72 = mul i32 %71, 269850533
  %73 = add i32 %67, -1138325064
  %74 = add i32 %73, %72
  store i32 %74, ptr %0, align 4, !tbaa !11
  %75 = add nsw i32 %2, 26
  %76 = sext i32 %75 to i64
  %77 = getelementptr inbounds i32, ptr %1, i64 %76
  %78 = load i32, ptr %77, align 4, !tbaa !11
  %79 = mul i32 %78, 269850533
  %80 = add i32 %74, -1138325064
  %81 = add i32 %80, %79
  store i32 %81, ptr %0, align 4, !tbaa !11
  %82 = add nsw i32 %2, 27
  %83 = sext i32 %82 to i64
  %84 = getelementptr inbounds i32, ptr %1, i64 %83
  %85 = load i32, ptr %84, align 4, !tbaa !11
  %86 = mul i32 %85, 269850533
  %87 = add i32 %81, -1138325064
  %88 = add i32 %87, %86
  store i32 %88, ptr %0, align 4, !tbaa !11
  %89 = add nsw i32 %2, 28
  %90 = sext i32 %89 to i64
  %91 = getelementptr inbounds i32, ptr %1, i64 %90
  %92 = load i32, ptr %91, align 4, !tbaa !11
  %93 = mul i32 %92, 269850533
  %94 = add i32 %88, -1138325064
  %95 = add i32 %94, %93
  store i32 %95, ptr %0, align 4, !tbaa !11
  %96 = add nsw i32 %2, 29
  %97 = sext i32 %96 to i64
  %98 = getelementptr inbounds i32, ptr %1, i64 %97
  %99 = load i32, ptr %98, align 4, !tbaa !11
  %100 = mul i32 %99, 269850533
  %101 = add i32 %95, -1138325064
  %102 = add i32 %101, %100
  store i32 %102, ptr %0, align 4, !tbaa !11
  ret void
}

; Function Attrs: inlinehint mustprogress optsize uwtable
define internal void @_ZN15loop_inner_bodyILi16EiE7do_workERiPKii(ptr noundef nonnull align 4 dereferenceable(4) %0, ptr noundef %1, i32 noundef %2) #9 comdat align 2 {
  %4 = sext i32 %2 to i64
  %5 = getelementptr inbounds i32, ptr %1, i64 %4
  %6 = load i32, ptr %5, align 4, !tbaa !11
  %7 = mul i32 %6, 269850533
  %8 = add i32 %7, -1138325064
  %9 = load i32, ptr %0, align 4, !tbaa !11
  %10 = add nsw i32 %8, %9
  store i32 %10, ptr %0, align 4, !tbaa !11
  %11 = add nsw i32 %2, 1
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds i32, ptr %1, i64 %12
  %14 = load i32, ptr %13, align 4, !tbaa !11
  %15 = mul i32 %14, 269850533
  %16 = add i32 %10, -1138325064
  %17 = add i32 %16, %15
  store i32 %17, ptr %0, align 4, !tbaa !11
  %18 = add nsw i32 %2, 2
  %19 = sext i32 %18 to i64
  %20 = getelementptr inbounds i32, ptr %1, i64 %19
  %21 = load i32, ptr %20, align 4, !tbaa !11
  %22 = mul i32 %21, 269850533
  %23 = add i32 %17, -1138325064
  %24 = add i32 %23, %22
  store i32 %24, ptr %0, align 4, !tbaa !11
  %25 = add nsw i32 %2, 3
  %26 = sext i32 %25 to i64
  %27 = getelementptr inbounds i32, ptr %1, i64 %26
  %28 = load i32, ptr %27, align 4, !tbaa !11
  %29 = mul i32 %28, 269850533
  %30 = add i32 %24, -1138325064
  %31 = add i32 %30, %29
  store i32 %31, ptr %0, align 4, !tbaa !11
  %32 = add nsw i32 %2, 4
  %33 = sext i32 %32 to i64
  %34 = getelementptr inbounds i32, ptr %1, i64 %33
  %35 = load i32, ptr %34, align 4, !tbaa !11
  %36 = mul i32 %35, 269850533
  %37 = add i32 %31, -1138325064
  %38 = add i32 %37, %36
  store i32 %38, ptr %0, align 4, !tbaa !11
  %39 = add nsw i32 %2, 5
  %40 = sext i32 %39 to i64
  %41 = getelementptr inbounds i32, ptr %1, i64 %40
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %38, -1138325064
  %45 = add i32 %44, %43
  store i32 %45, ptr %0, align 4, !tbaa !11
  %46 = add nsw i32 %2, 6
  %47 = sext i32 %46 to i64
  %48 = getelementptr inbounds i32, ptr %1, i64 %47
  %49 = load i32, ptr %48, align 4, !tbaa !11
  %50 = mul i32 %49, 269850533
  %51 = add i32 %45, -1138325064
  %52 = add i32 %51, %50
  store i32 %52, ptr %0, align 4, !tbaa !11
  %53 = add nsw i32 %2, 7
  %54 = sext i32 %53 to i64
  %55 = getelementptr inbounds i32, ptr %1, i64 %54
  %56 = load i32, ptr %55, align 4, !tbaa !11
  %57 = mul i32 %56, 269850533
  %58 = add i32 %52, -1138325064
  %59 = add i32 %58, %57
  store i32 %59, ptr %0, align 4, !tbaa !11
  %60 = add nsw i32 %2, 8
  %61 = sext i32 %60 to i64
  %62 = getelementptr inbounds i32, ptr %1, i64 %61
  %63 = load i32, ptr %62, align 4, !tbaa !11
  %64 = mul i32 %63, 269850533
  %65 = add i32 %59, -1138325064
  %66 = add i32 %65, %64
  store i32 %66, ptr %0, align 4, !tbaa !11
  %67 = add nsw i32 %2, 9
  %68 = sext i32 %67 to i64
  %69 = getelementptr inbounds i32, ptr %1, i64 %68
  %70 = load i32, ptr %69, align 4, !tbaa !11
  %71 = mul i32 %70, 269850533
  %72 = add i32 %66, -1138325064
  %73 = add i32 %72, %71
  store i32 %73, ptr %0, align 4, !tbaa !11
  %74 = add nsw i32 %2, 10
  %75 = sext i32 %74 to i64
  %76 = getelementptr inbounds i32, ptr %1, i64 %75
  %77 = load i32, ptr %76, align 4, !tbaa !11
  %78 = mul i32 %77, 269850533
  %79 = add i32 %73, -1138325064
  %80 = add i32 %79, %78
  store i32 %80, ptr %0, align 4, !tbaa !11
  %81 = add nsw i32 %2, 11
  %82 = sext i32 %81 to i64
  %83 = getelementptr inbounds i32, ptr %1, i64 %82
  %84 = load i32, ptr %83, align 4, !tbaa !11
  %85 = mul i32 %84, 269850533
  %86 = add i32 %80, -1138325064
  %87 = add i32 %86, %85
  store i32 %87, ptr %0, align 4, !tbaa !11
  %88 = add nsw i32 %2, 12
  %89 = sext i32 %88 to i64
  %90 = getelementptr inbounds i32, ptr %1, i64 %89
  %91 = load i32, ptr %90, align 4, !tbaa !11
  %92 = mul i32 %91, 269850533
  %93 = add i32 %87, -1138325064
  %94 = add i32 %93, %92
  store i32 %94, ptr %0, align 4, !tbaa !11
  %95 = add nsw i32 %2, 13
  %96 = sext i32 %95 to i64
  %97 = getelementptr inbounds i32, ptr %1, i64 %96
  %98 = load i32, ptr %97, align 4, !tbaa !11
  %99 = mul i32 %98, 269850533
  %100 = add i32 %94, -1138325064
  %101 = add i32 %100, %99
  store i32 %101, ptr %0, align 4, !tbaa !11
  %102 = add nsw i32 %2, 14
  %103 = sext i32 %102 to i64
  %104 = getelementptr inbounds i32, ptr %1, i64 %103
  %105 = load i32, ptr %104, align 4, !tbaa !11
  %106 = mul i32 %105, 269850533
  %107 = add i32 %101, -1138325064
  %108 = add i32 %107, %106
  store i32 %108, ptr %0, align 4, !tbaa !11
  %109 = add nsw i32 %2, 15
  %110 = sext i32 %109 to i64
  %111 = getelementptr inbounds i32, ptr %1, i64 %110
  %112 = load i32, ptr %111, align 4, !tbaa !11
  %113 = mul i32 %112, 269850533
  %114 = add i32 %108, -1138325064
  %115 = add i32 %114, %113
  store i32 %115, ptr %0, align 4, !tbaa !11
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi29EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi27EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi28EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 27)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi29EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 28)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi30EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca i32, align 4
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %51

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 29
  %10 = add nsw i32 %1, -29
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %47, %8
  %13 = phi i32 [ 0, %8 ], [ %48, %47 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #16
  store i32 0, ptr %4, align 4, !tbaa !11
  br i1 %9, label %14, label %20

14:                                               ; preds = %14, %12
  %15 = phi i32 [ %16, %14 ], [ 0, %12 ]
  call void @_ZN15loop_inner_bodyILi30EiE7do_workERiPKii(ptr noundef nonnull align 4 dereferenceable(4) %4, ptr noundef %0, i32 noundef %15) #12
  %16 = add nuw nsw i32 %15, 30
  %17 = icmp slt i32 %16, %10
  br i1 %17, label %14, label %18

18:                                               ; preds = %14
  %.lcssa = phi i32 [ %16, %14 ]
  %19 = load i32, ptr %4, align 4, !tbaa !11
  br label %20

20:                                               ; preds = %18, %12
  %21 = phi i32 [ 0, %12 ], [ %19, %18 ]
  %22 = phi i32 [ 0, %12 ], [ %.lcssa, %18 ]
  %23 = icmp slt i32 %22, %1
  br i1 %23, label %24, label %37

24:                                               ; preds = %20
  %25 = sext i32 %22 to i64
  br label %26

26:                                               ; preds = %26, %24
  %27 = phi i64 [ %25, %24 ], [ %34, %26 ]
  %28 = phi i32 [ %21, %24 ], [ %33, %26 ]
  %29 = getelementptr inbounds i32, ptr %0, i64 %27
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = mul i32 %30, 269850533
  %32 = add i32 %31, -1138325064
  %33 = add nsw i32 %32, %28
  %34 = add nsw i64 %27, 1
  %35 = icmp eq i64 %34, %11
  br i1 %35, label %36, label %26

36:                                               ; preds = %26
  %.lcssa1 = phi i32 [ %33, %26 ]
  store i32 %.lcssa1, ptr %4, align 4, !tbaa !11
  br label %37

37:                                               ; preds = %36, %20
  %38 = phi i32 [ %.lcssa1, %36 ], [ %21, %20 ]
  %39 = load double, ptr @init_value, align 8, !tbaa !17
  %40 = fptosi double %39 to i32
  %41 = mul i32 %40, -1564285888
  %42 = add i32 %41, -1269844480
  %43 = icmp eq i32 %42, %38
  br i1 %43, label %47, label %44

44:                                               ; preds = %37
  %45 = load i32, ptr @current_test, align 4, !tbaa !11
  %46 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %45) #12
  br label %47

47:                                               ; preds = %44, %37
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #16
  %48 = add nuw nsw i32 %13, 1
  %49 = load i32, ptr @iterations, align 4, !tbaa !11
  %50 = icmp slt i32 %48, %49
  br i1 %50, label %12, label %51, !llvm.loop !352

51:                                               ; preds = %47, %3
  %52 = call i64 @clock() #15
  store i64 %52, ptr @end_time, align 8, !tbaa !23
  %53 = load i64, ptr @start_time, align 8, !tbaa !23
  %54 = sub nsw i64 %52, %53
  %55 = sitofp i64 %54 to double
  %56 = fdiv double %55, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %56, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi31EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca i32, align 4
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %58

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 30
  %10 = add nsw i32 %1, -30
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %54, %8
  %13 = phi i32 [ 0, %8 ], [ %55, %54 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #16
  store i32 0, ptr %4, align 4, !tbaa !11
  br i1 %9, label %14, label %27

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %24, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi30EiE7do_workERiPKii(ptr noundef nonnull align 4 dereferenceable(4) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 30
  %18 = getelementptr inbounds i32, ptr %0, i64 %17
  %19 = load i32, ptr %18, align 4, !tbaa !11
  %20 = mul i32 %19, 269850533
  %21 = add i32 %20, -1138325064
  %22 = load i32, ptr %4, align 4, !tbaa !11
  %23 = add nsw i32 %21, %22
  store i32 %23, ptr %4, align 4, !tbaa !11
  %24 = add nuw i64 %15, 31
  %25 = trunc i64 %24 to i32
  %26 = icmp sgt i32 %10, %25
  br i1 %26, label %14, label %27

27:                                               ; preds = %14, %12
  %28 = phi i32 [ 0, %12 ], [ %23, %14 ]
  %29 = phi i32 [ 0, %12 ], [ %25, %14 ]
  %30 = icmp slt i32 %29, %1
  br i1 %30, label %31, label %44

31:                                               ; preds = %27
  %32 = sext i32 %29 to i64
  br label %33

33:                                               ; preds = %33, %31
  %34 = phi i64 [ %32, %31 ], [ %41, %33 ]
  %35 = phi i32 [ %28, %31 ], [ %40, %33 ]
  %36 = getelementptr inbounds i32, ptr %0, i64 %34
  %37 = load i32, ptr %36, align 4, !tbaa !11
  %38 = mul i32 %37, 269850533
  %39 = add i32 %38, -1138325064
  %40 = add nsw i32 %39, %35
  %41 = add nsw i64 %34, 1
  %42 = icmp eq i64 %41, %11
  br i1 %42, label %43, label %33

43:                                               ; preds = %33
  %.lcssa = phi i32 [ %40, %33 ]
  store i32 %.lcssa, ptr %4, align 4, !tbaa !11
  br label %44

44:                                               ; preds = %43, %27
  %45 = phi i32 [ %.lcssa, %43 ], [ %28, %27 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %54, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  br label %54

54:                                               ; preds = %51, %44
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #16
  %55 = add nuw nsw i32 %13, 1
  %56 = load i32, ptr @iterations, align 4, !tbaa !11
  %57 = icmp slt i32 %55, %56
  br i1 %57, label %12, label %58, !llvm.loop !353

58:                                               ; preds = %54, %3
  %59 = call i64 @clock() #15
  store i64 %59, ptr @end_time, align 8, !tbaa !23
  %60 = load i64, ptr @start_time, align 8, !tbaa !23
  %61 = sub nsw i64 %59, %60
  %62 = sitofp i64 %61 to double
  %63 = fdiv double %62, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %63, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi27EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi25EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi26EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 25)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi27EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 26)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi28EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 27
  %9 = add nsw i32 %1, -27
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ 0, %7 ], [ %64, %63 ]
  br i1 %8, label %14, label %37

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %33, %14 ], [ 0, %12 ]
  %16 = phi i32 [ %32, %14 ], [ 0, %12 ]
  %17 = getelementptr inbounds i32, ptr %0, i64 %15
  %18 = load <16 x i32>, ptr %17, align 4, !tbaa !11
  %19 = add nuw nsw i64 %15, 16
  %20 = getelementptr inbounds i32, ptr %0, i64 %19
  %21 = load <8 x i32>, ptr %20, align 4, !tbaa !11
  %22 = add nuw nsw i64 %15, 24
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load <4 x i32>, ptr %23, align 4, !tbaa !11
  %25 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %18)
  %26 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %21)
  %27 = add i32 %25, %26
  %28 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %24)
  %29 = add i32 %27, %28
  %30 = mul i32 %29, 269850533
  %31 = add i32 %16, -1808330720
  %32 = add i32 %31, %30
  %33 = add nuw nsw i64 %15, 28
  %34 = icmp slt i64 %33, %10
  br i1 %34, label %14, label %35

35:                                               ; preds = %14
  %.lcssa1 = phi i32 [ %32, %14 ]
  %.lcssa = phi i64 [ %33, %14 ]
  %36 = trunc i64 %.lcssa to i32
  br label %37

37:                                               ; preds = %35, %12
  %38 = phi i32 [ 0, %12 ], [ %.lcssa1, %35 ]
  %39 = phi i32 [ 0, %12 ], [ %36, %35 ]
  %40 = icmp slt i32 %39, %1
  br i1 %40, label %41, label %53

41:                                               ; preds = %37
  %42 = zext i32 %39 to i64
  br label %43

43:                                               ; preds = %43, %41
  %44 = phi i64 [ %42, %41 ], [ %51, %43 ]
  %45 = phi i32 [ %38, %41 ], [ %50, %43 ]
  %46 = getelementptr inbounds i32, ptr %0, i64 %44
  %47 = load i32, ptr %46, align 4, !tbaa !11
  %48 = mul i32 %47, 269850533
  %49 = add i32 %45, -1138325064
  %50 = add i32 %49, %48
  %51 = add nuw nsw i64 %44, 1
  %52 = icmp eq i64 %51, %11
  br i1 %52, label %53, label %43

53:                                               ; preds = %43, %37
  %54 = phi i32 [ %38, %37 ], [ %50, %43 ]
  %55 = load double, ptr @init_value, align 8, !tbaa !17
  %56 = fptosi double %55 to i32
  %57 = mul i32 %56, -1564285888
  %58 = add i32 %57, -1269844480
  %59 = icmp eq i32 %58, %54
  br i1 %59, label %63, label %60

60:                                               ; preds = %53
  %61 = load i32, ptr @current_test, align 4, !tbaa !11
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %61) #12
  br label %63

63:                                               ; preds = %60, %53
  %64 = add nuw nsw i32 %13, 1
  %65 = load i32, ptr @iterations, align 4, !tbaa !11
  %66 = icmp slt i32 %64, %65
  br i1 %66, label %12, label %67, !llvm.loop !354

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi29EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 28
  %9 = add nsw i32 %1, -28
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ 0, %7 ], [ %68, %67 ]
  br i1 %8, label %14, label %41

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %37, %14 ], [ 0, %12 ]
  %16 = phi i32 [ %36, %14 ], [ 0, %12 ]
  %17 = getelementptr inbounds i32, ptr %0, i64 %15
  %18 = load <16 x i32>, ptr %17, align 4, !tbaa !11
  %19 = add nuw nsw i64 %15, 16
  %20 = getelementptr inbounds i32, ptr %0, i64 %19
  %21 = load <8 x i32>, ptr %20, align 4, !tbaa !11
  %22 = add nuw nsw i64 %15, 24
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load <4 x i32>, ptr %23, align 4, !tbaa !11
  %25 = add nuw nsw i64 %15, 28
  %26 = getelementptr inbounds i32, ptr %0, i64 %25
  %27 = load i32, ptr %26, align 4, !tbaa !11
  %28 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %18)
  %29 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %21)
  %30 = add i32 %28, %29
  %31 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %24)
  %32 = add i32 %30, %31
  %33 = add i32 %32, %27
  %34 = mul i32 %33, 269850533
  %35 = add i32 %16, 1348311512
  %36 = add i32 %35, %34
  %37 = add nuw nsw i64 %15, 29
  %38 = icmp slt i64 %37, %10
  br i1 %38, label %14, label %39

39:                                               ; preds = %14
  %.lcssa1 = phi i32 [ %36, %14 ]
  %.lcssa = phi i64 [ %37, %14 ]
  %40 = trunc i64 %.lcssa to i32
  br label %41

41:                                               ; preds = %39, %12
  %42 = phi i32 [ 0, %12 ], [ %.lcssa1, %39 ]
  %43 = phi i32 [ 0, %12 ], [ %40, %39 ]
  %44 = icmp slt i32 %43, %1
  br i1 %44, label %45, label %57

45:                                               ; preds = %41
  %46 = zext i32 %43 to i64
  br label %47

47:                                               ; preds = %47, %45
  %48 = phi i64 [ %46, %45 ], [ %55, %47 ]
  %49 = phi i32 [ %42, %45 ], [ %54, %47 ]
  %50 = getelementptr inbounds i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !11
  %52 = mul i32 %51, 269850533
  %53 = add i32 %49, -1138325064
  %54 = add i32 %53, %52
  %55 = add nuw nsw i64 %48, 1
  %56 = icmp eq i64 %55, %11
  br i1 %56, label %57, label %47

57:                                               ; preds = %47, %41
  %58 = phi i32 [ %42, %41 ], [ %54, %47 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !17
  %60 = fptosi double %59 to i32
  %61 = mul i32 %60, -1564285888
  %62 = add i32 %61, -1269844480
  %63 = icmp eq i32 %62, %58
  br i1 %63, label %67, label %64

64:                                               ; preds = %57
  %65 = load i32, ptr @current_test, align 4, !tbaa !11
  %66 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %65) #12
  br label %67

67:                                               ; preds = %64, %57
  %68 = add nuw nsw i32 %13, 1
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  %70 = icmp slt i32 %68, %69
  br i1 %70, label %12, label %71, !llvm.loop !355

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.vector.reduce.add.v16i32(<16 x i32>) #10

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.vector.reduce.add.v8i32(<8 x i32>) #10

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.vector.reduce.add.v4i32(<4 x i32>) #10

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi25EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi23EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi24EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 23)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi25EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 24)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi26EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %70

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 25
  %9 = add nsw i32 %1, -25
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %66, %7
  %13 = phi i32 [ 0, %7 ], [ %67, %66 ]
  br i1 %8, label %14, label %40

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %36, %14 ], [ 0, %12 ]
  %16 = phi i32 [ %35, %14 ], [ 0, %12 ]
  %17 = getelementptr inbounds i32, ptr %0, i64 %15
  %18 = load <16 x i32>, ptr %17, align 4, !tbaa !11
  %19 = add nuw nsw i64 %15, 16
  %20 = getelementptr inbounds i32, ptr %0, i64 %19
  %21 = load <8 x i32>, ptr %20, align 4, !tbaa !11
  %22 = add nuw nsw i64 %15, 24
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load i32, ptr %23, align 4, !tbaa !11
  %25 = add nuw nsw i64 %15, 25
  %26 = getelementptr inbounds i32, ptr %0, i64 %25
  %27 = load i32, ptr %26, align 4, !tbaa !11
  %28 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %18)
  %29 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %21)
  %30 = add i32 %28, %29
  %31 = add i32 %30, %24
  %32 = add i32 %31, %27
  %33 = mul i32 %32, 269850533
  %34 = add i32 %16, 468319408
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %15, 26
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %14, label %38

38:                                               ; preds = %14
  %.lcssa1 = phi i32 [ %35, %14 ]
  %.lcssa = phi i64 [ %36, %14 ]
  %39 = trunc i64 %.lcssa to i32
  br label %40

40:                                               ; preds = %38, %12
  %41 = phi i32 [ 0, %12 ], [ %.lcssa1, %38 ]
  %42 = phi i32 [ 0, %12 ], [ %39, %38 ]
  %43 = icmp slt i32 %42, %1
  br i1 %43, label %44, label %56

44:                                               ; preds = %40
  %45 = zext i32 %42 to i64
  br label %46

46:                                               ; preds = %46, %44
  %47 = phi i64 [ %45, %44 ], [ %54, %46 ]
  %48 = phi i32 [ %41, %44 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46

56:                                               ; preds = %46, %40
  %57 = phi i32 [ %41, %40 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %66, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  br label %66

66:                                               ; preds = %63, %56
  %67 = add nuw nsw i32 %13, 1
  %68 = load i32, ptr @iterations, align 4, !tbaa !11
  %69 = icmp slt i32 %67, %68
  br i1 %69, label %12, label %70, !llvm.loop !356

70:                                               ; preds = %66, %3
  %71 = tail call i64 @clock() #15
  store i64 %71, ptr @end_time, align 8, !tbaa !23
  %72 = load i64, ptr @start_time, align 8, !tbaa !23
  %73 = sub nsw i64 %71, %72
  %74 = sitofp i64 %73 to double
  %75 = fdiv double %74, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %75, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi27EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %74

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 26
  %9 = add nsw i32 %1, -26
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %70, %7
  %13 = phi i32 [ 0, %7 ], [ %71, %70 ]
  br i1 %8, label %14, label %44

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %40, %14 ], [ 0, %12 ]
  %16 = phi i32 [ %39, %14 ], [ 0, %12 ]
  %17 = getelementptr inbounds i32, ptr %0, i64 %15
  %18 = load <16 x i32>, ptr %17, align 4, !tbaa !11
  %19 = add nuw nsw i64 %15, 16
  %20 = getelementptr inbounds i32, ptr %0, i64 %19
  %21 = load <8 x i32>, ptr %20, align 4, !tbaa !11
  %22 = add nuw nsw i64 %15, 24
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load i32, ptr %23, align 4, !tbaa !11
  %25 = add nuw nsw i64 %15, 25
  %26 = getelementptr inbounds i32, ptr %0, i64 %25
  %27 = load i32, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %15, 26
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %18)
  %32 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %21)
  %33 = add i32 %31, %32
  %34 = add i32 %33, %24
  %35 = add i32 %27, %30
  %36 = add i32 %34, %35
  %37 = mul i32 %36, 269850533
  %38 = add i32 %16, -670005656
  %39 = add i32 %38, %37
  %40 = add nuw nsw i64 %15, 27
  %41 = icmp slt i64 %40, %10
  br i1 %41, label %14, label %42

42:                                               ; preds = %14
  %.lcssa1 = phi i32 [ %39, %14 ]
  %.lcssa = phi i64 [ %40, %14 ]
  %43 = trunc i64 %.lcssa to i32
  br label %44

44:                                               ; preds = %42, %12
  %45 = phi i32 [ 0, %12 ], [ %.lcssa1, %42 ]
  %46 = phi i32 [ 0, %12 ], [ %43, %42 ]
  %47 = icmp slt i32 %46, %1
  br i1 %47, label %48, label %60

48:                                               ; preds = %44
  %49 = zext i32 %46 to i64
  br label %50

50:                                               ; preds = %50, %48
  %51 = phi i64 [ %49, %48 ], [ %58, %50 ]
  %52 = phi i32 [ %45, %48 ], [ %57, %50 ]
  %53 = getelementptr inbounds i32, ptr %0, i64 %51
  %54 = load i32, ptr %53, align 4, !tbaa !11
  %55 = mul i32 %54, 269850533
  %56 = add i32 %52, -1138325064
  %57 = add i32 %56, %55
  %58 = add nuw nsw i64 %51, 1
  %59 = icmp eq i64 %58, %11
  br i1 %59, label %60, label %50

60:                                               ; preds = %50, %44
  %61 = phi i32 [ %45, %44 ], [ %57, %50 ]
  %62 = load double, ptr @init_value, align 8, !tbaa !17
  %63 = fptosi double %62 to i32
  %64 = mul i32 %63, -1564285888
  %65 = add i32 %64, -1269844480
  %66 = icmp eq i32 %65, %61
  br i1 %66, label %70, label %67

67:                                               ; preds = %60
  %68 = load i32, ptr @current_test, align 4, !tbaa !11
  %69 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %68) #12
  br label %70

70:                                               ; preds = %67, %60
  %71 = add nuw nsw i32 %13, 1
  %72 = load i32, ptr @iterations, align 4, !tbaa !11
  %73 = icmp slt i32 %71, %72
  br i1 %73, label %12, label %74, !llvm.loop !357

74:                                               ; preds = %70, %3
  %75 = tail call i64 @clock() #15
  store i64 %75, ptr @end_time, align 8, !tbaa !23
  %76 = load i64, ptr @start_time, align 8, !tbaa !23
  %77 = sub nsw i64 %75, %76
  %78 = sitofp i64 %77 to double
  %79 = fdiv double %78, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %79, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi23EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi21EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi22EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 21)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi23EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 22)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi24EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %62

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 23
  %9 = add nsw i32 %1, -23
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %58, %7
  %13 = phi i32 [ 0, %7 ], [ %59, %58 ]
  br i1 %8, label %14, label %32

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %28, %14 ], [ 0, %12 ]
  %16 = phi i32 [ %27, %14 ], [ 0, %12 ]
  %17 = getelementptr inbounds i32, ptr %0, i64 %15
  %18 = load <16 x i32>, ptr %17, align 4, !tbaa !11
  %19 = add nuw nsw i64 %15, 16
  %20 = getelementptr inbounds i32, ptr %0, i64 %19
  %21 = load <8 x i32>, ptr %20, align 4, !tbaa !11
  %22 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %18)
  %23 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %21)
  %24 = add i32 %22, %23
  %25 = mul i32 %24, 269850533
  %26 = add i32 %16, -1549997760
  %27 = add i32 %26, %25
  %28 = add nuw nsw i64 %15, 24
  %29 = icmp slt i64 %28, %10
  br i1 %29, label %14, label %30

30:                                               ; preds = %14
  %.lcssa1 = phi i32 [ %27, %14 ]
  %.lcssa = phi i64 [ %28, %14 ]
  %31 = trunc i64 %.lcssa to i32
  br label %32

32:                                               ; preds = %30, %12
  %33 = phi i32 [ 0, %12 ], [ %.lcssa1, %30 ]
  %34 = phi i32 [ 0, %12 ], [ %31, %30 ]
  %35 = icmp slt i32 %34, %1
  br i1 %35, label %36, label %48

36:                                               ; preds = %32
  %37 = zext i32 %34 to i64
  br label %38

38:                                               ; preds = %38, %36
  %39 = phi i64 [ %37, %36 ], [ %46, %38 ]
  %40 = phi i32 [ %33, %36 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38

48:                                               ; preds = %38, %32
  %49 = phi i32 [ %33, %32 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %58, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  br label %58

58:                                               ; preds = %55, %48
  %59 = add nuw nsw i32 %13, 1
  %60 = load i32, ptr @iterations, align 4, !tbaa !11
  %61 = icmp slt i32 %59, %60
  br i1 %61, label %12, label %62, !llvm.loop !358

62:                                               ; preds = %58, %3
  %63 = tail call i64 @clock() #15
  store i64 %63, ptr @end_time, align 8, !tbaa !23
  %64 = load i64, ptr @start_time, align 8, !tbaa !23
  %65 = sub nsw i64 %63, %64
  %66 = sitofp i64 %65 to double
  %67 = fdiv double %66, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %67, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi25EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %66

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 24
  %9 = add nsw i32 %1, -24
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %62, %7
  %13 = phi i32 [ 0, %7 ], [ %63, %62 ]
  br i1 %8, label %14, label %36

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %32, %14 ], [ 0, %12 ]
  %16 = phi i32 [ %31, %14 ], [ 0, %12 ]
  %17 = getelementptr inbounds i32, ptr %0, i64 %15
  %18 = load <16 x i32>, ptr %17, align 4, !tbaa !11
  %19 = add nuw nsw i64 %15, 16
  %20 = getelementptr inbounds i32, ptr %0, i64 %19
  %21 = load <8 x i32>, ptr %20, align 4, !tbaa !11
  %22 = add nuw nsw i64 %15, 24
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load i32, ptr %23, align 4, !tbaa !11
  %25 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %18)
  %26 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %21)
  %27 = add i32 %25, %26
  %28 = add i32 %27, %24
  %29 = mul i32 %28, 269850533
  %30 = add i32 %16, 1606644472
  %31 = add i32 %30, %29
  %32 = add nuw nsw i64 %15, 25
  %33 = icmp slt i64 %32, %10
  br i1 %33, label %14, label %34

34:                                               ; preds = %14
  %.lcssa1 = phi i32 [ %31, %14 ]
  %.lcssa = phi i64 [ %32, %14 ]
  %35 = trunc i64 %.lcssa to i32
  br label %36

36:                                               ; preds = %34, %12
  %37 = phi i32 [ 0, %12 ], [ %.lcssa1, %34 ]
  %38 = phi i32 [ 0, %12 ], [ %35, %34 ]
  %39 = icmp slt i32 %38, %1
  br i1 %39, label %40, label %52

40:                                               ; preds = %36
  %41 = zext i32 %38 to i64
  br label %42

42:                                               ; preds = %42, %40
  %43 = phi i64 [ %41, %40 ], [ %50, %42 ]
  %44 = phi i32 [ %37, %40 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42

52:                                               ; preds = %42, %36
  %53 = phi i32 [ %37, %36 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %62, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  br label %62

62:                                               ; preds = %59, %52
  %63 = add nuw nsw i32 %13, 1
  %64 = load i32, ptr @iterations, align 4, !tbaa !11
  %65 = icmp slt i32 %63, %64
  br i1 %65, label %12, label %66, !llvm.loop !359

66:                                               ; preds = %62, %3
  %67 = tail call i64 @clock() #15
  store i64 %67, ptr @end_time, align 8, !tbaa !23
  %68 = load i64, ptr @start_time, align 8, !tbaa !23
  %69 = sub nsw i64 %67, %68
  %70 = sitofp i64 %69 to double
  %71 = fdiv double %70, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %71, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi21EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi19EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi20EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 19)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi21EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 20)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi22EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %72

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 21
  %9 = add nsw i32 %1, -21
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %68, %7
  %13 = phi i32 [ %5, %7 ], [ %69, %68 ]
  %14 = phi i32 [ 0, %7 ], [ %70, %68 ]
  br i1 %8, label %15, label %41

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %37, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %36, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 16
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 20
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add nuw nsw i64 %16, 21
  %27 = getelementptr inbounds i32, ptr %0, i64 %26
  %28 = load i32, ptr %27, align 4, !tbaa !11
  %29 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %30 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %31 = add i32 %29, %30
  %32 = add i32 %31, %25
  %33 = add i32 %32, %28
  %34 = mul i32 %33, 269850533
  %35 = add i32 %17, 726652368
  %36 = add i32 %35, %34
  %37 = add nuw nsw i64 %16, 22
  %38 = icmp slt i64 %37, %10
  br i1 %38, label %15, label %39

39:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %36, %15 ]
  %.lcssa = phi i64 [ %37, %15 ]
  %40 = trunc i64 %.lcssa to i32
  br label %41

41:                                               ; preds = %39, %12
  %42 = phi i32 [ 0, %12 ], [ %.lcssa1, %39 ]
  %43 = phi i32 [ 0, %12 ], [ %40, %39 ]
  %44 = icmp slt i32 %43, %1
  br i1 %44, label %45, label %57

45:                                               ; preds = %41
  %46 = zext i32 %43 to i64
  br label %47

47:                                               ; preds = %47, %45
  %48 = phi i64 [ %46, %45 ], [ %55, %47 ]
  %49 = phi i32 [ %42, %45 ], [ %54, %47 ]
  %50 = getelementptr inbounds i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !11
  %52 = mul i32 %51, 269850533
  %53 = add i32 %49, -1138325064
  %54 = add i32 %53, %52
  %55 = add nuw nsw i64 %48, 1
  %56 = icmp eq i64 %55, %11
  br i1 %56, label %57, label %47

57:                                               ; preds = %47, %41
  %58 = phi i32 [ %42, %41 ], [ %54, %47 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !17
  %60 = fptosi double %59 to i32
  %61 = mul i32 %60, -1564285888
  %62 = add i32 %61, -1269844480
  %63 = icmp eq i32 %62, %58
  br i1 %63, label %68, label %64

64:                                               ; preds = %57
  %65 = load i32, ptr @current_test, align 4, !tbaa !11
  %66 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %65) #12
  %67 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %68

68:                                               ; preds = %64, %57
  %69 = phi i32 [ %13, %57 ], [ %67, %64 ]
  %70 = add nuw nsw i32 %14, 1
  %71 = icmp slt i32 %70, %69
  br i1 %71, label %12, label %72, !llvm.loop !360

72:                                               ; preds = %68, %3
  %73 = tail call i64 @clock() #15
  store i64 %73, ptr @end_time, align 8, !tbaa !23
  %74 = load i64, ptr @start_time, align 8, !tbaa !23
  %75 = sub nsw i64 %73, %74
  %76 = sitofp i64 %75 to double
  %77 = fdiv double %76, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %77, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi23EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %76

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 22
  %9 = add nsw i32 %1, -22
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %72, %7
  %13 = phi i32 [ %5, %7 ], [ %73, %72 ]
  %14 = phi i32 [ 0, %7 ], [ %74, %72 ]
  br i1 %8, label %15, label %45

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %41, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %40, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 16
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 20
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add nuw nsw i64 %16, 21
  %27 = getelementptr inbounds i32, ptr %0, i64 %26
  %28 = load i32, ptr %27, align 4, !tbaa !11
  %29 = add nuw nsw i64 %16, 22
  %30 = getelementptr inbounds i32, ptr %0, i64 %29
  %31 = load i32, ptr %30, align 4, !tbaa !11
  %32 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %33 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %34 = add i32 %32, %33
  %35 = add i32 %34, %25
  %36 = add i32 %28, %31
  %37 = add i32 %35, %36
  %38 = mul i32 %37, 269850533
  %39 = add i32 %17, -411672696
  %40 = add i32 %39, %38
  %41 = add nuw nsw i64 %16, 23
  %42 = icmp slt i64 %41, %10
  br i1 %42, label %15, label %43

43:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %40, %15 ]
  %.lcssa = phi i64 [ %41, %15 ]
  %44 = trunc i64 %.lcssa to i32
  br label %45

45:                                               ; preds = %43, %12
  %46 = phi i32 [ 0, %12 ], [ %.lcssa1, %43 ]
  %47 = phi i32 [ 0, %12 ], [ %44, %43 ]
  %48 = icmp slt i32 %47, %1
  br i1 %48, label %49, label %61

49:                                               ; preds = %45
  %50 = zext i32 %47 to i64
  br label %51

51:                                               ; preds = %51, %49
  %52 = phi i64 [ %50, %49 ], [ %59, %51 ]
  %53 = phi i32 [ %46, %49 ], [ %58, %51 ]
  %54 = getelementptr inbounds i32, ptr %0, i64 %52
  %55 = load i32, ptr %54, align 4, !tbaa !11
  %56 = mul i32 %55, 269850533
  %57 = add i32 %53, -1138325064
  %58 = add i32 %57, %56
  %59 = add nuw nsw i64 %52, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %51

61:                                               ; preds = %51, %45
  %62 = phi i32 [ %46, %45 ], [ %58, %51 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !17
  %64 = fptosi double %63 to i32
  %65 = mul i32 %64, -1564285888
  %66 = add i32 %65, -1269844480
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %72, label %68

68:                                               ; preds = %61
  %69 = load i32, ptr @current_test, align 4, !tbaa !11
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %69) #12
  %71 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %72

72:                                               ; preds = %68, %61
  %73 = phi i32 [ %13, %61 ], [ %71, %68 ]
  %74 = add nuw nsw i32 %14, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %12, label %76, !llvm.loop !361

76:                                               ; preds = %72, %3
  %77 = tail call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi19EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi17EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi18EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 17)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi19EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 18)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi20EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %64

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 19
  %9 = add nsw i32 %1, -19
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %60, %7
  %13 = phi i32 [ %5, %7 ], [ %61, %60 ]
  %14 = phi i32 [ 0, %7 ], [ %62, %60 ]
  br i1 %8, label %15, label %33

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %29, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %28, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 16
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %24 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %25 = add i32 %23, %24
  %26 = mul i32 %25, 269850533
  %27 = add i32 %17, -1291664800
  %28 = add i32 %27, %26
  %29 = add nuw nsw i64 %16, 20
  %30 = icmp slt i64 %29, %10
  br i1 %30, label %15, label %31

31:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %28, %15 ]
  %.lcssa = phi i64 [ %29, %15 ]
  %32 = trunc i64 %.lcssa to i32
  br label %33

33:                                               ; preds = %31, %12
  %34 = phi i32 [ 0, %12 ], [ %.lcssa1, %31 ]
  %35 = phi i32 [ 0, %12 ], [ %32, %31 ]
  %36 = icmp slt i32 %35, %1
  br i1 %36, label %37, label %49

37:                                               ; preds = %33
  %38 = zext i32 %35 to i64
  br label %39

39:                                               ; preds = %39, %37
  %40 = phi i64 [ %38, %37 ], [ %47, %39 ]
  %41 = phi i32 [ %34, %37 ], [ %46, %39 ]
  %42 = getelementptr inbounds i32, ptr %0, i64 %40
  %43 = load i32, ptr %42, align 4, !tbaa !11
  %44 = mul i32 %43, 269850533
  %45 = add i32 %41, -1138325064
  %46 = add i32 %45, %44
  %47 = add nuw nsw i64 %40, 1
  %48 = icmp eq i64 %47, %11
  br i1 %48, label %49, label %39

49:                                               ; preds = %39, %33
  %50 = phi i32 [ %34, %33 ], [ %46, %39 ]
  %51 = load double, ptr @init_value, align 8, !tbaa !17
  %52 = fptosi double %51 to i32
  %53 = mul i32 %52, -1564285888
  %54 = add i32 %53, -1269844480
  %55 = icmp eq i32 %54, %50
  br i1 %55, label %60, label %56

56:                                               ; preds = %49
  %57 = load i32, ptr @current_test, align 4, !tbaa !11
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %57) #12
  %59 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %60

60:                                               ; preds = %56, %49
  %61 = phi i32 [ %13, %49 ], [ %59, %56 ]
  %62 = add nuw nsw i32 %14, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %12, label %64, !llvm.loop !362

64:                                               ; preds = %60, %3
  %65 = tail call i64 @clock() #15
  store i64 %65, ptr @end_time, align 8, !tbaa !23
  %66 = load i64, ptr @start_time, align 8, !tbaa !23
  %67 = sub nsw i64 %65, %66
  %68 = sitofp i64 %67 to double
  %69 = fdiv double %68, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %69, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi21EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %68

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 20
  %9 = add nsw i32 %1, -20
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %64, %7
  %13 = phi i32 [ %5, %7 ], [ %65, %64 ]
  %14 = phi i32 [ 0, %7 ], [ %66, %64 ]
  br i1 %8, label %15, label %37

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %33, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %32, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 16
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 20
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %27 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %28 = add i32 %26, %27
  %29 = add i32 %28, %25
  %30 = mul i32 %29, 269850533
  %31 = add i32 %17, 1864977432
  %32 = add i32 %31, %30
  %33 = add nuw nsw i64 %16, 21
  %34 = icmp slt i64 %33, %10
  br i1 %34, label %15, label %35

35:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %32, %15 ]
  %.lcssa = phi i64 [ %33, %15 ]
  %36 = trunc i64 %.lcssa to i32
  br label %37

37:                                               ; preds = %35, %12
  %38 = phi i32 [ 0, %12 ], [ %.lcssa1, %35 ]
  %39 = phi i32 [ 0, %12 ], [ %36, %35 ]
  %40 = icmp slt i32 %39, %1
  br i1 %40, label %41, label %53

41:                                               ; preds = %37
  %42 = zext i32 %39 to i64
  br label %43

43:                                               ; preds = %43, %41
  %44 = phi i64 [ %42, %41 ], [ %51, %43 ]
  %45 = phi i32 [ %38, %41 ], [ %50, %43 ]
  %46 = getelementptr inbounds i32, ptr %0, i64 %44
  %47 = load i32, ptr %46, align 4, !tbaa !11
  %48 = mul i32 %47, 269850533
  %49 = add i32 %45, -1138325064
  %50 = add i32 %49, %48
  %51 = add nuw nsw i64 %44, 1
  %52 = icmp eq i64 %51, %11
  br i1 %52, label %53, label %43

53:                                               ; preds = %43, %37
  %54 = phi i32 [ %38, %37 ], [ %50, %43 ]
  %55 = load double, ptr @init_value, align 8, !tbaa !17
  %56 = fptosi double %55 to i32
  %57 = mul i32 %56, -1564285888
  %58 = add i32 %57, -1269844480
  %59 = icmp eq i32 %58, %54
  br i1 %59, label %64, label %60

60:                                               ; preds = %53
  %61 = load i32, ptr @current_test, align 4, !tbaa !11
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %61) #12
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %64

64:                                               ; preds = %60, %53
  %65 = phi i32 [ %13, %53 ], [ %63, %60 ]
  %66 = add nuw nsw i32 %14, 1
  %67 = icmp slt i32 %66, %65
  br i1 %67, label %12, label %68, !llvm.loop !363

68:                                               ; preds = %64, %3
  %69 = tail call i64 @clock() #15
  store i64 %69, ptr @end_time, align 8, !tbaa !23
  %70 = load i64, ptr @start_time, align 8, !tbaa !23
  %71 = sub nsw i64 %69, %70
  %72 = sitofp i64 %71 to double
  %73 = fdiv double %72, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %73, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi17EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi15EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi16EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 15)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi17EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 16)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi18EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 17
  %9 = add nsw i32 %1, -17
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ %5, %7 ], [ %64, %63 ]
  %14 = phi i32 [ 0, %7 ], [ %65, %63 ]
  br i1 %8, label %15, label %36

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %32, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %31, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 16
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 17
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %27 = add i32 %26, %22
  %28 = add i32 %27, %25
  %29 = mul i32 %28, 269850533
  %30 = add i32 %17, 984985328
  %31 = add i32 %30, %29
  %32 = add nuw nsw i64 %16, 18
  %33 = icmp slt i64 %32, %10
  br i1 %33, label %15, label %34

34:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %31, %15 ]
  %.lcssa = phi i64 [ %32, %15 ]
  %35 = trunc i64 %.lcssa to i32
  br label %36

36:                                               ; preds = %34, %12
  %37 = phi i32 [ 0, %12 ], [ %.lcssa1, %34 ]
  %38 = phi i32 [ 0, %12 ], [ %35, %34 ]
  %39 = icmp slt i32 %38, %1
  br i1 %39, label %40, label %52

40:                                               ; preds = %36
  %41 = zext i32 %38 to i64
  br label %42

42:                                               ; preds = %42, %40
  %43 = phi i64 [ %41, %40 ], [ %50, %42 ]
  %44 = phi i32 [ %37, %40 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42

52:                                               ; preds = %42, %36
  %53 = phi i32 [ %37, %36 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %63, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  %62 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %63

63:                                               ; preds = %59, %52
  %64 = phi i32 [ %13, %52 ], [ %62, %59 ]
  %65 = add nuw nsw i32 %14, 1
  %66 = icmp slt i32 %65, %64
  br i1 %66, label %12, label %67, !llvm.loop !364

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi19EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 18
  %9 = add nsw i32 %1, -18
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ %5, %7 ], [ %68, %67 ]
  %14 = phi i32 [ 0, %7 ], [ %69, %67 ]
  br i1 %8, label %15, label %40

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %36, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %35, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 16
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 17
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add nuw nsw i64 %16, 18
  %27 = getelementptr inbounds i32, ptr %0, i64 %26
  %28 = load i32, ptr %27, align 4, !tbaa !11
  %29 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %30 = add i32 %29, %22
  %31 = add i32 %25, %28
  %32 = add i32 %30, %31
  %33 = mul i32 %32, 269850533
  %34 = add i32 %17, -153339736
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %16, 19
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %15, label %38

38:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %35, %15 ]
  %.lcssa = phi i64 [ %36, %15 ]
  %39 = trunc i64 %.lcssa to i32
  br label %40

40:                                               ; preds = %38, %12
  %41 = phi i32 [ 0, %12 ], [ %.lcssa1, %38 ]
  %42 = phi i32 [ 0, %12 ], [ %39, %38 ]
  %43 = icmp slt i32 %42, %1
  br i1 %43, label %44, label %56

44:                                               ; preds = %40
  %45 = zext i32 %42 to i64
  br label %46

46:                                               ; preds = %46, %44
  %47 = phi i64 [ %45, %44 ], [ %54, %46 ]
  %48 = phi i32 [ %41, %44 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46

56:                                               ; preds = %46, %40
  %57 = phi i32 [ %41, %40 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %67, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %56
  %68 = phi i32 [ %13, %56 ], [ %66, %63 ]
  %69 = add nuw nsw i32 %14, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %12, label %71, !llvm.loop !365

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi15EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi13EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi14EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 13)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi15EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 14)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi16EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %59

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 15
  %9 = add nsw i32 %1, -15
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %55, %7
  %13 = phi i32 [ %5, %7 ], [ %56, %55 ]
  %14 = phi i32 [ 0, %7 ], [ %57, %55 ]
  br i1 %8, label %15, label %28

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %24, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %23, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %21 = mul i32 %20, 269850533
  %22 = add i32 %17, -1033331840
  %23 = add i32 %22, %21
  %24 = add nuw nsw i64 %16, 16
  %25 = icmp slt i64 %24, %10
  br i1 %25, label %15, label %26

26:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %23, %15 ]
  %.lcssa = phi i64 [ %24, %15 ]
  %27 = trunc i64 %.lcssa to i32
  br label %28

28:                                               ; preds = %26, %12
  %29 = phi i32 [ 0, %12 ], [ %.lcssa1, %26 ]
  %30 = phi i32 [ 0, %12 ], [ %27, %26 ]
  %31 = icmp slt i32 %30, %1
  br i1 %31, label %32, label %44

32:                                               ; preds = %28
  %33 = zext i32 %30 to i64
  br label %34

34:                                               ; preds = %34, %32
  %35 = phi i64 [ %33, %32 ], [ %42, %34 ]
  %36 = phi i32 [ %29, %32 ], [ %41, %34 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %35
  %38 = load i32, ptr %37, align 4, !tbaa !11
  %39 = mul i32 %38, 269850533
  %40 = add i32 %36, -1138325064
  %41 = add i32 %40, %39
  %42 = add nuw nsw i64 %35, 1
  %43 = icmp eq i64 %42, %11
  br i1 %43, label %44, label %34

44:                                               ; preds = %34, %28
  %45 = phi i32 [ %29, %28 ], [ %41, %34 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %55, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %44
  %56 = phi i32 [ %13, %44 ], [ %54, %51 ]
  %57 = add nuw nsw i32 %14, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %12, label %59, !llvm.loop !366

59:                                               ; preds = %55, %3
  %60 = tail call i64 @clock() #15
  store i64 %60, ptr @end_time, align 8, !tbaa !23
  %61 = load i64, ptr @start_time, align 8, !tbaa !23
  %62 = sub nsw i64 %60, %61
  %63 = sitofp i64 %62 to double
  %64 = fdiv double %63, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %64, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi17EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %63

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 16
  %9 = add nsw i32 %1, -16
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %59, %7
  %13 = phi i32 [ %5, %7 ], [ %60, %59 ]
  %14 = phi i32 [ 0, %7 ], [ %61, %59 ]
  br i1 %8, label %15, label %32

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %28, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %27, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 16
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %24 = add i32 %23, %22
  %25 = mul i32 %24, 269850533
  %26 = add i32 %17, 2123310392
  %27 = add i32 %26, %25
  %28 = add nuw nsw i64 %16, 17
  %29 = icmp slt i64 %28, %10
  br i1 %29, label %15, label %30

30:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %27, %15 ]
  %.lcssa = phi i64 [ %28, %15 ]
  %31 = trunc i64 %.lcssa to i32
  br label %32

32:                                               ; preds = %30, %12
  %33 = phi i32 [ 0, %12 ], [ %.lcssa1, %30 ]
  %34 = phi i32 [ 0, %12 ], [ %31, %30 ]
  %35 = icmp slt i32 %34, %1
  br i1 %35, label %36, label %48

36:                                               ; preds = %32
  %37 = zext i32 %34 to i64
  br label %38

38:                                               ; preds = %38, %36
  %39 = phi i64 [ %37, %36 ], [ %46, %38 ]
  %40 = phi i32 [ %33, %36 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38

48:                                               ; preds = %38, %32
  %49 = phi i32 [ %33, %32 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %59, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  %58 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %59

59:                                               ; preds = %55, %48
  %60 = phi i32 [ %13, %48 ], [ %58, %55 ]
  %61 = add nuw nsw i32 %14, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %12, label %63, !llvm.loop !367

63:                                               ; preds = %59, %3
  %64 = tail call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi13EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi11EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi12EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 11)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi13EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 12)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi14EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %72

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 13
  %9 = add nsw i32 %1, -13
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %68, %7
  %13 = phi i32 [ %5, %7 ], [ %69, %68 ]
  %14 = phi i32 [ 0, %7 ], [ %70, %68 ]
  br i1 %8, label %15, label %41

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %37, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %36, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 8
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 12
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add nuw nsw i64 %16, 13
  %27 = getelementptr inbounds i32, ptr %0, i64 %26
  %28 = load i32, ptr %27, align 4, !tbaa !11
  %29 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %30 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %31 = add i32 %29, %30
  %32 = add i32 %31, %25
  %33 = add i32 %32, %28
  %34 = mul i32 %33, 269850533
  %35 = add i32 %17, 1243318288
  %36 = add i32 %35, %34
  %37 = add nuw nsw i64 %16, 14
  %38 = icmp slt i64 %37, %10
  br i1 %38, label %15, label %39

39:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %36, %15 ]
  %.lcssa = phi i64 [ %37, %15 ]
  %40 = trunc i64 %.lcssa to i32
  br label %41

41:                                               ; preds = %39, %12
  %42 = phi i32 [ 0, %12 ], [ %.lcssa1, %39 ]
  %43 = phi i32 [ 0, %12 ], [ %40, %39 ]
  %44 = icmp slt i32 %43, %1
  br i1 %44, label %45, label %57

45:                                               ; preds = %41
  %46 = zext i32 %43 to i64
  br label %47

47:                                               ; preds = %47, %45
  %48 = phi i64 [ %46, %45 ], [ %55, %47 ]
  %49 = phi i32 [ %42, %45 ], [ %54, %47 ]
  %50 = getelementptr inbounds i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !11
  %52 = mul i32 %51, 269850533
  %53 = add i32 %49, -1138325064
  %54 = add i32 %53, %52
  %55 = add nuw nsw i64 %48, 1
  %56 = icmp eq i64 %55, %11
  br i1 %56, label %57, label %47

57:                                               ; preds = %47, %41
  %58 = phi i32 [ %42, %41 ], [ %54, %47 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !17
  %60 = fptosi double %59 to i32
  %61 = mul i32 %60, -1564285888
  %62 = add i32 %61, -1269844480
  %63 = icmp eq i32 %62, %58
  br i1 %63, label %68, label %64

64:                                               ; preds = %57
  %65 = load i32, ptr @current_test, align 4, !tbaa !11
  %66 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %65) #12
  %67 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %68

68:                                               ; preds = %64, %57
  %69 = phi i32 [ %13, %57 ], [ %67, %64 ]
  %70 = add nuw nsw i32 %14, 1
  %71 = icmp slt i32 %70, %69
  br i1 %71, label %12, label %72, !llvm.loop !368

72:                                               ; preds = %68, %3
  %73 = tail call i64 @clock() #15
  store i64 %73, ptr @end_time, align 8, !tbaa !23
  %74 = load i64, ptr @start_time, align 8, !tbaa !23
  %75 = sub nsw i64 %73, %74
  %76 = sitofp i64 %75 to double
  %77 = fdiv double %76, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %77, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi15EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %76

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 14
  %9 = add nsw i32 %1, -14
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %72, %7
  %13 = phi i32 [ %5, %7 ], [ %73, %72 ]
  %14 = phi i32 [ 0, %7 ], [ %74, %72 ]
  br i1 %8, label %15, label %45

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %41, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %40, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 8
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 12
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add nuw nsw i64 %16, 13
  %27 = getelementptr inbounds i32, ptr %0, i64 %26
  %28 = load i32, ptr %27, align 4, !tbaa !11
  %29 = add nuw nsw i64 %16, 14
  %30 = getelementptr inbounds i32, ptr %0, i64 %29
  %31 = load i32, ptr %30, align 4, !tbaa !11
  %32 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %33 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %34 = add i32 %32, %33
  %35 = add i32 %34, %25
  %36 = add i32 %28, %31
  %37 = add i32 %35, %36
  %38 = mul i32 %37, 269850533
  %39 = add i32 %17, 104993224
  %40 = add i32 %39, %38
  %41 = add nuw nsw i64 %16, 15
  %42 = icmp slt i64 %41, %10
  br i1 %42, label %15, label %43

43:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %40, %15 ]
  %.lcssa = phi i64 [ %41, %15 ]
  %44 = trunc i64 %.lcssa to i32
  br label %45

45:                                               ; preds = %43, %12
  %46 = phi i32 [ 0, %12 ], [ %.lcssa1, %43 ]
  %47 = phi i32 [ 0, %12 ], [ %44, %43 ]
  %48 = icmp slt i32 %47, %1
  br i1 %48, label %49, label %61

49:                                               ; preds = %45
  %50 = zext i32 %47 to i64
  br label %51

51:                                               ; preds = %51, %49
  %52 = phi i64 [ %50, %49 ], [ %59, %51 ]
  %53 = phi i32 [ %46, %49 ], [ %58, %51 ]
  %54 = getelementptr inbounds i32, ptr %0, i64 %52
  %55 = load i32, ptr %54, align 4, !tbaa !11
  %56 = mul i32 %55, 269850533
  %57 = add i32 %53, -1138325064
  %58 = add i32 %57, %56
  %59 = add nuw nsw i64 %52, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %51

61:                                               ; preds = %51, %45
  %62 = phi i32 [ %46, %45 ], [ %58, %51 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !17
  %64 = fptosi double %63 to i32
  %65 = mul i32 %64, -1564285888
  %66 = add i32 %65, -1269844480
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %72, label %68

68:                                               ; preds = %61
  %69 = load i32, ptr @current_test, align 4, !tbaa !11
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %69) #12
  %71 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %72

72:                                               ; preds = %68, %61
  %73 = phi i32 [ %13, %61 ], [ %71, %68 ]
  %74 = add nuw nsw i32 %14, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %12, label %76, !llvm.loop !369

76:                                               ; preds = %72, %3
  %77 = tail call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi11EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi9EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi10EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 9)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi11EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 10)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi12EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %64

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 11
  %9 = add nsw i32 %1, -11
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %60, %7
  %13 = phi i32 [ %5, %7 ], [ %61, %60 ]
  %14 = phi i32 [ 0, %7 ], [ %62, %60 ]
  br i1 %8, label %15, label %33

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %29, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %28, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 8
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %24 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %25 = add i32 %23, %24
  %26 = mul i32 %25, 269850533
  %27 = add i32 %17, -774998880
  %28 = add i32 %27, %26
  %29 = add nuw nsw i64 %16, 12
  %30 = icmp slt i64 %29, %10
  br i1 %30, label %15, label %31

31:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %28, %15 ]
  %.lcssa = phi i64 [ %29, %15 ]
  %32 = trunc i64 %.lcssa to i32
  br label %33

33:                                               ; preds = %31, %12
  %34 = phi i32 [ 0, %12 ], [ %.lcssa1, %31 ]
  %35 = phi i32 [ 0, %12 ], [ %32, %31 ]
  %36 = icmp slt i32 %35, %1
  br i1 %36, label %37, label %49

37:                                               ; preds = %33
  %38 = zext i32 %35 to i64
  br label %39

39:                                               ; preds = %39, %37
  %40 = phi i64 [ %38, %37 ], [ %47, %39 ]
  %41 = phi i32 [ %34, %37 ], [ %46, %39 ]
  %42 = getelementptr inbounds i32, ptr %0, i64 %40
  %43 = load i32, ptr %42, align 4, !tbaa !11
  %44 = mul i32 %43, 269850533
  %45 = add i32 %41, -1138325064
  %46 = add i32 %45, %44
  %47 = add nuw nsw i64 %40, 1
  %48 = icmp eq i64 %47, %11
  br i1 %48, label %49, label %39

49:                                               ; preds = %39, %33
  %50 = phi i32 [ %34, %33 ], [ %46, %39 ]
  %51 = load double, ptr @init_value, align 8, !tbaa !17
  %52 = fptosi double %51 to i32
  %53 = mul i32 %52, -1564285888
  %54 = add i32 %53, -1269844480
  %55 = icmp eq i32 %54, %50
  br i1 %55, label %60, label %56

56:                                               ; preds = %49
  %57 = load i32, ptr @current_test, align 4, !tbaa !11
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %57) #12
  %59 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %60

60:                                               ; preds = %56, %49
  %61 = phi i32 [ %13, %49 ], [ %59, %56 ]
  %62 = add nuw nsw i32 %14, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %12, label %64, !llvm.loop !370

64:                                               ; preds = %60, %3
  %65 = tail call i64 @clock() #15
  store i64 %65, ptr @end_time, align 8, !tbaa !23
  %66 = load i64, ptr @start_time, align 8, !tbaa !23
  %67 = sub nsw i64 %65, %66
  %68 = sitofp i64 %67 to double
  %69 = fdiv double %68, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %69, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi13EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %68

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 12
  %9 = add nsw i32 %1, -12
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %64, %7
  %13 = phi i32 [ %5, %7 ], [ %65, %64 ]
  %14 = phi i32 [ 0, %7 ], [ %66, %64 ]
  br i1 %8, label %15, label %37

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %33, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %32, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 8
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 12
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %27 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %28 = add i32 %26, %27
  %29 = add i32 %28, %25
  %30 = mul i32 %29, 269850533
  %31 = add i32 %17, -1913323944
  %32 = add i32 %31, %30
  %33 = add nuw nsw i64 %16, 13
  %34 = icmp slt i64 %33, %10
  br i1 %34, label %15, label %35

35:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %32, %15 ]
  %.lcssa = phi i64 [ %33, %15 ]
  %36 = trunc i64 %.lcssa to i32
  br label %37

37:                                               ; preds = %35, %12
  %38 = phi i32 [ 0, %12 ], [ %.lcssa1, %35 ]
  %39 = phi i32 [ 0, %12 ], [ %36, %35 ]
  %40 = icmp slt i32 %39, %1
  br i1 %40, label %41, label %53

41:                                               ; preds = %37
  %42 = zext i32 %39 to i64
  br label %43

43:                                               ; preds = %43, %41
  %44 = phi i64 [ %42, %41 ], [ %51, %43 ]
  %45 = phi i32 [ %38, %41 ], [ %50, %43 ]
  %46 = getelementptr inbounds i32, ptr %0, i64 %44
  %47 = load i32, ptr %46, align 4, !tbaa !11
  %48 = mul i32 %47, 269850533
  %49 = add i32 %45, -1138325064
  %50 = add i32 %49, %48
  %51 = add nuw nsw i64 %44, 1
  %52 = icmp eq i64 %51, %11
  br i1 %52, label %53, label %43

53:                                               ; preds = %43, %37
  %54 = phi i32 [ %38, %37 ], [ %50, %43 ]
  %55 = load double, ptr @init_value, align 8, !tbaa !17
  %56 = fptosi double %55 to i32
  %57 = mul i32 %56, -1564285888
  %58 = add i32 %57, -1269844480
  %59 = icmp eq i32 %58, %54
  br i1 %59, label %64, label %60

60:                                               ; preds = %53
  %61 = load i32, ptr @current_test, align 4, !tbaa !11
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %61) #12
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %64

64:                                               ; preds = %60, %53
  %65 = phi i32 [ %13, %53 ], [ %63, %60 ]
  %66 = add nuw nsw i32 %14, 1
  %67 = icmp slt i32 %66, %65
  br i1 %67, label %12, label %68, !llvm.loop !371

68:                                               ; preds = %64, %3
  %69 = tail call i64 @clock() #15
  store i64 %69, ptr @end_time, align 8, !tbaa !23
  %70 = load i64, ptr @start_time, align 8, !tbaa !23
  %71 = sub nsw i64 %69, %70
  %72 = sitofp i64 %71 to double
  %73 = fdiv double %72, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %73, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi9EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi7EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi8EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 7)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi9EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 8)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi10EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 9
  %9 = add nsw i32 %1, -9
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ %5, %7 ], [ %64, %63 ]
  %14 = phi i32 [ 0, %7 ], [ %65, %63 ]
  br i1 %8, label %15, label %36

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %32, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %31, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 8
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 9
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %27 = add i32 %26, %22
  %28 = add i32 %27, %25
  %29 = mul i32 %28, 269850533
  %30 = add i32 %17, 1501651248
  %31 = add i32 %30, %29
  %32 = add nuw nsw i64 %16, 10
  %33 = icmp slt i64 %32, %10
  br i1 %33, label %15, label %34

34:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %31, %15 ]
  %.lcssa = phi i64 [ %32, %15 ]
  %35 = trunc i64 %.lcssa to i32
  br label %36

36:                                               ; preds = %34, %12
  %37 = phi i32 [ 0, %12 ], [ %.lcssa1, %34 ]
  %38 = phi i32 [ 0, %12 ], [ %35, %34 ]
  %39 = icmp slt i32 %38, %1
  br i1 %39, label %40, label %52

40:                                               ; preds = %36
  %41 = zext i32 %38 to i64
  br label %42

42:                                               ; preds = %42, %40
  %43 = phi i64 [ %41, %40 ], [ %50, %42 ]
  %44 = phi i32 [ %37, %40 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42

52:                                               ; preds = %42, %36
  %53 = phi i32 [ %37, %36 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %63, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  %62 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %63

63:                                               ; preds = %59, %52
  %64 = phi i32 [ %13, %52 ], [ %62, %59 ]
  %65 = add nuw nsw i32 %14, 1
  %66 = icmp slt i32 %65, %64
  br i1 %66, label %12, label %67, !llvm.loop !372

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi11EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 10
  %9 = add nsw i32 %1, -10
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ %5, %7 ], [ %68, %67 ]
  %14 = phi i32 [ 0, %7 ], [ %69, %67 ]
  br i1 %8, label %15, label %40

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %36, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %35, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 8
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 9
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add nuw nsw i64 %16, 10
  %27 = getelementptr inbounds i32, ptr %0, i64 %26
  %28 = load i32, ptr %27, align 4, !tbaa !11
  %29 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %30 = add i32 %29, %22
  %31 = add i32 %25, %28
  %32 = add i32 %30, %31
  %33 = mul i32 %32, 269850533
  %34 = add i32 %17, 363326184
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %16, 11
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %15, label %38

38:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %35, %15 ]
  %.lcssa = phi i64 [ %36, %15 ]
  %39 = trunc i64 %.lcssa to i32
  br label %40

40:                                               ; preds = %38, %12
  %41 = phi i32 [ 0, %12 ], [ %.lcssa1, %38 ]
  %42 = phi i32 [ 0, %12 ], [ %39, %38 ]
  %43 = icmp slt i32 %42, %1
  br i1 %43, label %44, label %56

44:                                               ; preds = %40
  %45 = zext i32 %42 to i64
  br label %46

46:                                               ; preds = %46, %44
  %47 = phi i64 [ %45, %44 ], [ %54, %46 ]
  %48 = phi i32 [ %41, %44 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46

56:                                               ; preds = %46, %40
  %57 = phi i32 [ %41, %40 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %67, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %56
  %68 = phi i32 [ %13, %56 ], [ %66, %63 ]
  %69 = add nuw nsw i32 %14, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %12, label %71, !llvm.loop !373

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi7EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi5EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi6EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 5)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi7EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 6)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi8EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %59

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 7
  %9 = add nsw i32 %1, -7
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %55, %7
  %13 = phi i32 [ %5, %7 ], [ %56, %55 ]
  %14 = phi i32 [ 0, %7 ], [ %57, %55 ]
  br i1 %8, label %15, label %28

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %24, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %23, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %21 = mul i32 %20, 269850533
  %22 = add i32 %17, -516665920
  %23 = add i32 %22, %21
  %24 = add nuw nsw i64 %16, 8
  %25 = icmp slt i64 %24, %10
  br i1 %25, label %15, label %26

26:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %23, %15 ]
  %.lcssa = phi i64 [ %24, %15 ]
  %27 = trunc i64 %.lcssa to i32
  br label %28

28:                                               ; preds = %26, %12
  %29 = phi i32 [ 0, %12 ], [ %.lcssa1, %26 ]
  %30 = phi i32 [ 0, %12 ], [ %27, %26 ]
  %31 = icmp slt i32 %30, %1
  br i1 %31, label %32, label %44

32:                                               ; preds = %28
  %33 = zext i32 %30 to i64
  br label %34

34:                                               ; preds = %34, %32
  %35 = phi i64 [ %33, %32 ], [ %42, %34 ]
  %36 = phi i32 [ %29, %32 ], [ %41, %34 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %35
  %38 = load i32, ptr %37, align 4, !tbaa !11
  %39 = mul i32 %38, 269850533
  %40 = add i32 %36, -1138325064
  %41 = add i32 %40, %39
  %42 = add nuw nsw i64 %35, 1
  %43 = icmp eq i64 %42, %11
  br i1 %43, label %44, label %34

44:                                               ; preds = %34, %28
  %45 = phi i32 [ %29, %28 ], [ %41, %34 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %55, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %44
  %56 = phi i32 [ %13, %44 ], [ %54, %51 ]
  %57 = add nuw nsw i32 %14, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %12, label %59, !llvm.loop !374

59:                                               ; preds = %55, %3
  %60 = tail call i64 @clock() #15
  store i64 %60, ptr @end_time, align 8, !tbaa !23
  %61 = load i64, ptr @start_time, align 8, !tbaa !23
  %62 = sub nsw i64 %60, %61
  %63 = sitofp i64 %62 to double
  %64 = fdiv double %63, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %64, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi9EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %63

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 8
  %9 = add nsw i32 %1, -8
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %59, %7
  %13 = phi i32 [ %5, %7 ], [ %60, %59 ]
  %14 = phi i32 [ 0, %7 ], [ %61, %59 ]
  br i1 %8, label %15, label %32

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %28, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %27, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 8
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %24 = add i32 %23, %22
  %25 = mul i32 %24, 269850533
  %26 = add i32 %17, -1654990984
  %27 = add i32 %26, %25
  %28 = add nuw nsw i64 %16, 9
  %29 = icmp slt i64 %28, %10
  br i1 %29, label %15, label %30

30:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %27, %15 ]
  %.lcssa = phi i64 [ %28, %15 ]
  %31 = trunc i64 %.lcssa to i32
  br label %32

32:                                               ; preds = %30, %12
  %33 = phi i32 [ 0, %12 ], [ %.lcssa1, %30 ]
  %34 = phi i32 [ 0, %12 ], [ %31, %30 ]
  %35 = icmp slt i32 %34, %1
  br i1 %35, label %36, label %48

36:                                               ; preds = %32
  %37 = zext i32 %34 to i64
  br label %38

38:                                               ; preds = %38, %36
  %39 = phi i64 [ %37, %36 ], [ %46, %38 ]
  %40 = phi i32 [ %33, %36 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38

48:                                               ; preds = %38, %32
  %49 = phi i32 [ %33, %32 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %59, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  %58 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %59

59:                                               ; preds = %55, %48
  %60 = phi i32 [ %13, %48 ], [ %58, %55 ]
  %61 = add nuw nsw i32 %14, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %12, label %63, !llvm.loop !375

63:                                               ; preds = %59, %3
  %64 = tail call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi5EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN15goto_loop_testsILi3EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi4EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 3)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi5EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 4)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi6EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 5
  %9 = add nsw i32 %1, -5
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ %5, %7 ], [ %64, %63 ]
  %14 = phi i32 [ 0, %7 ], [ %65, %63 ]
  br i1 %8, label %15, label %36

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %32, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %31, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <4 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 4
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 5
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %19)
  %27 = add i32 %26, %22
  %28 = add i32 %27, %25
  %29 = mul i32 %28, 269850533
  %30 = add i32 %17, 1759984208
  %31 = add i32 %30, %29
  %32 = add nuw nsw i64 %16, 6
  %33 = icmp slt i64 %32, %10
  br i1 %33, label %15, label %34

34:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %31, %15 ]
  %.lcssa = phi i64 [ %32, %15 ]
  %35 = trunc i64 %.lcssa to i32
  br label %36

36:                                               ; preds = %34, %12
  %37 = phi i32 [ 0, %12 ], [ %.lcssa1, %34 ]
  %38 = phi i32 [ 0, %12 ], [ %35, %34 ]
  %39 = icmp slt i32 %38, %1
  br i1 %39, label %40, label %52

40:                                               ; preds = %36
  %41 = zext i32 %38 to i64
  br label %42

42:                                               ; preds = %42, %40
  %43 = phi i64 [ %41, %40 ], [ %50, %42 ]
  %44 = phi i32 [ %37, %40 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42

52:                                               ; preds = %42, %36
  %53 = phi i32 [ %37, %36 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %63, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  %62 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %63

63:                                               ; preds = %59, %52
  %64 = phi i32 [ %13, %52 ], [ %62, %59 ]
  %65 = add nuw nsw i32 %14, 1
  %66 = icmp slt i32 %65, %64
  br i1 %66, label %12, label %67, !llvm.loop !376

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi7EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 6
  %9 = add nsw i32 %1, -6
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ %5, %7 ], [ %68, %67 ]
  %14 = phi i32 [ 0, %7 ], [ %69, %67 ]
  br i1 %8, label %15, label %40

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %36, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %35, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <4 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 4
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 5
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add nuw nsw i64 %16, 6
  %27 = getelementptr inbounds i32, ptr %0, i64 %26
  %28 = load i32, ptr %27, align 4, !tbaa !11
  %29 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %19)
  %30 = add i32 %29, %22
  %31 = add i32 %25, %28
  %32 = add i32 %30, %31
  %33 = mul i32 %32, 269850533
  %34 = add i32 %17, 621659144
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %16, 7
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %15, label %38

38:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %35, %15 ]
  %.lcssa = phi i64 [ %36, %15 ]
  %39 = trunc i64 %.lcssa to i32
  br label %40

40:                                               ; preds = %38, %12
  %41 = phi i32 [ 0, %12 ], [ %.lcssa1, %38 ]
  %42 = phi i32 [ 0, %12 ], [ %39, %38 ]
  %43 = icmp slt i32 %42, %1
  br i1 %43, label %44, label %56

44:                                               ; preds = %40
  %45 = zext i32 %42 to i64
  br label %46

46:                                               ; preds = %46, %44
  %47 = phi i64 [ %45, %44 ], [ %54, %46 ]
  %48 = phi i32 [ %41, %44 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46

56:                                               ; preds = %46, %40
  %57 = phi i32 [ %41, %40 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %67, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %56
  %68 = phi i32 [ %13, %56 ], [ %66, %63 ]
  %69 = add nuw nsw i32 %14, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %12, label %71, !llvm.loop !377

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN15goto_loop_testsILi3EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_Z28test_goto_loop_unroll_factorILi1EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull @temp_string) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi2EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 1)) #12
  tail call void @_Z28test_goto_loop_unroll_factorILi3EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 2)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi4EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %59

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 3
  %9 = add nsw i32 %1, -3
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %55, %7
  %13 = phi i32 [ %5, %7 ], [ %56, %55 ]
  %14 = phi i32 [ 0, %7 ], [ %57, %55 ]
  br i1 %8, label %15, label %28

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %24, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %23, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <4 x i32>, ptr %18, align 4, !tbaa !11
  %20 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %19)
  %21 = mul i32 %20, 269850533
  %22 = add i32 %17, -258332960
  %23 = add i32 %22, %21
  %24 = add nuw nsw i64 %16, 4
  %25 = icmp slt i64 %24, %10
  br i1 %25, label %15, label %26

26:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %23, %15 ]
  %.lcssa = phi i64 [ %24, %15 ]
  %27 = trunc i64 %.lcssa to i32
  br label %28

28:                                               ; preds = %26, %12
  %29 = phi i32 [ 0, %12 ], [ %.lcssa1, %26 ]
  %30 = phi i32 [ 0, %12 ], [ %27, %26 ]
  %31 = icmp slt i32 %30, %1
  br i1 %31, label %32, label %44

32:                                               ; preds = %28
  %33 = zext i32 %30 to i64
  br label %34

34:                                               ; preds = %34, %32
  %35 = phi i64 [ %33, %32 ], [ %42, %34 ]
  %36 = phi i32 [ %29, %32 ], [ %41, %34 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %35
  %38 = load i32, ptr %37, align 4, !tbaa !11
  %39 = mul i32 %38, 269850533
  %40 = add i32 %36, -1138325064
  %41 = add i32 %40, %39
  %42 = add nuw nsw i64 %35, 1
  %43 = icmp eq i64 %42, %11
  br i1 %43, label %44, label %34

44:                                               ; preds = %34, %28
  %45 = phi i32 [ %29, %28 ], [ %41, %34 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %55, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %44
  %56 = phi i32 [ %13, %44 ], [ %54, %51 ]
  %57 = add nuw nsw i32 %14, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %12, label %59, !llvm.loop !378

59:                                               ; preds = %55, %3
  %60 = tail call i64 @clock() #15
  store i64 %60, ptr @end_time, align 8, !tbaa !23
  %61 = load i64, ptr @start_time, align 8, !tbaa !23
  %62 = sub nsw i64 %60, %61
  %63 = sitofp i64 %62 to double
  %64 = fdiv double %63, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %64, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi5EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %63

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 4
  %9 = add nsw i32 %1, -4
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %59, %7
  %13 = phi i32 [ %5, %7 ], [ %60, %59 ]
  %14 = phi i32 [ 0, %7 ], [ %61, %59 ]
  br i1 %8, label %15, label %32

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %28, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %27, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <4 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 4
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %19)
  %24 = add i32 %23, %22
  %25 = mul i32 %24, 269850533
  %26 = add i32 %17, -1396658024
  %27 = add i32 %26, %25
  %28 = add nuw nsw i64 %16, 5
  %29 = icmp slt i64 %28, %10
  br i1 %29, label %15, label %30

30:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %27, %15 ]
  %.lcssa = phi i64 [ %28, %15 ]
  %31 = trunc i64 %.lcssa to i32
  br label %32

32:                                               ; preds = %30, %12
  %33 = phi i32 [ 0, %12 ], [ %.lcssa1, %30 ]
  %34 = phi i32 [ 0, %12 ], [ %31, %30 ]
  %35 = icmp slt i32 %34, %1
  br i1 %35, label %36, label %48

36:                                               ; preds = %32
  %37 = zext i32 %34 to i64
  br label %38

38:                                               ; preds = %38, %36
  %39 = phi i64 [ %37, %36 ], [ %46, %38 ]
  %40 = phi i32 [ %33, %36 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38

48:                                               ; preds = %38, %32
  %49 = phi i32 [ %33, %32 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %59, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  %58 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %59

59:                                               ; preds = %55, %48
  %60 = phi i32 [ %13, %48 ], [ %58, %55 ]
  %61 = add nuw nsw i32 %14, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %12, label %63, !llvm.loop !379

63:                                               ; preds = %59, %3
  %64 = tail call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi1EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %38

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 0
  %9 = zext i32 %1 to i64
  br label %10

10:                                               ; preds = %34, %7
  %11 = phi i32 [ %5, %7 ], [ %35, %34 ]
  %12 = phi i32 [ 0, %7 ], [ %36, %34 ]
  br i1 %8, label %13, label %23

13:                                               ; preds = %13, %10
  %14 = phi i64 [ %21, %13 ], [ 0, %10 ]
  %15 = phi i32 [ %20, %13 ], [ 0, %10 ]
  %16 = getelementptr inbounds i32, ptr %0, i64 %14
  %17 = load i32, ptr %16, align 4, !tbaa !11
  %18 = mul i32 %17, 269850533
  %19 = add i32 %15, -1138325064
  %20 = add i32 %19, %18
  %21 = add nuw nsw i64 %14, 1
  %22 = icmp eq i64 %21, %9
  br i1 %22, label %23, label %13

23:                                               ; preds = %13, %10
  %24 = phi i32 [ 0, %10 ], [ %20, %13 ]
  %25 = load double, ptr @init_value, align 8, !tbaa !17
  %26 = fptosi double %25 to i32
  %27 = mul i32 %26, -1564285888
  %28 = add i32 %27, -1269844480
  %29 = icmp eq i32 %28, %24
  br i1 %29, label %34, label %30

30:                                               ; preds = %23
  %31 = load i32, ptr @current_test, align 4, !tbaa !11
  %32 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %31) #12
  %33 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %34

34:                                               ; preds = %30, %23
  %35 = phi i32 [ %11, %23 ], [ %33, %30 ]
  %36 = add nuw nsw i32 %12, 1
  %37 = icmp slt i32 %36, %35
  br i1 %37, label %10, label %38, !llvm.loop !380

38:                                               ; preds = %34, %3
  %39 = tail call i64 @clock() #15
  store i64 %39, ptr @end_time, align 8, !tbaa !23
  %40 = load i64, ptr @start_time, align 8, !tbaa !23
  %41 = sub nsw i64 %39, %40
  %42 = sitofp i64 %41 to double
  %43 = fdiv double %42, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %43, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi2EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %62

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 1
  %9 = add nsw i32 %1, -1
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %58, %7
  %13 = phi i32 [ %5, %7 ], [ %59, %58 ]
  %14 = phi i32 [ 0, %7 ], [ %60, %58 ]
  br i1 %8, label %15, label %31

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %27, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %26, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load i32, ptr %18, align 4, !tbaa !11
  %20 = or i64 %16, 1
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add i32 %22, %19
  %24 = mul i32 %23, 269850533
  %25 = add i32 %17, 2018317168
  %26 = add i32 %25, %24
  %27 = add nuw nsw i64 %16, 2
  %28 = icmp slt i64 %27, %10
  br i1 %28, label %15, label %29

29:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %26, %15 ]
  %.lcssa = phi i64 [ %27, %15 ]
  %30 = trunc i64 %.lcssa to i32
  br label %31

31:                                               ; preds = %29, %12
  %32 = phi i32 [ 0, %12 ], [ %.lcssa1, %29 ]
  %33 = phi i32 [ 0, %12 ], [ %30, %29 ]
  %34 = icmp slt i32 %33, %1
  br i1 %34, label %35, label %47

35:                                               ; preds = %31
  %36 = zext i32 %33 to i64
  br label %37

37:                                               ; preds = %37, %35
  %38 = phi i64 [ %36, %35 ], [ %45, %37 ]
  %39 = phi i32 [ %32, %35 ], [ %44, %37 ]
  %40 = getelementptr inbounds i32, ptr %0, i64 %38
  %41 = load i32, ptr %40, align 4, !tbaa !11
  %42 = mul i32 %41, 269850533
  %43 = add i32 %39, -1138325064
  %44 = add i32 %43, %42
  %45 = add nuw nsw i64 %38, 1
  %46 = icmp eq i64 %45, %11
  br i1 %46, label %47, label %37

47:                                               ; preds = %37, %31
  %48 = phi i32 [ %32, %31 ], [ %44, %37 ]
  %49 = load double, ptr @init_value, align 8, !tbaa !17
  %50 = fptosi double %49 to i32
  %51 = mul i32 %50, -1564285888
  %52 = add i32 %51, -1269844480
  %53 = icmp eq i32 %52, %48
  br i1 %53, label %58, label %54

54:                                               ; preds = %47
  %55 = load i32, ptr @current_test, align 4, !tbaa !11
  %56 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %55) #12
  %57 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %58

58:                                               ; preds = %54, %47
  %59 = phi i32 [ %13, %47 ], [ %57, %54 ]
  %60 = add nuw nsw i32 %14, 1
  %61 = icmp slt i32 %60, %59
  br i1 %61, label %12, label %62, !llvm.loop !381

62:                                               ; preds = %58, %3
  %63 = tail call i64 @clock() #15
  store i64 %63, ptr @end_time, align 8, !tbaa !23
  %64 = load i64, ptr @start_time, align 8, !tbaa !23
  %65 = sub nsw i64 %63, %64
  %66 = sitofp i64 %65 to double
  %67 = fdiv double %66, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %67, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z28test_goto_loop_unroll_factorILi3EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %66

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 2
  %9 = add nsw i32 %1, -2
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %62, %7
  %13 = phi i32 [ %5, %7 ], [ %63, %62 ]
  %14 = phi i32 [ 0, %7 ], [ %64, %62 ]
  br i1 %8, label %15, label %35

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %31, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %30, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load i32, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 1
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 2
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add i32 %22, %19
  %27 = add i32 %26, %25
  %28 = mul i32 %27, 269850533
  %29 = add i32 %17, 879992104
  %30 = add i32 %29, %28
  %31 = add nuw nsw i64 %16, 3
  %32 = icmp slt i64 %31, %10
  br i1 %32, label %15, label %33

33:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %30, %15 ]
  %.lcssa = phi i64 [ %31, %15 ]
  %34 = trunc i64 %.lcssa to i32
  br label %35

35:                                               ; preds = %33, %12
  %36 = phi i32 [ 0, %12 ], [ %.lcssa1, %33 ]
  %37 = phi i32 [ 0, %12 ], [ %34, %33 ]
  %38 = icmp slt i32 %37, %1
  br i1 %38, label %39, label %51

39:                                               ; preds = %35
  %40 = zext i32 %37 to i64
  br label %41

41:                                               ; preds = %41, %39
  %42 = phi i64 [ %40, %39 ], [ %49, %41 ]
  %43 = phi i32 [ %36, %39 ], [ %48, %41 ]
  %44 = getelementptr inbounds i32, ptr %0, i64 %42
  %45 = load i32, ptr %44, align 4, !tbaa !11
  %46 = mul i32 %45, 269850533
  %47 = add i32 %43, -1138325064
  %48 = add i32 %47, %46
  %49 = add nuw nsw i64 %42, 1
  %50 = icmp eq i64 %49, %11
  br i1 %50, label %51, label %41

51:                                               ; preds = %41, %35
  %52 = phi i32 [ %36, %35 ], [ %48, %41 ]
  %53 = load double, ptr @init_value, align 8, !tbaa !17
  %54 = fptosi double %53 to i32
  %55 = mul i32 %54, -1564285888
  %56 = add i32 %55, -1269844480
  %57 = icmp eq i32 %56, %52
  br i1 %57, label %62, label %58

58:                                               ; preds = %51
  %59 = load i32, ptr @current_test, align 4, !tbaa !11
  %60 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %59) #12
  %61 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %62

62:                                               ; preds = %58, %51
  %63 = phi i32 [ %13, %51 ], [ %61, %58 ]
  %64 = add nuw nsw i32 %14, 1
  %65 = icmp slt i32 %64, %63
  br i1 %65, label %12, label %66, !llvm.loop !382

66:                                               ; preds = %62, %3
  %67 = tail call i64 @clock() #15
  store i64 %67, ptr @end_time, align 8, !tbaa !23
  %68 = load i64, ptr @start_time, align 8, !tbaa !23
  %69 = sub nsw i64 %67, %68
  %70 = sitofp i64 %69 to double
  %71 = fdiv double %70, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %71, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi29EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi27EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi28EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 27)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi29EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 28)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi30EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca i32, align 4
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %51

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 29
  %10 = add nsw i32 %1, -29
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %47, %8
  %13 = phi i32 [ 0, %8 ], [ %48, %47 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #16
  store i32 0, ptr %4, align 4, !tbaa !11
  br i1 %9, label %14, label %20

14:                                               ; preds = %14, %12
  %15 = phi i32 [ %16, %14 ], [ 0, %12 ]
  call void @_ZN15loop_inner_bodyILi30EiE7do_workERiPKii(ptr noundef nonnull align 4 dereferenceable(4) %4, ptr noundef %0, i32 noundef %15) #12
  %16 = add nuw nsw i32 %15, 30
  %17 = icmp slt i32 %16, %10
  br i1 %17, label %14, label %18, !llvm.loop !383

18:                                               ; preds = %14
  %.lcssa = phi i32 [ %16, %14 ]
  %19 = load i32, ptr %4, align 4, !tbaa !11
  br label %20

20:                                               ; preds = %18, %12
  %21 = phi i32 [ 0, %12 ], [ %19, %18 ]
  %22 = phi i32 [ 0, %12 ], [ %.lcssa, %18 ]
  %23 = icmp slt i32 %22, %1
  br i1 %23, label %24, label %37

24:                                               ; preds = %20
  %25 = sext i32 %22 to i64
  br label %26

26:                                               ; preds = %26, %24
  %27 = phi i64 [ %25, %24 ], [ %34, %26 ]
  %28 = phi i32 [ %21, %24 ], [ %33, %26 ]
  %29 = getelementptr inbounds i32, ptr %0, i64 %27
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = mul i32 %30, 269850533
  %32 = add i32 %31, -1138325064
  %33 = add nsw i32 %32, %28
  %34 = add nsw i64 %27, 1
  %35 = icmp eq i64 %34, %11
  br i1 %35, label %36, label %26, !llvm.loop !384

36:                                               ; preds = %26
  %.lcssa1 = phi i32 [ %33, %26 ]
  store i32 %.lcssa1, ptr %4, align 4, !tbaa !11
  br label %37

37:                                               ; preds = %36, %20
  %38 = phi i32 [ %.lcssa1, %36 ], [ %21, %20 ]
  %39 = load double, ptr @init_value, align 8, !tbaa !17
  %40 = fptosi double %39 to i32
  %41 = mul i32 %40, -1564285888
  %42 = add i32 %41, -1269844480
  %43 = icmp eq i32 %42, %38
  br i1 %43, label %47, label %44

44:                                               ; preds = %37
  %45 = load i32, ptr @current_test, align 4, !tbaa !11
  %46 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %45) #12
  br label %47

47:                                               ; preds = %44, %37
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #16
  %48 = add nuw nsw i32 %13, 1
  %49 = load i32, ptr @iterations, align 4, !tbaa !11
  %50 = icmp slt i32 %48, %49
  br i1 %50, label %12, label %51, !llvm.loop !385

51:                                               ; preds = %47, %3
  %52 = call i64 @clock() #15
  store i64 %52, ptr @end_time, align 8, !tbaa !23
  %53 = load i64, ptr @start_time, align 8, !tbaa !23
  %54 = sub nsw i64 %52, %53
  %55 = sitofp i64 %54 to double
  %56 = fdiv double %55, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %56, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi31EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca i32, align 4
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %58

8:                                                ; preds = %3
  %9 = icmp sgt i32 %1, 30
  %10 = add nsw i32 %1, -30
  %11 = sext i32 %1 to i64
  br label %12

12:                                               ; preds = %54, %8
  %13 = phi i32 [ 0, %8 ], [ %55, %54 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #16
  store i32 0, ptr %4, align 4, !tbaa !11
  br i1 %9, label %14, label %27

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %24, %14 ], [ 0, %12 ]
  %16 = trunc i64 %15 to i32
  call void @_ZN15loop_inner_bodyILi30EiE7do_workERiPKii(ptr noundef nonnull align 4 dereferenceable(4) %4, ptr noundef %0, i32 noundef %16) #12
  %17 = add nuw nsw i64 %15, 30
  %18 = getelementptr inbounds i32, ptr %0, i64 %17
  %19 = load i32, ptr %18, align 4, !tbaa !11
  %20 = mul i32 %19, 269850533
  %21 = add i32 %20, -1138325064
  %22 = load i32, ptr %4, align 4, !tbaa !11
  %23 = add nsw i32 %21, %22
  store i32 %23, ptr %4, align 4, !tbaa !11
  %24 = add nuw i64 %15, 31
  %25 = trunc i64 %24 to i32
  %26 = icmp sgt i32 %10, %25
  br i1 %26, label %14, label %27, !llvm.loop !386

27:                                               ; preds = %14, %12
  %28 = phi i32 [ 0, %12 ], [ %23, %14 ]
  %29 = phi i32 [ 0, %12 ], [ %25, %14 ]
  %30 = icmp slt i32 %29, %1
  br i1 %30, label %31, label %44

31:                                               ; preds = %27
  %32 = sext i32 %29 to i64
  br label %33

33:                                               ; preds = %33, %31
  %34 = phi i64 [ %32, %31 ], [ %41, %33 ]
  %35 = phi i32 [ %28, %31 ], [ %40, %33 ]
  %36 = getelementptr inbounds i32, ptr %0, i64 %34
  %37 = load i32, ptr %36, align 4, !tbaa !11
  %38 = mul i32 %37, 269850533
  %39 = add i32 %38, -1138325064
  %40 = add nsw i32 %39, %35
  %41 = add nsw i64 %34, 1
  %42 = icmp eq i64 %41, %11
  br i1 %42, label %43, label %33, !llvm.loop !387

43:                                               ; preds = %33
  %.lcssa = phi i32 [ %40, %33 ]
  store i32 %.lcssa, ptr %4, align 4, !tbaa !11
  br label %44

44:                                               ; preds = %43, %27
  %45 = phi i32 [ %.lcssa, %43 ], [ %28, %27 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %54, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  br label %54

54:                                               ; preds = %51, %44
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #16
  %55 = add nuw nsw i32 %13, 1
  %56 = load i32, ptr @iterations, align 4, !tbaa !11
  %57 = icmp slt i32 %55, %56
  br i1 %57, label %12, label %58, !llvm.loop !388

58:                                               ; preds = %54, %3
  %59 = call i64 @clock() #15
  store i64 %59, ptr @end_time, align 8, !tbaa !23
  %60 = load i64, ptr @start_time, align 8, !tbaa !23
  %61 = sub nsw i64 %59, %60
  %62 = sitofp i64 %61 to double
  %63 = fdiv double %62, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %63, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi27EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi25EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi26EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 25)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi27EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 26)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi28EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 27
  %9 = add nsw i32 %1, -27
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ 0, %7 ], [ %64, %63 ]
  br i1 %8, label %14, label %37

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %33, %14 ], [ 0, %12 ]
  %16 = phi i32 [ %32, %14 ], [ 0, %12 ]
  %17 = getelementptr inbounds i32, ptr %0, i64 %15
  %18 = load <16 x i32>, ptr %17, align 4, !tbaa !11
  %19 = add nuw nsw i64 %15, 16
  %20 = getelementptr inbounds i32, ptr %0, i64 %19
  %21 = load <8 x i32>, ptr %20, align 4, !tbaa !11
  %22 = add nuw nsw i64 %15, 24
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load <4 x i32>, ptr %23, align 4, !tbaa !11
  %25 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %18)
  %26 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %21)
  %27 = add i32 %25, %26
  %28 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %24)
  %29 = add i32 %27, %28
  %30 = mul i32 %29, 269850533
  %31 = add i32 %16, -1808330720
  %32 = add i32 %31, %30
  %33 = add nuw nsw i64 %15, 28
  %34 = icmp slt i64 %33, %10
  br i1 %34, label %14, label %35, !llvm.loop !389

35:                                               ; preds = %14
  %.lcssa1 = phi i32 [ %32, %14 ]
  %.lcssa = phi i64 [ %33, %14 ]
  %36 = trunc i64 %.lcssa to i32
  br label %37

37:                                               ; preds = %35, %12
  %38 = phi i32 [ 0, %12 ], [ %.lcssa1, %35 ]
  %39 = phi i32 [ 0, %12 ], [ %36, %35 ]
  %40 = icmp slt i32 %39, %1
  br i1 %40, label %41, label %53

41:                                               ; preds = %37
  %42 = zext i32 %39 to i64
  br label %43

43:                                               ; preds = %43, %41
  %44 = phi i64 [ %42, %41 ], [ %51, %43 ]
  %45 = phi i32 [ %38, %41 ], [ %50, %43 ]
  %46 = getelementptr inbounds i32, ptr %0, i64 %44
  %47 = load i32, ptr %46, align 4, !tbaa !11
  %48 = mul i32 %47, 269850533
  %49 = add i32 %45, -1138325064
  %50 = add i32 %49, %48
  %51 = add nuw nsw i64 %44, 1
  %52 = icmp eq i64 %51, %11
  br i1 %52, label %53, label %43, !llvm.loop !390

53:                                               ; preds = %43, %37
  %54 = phi i32 [ %38, %37 ], [ %50, %43 ]
  %55 = load double, ptr @init_value, align 8, !tbaa !17
  %56 = fptosi double %55 to i32
  %57 = mul i32 %56, -1564285888
  %58 = add i32 %57, -1269844480
  %59 = icmp eq i32 %58, %54
  br i1 %59, label %63, label %60

60:                                               ; preds = %53
  %61 = load i32, ptr @current_test, align 4, !tbaa !11
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %61) #12
  br label %63

63:                                               ; preds = %60, %53
  %64 = add nuw nsw i32 %13, 1
  %65 = load i32, ptr @iterations, align 4, !tbaa !11
  %66 = icmp slt i32 %64, %65
  br i1 %66, label %12, label %67, !llvm.loop !391

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi29EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 28
  %9 = add nsw i32 %1, -28
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ 0, %7 ], [ %68, %67 ]
  br i1 %8, label %14, label %41

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %37, %14 ], [ 0, %12 ]
  %16 = phi i32 [ %36, %14 ], [ 0, %12 ]
  %17 = getelementptr inbounds i32, ptr %0, i64 %15
  %18 = load <16 x i32>, ptr %17, align 4, !tbaa !11
  %19 = add nuw nsw i64 %15, 16
  %20 = getelementptr inbounds i32, ptr %0, i64 %19
  %21 = load <8 x i32>, ptr %20, align 4, !tbaa !11
  %22 = add nuw nsw i64 %15, 24
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load <4 x i32>, ptr %23, align 4, !tbaa !11
  %25 = add nuw nsw i64 %15, 28
  %26 = getelementptr inbounds i32, ptr %0, i64 %25
  %27 = load i32, ptr %26, align 4, !tbaa !11
  %28 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %18)
  %29 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %21)
  %30 = add i32 %28, %29
  %31 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %24)
  %32 = add i32 %30, %31
  %33 = add i32 %32, %27
  %34 = mul i32 %33, 269850533
  %35 = add i32 %16, 1348311512
  %36 = add i32 %35, %34
  %37 = add nuw nsw i64 %15, 29
  %38 = icmp slt i64 %37, %10
  br i1 %38, label %14, label %39, !llvm.loop !392

39:                                               ; preds = %14
  %.lcssa1 = phi i32 [ %36, %14 ]
  %.lcssa = phi i64 [ %37, %14 ]
  %40 = trunc i64 %.lcssa to i32
  br label %41

41:                                               ; preds = %39, %12
  %42 = phi i32 [ 0, %12 ], [ %.lcssa1, %39 ]
  %43 = phi i32 [ 0, %12 ], [ %40, %39 ]
  %44 = icmp slt i32 %43, %1
  br i1 %44, label %45, label %57

45:                                               ; preds = %41
  %46 = zext i32 %43 to i64
  br label %47

47:                                               ; preds = %47, %45
  %48 = phi i64 [ %46, %45 ], [ %55, %47 ]
  %49 = phi i32 [ %42, %45 ], [ %54, %47 ]
  %50 = getelementptr inbounds i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !11
  %52 = mul i32 %51, 269850533
  %53 = add i32 %49, -1138325064
  %54 = add i32 %53, %52
  %55 = add nuw nsw i64 %48, 1
  %56 = icmp eq i64 %55, %11
  br i1 %56, label %57, label %47, !llvm.loop !393

57:                                               ; preds = %47, %41
  %58 = phi i32 [ %42, %41 ], [ %54, %47 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !17
  %60 = fptosi double %59 to i32
  %61 = mul i32 %60, -1564285888
  %62 = add i32 %61, -1269844480
  %63 = icmp eq i32 %62, %58
  br i1 %63, label %67, label %64

64:                                               ; preds = %57
  %65 = load i32, ptr @current_test, align 4, !tbaa !11
  %66 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %65) #12
  br label %67

67:                                               ; preds = %64, %57
  %68 = add nuw nsw i32 %13, 1
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  %70 = icmp slt i32 %68, %69
  br i1 %70, label %12, label %71, !llvm.loop !394

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi25EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi23EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi24EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 23)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi25EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 24)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi26EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %70

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 25
  %9 = add nsw i32 %1, -25
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %66, %7
  %13 = phi i32 [ 0, %7 ], [ %67, %66 ]
  br i1 %8, label %14, label %40

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %36, %14 ], [ 0, %12 ]
  %16 = phi i32 [ %35, %14 ], [ 0, %12 ]
  %17 = getelementptr inbounds i32, ptr %0, i64 %15
  %18 = load <16 x i32>, ptr %17, align 4, !tbaa !11
  %19 = add nuw nsw i64 %15, 16
  %20 = getelementptr inbounds i32, ptr %0, i64 %19
  %21 = load <8 x i32>, ptr %20, align 4, !tbaa !11
  %22 = add nuw nsw i64 %15, 24
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load i32, ptr %23, align 4, !tbaa !11
  %25 = add nuw nsw i64 %15, 25
  %26 = getelementptr inbounds i32, ptr %0, i64 %25
  %27 = load i32, ptr %26, align 4, !tbaa !11
  %28 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %18)
  %29 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %21)
  %30 = add i32 %28, %29
  %31 = add i32 %30, %24
  %32 = add i32 %31, %27
  %33 = mul i32 %32, 269850533
  %34 = add i32 %16, 468319408
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %15, 26
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %14, label %38, !llvm.loop !395

38:                                               ; preds = %14
  %.lcssa1 = phi i32 [ %35, %14 ]
  %.lcssa = phi i64 [ %36, %14 ]
  %39 = trunc i64 %.lcssa to i32
  br label %40

40:                                               ; preds = %38, %12
  %41 = phi i32 [ 0, %12 ], [ %.lcssa1, %38 ]
  %42 = phi i32 [ 0, %12 ], [ %39, %38 ]
  %43 = icmp slt i32 %42, %1
  br i1 %43, label %44, label %56

44:                                               ; preds = %40
  %45 = zext i32 %42 to i64
  br label %46

46:                                               ; preds = %46, %44
  %47 = phi i64 [ %45, %44 ], [ %54, %46 ]
  %48 = phi i32 [ %41, %44 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46, !llvm.loop !396

56:                                               ; preds = %46, %40
  %57 = phi i32 [ %41, %40 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %66, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  br label %66

66:                                               ; preds = %63, %56
  %67 = add nuw nsw i32 %13, 1
  %68 = load i32, ptr @iterations, align 4, !tbaa !11
  %69 = icmp slt i32 %67, %68
  br i1 %69, label %12, label %70, !llvm.loop !397

70:                                               ; preds = %66, %3
  %71 = tail call i64 @clock() #15
  store i64 %71, ptr @end_time, align 8, !tbaa !23
  %72 = load i64, ptr @start_time, align 8, !tbaa !23
  %73 = sub nsw i64 %71, %72
  %74 = sitofp i64 %73 to double
  %75 = fdiv double %74, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %75, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi27EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %74

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 26
  %9 = add nsw i32 %1, -26
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %70, %7
  %13 = phi i32 [ 0, %7 ], [ %71, %70 ]
  br i1 %8, label %14, label %44

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %40, %14 ], [ 0, %12 ]
  %16 = phi i32 [ %39, %14 ], [ 0, %12 ]
  %17 = getelementptr inbounds i32, ptr %0, i64 %15
  %18 = load <16 x i32>, ptr %17, align 4, !tbaa !11
  %19 = add nuw nsw i64 %15, 16
  %20 = getelementptr inbounds i32, ptr %0, i64 %19
  %21 = load <8 x i32>, ptr %20, align 4, !tbaa !11
  %22 = add nuw nsw i64 %15, 24
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load i32, ptr %23, align 4, !tbaa !11
  %25 = add nuw nsw i64 %15, 25
  %26 = getelementptr inbounds i32, ptr %0, i64 %25
  %27 = load i32, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %15, 26
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %18)
  %32 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %21)
  %33 = add i32 %31, %32
  %34 = add i32 %33, %24
  %35 = add i32 %27, %30
  %36 = add i32 %34, %35
  %37 = mul i32 %36, 269850533
  %38 = add i32 %16, -670005656
  %39 = add i32 %38, %37
  %40 = add nuw nsw i64 %15, 27
  %41 = icmp slt i64 %40, %10
  br i1 %41, label %14, label %42, !llvm.loop !398

42:                                               ; preds = %14
  %.lcssa1 = phi i32 [ %39, %14 ]
  %.lcssa = phi i64 [ %40, %14 ]
  %43 = trunc i64 %.lcssa to i32
  br label %44

44:                                               ; preds = %42, %12
  %45 = phi i32 [ 0, %12 ], [ %.lcssa1, %42 ]
  %46 = phi i32 [ 0, %12 ], [ %43, %42 ]
  %47 = icmp slt i32 %46, %1
  br i1 %47, label %48, label %60

48:                                               ; preds = %44
  %49 = zext i32 %46 to i64
  br label %50

50:                                               ; preds = %50, %48
  %51 = phi i64 [ %49, %48 ], [ %58, %50 ]
  %52 = phi i32 [ %45, %48 ], [ %57, %50 ]
  %53 = getelementptr inbounds i32, ptr %0, i64 %51
  %54 = load i32, ptr %53, align 4, !tbaa !11
  %55 = mul i32 %54, 269850533
  %56 = add i32 %52, -1138325064
  %57 = add i32 %56, %55
  %58 = add nuw nsw i64 %51, 1
  %59 = icmp eq i64 %58, %11
  br i1 %59, label %60, label %50, !llvm.loop !399

60:                                               ; preds = %50, %44
  %61 = phi i32 [ %45, %44 ], [ %57, %50 ]
  %62 = load double, ptr @init_value, align 8, !tbaa !17
  %63 = fptosi double %62 to i32
  %64 = mul i32 %63, -1564285888
  %65 = add i32 %64, -1269844480
  %66 = icmp eq i32 %65, %61
  br i1 %66, label %70, label %67

67:                                               ; preds = %60
  %68 = load i32, ptr @current_test, align 4, !tbaa !11
  %69 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %68) #12
  br label %70

70:                                               ; preds = %67, %60
  %71 = add nuw nsw i32 %13, 1
  %72 = load i32, ptr @iterations, align 4, !tbaa !11
  %73 = icmp slt i32 %71, %72
  br i1 %73, label %12, label %74, !llvm.loop !400

74:                                               ; preds = %70, %3
  %75 = tail call i64 @clock() #15
  store i64 %75, ptr @end_time, align 8, !tbaa !23
  %76 = load i64, ptr @start_time, align 8, !tbaa !23
  %77 = sub nsw i64 %75, %76
  %78 = sitofp i64 %77 to double
  %79 = fdiv double %78, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %79, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi23EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi21EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi22EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 21)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi23EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 22)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi24EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %62

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 23
  %9 = add nsw i32 %1, -23
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %58, %7
  %13 = phi i32 [ 0, %7 ], [ %59, %58 ]
  br i1 %8, label %14, label %32

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %28, %14 ], [ 0, %12 ]
  %16 = phi i32 [ %27, %14 ], [ 0, %12 ]
  %17 = getelementptr inbounds i32, ptr %0, i64 %15
  %18 = load <16 x i32>, ptr %17, align 4, !tbaa !11
  %19 = add nuw nsw i64 %15, 16
  %20 = getelementptr inbounds i32, ptr %0, i64 %19
  %21 = load <8 x i32>, ptr %20, align 4, !tbaa !11
  %22 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %18)
  %23 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %21)
  %24 = add i32 %22, %23
  %25 = mul i32 %24, 269850533
  %26 = add i32 %16, -1549997760
  %27 = add i32 %26, %25
  %28 = add nuw nsw i64 %15, 24
  %29 = icmp slt i64 %28, %10
  br i1 %29, label %14, label %30, !llvm.loop !401

30:                                               ; preds = %14
  %.lcssa1 = phi i32 [ %27, %14 ]
  %.lcssa = phi i64 [ %28, %14 ]
  %31 = trunc i64 %.lcssa to i32
  br label %32

32:                                               ; preds = %30, %12
  %33 = phi i32 [ 0, %12 ], [ %.lcssa1, %30 ]
  %34 = phi i32 [ 0, %12 ], [ %31, %30 ]
  %35 = icmp slt i32 %34, %1
  br i1 %35, label %36, label %48

36:                                               ; preds = %32
  %37 = zext i32 %34 to i64
  br label %38

38:                                               ; preds = %38, %36
  %39 = phi i64 [ %37, %36 ], [ %46, %38 ]
  %40 = phi i32 [ %33, %36 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38, !llvm.loop !402

48:                                               ; preds = %38, %32
  %49 = phi i32 [ %33, %32 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %58, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  br label %58

58:                                               ; preds = %55, %48
  %59 = add nuw nsw i32 %13, 1
  %60 = load i32, ptr @iterations, align 4, !tbaa !11
  %61 = icmp slt i32 %59, %60
  br i1 %61, label %12, label %62, !llvm.loop !403

62:                                               ; preds = %58, %3
  %63 = tail call i64 @clock() #15
  store i64 %63, ptr @end_time, align 8, !tbaa !23
  %64 = load i64, ptr @start_time, align 8, !tbaa !23
  %65 = sub nsw i64 %63, %64
  %66 = sitofp i64 %65 to double
  %67 = fdiv double %66, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %67, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi25EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %66

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 24
  %9 = add nsw i32 %1, -24
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %62, %7
  %13 = phi i32 [ 0, %7 ], [ %63, %62 ]
  br i1 %8, label %14, label %36

14:                                               ; preds = %14, %12
  %15 = phi i64 [ %32, %14 ], [ 0, %12 ]
  %16 = phi i32 [ %31, %14 ], [ 0, %12 ]
  %17 = getelementptr inbounds i32, ptr %0, i64 %15
  %18 = load <16 x i32>, ptr %17, align 4, !tbaa !11
  %19 = add nuw nsw i64 %15, 16
  %20 = getelementptr inbounds i32, ptr %0, i64 %19
  %21 = load <8 x i32>, ptr %20, align 4, !tbaa !11
  %22 = add nuw nsw i64 %15, 24
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load i32, ptr %23, align 4, !tbaa !11
  %25 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %18)
  %26 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %21)
  %27 = add i32 %25, %26
  %28 = add i32 %27, %24
  %29 = mul i32 %28, 269850533
  %30 = add i32 %16, 1606644472
  %31 = add i32 %30, %29
  %32 = add nuw nsw i64 %15, 25
  %33 = icmp slt i64 %32, %10
  br i1 %33, label %14, label %34, !llvm.loop !404

34:                                               ; preds = %14
  %.lcssa1 = phi i32 [ %31, %14 ]
  %.lcssa = phi i64 [ %32, %14 ]
  %35 = trunc i64 %.lcssa to i32
  br label %36

36:                                               ; preds = %34, %12
  %37 = phi i32 [ 0, %12 ], [ %.lcssa1, %34 ]
  %38 = phi i32 [ 0, %12 ], [ %35, %34 ]
  %39 = icmp slt i32 %38, %1
  br i1 %39, label %40, label %52

40:                                               ; preds = %36
  %41 = zext i32 %38 to i64
  br label %42

42:                                               ; preds = %42, %40
  %43 = phi i64 [ %41, %40 ], [ %50, %42 ]
  %44 = phi i32 [ %37, %40 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42, !llvm.loop !405

52:                                               ; preds = %42, %36
  %53 = phi i32 [ %37, %36 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %62, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  br label %62

62:                                               ; preds = %59, %52
  %63 = add nuw nsw i32 %13, 1
  %64 = load i32, ptr @iterations, align 4, !tbaa !11
  %65 = icmp slt i32 %63, %64
  br i1 %65, label %12, label %66, !llvm.loop !406

66:                                               ; preds = %62, %3
  %67 = tail call i64 @clock() #15
  store i64 %67, ptr @end_time, align 8, !tbaa !23
  %68 = load i64, ptr @start_time, align 8, !tbaa !23
  %69 = sub nsw i64 %67, %68
  %70 = sitofp i64 %69 to double
  %71 = fdiv double %70, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %71, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi21EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi19EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi20EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 19)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi21EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 20)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi22EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %72

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 21
  %9 = add nsw i32 %1, -21
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %68, %7
  %13 = phi i32 [ %5, %7 ], [ %69, %68 ]
  %14 = phi i32 [ 0, %7 ], [ %70, %68 ]
  br i1 %8, label %15, label %41

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %37, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %36, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 16
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 20
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add nuw nsw i64 %16, 21
  %27 = getelementptr inbounds i32, ptr %0, i64 %26
  %28 = load i32, ptr %27, align 4, !tbaa !11
  %29 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %30 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %31 = add i32 %29, %30
  %32 = add i32 %31, %25
  %33 = add i32 %32, %28
  %34 = mul i32 %33, 269850533
  %35 = add i32 %17, 726652368
  %36 = add i32 %35, %34
  %37 = add nuw nsw i64 %16, 22
  %38 = icmp slt i64 %37, %10
  br i1 %38, label %15, label %39, !llvm.loop !407

39:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %36, %15 ]
  %.lcssa = phi i64 [ %37, %15 ]
  %40 = trunc i64 %.lcssa to i32
  br label %41

41:                                               ; preds = %39, %12
  %42 = phi i32 [ 0, %12 ], [ %.lcssa1, %39 ]
  %43 = phi i32 [ 0, %12 ], [ %40, %39 ]
  %44 = icmp slt i32 %43, %1
  br i1 %44, label %45, label %57

45:                                               ; preds = %41
  %46 = zext i32 %43 to i64
  br label %47

47:                                               ; preds = %47, %45
  %48 = phi i64 [ %46, %45 ], [ %55, %47 ]
  %49 = phi i32 [ %42, %45 ], [ %54, %47 ]
  %50 = getelementptr inbounds i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !11
  %52 = mul i32 %51, 269850533
  %53 = add i32 %49, -1138325064
  %54 = add i32 %53, %52
  %55 = add nuw nsw i64 %48, 1
  %56 = icmp eq i64 %55, %11
  br i1 %56, label %57, label %47, !llvm.loop !408

57:                                               ; preds = %47, %41
  %58 = phi i32 [ %42, %41 ], [ %54, %47 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !17
  %60 = fptosi double %59 to i32
  %61 = mul i32 %60, -1564285888
  %62 = add i32 %61, -1269844480
  %63 = icmp eq i32 %62, %58
  br i1 %63, label %68, label %64

64:                                               ; preds = %57
  %65 = load i32, ptr @current_test, align 4, !tbaa !11
  %66 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %65) #12
  %67 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %68

68:                                               ; preds = %64, %57
  %69 = phi i32 [ %13, %57 ], [ %67, %64 ]
  %70 = add nuw nsw i32 %14, 1
  %71 = icmp slt i32 %70, %69
  br i1 %71, label %12, label %72, !llvm.loop !409

72:                                               ; preds = %68, %3
  %73 = tail call i64 @clock() #15
  store i64 %73, ptr @end_time, align 8, !tbaa !23
  %74 = load i64, ptr @start_time, align 8, !tbaa !23
  %75 = sub nsw i64 %73, %74
  %76 = sitofp i64 %75 to double
  %77 = fdiv double %76, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %77, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi23EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %76

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 22
  %9 = add nsw i32 %1, -22
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %72, %7
  %13 = phi i32 [ %5, %7 ], [ %73, %72 ]
  %14 = phi i32 [ 0, %7 ], [ %74, %72 ]
  br i1 %8, label %15, label %45

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %41, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %40, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 16
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 20
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add nuw nsw i64 %16, 21
  %27 = getelementptr inbounds i32, ptr %0, i64 %26
  %28 = load i32, ptr %27, align 4, !tbaa !11
  %29 = add nuw nsw i64 %16, 22
  %30 = getelementptr inbounds i32, ptr %0, i64 %29
  %31 = load i32, ptr %30, align 4, !tbaa !11
  %32 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %33 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %34 = add i32 %32, %33
  %35 = add i32 %34, %25
  %36 = add i32 %28, %31
  %37 = add i32 %35, %36
  %38 = mul i32 %37, 269850533
  %39 = add i32 %17, -411672696
  %40 = add i32 %39, %38
  %41 = add nuw nsw i64 %16, 23
  %42 = icmp slt i64 %41, %10
  br i1 %42, label %15, label %43, !llvm.loop !410

43:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %40, %15 ]
  %.lcssa = phi i64 [ %41, %15 ]
  %44 = trunc i64 %.lcssa to i32
  br label %45

45:                                               ; preds = %43, %12
  %46 = phi i32 [ 0, %12 ], [ %.lcssa1, %43 ]
  %47 = phi i32 [ 0, %12 ], [ %44, %43 ]
  %48 = icmp slt i32 %47, %1
  br i1 %48, label %49, label %61

49:                                               ; preds = %45
  %50 = zext i32 %47 to i64
  br label %51

51:                                               ; preds = %51, %49
  %52 = phi i64 [ %50, %49 ], [ %59, %51 ]
  %53 = phi i32 [ %46, %49 ], [ %58, %51 ]
  %54 = getelementptr inbounds i32, ptr %0, i64 %52
  %55 = load i32, ptr %54, align 4, !tbaa !11
  %56 = mul i32 %55, 269850533
  %57 = add i32 %53, -1138325064
  %58 = add i32 %57, %56
  %59 = add nuw nsw i64 %52, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %51, !llvm.loop !411

61:                                               ; preds = %51, %45
  %62 = phi i32 [ %46, %45 ], [ %58, %51 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !17
  %64 = fptosi double %63 to i32
  %65 = mul i32 %64, -1564285888
  %66 = add i32 %65, -1269844480
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %72, label %68

68:                                               ; preds = %61
  %69 = load i32, ptr @current_test, align 4, !tbaa !11
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %69) #12
  %71 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %72

72:                                               ; preds = %68, %61
  %73 = phi i32 [ %13, %61 ], [ %71, %68 ]
  %74 = add nuw nsw i32 %14, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %12, label %76, !llvm.loop !412

76:                                               ; preds = %72, %3
  %77 = tail call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi19EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi17EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi18EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 17)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi19EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 18)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi20EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %64

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 19
  %9 = add nsw i32 %1, -19
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %60, %7
  %13 = phi i32 [ %5, %7 ], [ %61, %60 ]
  %14 = phi i32 [ 0, %7 ], [ %62, %60 ]
  br i1 %8, label %15, label %33

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %29, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %28, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 16
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %24 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %25 = add i32 %23, %24
  %26 = mul i32 %25, 269850533
  %27 = add i32 %17, -1291664800
  %28 = add i32 %27, %26
  %29 = add nuw nsw i64 %16, 20
  %30 = icmp slt i64 %29, %10
  br i1 %30, label %15, label %31, !llvm.loop !413

31:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %28, %15 ]
  %.lcssa = phi i64 [ %29, %15 ]
  %32 = trunc i64 %.lcssa to i32
  br label %33

33:                                               ; preds = %31, %12
  %34 = phi i32 [ 0, %12 ], [ %.lcssa1, %31 ]
  %35 = phi i32 [ 0, %12 ], [ %32, %31 ]
  %36 = icmp slt i32 %35, %1
  br i1 %36, label %37, label %49

37:                                               ; preds = %33
  %38 = zext i32 %35 to i64
  br label %39

39:                                               ; preds = %39, %37
  %40 = phi i64 [ %38, %37 ], [ %47, %39 ]
  %41 = phi i32 [ %34, %37 ], [ %46, %39 ]
  %42 = getelementptr inbounds i32, ptr %0, i64 %40
  %43 = load i32, ptr %42, align 4, !tbaa !11
  %44 = mul i32 %43, 269850533
  %45 = add i32 %41, -1138325064
  %46 = add i32 %45, %44
  %47 = add nuw nsw i64 %40, 1
  %48 = icmp eq i64 %47, %11
  br i1 %48, label %49, label %39, !llvm.loop !414

49:                                               ; preds = %39, %33
  %50 = phi i32 [ %34, %33 ], [ %46, %39 ]
  %51 = load double, ptr @init_value, align 8, !tbaa !17
  %52 = fptosi double %51 to i32
  %53 = mul i32 %52, -1564285888
  %54 = add i32 %53, -1269844480
  %55 = icmp eq i32 %54, %50
  br i1 %55, label %60, label %56

56:                                               ; preds = %49
  %57 = load i32, ptr @current_test, align 4, !tbaa !11
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %57) #12
  %59 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %60

60:                                               ; preds = %56, %49
  %61 = phi i32 [ %13, %49 ], [ %59, %56 ]
  %62 = add nuw nsw i32 %14, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %12, label %64, !llvm.loop !415

64:                                               ; preds = %60, %3
  %65 = tail call i64 @clock() #15
  store i64 %65, ptr @end_time, align 8, !tbaa !23
  %66 = load i64, ptr @start_time, align 8, !tbaa !23
  %67 = sub nsw i64 %65, %66
  %68 = sitofp i64 %67 to double
  %69 = fdiv double %68, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %69, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi21EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %68

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 20
  %9 = add nsw i32 %1, -20
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %64, %7
  %13 = phi i32 [ %5, %7 ], [ %65, %64 ]
  %14 = phi i32 [ 0, %7 ], [ %66, %64 ]
  br i1 %8, label %15, label %37

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %33, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %32, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 16
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 20
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %27 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %28 = add i32 %26, %27
  %29 = add i32 %28, %25
  %30 = mul i32 %29, 269850533
  %31 = add i32 %17, 1864977432
  %32 = add i32 %31, %30
  %33 = add nuw nsw i64 %16, 21
  %34 = icmp slt i64 %33, %10
  br i1 %34, label %15, label %35, !llvm.loop !416

35:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %32, %15 ]
  %.lcssa = phi i64 [ %33, %15 ]
  %36 = trunc i64 %.lcssa to i32
  br label %37

37:                                               ; preds = %35, %12
  %38 = phi i32 [ 0, %12 ], [ %.lcssa1, %35 ]
  %39 = phi i32 [ 0, %12 ], [ %36, %35 ]
  %40 = icmp slt i32 %39, %1
  br i1 %40, label %41, label %53

41:                                               ; preds = %37
  %42 = zext i32 %39 to i64
  br label %43

43:                                               ; preds = %43, %41
  %44 = phi i64 [ %42, %41 ], [ %51, %43 ]
  %45 = phi i32 [ %38, %41 ], [ %50, %43 ]
  %46 = getelementptr inbounds i32, ptr %0, i64 %44
  %47 = load i32, ptr %46, align 4, !tbaa !11
  %48 = mul i32 %47, 269850533
  %49 = add i32 %45, -1138325064
  %50 = add i32 %49, %48
  %51 = add nuw nsw i64 %44, 1
  %52 = icmp eq i64 %51, %11
  br i1 %52, label %53, label %43, !llvm.loop !417

53:                                               ; preds = %43, %37
  %54 = phi i32 [ %38, %37 ], [ %50, %43 ]
  %55 = load double, ptr @init_value, align 8, !tbaa !17
  %56 = fptosi double %55 to i32
  %57 = mul i32 %56, -1564285888
  %58 = add i32 %57, -1269844480
  %59 = icmp eq i32 %58, %54
  br i1 %59, label %64, label %60

60:                                               ; preds = %53
  %61 = load i32, ptr @current_test, align 4, !tbaa !11
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %61) #12
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %64

64:                                               ; preds = %60, %53
  %65 = phi i32 [ %13, %53 ], [ %63, %60 ]
  %66 = add nuw nsw i32 %14, 1
  %67 = icmp slt i32 %66, %65
  br i1 %67, label %12, label %68, !llvm.loop !418

68:                                               ; preds = %64, %3
  %69 = tail call i64 @clock() #15
  store i64 %69, ptr @end_time, align 8, !tbaa !23
  %70 = load i64, ptr @start_time, align 8, !tbaa !23
  %71 = sub nsw i64 %69, %70
  %72 = sitofp i64 %71 to double
  %73 = fdiv double %72, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %73, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi17EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi15EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi16EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 15)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi17EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 16)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi18EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 17
  %9 = add nsw i32 %1, -17
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ %5, %7 ], [ %64, %63 ]
  %14 = phi i32 [ 0, %7 ], [ %65, %63 ]
  br i1 %8, label %15, label %36

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %32, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %31, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 16
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 17
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %27 = add i32 %26, %22
  %28 = add i32 %27, %25
  %29 = mul i32 %28, 269850533
  %30 = add i32 %17, 984985328
  %31 = add i32 %30, %29
  %32 = add nuw nsw i64 %16, 18
  %33 = icmp slt i64 %32, %10
  br i1 %33, label %15, label %34, !llvm.loop !419

34:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %31, %15 ]
  %.lcssa = phi i64 [ %32, %15 ]
  %35 = trunc i64 %.lcssa to i32
  br label %36

36:                                               ; preds = %34, %12
  %37 = phi i32 [ 0, %12 ], [ %.lcssa1, %34 ]
  %38 = phi i32 [ 0, %12 ], [ %35, %34 ]
  %39 = icmp slt i32 %38, %1
  br i1 %39, label %40, label %52

40:                                               ; preds = %36
  %41 = zext i32 %38 to i64
  br label %42

42:                                               ; preds = %42, %40
  %43 = phi i64 [ %41, %40 ], [ %50, %42 ]
  %44 = phi i32 [ %37, %40 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42, !llvm.loop !420

52:                                               ; preds = %42, %36
  %53 = phi i32 [ %37, %36 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %63, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  %62 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %63

63:                                               ; preds = %59, %52
  %64 = phi i32 [ %13, %52 ], [ %62, %59 ]
  %65 = add nuw nsw i32 %14, 1
  %66 = icmp slt i32 %65, %64
  br i1 %66, label %12, label %67, !llvm.loop !421

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi19EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 18
  %9 = add nsw i32 %1, -18
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ %5, %7 ], [ %68, %67 ]
  %14 = phi i32 [ 0, %7 ], [ %69, %67 ]
  br i1 %8, label %15, label %40

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %36, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %35, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 16
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 17
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add nuw nsw i64 %16, 18
  %27 = getelementptr inbounds i32, ptr %0, i64 %26
  %28 = load i32, ptr %27, align 4, !tbaa !11
  %29 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %30 = add i32 %29, %22
  %31 = add i32 %25, %28
  %32 = add i32 %30, %31
  %33 = mul i32 %32, 269850533
  %34 = add i32 %17, -153339736
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %16, 19
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %15, label %38, !llvm.loop !422

38:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %35, %15 ]
  %.lcssa = phi i64 [ %36, %15 ]
  %39 = trunc i64 %.lcssa to i32
  br label %40

40:                                               ; preds = %38, %12
  %41 = phi i32 [ 0, %12 ], [ %.lcssa1, %38 ]
  %42 = phi i32 [ 0, %12 ], [ %39, %38 ]
  %43 = icmp slt i32 %42, %1
  br i1 %43, label %44, label %56

44:                                               ; preds = %40
  %45 = zext i32 %42 to i64
  br label %46

46:                                               ; preds = %46, %44
  %47 = phi i64 [ %45, %44 ], [ %54, %46 ]
  %48 = phi i32 [ %41, %44 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46, !llvm.loop !423

56:                                               ; preds = %46, %40
  %57 = phi i32 [ %41, %40 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %67, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %56
  %68 = phi i32 [ %13, %56 ], [ %66, %63 ]
  %69 = add nuw nsw i32 %14, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %12, label %71, !llvm.loop !424

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi15EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi13EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi14EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 13)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi15EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 14)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi16EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %59

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 15
  %9 = add nsw i32 %1, -15
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %55, %7
  %13 = phi i32 [ %5, %7 ], [ %56, %55 ]
  %14 = phi i32 [ 0, %7 ], [ %57, %55 ]
  br i1 %8, label %15, label %28

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %24, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %23, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %21 = mul i32 %20, 269850533
  %22 = add i32 %17, -1033331840
  %23 = add i32 %22, %21
  %24 = add nuw nsw i64 %16, 16
  %25 = icmp slt i64 %24, %10
  br i1 %25, label %15, label %26, !llvm.loop !425

26:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %23, %15 ]
  %.lcssa = phi i64 [ %24, %15 ]
  %27 = trunc i64 %.lcssa to i32
  br label %28

28:                                               ; preds = %26, %12
  %29 = phi i32 [ 0, %12 ], [ %.lcssa1, %26 ]
  %30 = phi i32 [ 0, %12 ], [ %27, %26 ]
  %31 = icmp slt i32 %30, %1
  br i1 %31, label %32, label %44

32:                                               ; preds = %28
  %33 = zext i32 %30 to i64
  br label %34

34:                                               ; preds = %34, %32
  %35 = phi i64 [ %33, %32 ], [ %42, %34 ]
  %36 = phi i32 [ %29, %32 ], [ %41, %34 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %35
  %38 = load i32, ptr %37, align 4, !tbaa !11
  %39 = mul i32 %38, 269850533
  %40 = add i32 %36, -1138325064
  %41 = add i32 %40, %39
  %42 = add nuw nsw i64 %35, 1
  %43 = icmp eq i64 %42, %11
  br i1 %43, label %44, label %34, !llvm.loop !426

44:                                               ; preds = %34, %28
  %45 = phi i32 [ %29, %28 ], [ %41, %34 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %55, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %44
  %56 = phi i32 [ %13, %44 ], [ %54, %51 ]
  %57 = add nuw nsw i32 %14, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %12, label %59, !llvm.loop !427

59:                                               ; preds = %55, %3
  %60 = tail call i64 @clock() #15
  store i64 %60, ptr @end_time, align 8, !tbaa !23
  %61 = load i64, ptr @start_time, align 8, !tbaa !23
  %62 = sub nsw i64 %60, %61
  %63 = sitofp i64 %62 to double
  %64 = fdiv double %63, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %64, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi17EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %63

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 16
  %9 = add nsw i32 %1, -16
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %59, %7
  %13 = phi i32 [ %5, %7 ], [ %60, %59 ]
  %14 = phi i32 [ 0, %7 ], [ %61, %59 ]
  br i1 %8, label %15, label %32

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %28, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %27, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <16 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 16
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %19)
  %24 = add i32 %23, %22
  %25 = mul i32 %24, 269850533
  %26 = add i32 %17, 2123310392
  %27 = add i32 %26, %25
  %28 = add nuw nsw i64 %16, 17
  %29 = icmp slt i64 %28, %10
  br i1 %29, label %15, label %30, !llvm.loop !428

30:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %27, %15 ]
  %.lcssa = phi i64 [ %28, %15 ]
  %31 = trunc i64 %.lcssa to i32
  br label %32

32:                                               ; preds = %30, %12
  %33 = phi i32 [ 0, %12 ], [ %.lcssa1, %30 ]
  %34 = phi i32 [ 0, %12 ], [ %31, %30 ]
  %35 = icmp slt i32 %34, %1
  br i1 %35, label %36, label %48

36:                                               ; preds = %32
  %37 = zext i32 %34 to i64
  br label %38

38:                                               ; preds = %38, %36
  %39 = phi i64 [ %37, %36 ], [ %46, %38 ]
  %40 = phi i32 [ %33, %36 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38, !llvm.loop !429

48:                                               ; preds = %38, %32
  %49 = phi i32 [ %33, %32 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %59, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  %58 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %59

59:                                               ; preds = %55, %48
  %60 = phi i32 [ %13, %48 ], [ %58, %55 ]
  %61 = add nuw nsw i32 %14, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %12, label %63, !llvm.loop !430

63:                                               ; preds = %59, %3
  %64 = tail call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi13EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi11EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi12EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 11)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi13EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 12)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi14EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %72

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 13
  %9 = add nsw i32 %1, -13
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %68, %7
  %13 = phi i32 [ %5, %7 ], [ %69, %68 ]
  %14 = phi i32 [ 0, %7 ], [ %70, %68 ]
  br i1 %8, label %15, label %41

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %37, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %36, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 8
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 12
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add nuw nsw i64 %16, 13
  %27 = getelementptr inbounds i32, ptr %0, i64 %26
  %28 = load i32, ptr %27, align 4, !tbaa !11
  %29 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %30 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %31 = add i32 %29, %30
  %32 = add i32 %31, %25
  %33 = add i32 %32, %28
  %34 = mul i32 %33, 269850533
  %35 = add i32 %17, 1243318288
  %36 = add i32 %35, %34
  %37 = add nuw nsw i64 %16, 14
  %38 = icmp slt i64 %37, %10
  br i1 %38, label %15, label %39, !llvm.loop !431

39:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %36, %15 ]
  %.lcssa = phi i64 [ %37, %15 ]
  %40 = trunc i64 %.lcssa to i32
  br label %41

41:                                               ; preds = %39, %12
  %42 = phi i32 [ 0, %12 ], [ %.lcssa1, %39 ]
  %43 = phi i32 [ 0, %12 ], [ %40, %39 ]
  %44 = icmp slt i32 %43, %1
  br i1 %44, label %45, label %57

45:                                               ; preds = %41
  %46 = zext i32 %43 to i64
  br label %47

47:                                               ; preds = %47, %45
  %48 = phi i64 [ %46, %45 ], [ %55, %47 ]
  %49 = phi i32 [ %42, %45 ], [ %54, %47 ]
  %50 = getelementptr inbounds i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !11
  %52 = mul i32 %51, 269850533
  %53 = add i32 %49, -1138325064
  %54 = add i32 %53, %52
  %55 = add nuw nsw i64 %48, 1
  %56 = icmp eq i64 %55, %11
  br i1 %56, label %57, label %47, !llvm.loop !432

57:                                               ; preds = %47, %41
  %58 = phi i32 [ %42, %41 ], [ %54, %47 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !17
  %60 = fptosi double %59 to i32
  %61 = mul i32 %60, -1564285888
  %62 = add i32 %61, -1269844480
  %63 = icmp eq i32 %62, %58
  br i1 %63, label %68, label %64

64:                                               ; preds = %57
  %65 = load i32, ptr @current_test, align 4, !tbaa !11
  %66 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %65) #12
  %67 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %68

68:                                               ; preds = %64, %57
  %69 = phi i32 [ %13, %57 ], [ %67, %64 ]
  %70 = add nuw nsw i32 %14, 1
  %71 = icmp slt i32 %70, %69
  br i1 %71, label %12, label %72, !llvm.loop !433

72:                                               ; preds = %68, %3
  %73 = tail call i64 @clock() #15
  store i64 %73, ptr @end_time, align 8, !tbaa !23
  %74 = load i64, ptr @start_time, align 8, !tbaa !23
  %75 = sub nsw i64 %73, %74
  %76 = sitofp i64 %75 to double
  %77 = fdiv double %76, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %77, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi15EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %76

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 14
  %9 = add nsw i32 %1, -14
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %72, %7
  %13 = phi i32 [ %5, %7 ], [ %73, %72 ]
  %14 = phi i32 [ 0, %7 ], [ %74, %72 ]
  br i1 %8, label %15, label %45

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %41, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %40, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 8
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 12
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add nuw nsw i64 %16, 13
  %27 = getelementptr inbounds i32, ptr %0, i64 %26
  %28 = load i32, ptr %27, align 4, !tbaa !11
  %29 = add nuw nsw i64 %16, 14
  %30 = getelementptr inbounds i32, ptr %0, i64 %29
  %31 = load i32, ptr %30, align 4, !tbaa !11
  %32 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %33 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %34 = add i32 %32, %33
  %35 = add i32 %34, %25
  %36 = add i32 %28, %31
  %37 = add i32 %35, %36
  %38 = mul i32 %37, 269850533
  %39 = add i32 %17, 104993224
  %40 = add i32 %39, %38
  %41 = add nuw nsw i64 %16, 15
  %42 = icmp slt i64 %41, %10
  br i1 %42, label %15, label %43, !llvm.loop !434

43:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %40, %15 ]
  %.lcssa = phi i64 [ %41, %15 ]
  %44 = trunc i64 %.lcssa to i32
  br label %45

45:                                               ; preds = %43, %12
  %46 = phi i32 [ 0, %12 ], [ %.lcssa1, %43 ]
  %47 = phi i32 [ 0, %12 ], [ %44, %43 ]
  %48 = icmp slt i32 %47, %1
  br i1 %48, label %49, label %61

49:                                               ; preds = %45
  %50 = zext i32 %47 to i64
  br label %51

51:                                               ; preds = %51, %49
  %52 = phi i64 [ %50, %49 ], [ %59, %51 ]
  %53 = phi i32 [ %46, %49 ], [ %58, %51 ]
  %54 = getelementptr inbounds i32, ptr %0, i64 %52
  %55 = load i32, ptr %54, align 4, !tbaa !11
  %56 = mul i32 %55, 269850533
  %57 = add i32 %53, -1138325064
  %58 = add i32 %57, %56
  %59 = add nuw nsw i64 %52, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %51, !llvm.loop !435

61:                                               ; preds = %51, %45
  %62 = phi i32 [ %46, %45 ], [ %58, %51 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !17
  %64 = fptosi double %63 to i32
  %65 = mul i32 %64, -1564285888
  %66 = add i32 %65, -1269844480
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %72, label %68

68:                                               ; preds = %61
  %69 = load i32, ptr @current_test, align 4, !tbaa !11
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %69) #12
  %71 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %72

72:                                               ; preds = %68, %61
  %73 = phi i32 [ %13, %61 ], [ %71, %68 ]
  %74 = add nuw nsw i32 %14, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %12, label %76, !llvm.loop !436

76:                                               ; preds = %72, %3
  %77 = tail call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi11EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi9EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi10EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 9)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi11EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 10)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi12EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %64

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 11
  %9 = add nsw i32 %1, -11
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %60, %7
  %13 = phi i32 [ %5, %7 ], [ %61, %60 ]
  %14 = phi i32 [ 0, %7 ], [ %62, %60 ]
  br i1 %8, label %15, label %33

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %29, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %28, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 8
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %24 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %25 = add i32 %23, %24
  %26 = mul i32 %25, 269850533
  %27 = add i32 %17, -774998880
  %28 = add i32 %27, %26
  %29 = add nuw nsw i64 %16, 12
  %30 = icmp slt i64 %29, %10
  br i1 %30, label %15, label %31, !llvm.loop !437

31:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %28, %15 ]
  %.lcssa = phi i64 [ %29, %15 ]
  %32 = trunc i64 %.lcssa to i32
  br label %33

33:                                               ; preds = %31, %12
  %34 = phi i32 [ 0, %12 ], [ %.lcssa1, %31 ]
  %35 = phi i32 [ 0, %12 ], [ %32, %31 ]
  %36 = icmp slt i32 %35, %1
  br i1 %36, label %37, label %49

37:                                               ; preds = %33
  %38 = zext i32 %35 to i64
  br label %39

39:                                               ; preds = %39, %37
  %40 = phi i64 [ %38, %37 ], [ %47, %39 ]
  %41 = phi i32 [ %34, %37 ], [ %46, %39 ]
  %42 = getelementptr inbounds i32, ptr %0, i64 %40
  %43 = load i32, ptr %42, align 4, !tbaa !11
  %44 = mul i32 %43, 269850533
  %45 = add i32 %41, -1138325064
  %46 = add i32 %45, %44
  %47 = add nuw nsw i64 %40, 1
  %48 = icmp eq i64 %47, %11
  br i1 %48, label %49, label %39, !llvm.loop !438

49:                                               ; preds = %39, %33
  %50 = phi i32 [ %34, %33 ], [ %46, %39 ]
  %51 = load double, ptr @init_value, align 8, !tbaa !17
  %52 = fptosi double %51 to i32
  %53 = mul i32 %52, -1564285888
  %54 = add i32 %53, -1269844480
  %55 = icmp eq i32 %54, %50
  br i1 %55, label %60, label %56

56:                                               ; preds = %49
  %57 = load i32, ptr @current_test, align 4, !tbaa !11
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %57) #12
  %59 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %60

60:                                               ; preds = %56, %49
  %61 = phi i32 [ %13, %49 ], [ %59, %56 ]
  %62 = add nuw nsw i32 %14, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %12, label %64, !llvm.loop !439

64:                                               ; preds = %60, %3
  %65 = tail call i64 @clock() #15
  store i64 %65, ptr @end_time, align 8, !tbaa !23
  %66 = load i64, ptr @start_time, align 8, !tbaa !23
  %67 = sub nsw i64 %65, %66
  %68 = sitofp i64 %67 to double
  %69 = fdiv double %68, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %69, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi13EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %68

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 12
  %9 = add nsw i32 %1, -12
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %64, %7
  %13 = phi i32 [ %5, %7 ], [ %65, %64 ]
  %14 = phi i32 [ 0, %7 ], [ %66, %64 ]
  br i1 %8, label %15, label %37

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %33, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %32, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 8
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load <4 x i32>, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 12
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %27 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %22)
  %28 = add i32 %26, %27
  %29 = add i32 %28, %25
  %30 = mul i32 %29, 269850533
  %31 = add i32 %17, -1913323944
  %32 = add i32 %31, %30
  %33 = add nuw nsw i64 %16, 13
  %34 = icmp slt i64 %33, %10
  br i1 %34, label %15, label %35, !llvm.loop !440

35:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %32, %15 ]
  %.lcssa = phi i64 [ %33, %15 ]
  %36 = trunc i64 %.lcssa to i32
  br label %37

37:                                               ; preds = %35, %12
  %38 = phi i32 [ 0, %12 ], [ %.lcssa1, %35 ]
  %39 = phi i32 [ 0, %12 ], [ %36, %35 ]
  %40 = icmp slt i32 %39, %1
  br i1 %40, label %41, label %53

41:                                               ; preds = %37
  %42 = zext i32 %39 to i64
  br label %43

43:                                               ; preds = %43, %41
  %44 = phi i64 [ %42, %41 ], [ %51, %43 ]
  %45 = phi i32 [ %38, %41 ], [ %50, %43 ]
  %46 = getelementptr inbounds i32, ptr %0, i64 %44
  %47 = load i32, ptr %46, align 4, !tbaa !11
  %48 = mul i32 %47, 269850533
  %49 = add i32 %45, -1138325064
  %50 = add i32 %49, %48
  %51 = add nuw nsw i64 %44, 1
  %52 = icmp eq i64 %51, %11
  br i1 %52, label %53, label %43, !llvm.loop !441

53:                                               ; preds = %43, %37
  %54 = phi i32 [ %38, %37 ], [ %50, %43 ]
  %55 = load double, ptr @init_value, align 8, !tbaa !17
  %56 = fptosi double %55 to i32
  %57 = mul i32 %56, -1564285888
  %58 = add i32 %57, -1269844480
  %59 = icmp eq i32 %58, %54
  br i1 %59, label %64, label %60

60:                                               ; preds = %53
  %61 = load i32, ptr @current_test, align 4, !tbaa !11
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %61) #12
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %64

64:                                               ; preds = %60, %53
  %65 = phi i32 [ %13, %53 ], [ %63, %60 ]
  %66 = add nuw nsw i32 %14, 1
  %67 = icmp slt i32 %66, %65
  br i1 %67, label %12, label %68, !llvm.loop !442

68:                                               ; preds = %64, %3
  %69 = tail call i64 @clock() #15
  store i64 %69, ptr @end_time, align 8, !tbaa !23
  %70 = load i64, ptr @start_time, align 8, !tbaa !23
  %71 = sub nsw i64 %69, %70
  %72 = sitofp i64 %71 to double
  %73 = fdiv double %72, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %73, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi9EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi7EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi8EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 7)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi9EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 8)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi10EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 9
  %9 = add nsw i32 %1, -9
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ %5, %7 ], [ %64, %63 ]
  %14 = phi i32 [ 0, %7 ], [ %65, %63 ]
  br i1 %8, label %15, label %36

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %32, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %31, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 8
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 9
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %27 = add i32 %26, %22
  %28 = add i32 %27, %25
  %29 = mul i32 %28, 269850533
  %30 = add i32 %17, 1501651248
  %31 = add i32 %30, %29
  %32 = add nuw nsw i64 %16, 10
  %33 = icmp slt i64 %32, %10
  br i1 %33, label %15, label %34, !llvm.loop !443

34:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %31, %15 ]
  %.lcssa = phi i64 [ %32, %15 ]
  %35 = trunc i64 %.lcssa to i32
  br label %36

36:                                               ; preds = %34, %12
  %37 = phi i32 [ 0, %12 ], [ %.lcssa1, %34 ]
  %38 = phi i32 [ 0, %12 ], [ %35, %34 ]
  %39 = icmp slt i32 %38, %1
  br i1 %39, label %40, label %52

40:                                               ; preds = %36
  %41 = zext i32 %38 to i64
  br label %42

42:                                               ; preds = %42, %40
  %43 = phi i64 [ %41, %40 ], [ %50, %42 ]
  %44 = phi i32 [ %37, %40 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42, !llvm.loop !444

52:                                               ; preds = %42, %36
  %53 = phi i32 [ %37, %36 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %63, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  %62 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %63

63:                                               ; preds = %59, %52
  %64 = phi i32 [ %13, %52 ], [ %62, %59 ]
  %65 = add nuw nsw i32 %14, 1
  %66 = icmp slt i32 %65, %64
  br i1 %66, label %12, label %67, !llvm.loop !445

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi11EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 10
  %9 = add nsw i32 %1, -10
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ %5, %7 ], [ %68, %67 ]
  %14 = phi i32 [ 0, %7 ], [ %69, %67 ]
  br i1 %8, label %15, label %40

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %36, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %35, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 8
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 9
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add nuw nsw i64 %16, 10
  %27 = getelementptr inbounds i32, ptr %0, i64 %26
  %28 = load i32, ptr %27, align 4, !tbaa !11
  %29 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %30 = add i32 %29, %22
  %31 = add i32 %25, %28
  %32 = add i32 %30, %31
  %33 = mul i32 %32, 269850533
  %34 = add i32 %17, 363326184
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %16, 11
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %15, label %38, !llvm.loop !446

38:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %35, %15 ]
  %.lcssa = phi i64 [ %36, %15 ]
  %39 = trunc i64 %.lcssa to i32
  br label %40

40:                                               ; preds = %38, %12
  %41 = phi i32 [ 0, %12 ], [ %.lcssa1, %38 ]
  %42 = phi i32 [ 0, %12 ], [ %39, %38 ]
  %43 = icmp slt i32 %42, %1
  br i1 %43, label %44, label %56

44:                                               ; preds = %40
  %45 = zext i32 %42 to i64
  br label %46

46:                                               ; preds = %46, %44
  %47 = phi i64 [ %45, %44 ], [ %54, %46 ]
  %48 = phi i32 [ %41, %44 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46, !llvm.loop !447

56:                                               ; preds = %46, %40
  %57 = phi i32 [ %41, %40 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %67, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %56
  %68 = phi i32 [ %13, %56 ], [ %66, %63 ]
  %69 = add nuw nsw i32 %14, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %12, label %71, !llvm.loop !448

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi7EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi5EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi6EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 5)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi7EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 6)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi8EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %59

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 7
  %9 = add nsw i32 %1, -7
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %55, %7
  %13 = phi i32 [ %5, %7 ], [ %56, %55 ]
  %14 = phi i32 [ 0, %7 ], [ %57, %55 ]
  br i1 %8, label %15, label %28

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %24, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %23, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %21 = mul i32 %20, 269850533
  %22 = add i32 %17, -516665920
  %23 = add i32 %22, %21
  %24 = add nuw nsw i64 %16, 8
  %25 = icmp slt i64 %24, %10
  br i1 %25, label %15, label %26, !llvm.loop !449

26:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %23, %15 ]
  %.lcssa = phi i64 [ %24, %15 ]
  %27 = trunc i64 %.lcssa to i32
  br label %28

28:                                               ; preds = %26, %12
  %29 = phi i32 [ 0, %12 ], [ %.lcssa1, %26 ]
  %30 = phi i32 [ 0, %12 ], [ %27, %26 ]
  %31 = icmp slt i32 %30, %1
  br i1 %31, label %32, label %44

32:                                               ; preds = %28
  %33 = zext i32 %30 to i64
  br label %34

34:                                               ; preds = %34, %32
  %35 = phi i64 [ %33, %32 ], [ %42, %34 ]
  %36 = phi i32 [ %29, %32 ], [ %41, %34 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %35
  %38 = load i32, ptr %37, align 4, !tbaa !11
  %39 = mul i32 %38, 269850533
  %40 = add i32 %36, -1138325064
  %41 = add i32 %40, %39
  %42 = add nuw nsw i64 %35, 1
  %43 = icmp eq i64 %42, %11
  br i1 %43, label %44, label %34, !llvm.loop !450

44:                                               ; preds = %34, %28
  %45 = phi i32 [ %29, %28 ], [ %41, %34 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %55, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %44
  %56 = phi i32 [ %13, %44 ], [ %54, %51 ]
  %57 = add nuw nsw i32 %14, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %12, label %59, !llvm.loop !451

59:                                               ; preds = %55, %3
  %60 = tail call i64 @clock() #15
  store i64 %60, ptr @end_time, align 8, !tbaa !23
  %61 = load i64, ptr @start_time, align 8, !tbaa !23
  %62 = sub nsw i64 %60, %61
  %63 = sitofp i64 %62 to double
  %64 = fdiv double %63, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %64, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi9EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %63

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 8
  %9 = add nsw i32 %1, -8
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %59, %7
  %13 = phi i32 [ %5, %7 ], [ %60, %59 ]
  %14 = phi i32 [ 0, %7 ], [ %61, %59 ]
  br i1 %8, label %15, label %32

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %28, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %27, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <8 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 8
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %19)
  %24 = add i32 %23, %22
  %25 = mul i32 %24, 269850533
  %26 = add i32 %17, -1654990984
  %27 = add i32 %26, %25
  %28 = add nuw nsw i64 %16, 9
  %29 = icmp slt i64 %28, %10
  br i1 %29, label %15, label %30, !llvm.loop !452

30:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %27, %15 ]
  %.lcssa = phi i64 [ %28, %15 ]
  %31 = trunc i64 %.lcssa to i32
  br label %32

32:                                               ; preds = %30, %12
  %33 = phi i32 [ 0, %12 ], [ %.lcssa1, %30 ]
  %34 = phi i32 [ 0, %12 ], [ %31, %30 ]
  %35 = icmp slt i32 %34, %1
  br i1 %35, label %36, label %48

36:                                               ; preds = %32
  %37 = zext i32 %34 to i64
  br label %38

38:                                               ; preds = %38, %36
  %39 = phi i64 [ %37, %36 ], [ %46, %38 ]
  %40 = phi i32 [ %33, %36 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38, !llvm.loop !453

48:                                               ; preds = %38, %32
  %49 = phi i32 [ %33, %32 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %59, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  %58 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %59

59:                                               ; preds = %55, %48
  %60 = phi i32 [ %13, %48 ], [ %58, %55 ]
  %61 = add nuw nsw i32 %14, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %12, label %63, !llvm.loop !454

63:                                               ; preds = %59, %3
  %64 = tail call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi5EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN13do_loop_testsILi3EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z26test_do_loop_unroll_factorILi4EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 3)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi5EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 4)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi6EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 5
  %9 = add nsw i32 %1, -5
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ %5, %7 ], [ %64, %63 ]
  %14 = phi i32 [ 0, %7 ], [ %65, %63 ]
  br i1 %8, label %15, label %36

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %32, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %31, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <4 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 4
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 5
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %19)
  %27 = add i32 %26, %22
  %28 = add i32 %27, %25
  %29 = mul i32 %28, 269850533
  %30 = add i32 %17, 1759984208
  %31 = add i32 %30, %29
  %32 = add nuw nsw i64 %16, 6
  %33 = icmp slt i64 %32, %10
  br i1 %33, label %15, label %34, !llvm.loop !455

34:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %31, %15 ]
  %.lcssa = phi i64 [ %32, %15 ]
  %35 = trunc i64 %.lcssa to i32
  br label %36

36:                                               ; preds = %34, %12
  %37 = phi i32 [ 0, %12 ], [ %.lcssa1, %34 ]
  %38 = phi i32 [ 0, %12 ], [ %35, %34 ]
  %39 = icmp slt i32 %38, %1
  br i1 %39, label %40, label %52

40:                                               ; preds = %36
  %41 = zext i32 %38 to i64
  br label %42

42:                                               ; preds = %42, %40
  %43 = phi i64 [ %41, %40 ], [ %50, %42 ]
  %44 = phi i32 [ %37, %40 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42, !llvm.loop !456

52:                                               ; preds = %42, %36
  %53 = phi i32 [ %37, %36 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %63, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  %62 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %63

63:                                               ; preds = %59, %52
  %64 = phi i32 [ %13, %52 ], [ %62, %59 ]
  %65 = add nuw nsw i32 %14, 1
  %66 = icmp slt i32 %65, %64
  br i1 %66, label %12, label %67, !llvm.loop !457

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi7EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 6
  %9 = add nsw i32 %1, -6
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ %5, %7 ], [ %68, %67 ]
  %14 = phi i32 [ 0, %7 ], [ %69, %67 ]
  br i1 %8, label %15, label %40

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %36, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %35, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <4 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 4
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 5
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add nuw nsw i64 %16, 6
  %27 = getelementptr inbounds i32, ptr %0, i64 %26
  %28 = load i32, ptr %27, align 4, !tbaa !11
  %29 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %19)
  %30 = add i32 %29, %22
  %31 = add i32 %25, %28
  %32 = add i32 %30, %31
  %33 = mul i32 %32, 269850533
  %34 = add i32 %17, 621659144
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %16, 7
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %15, label %38, !llvm.loop !458

38:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %35, %15 ]
  %.lcssa = phi i64 [ %36, %15 ]
  %39 = trunc i64 %.lcssa to i32
  br label %40

40:                                               ; preds = %38, %12
  %41 = phi i32 [ 0, %12 ], [ %.lcssa1, %38 ]
  %42 = phi i32 [ 0, %12 ], [ %39, %38 ]
  %43 = icmp slt i32 %42, %1
  br i1 %43, label %44, label %56

44:                                               ; preds = %40
  %45 = zext i32 %42 to i64
  br label %46

46:                                               ; preds = %46, %44
  %47 = phi i64 [ %45, %44 ], [ %54, %46 ]
  %48 = phi i32 [ %41, %44 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46, !llvm.loop !459

56:                                               ; preds = %46, %40
  %57 = phi i32 [ %41, %40 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %67, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %56
  %68 = phi i32 [ %13, %56 ], [ %66, %63 ]
  %69 = add nuw nsw i32 %14, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %12, label %71, !llvm.loop !460

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN13do_loop_testsILi3EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_Z26test_do_loop_unroll_factorILi1EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull @temp_string) #12
  tail call void @_Z26test_do_loop_unroll_factorILi2EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 1)) #12
  tail call void @_Z26test_do_loop_unroll_factorILi3EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 2)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi4EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %59

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 3
  %9 = add nsw i32 %1, -3
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %55, %7
  %13 = phi i32 [ %5, %7 ], [ %56, %55 ]
  %14 = phi i32 [ 0, %7 ], [ %57, %55 ]
  br i1 %8, label %15, label %28

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %24, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %23, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <4 x i32>, ptr %18, align 4, !tbaa !11
  %20 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %19)
  %21 = mul i32 %20, 269850533
  %22 = add i32 %17, -258332960
  %23 = add i32 %22, %21
  %24 = add nuw nsw i64 %16, 4
  %25 = icmp slt i64 %24, %10
  br i1 %25, label %15, label %26, !llvm.loop !461

26:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %23, %15 ]
  %.lcssa = phi i64 [ %24, %15 ]
  %27 = trunc i64 %.lcssa to i32
  br label %28

28:                                               ; preds = %26, %12
  %29 = phi i32 [ 0, %12 ], [ %.lcssa1, %26 ]
  %30 = phi i32 [ 0, %12 ], [ %27, %26 ]
  %31 = icmp slt i32 %30, %1
  br i1 %31, label %32, label %44

32:                                               ; preds = %28
  %33 = zext i32 %30 to i64
  br label %34

34:                                               ; preds = %34, %32
  %35 = phi i64 [ %33, %32 ], [ %42, %34 ]
  %36 = phi i32 [ %29, %32 ], [ %41, %34 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %35
  %38 = load i32, ptr %37, align 4, !tbaa !11
  %39 = mul i32 %38, 269850533
  %40 = add i32 %36, -1138325064
  %41 = add i32 %40, %39
  %42 = add nuw nsw i64 %35, 1
  %43 = icmp eq i64 %42, %11
  br i1 %43, label %44, label %34, !llvm.loop !462

44:                                               ; preds = %34, %28
  %45 = phi i32 [ %29, %28 ], [ %41, %34 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %55, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %44
  %56 = phi i32 [ %13, %44 ], [ %54, %51 ]
  %57 = add nuw nsw i32 %14, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %12, label %59, !llvm.loop !463

59:                                               ; preds = %55, %3
  %60 = tail call i64 @clock() #15
  store i64 %60, ptr @end_time, align 8, !tbaa !23
  %61 = load i64, ptr @start_time, align 8, !tbaa !23
  %62 = sub nsw i64 %60, %61
  %63 = sitofp i64 %62 to double
  %64 = fdiv double %63, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %64, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi5EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %63

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 4
  %9 = add nsw i32 %1, -4
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %59, %7
  %13 = phi i32 [ %5, %7 ], [ %60, %59 ]
  %14 = phi i32 [ 0, %7 ], [ %61, %59 ]
  br i1 %8, label %15, label %32

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %28, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %27, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load <4 x i32>, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 4
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %19)
  %24 = add i32 %23, %22
  %25 = mul i32 %24, 269850533
  %26 = add i32 %17, -1396658024
  %27 = add i32 %26, %25
  %28 = add nuw nsw i64 %16, 5
  %29 = icmp slt i64 %28, %10
  br i1 %29, label %15, label %30, !llvm.loop !464

30:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %27, %15 ]
  %.lcssa = phi i64 [ %28, %15 ]
  %31 = trunc i64 %.lcssa to i32
  br label %32

32:                                               ; preds = %30, %12
  %33 = phi i32 [ 0, %12 ], [ %.lcssa1, %30 ]
  %34 = phi i32 [ 0, %12 ], [ %31, %30 ]
  %35 = icmp slt i32 %34, %1
  br i1 %35, label %36, label %48

36:                                               ; preds = %32
  %37 = zext i32 %34 to i64
  br label %38

38:                                               ; preds = %38, %36
  %39 = phi i64 [ %37, %36 ], [ %46, %38 ]
  %40 = phi i32 [ %33, %36 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38, !llvm.loop !465

48:                                               ; preds = %38, %32
  %49 = phi i32 [ %33, %32 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %59, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  %58 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %59

59:                                               ; preds = %55, %48
  %60 = phi i32 [ %13, %48 ], [ %58, %55 ]
  %61 = add nuw nsw i32 %14, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %12, label %63, !llvm.loop !466

63:                                               ; preds = %59, %3
  %64 = tail call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi1EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %38

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 0
  %9 = zext i32 %1 to i64
  br label %10

10:                                               ; preds = %34, %7
  %11 = phi i32 [ %5, %7 ], [ %35, %34 ]
  %12 = phi i32 [ 0, %7 ], [ %36, %34 ]
  br i1 %8, label %13, label %23

13:                                               ; preds = %13, %10
  %14 = phi i64 [ %21, %13 ], [ 0, %10 ]
  %15 = phi i32 [ %20, %13 ], [ 0, %10 ]
  %16 = getelementptr inbounds i32, ptr %0, i64 %14
  %17 = load i32, ptr %16, align 4, !tbaa !11
  %18 = mul i32 %17, 269850533
  %19 = add i32 %15, -1138325064
  %20 = add i32 %19, %18
  %21 = add nuw nsw i64 %14, 1
  %22 = icmp eq i64 %21, %9
  br i1 %22, label %23, label %13, !llvm.loop !467

23:                                               ; preds = %13, %10
  %24 = phi i32 [ 0, %10 ], [ %20, %13 ]
  %25 = load double, ptr @init_value, align 8, !tbaa !17
  %26 = fptosi double %25 to i32
  %27 = mul i32 %26, -1564285888
  %28 = add i32 %27, -1269844480
  %29 = icmp eq i32 %28, %24
  br i1 %29, label %34, label %30

30:                                               ; preds = %23
  %31 = load i32, ptr @current_test, align 4, !tbaa !11
  %32 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %31) #12
  %33 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %34

34:                                               ; preds = %30, %23
  %35 = phi i32 [ %11, %23 ], [ %33, %30 ]
  %36 = add nuw nsw i32 %12, 1
  %37 = icmp slt i32 %36, %35
  br i1 %37, label %10, label %38, !llvm.loop !468

38:                                               ; preds = %34, %3
  %39 = tail call i64 @clock() #15
  store i64 %39, ptr @end_time, align 8, !tbaa !23
  %40 = load i64, ptr @start_time, align 8, !tbaa !23
  %41 = sub nsw i64 %39, %40
  %42 = sitofp i64 %41 to double
  %43 = fdiv double %42, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %43, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi2EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %62

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 1
  %9 = add nsw i32 %1, -1
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %58, %7
  %13 = phi i32 [ %5, %7 ], [ %59, %58 ]
  %14 = phi i32 [ 0, %7 ], [ %60, %58 ]
  br i1 %8, label %15, label %31

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %27, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %26, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load i32, ptr %18, align 4, !tbaa !11
  %20 = or i64 %16, 1
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add i32 %22, %19
  %24 = mul i32 %23, 269850533
  %25 = add i32 %17, 2018317168
  %26 = add i32 %25, %24
  %27 = add nuw nsw i64 %16, 2
  %28 = icmp slt i64 %27, %10
  br i1 %28, label %15, label %29, !llvm.loop !469

29:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %26, %15 ]
  %.lcssa = phi i64 [ %27, %15 ]
  %30 = trunc i64 %.lcssa to i32
  br label %31

31:                                               ; preds = %29, %12
  %32 = phi i32 [ 0, %12 ], [ %.lcssa1, %29 ]
  %33 = phi i32 [ 0, %12 ], [ %30, %29 ]
  %34 = icmp slt i32 %33, %1
  br i1 %34, label %35, label %47

35:                                               ; preds = %31
  %36 = zext i32 %33 to i64
  br label %37

37:                                               ; preds = %37, %35
  %38 = phi i64 [ %36, %35 ], [ %45, %37 ]
  %39 = phi i32 [ %32, %35 ], [ %44, %37 ]
  %40 = getelementptr inbounds i32, ptr %0, i64 %38
  %41 = load i32, ptr %40, align 4, !tbaa !11
  %42 = mul i32 %41, 269850533
  %43 = add i32 %39, -1138325064
  %44 = add i32 %43, %42
  %45 = add nuw nsw i64 %38, 1
  %46 = icmp eq i64 %45, %11
  br i1 %46, label %47, label %37, !llvm.loop !470

47:                                               ; preds = %37, %31
  %48 = phi i32 [ %32, %31 ], [ %44, %37 ]
  %49 = load double, ptr @init_value, align 8, !tbaa !17
  %50 = fptosi double %49 to i32
  %51 = mul i32 %50, -1564285888
  %52 = add i32 %51, -1269844480
  %53 = icmp eq i32 %52, %48
  br i1 %53, label %58, label %54

54:                                               ; preds = %47
  %55 = load i32, ptr @current_test, align 4, !tbaa !11
  %56 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %55) #12
  %57 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %58

58:                                               ; preds = %54, %47
  %59 = phi i32 [ %13, %47 ], [ %57, %54 ]
  %60 = add nuw nsw i32 %14, 1
  %61 = icmp slt i32 %60, %59
  br i1 %61, label %12, label %62, !llvm.loop !471

62:                                               ; preds = %58, %3
  %63 = tail call i64 @clock() #15
  store i64 %63, ptr @end_time, align 8, !tbaa !23
  %64 = load i64, ptr @start_time, align 8, !tbaa !23
  %65 = sub nsw i64 %63, %64
  %66 = sitofp i64 %65 to double
  %67 = fdiv double %66, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %67, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z26test_do_loop_unroll_factorILi3EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %66

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 2
  %9 = add nsw i32 %1, -2
  %10 = sext i32 %9 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %62, %7
  %13 = phi i32 [ %5, %7 ], [ %63, %62 ]
  %14 = phi i32 [ 0, %7 ], [ %64, %62 ]
  br i1 %8, label %15, label %35

15:                                               ; preds = %15, %12
  %16 = phi i64 [ %31, %15 ], [ 0, %12 ]
  %17 = phi i32 [ %30, %15 ], [ 0, %12 ]
  %18 = getelementptr inbounds i32, ptr %0, i64 %16
  %19 = load i32, ptr %18, align 4, !tbaa !11
  %20 = add nuw nsw i64 %16, 1
  %21 = getelementptr inbounds i32, ptr %0, i64 %20
  %22 = load i32, ptr %21, align 4, !tbaa !11
  %23 = add nuw nsw i64 %16, 2
  %24 = getelementptr inbounds i32, ptr %0, i64 %23
  %25 = load i32, ptr %24, align 4, !tbaa !11
  %26 = add i32 %22, %19
  %27 = add i32 %26, %25
  %28 = mul i32 %27, 269850533
  %29 = add i32 %17, 879992104
  %30 = add i32 %29, %28
  %31 = add nuw nsw i64 %16, 3
  %32 = icmp slt i64 %31, %10
  br i1 %32, label %15, label %33, !llvm.loop !472

33:                                               ; preds = %15
  %.lcssa1 = phi i32 [ %30, %15 ]
  %.lcssa = phi i64 [ %31, %15 ]
  %34 = trunc i64 %.lcssa to i32
  br label %35

35:                                               ; preds = %33, %12
  %36 = phi i32 [ 0, %12 ], [ %.lcssa1, %33 ]
  %37 = phi i32 [ 0, %12 ], [ %34, %33 ]
  %38 = icmp slt i32 %37, %1
  br i1 %38, label %39, label %51

39:                                               ; preds = %35
  %40 = zext i32 %37 to i64
  br label %41

41:                                               ; preds = %41, %39
  %42 = phi i64 [ %40, %39 ], [ %49, %41 ]
  %43 = phi i32 [ %36, %39 ], [ %48, %41 ]
  %44 = getelementptr inbounds i32, ptr %0, i64 %42
  %45 = load i32, ptr %44, align 4, !tbaa !11
  %46 = mul i32 %45, 269850533
  %47 = add i32 %43, -1138325064
  %48 = add i32 %47, %46
  %49 = add nuw nsw i64 %42, 1
  %50 = icmp eq i64 %49, %11
  br i1 %50, label %51, label %41, !llvm.loop !473

51:                                               ; preds = %41, %35
  %52 = phi i32 [ %36, %35 ], [ %48, %41 ]
  %53 = load double, ptr @init_value, align 8, !tbaa !17
  %54 = fptosi double %53 to i32
  %55 = mul i32 %54, -1564285888
  %56 = add i32 %55, -1269844480
  %57 = icmp eq i32 %56, %52
  br i1 %57, label %62, label %58

58:                                               ; preds = %51
  %59 = load i32, ptr @current_test, align 4, !tbaa !11
  %60 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %59) #12
  %61 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %62

62:                                               ; preds = %58, %51
  %63 = phi i32 [ %13, %51 ], [ %61, %58 ]
  %64 = add nuw nsw i32 %14, 1
  %65 = icmp slt i32 %64, %63
  br i1 %65, label %12, label %66, !llvm.loop !474

66:                                               ; preds = %62, %3
  %67 = tail call i64 @clock() #15
  store i64 %67, ptr @end_time, align 8, !tbaa !23
  %68 = load i64, ptr @start_time, align 8, !tbaa !23
  %69 = sub nsw i64 %67, %68
  %70 = sitofp i64 %69 to double
  %71 = fdiv double %70, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %71, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi29EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi27EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi28EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 27)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi29EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 28)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi30EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca i32, align 4
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %51

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -29
  %10 = icmp sgt i32 %1, 29
  br label %11

11:                                               ; preds = %47, %8
  %12 = phi i32 [ 0, %8 ], [ %48, %47 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #16
  store i32 0, ptr %4, align 4, !tbaa !11
  br i1 %10, label %21, label %15

13:                                               ; preds = %21
  %.lcssa = phi i32 [ %23, %21 ]
  %14 = load i32, ptr %4, align 4, !tbaa !11
  br label %15

15:                                               ; preds = %13, %11
  %16 = phi i32 [ 0, %11 ], [ %14, %13 ]
  %17 = phi i32 [ 0, %11 ], [ %.lcssa, %13 ]
  %18 = icmp slt i32 %17, %1
  br i1 %18, label %19, label %37

19:                                               ; preds = %15
  %20 = zext i32 %17 to i64
  br label %25

21:                                               ; preds = %21, %11
  %22 = phi i32 [ %23, %21 ], [ 0, %11 ]
  call void @_ZN15loop_inner_bodyILi30EiE7do_workERiPKii(ptr noundef nonnull align 4 dereferenceable(4) %4, ptr noundef %0, i32 noundef %22) #12
  %23 = add nuw nsw i32 %22, 30
  %24 = icmp slt i32 %23, %9
  br i1 %24, label %21, label %13, !llvm.loop !475

25:                                               ; preds = %25, %19
  %26 = phi i64 [ %20, %19 ], [ %33, %25 ]
  %27 = phi i32 [ %16, %19 ], [ %32, %25 ]
  %28 = getelementptr inbounds i32, ptr %0, i64 %26
  %29 = load i32, ptr %28, align 4, !tbaa !11
  %30 = mul i32 %29, 269850533
  %31 = add i32 %30, -1138325064
  %32 = add nsw i32 %31, %27
  %33 = add nuw nsw i64 %26, 1
  %34 = trunc i64 %33 to i32
  %35 = icmp eq i32 %34, %1
  br i1 %35, label %36, label %25, !llvm.loop !476

36:                                               ; preds = %25
  %.lcssa1 = phi i32 [ %32, %25 ]
  store i32 %.lcssa1, ptr %4, align 4, !tbaa !11
  br label %37

37:                                               ; preds = %36, %15
  %38 = phi i32 [ %.lcssa1, %36 ], [ %16, %15 ]
  %39 = load double, ptr @init_value, align 8, !tbaa !17
  %40 = fptosi double %39 to i32
  %41 = mul i32 %40, -1564285888
  %42 = add i32 %41, -1269844480
  %43 = icmp eq i32 %42, %38
  br i1 %43, label %47, label %44

44:                                               ; preds = %37
  %45 = load i32, ptr @current_test, align 4, !tbaa !11
  %46 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %45) #12
  br label %47

47:                                               ; preds = %44, %37
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #16
  %48 = add nuw nsw i32 %12, 1
  %49 = load i32, ptr @iterations, align 4, !tbaa !11
  %50 = icmp slt i32 %48, %49
  br i1 %50, label %11, label %51, !llvm.loop !477

51:                                               ; preds = %47, %3
  %52 = call i64 @clock() #15
  store i64 %52, ptr @end_time, align 8, !tbaa !23
  %53 = load i64, ptr @start_time, align 8, !tbaa !23
  %54 = sub nsw i64 %52, %53
  %55 = sitofp i64 %54 to double
  %56 = fdiv double %55, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %56, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi31EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca i32, align 4
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %58

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -30
  %10 = icmp sgt i32 %1, 30
  br label %11

11:                                               ; preds = %54, %8
  %12 = phi i32 [ 0, %8 ], [ %55, %54 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #16
  store i32 0, ptr %4, align 4, !tbaa !11
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi i32 [ 0, %11 ], [ %28, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %30, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %44

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %32

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %29, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi30EiE7do_workERiPKii(ptr noundef nonnull align 4 dereferenceable(4) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 30
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load i32, ptr %23, align 4, !tbaa !11
  %25 = mul i32 %24, 269850533
  %26 = add i32 %25, -1138325064
  %27 = load i32, ptr %4, align 4, !tbaa !11
  %28 = add nsw i32 %26, %27
  store i32 %28, ptr %4, align 4, !tbaa !11
  %29 = add nuw i64 %20, 31
  %30 = trunc i64 %29 to i32
  %31 = icmp sgt i32 %9, %30
  br i1 %31, label %19, label %13, !llvm.loop !478

32:                                               ; preds = %32, %17
  %33 = phi i64 [ %18, %17 ], [ %40, %32 ]
  %34 = phi i32 [ %14, %17 ], [ %39, %32 ]
  %35 = getelementptr inbounds i32, ptr %0, i64 %33
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = mul i32 %36, 269850533
  %38 = add i32 %37, -1138325064
  %39 = add nsw i32 %38, %34
  %40 = add nuw nsw i64 %33, 1
  %41 = trunc i64 %40 to i32
  %42 = icmp slt i32 %41, %1
  br i1 %42, label %32, label %43, !llvm.loop !479

43:                                               ; preds = %32
  %.lcssa = phi i32 [ %39, %32 ]
  store i32 %.lcssa, ptr %4, align 4, !tbaa !11
  br label %44

44:                                               ; preds = %43, %13
  %45 = phi i32 [ %.lcssa, %43 ], [ %14, %13 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %54, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  br label %54

54:                                               ; preds = %51, %44
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #16
  %55 = add nuw nsw i32 %12, 1
  %56 = load i32, ptr @iterations, align 4, !tbaa !11
  %57 = icmp slt i32 %55, %56
  br i1 %57, label %11, label %58, !llvm.loop !480

58:                                               ; preds = %54, %3
  %59 = call i64 @clock() #15
  store i64 %59, ptr @end_time, align 8, !tbaa !23
  %60 = load i64, ptr @start_time, align 8, !tbaa !23
  %61 = sub nsw i64 %59, %60
  %62 = sitofp i64 %61 to double
  %63 = fdiv double %62, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %63, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi27EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi25EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi26EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 25)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi27EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 26)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi28EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -27
  %9 = icmp sgt i32 %1, 27
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ 0, %7 ], [ %64, %63 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi i32 [ %40, %22 ]
  %.lcssa = phi i64 [ %41, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i32 [ 0, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %53

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %43

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %41, %22 ], [ 0, %12 ]
  %24 = phi i32 [ %40, %22 ], [ 0, %12 ]
  %25 = getelementptr inbounds i32, ptr %0, i64 %23
  %26 = load <16 x i32>, ptr %25, align 4, !tbaa !11
  %27 = add nuw nsw i64 %23, 16
  %28 = getelementptr inbounds i32, ptr %0, i64 %27
  %29 = load <8 x i32>, ptr %28, align 4, !tbaa !11
  %30 = add nuw nsw i64 %23, 24
  %31 = getelementptr inbounds i32, ptr %0, i64 %30
  %32 = load <4 x i32>, ptr %31, align 4, !tbaa !11
  %33 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %26)
  %34 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %29)
  %35 = add i32 %33, %34
  %36 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %32)
  %37 = add i32 %35, %36
  %38 = mul i32 %37, 269850533
  %39 = add i32 %24, -1808330720
  %40 = add i32 %39, %38
  %41 = add nuw nsw i64 %23, 28
  %42 = icmp slt i64 %41, %10
  br i1 %42, label %22, label %14, !llvm.loop !481

43:                                               ; preds = %43, %20
  %44 = phi i64 [ %21, %20 ], [ %51, %43 ]
  %45 = phi i32 [ %17, %20 ], [ %50, %43 ]
  %46 = getelementptr inbounds i32, ptr %0, i64 %44
  %47 = load i32, ptr %46, align 4, !tbaa !11
  %48 = mul i32 %47, 269850533
  %49 = add i32 %45, -1138325064
  %50 = add i32 %49, %48
  %51 = add nuw nsw i64 %44, 1
  %52 = icmp eq i64 %51, %11
  br i1 %52, label %53, label %43, !llvm.loop !482

53:                                               ; preds = %43, %16
  %54 = phi i32 [ %17, %16 ], [ %50, %43 ]
  %55 = load double, ptr @init_value, align 8, !tbaa !17
  %56 = fptosi double %55 to i32
  %57 = mul i32 %56, -1564285888
  %58 = add i32 %57, -1269844480
  %59 = icmp eq i32 %58, %54
  br i1 %59, label %63, label %60

60:                                               ; preds = %53
  %61 = load i32, ptr @current_test, align 4, !tbaa !11
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %61) #12
  br label %63

63:                                               ; preds = %60, %53
  %64 = add nuw nsw i32 %13, 1
  %65 = load i32, ptr @iterations, align 4, !tbaa !11
  %66 = icmp slt i32 %64, %65
  br i1 %66, label %12, label %67, !llvm.loop !483

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi29EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -28
  %9 = icmp sgt i32 %1, 28
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ 0, %7 ], [ %68, %67 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi i32 [ %44, %22 ]
  %.lcssa = phi i64 [ %45, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i32 [ 0, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %57

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %47

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %45, %22 ], [ 0, %12 ]
  %24 = phi i32 [ %44, %22 ], [ 0, %12 ]
  %25 = getelementptr inbounds i32, ptr %0, i64 %23
  %26 = load <16 x i32>, ptr %25, align 4, !tbaa !11
  %27 = add nuw nsw i64 %23, 16
  %28 = getelementptr inbounds i32, ptr %0, i64 %27
  %29 = load <8 x i32>, ptr %28, align 4, !tbaa !11
  %30 = add nuw nsw i64 %23, 24
  %31 = getelementptr inbounds i32, ptr %0, i64 %30
  %32 = load <4 x i32>, ptr %31, align 4, !tbaa !11
  %33 = add nuw nsw i64 %23, 28
  %34 = getelementptr inbounds i32, ptr %0, i64 %33
  %35 = load i32, ptr %34, align 4, !tbaa !11
  %36 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %26)
  %37 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %29)
  %38 = add i32 %36, %37
  %39 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %32)
  %40 = add i32 %38, %39
  %41 = add i32 %40, %35
  %42 = mul i32 %41, 269850533
  %43 = add i32 %24, 1348311512
  %44 = add i32 %43, %42
  %45 = add nuw nsw i64 %23, 29
  %46 = icmp slt i64 %45, %10
  br i1 %46, label %22, label %14, !llvm.loop !484

47:                                               ; preds = %47, %20
  %48 = phi i64 [ %21, %20 ], [ %55, %47 ]
  %49 = phi i32 [ %17, %20 ], [ %54, %47 ]
  %50 = getelementptr inbounds i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !11
  %52 = mul i32 %51, 269850533
  %53 = add i32 %49, -1138325064
  %54 = add i32 %53, %52
  %55 = add nuw nsw i64 %48, 1
  %56 = icmp eq i64 %55, %11
  br i1 %56, label %57, label %47, !llvm.loop !485

57:                                               ; preds = %47, %16
  %58 = phi i32 [ %17, %16 ], [ %54, %47 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !17
  %60 = fptosi double %59 to i32
  %61 = mul i32 %60, -1564285888
  %62 = add i32 %61, -1269844480
  %63 = icmp eq i32 %62, %58
  br i1 %63, label %67, label %64

64:                                               ; preds = %57
  %65 = load i32, ptr @current_test, align 4, !tbaa !11
  %66 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %65) #12
  br label %67

67:                                               ; preds = %64, %57
  %68 = add nuw nsw i32 %13, 1
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  %70 = icmp slt i32 %68, %69
  br i1 %70, label %12, label %71, !llvm.loop !486

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi25EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi23EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi24EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 23)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi25EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 24)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi26EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %70

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -25
  %9 = icmp sgt i32 %1, 25
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %66, %7
  %13 = phi i32 [ 0, %7 ], [ %67, %66 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi i32 [ %43, %22 ]
  %.lcssa = phi i64 [ %44, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i32 [ 0, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %56

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %46

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %44, %22 ], [ 0, %12 ]
  %24 = phi i32 [ %43, %22 ], [ 0, %12 ]
  %25 = getelementptr inbounds i32, ptr %0, i64 %23
  %26 = load <16 x i32>, ptr %25, align 4, !tbaa !11
  %27 = add nuw nsw i64 %23, 16
  %28 = getelementptr inbounds i32, ptr %0, i64 %27
  %29 = load <8 x i32>, ptr %28, align 4, !tbaa !11
  %30 = add nuw nsw i64 %23, 24
  %31 = getelementptr inbounds i32, ptr %0, i64 %30
  %32 = load i32, ptr %31, align 4, !tbaa !11
  %33 = add nuw nsw i64 %23, 25
  %34 = getelementptr inbounds i32, ptr %0, i64 %33
  %35 = load i32, ptr %34, align 4, !tbaa !11
  %36 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %26)
  %37 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %29)
  %38 = add i32 %36, %37
  %39 = add i32 %38, %32
  %40 = add i32 %39, %35
  %41 = mul i32 %40, 269850533
  %42 = add i32 %24, 468319408
  %43 = add i32 %42, %41
  %44 = add nuw nsw i64 %23, 26
  %45 = icmp slt i64 %44, %10
  br i1 %45, label %22, label %14, !llvm.loop !487

46:                                               ; preds = %46, %20
  %47 = phi i64 [ %21, %20 ], [ %54, %46 ]
  %48 = phi i32 [ %17, %20 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46, !llvm.loop !488

56:                                               ; preds = %46, %16
  %57 = phi i32 [ %17, %16 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %66, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  br label %66

66:                                               ; preds = %63, %56
  %67 = add nuw nsw i32 %13, 1
  %68 = load i32, ptr @iterations, align 4, !tbaa !11
  %69 = icmp slt i32 %67, %68
  br i1 %69, label %12, label %70, !llvm.loop !489

70:                                               ; preds = %66, %3
  %71 = tail call i64 @clock() #15
  store i64 %71, ptr @end_time, align 8, !tbaa !23
  %72 = load i64, ptr @start_time, align 8, !tbaa !23
  %73 = sub nsw i64 %71, %72
  %74 = sitofp i64 %73 to double
  %75 = fdiv double %74, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %75, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi27EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %74

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -26
  %9 = icmp sgt i32 %1, 26
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %70, %7
  %13 = phi i32 [ 0, %7 ], [ %71, %70 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi i32 [ %47, %22 ]
  %.lcssa = phi i64 [ %48, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i32 [ 0, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %60

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %50

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %48, %22 ], [ 0, %12 ]
  %24 = phi i32 [ %47, %22 ], [ 0, %12 ]
  %25 = getelementptr inbounds i32, ptr %0, i64 %23
  %26 = load <16 x i32>, ptr %25, align 4, !tbaa !11
  %27 = add nuw nsw i64 %23, 16
  %28 = getelementptr inbounds i32, ptr %0, i64 %27
  %29 = load <8 x i32>, ptr %28, align 4, !tbaa !11
  %30 = add nuw nsw i64 %23, 24
  %31 = getelementptr inbounds i32, ptr %0, i64 %30
  %32 = load i32, ptr %31, align 4, !tbaa !11
  %33 = add nuw nsw i64 %23, 25
  %34 = getelementptr inbounds i32, ptr %0, i64 %33
  %35 = load i32, ptr %34, align 4, !tbaa !11
  %36 = add nuw nsw i64 %23, 26
  %37 = getelementptr inbounds i32, ptr %0, i64 %36
  %38 = load i32, ptr %37, align 4, !tbaa !11
  %39 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %26)
  %40 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %29)
  %41 = add i32 %39, %40
  %42 = add i32 %41, %32
  %43 = add i32 %35, %38
  %44 = add i32 %42, %43
  %45 = mul i32 %44, 269850533
  %46 = add i32 %24, -670005656
  %47 = add i32 %46, %45
  %48 = add nuw nsw i64 %23, 27
  %49 = icmp slt i64 %48, %10
  br i1 %49, label %22, label %14, !llvm.loop !490

50:                                               ; preds = %50, %20
  %51 = phi i64 [ %21, %20 ], [ %58, %50 ]
  %52 = phi i32 [ %17, %20 ], [ %57, %50 ]
  %53 = getelementptr inbounds i32, ptr %0, i64 %51
  %54 = load i32, ptr %53, align 4, !tbaa !11
  %55 = mul i32 %54, 269850533
  %56 = add i32 %52, -1138325064
  %57 = add i32 %56, %55
  %58 = add nuw nsw i64 %51, 1
  %59 = icmp eq i64 %58, %11
  br i1 %59, label %60, label %50, !llvm.loop !491

60:                                               ; preds = %50, %16
  %61 = phi i32 [ %17, %16 ], [ %57, %50 ]
  %62 = load double, ptr @init_value, align 8, !tbaa !17
  %63 = fptosi double %62 to i32
  %64 = mul i32 %63, -1564285888
  %65 = add i32 %64, -1269844480
  %66 = icmp eq i32 %65, %61
  br i1 %66, label %70, label %67

67:                                               ; preds = %60
  %68 = load i32, ptr @current_test, align 4, !tbaa !11
  %69 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %68) #12
  br label %70

70:                                               ; preds = %67, %60
  %71 = add nuw nsw i32 %13, 1
  %72 = load i32, ptr @iterations, align 4, !tbaa !11
  %73 = icmp slt i32 %71, %72
  br i1 %73, label %12, label %74, !llvm.loop !492

74:                                               ; preds = %70, %3
  %75 = tail call i64 @clock() #15
  store i64 %75, ptr @end_time, align 8, !tbaa !23
  %76 = load i64, ptr @start_time, align 8, !tbaa !23
  %77 = sub nsw i64 %75, %76
  %78 = sitofp i64 %77 to double
  %79 = fdiv double %78, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %79, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi23EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi21EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi22EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 21)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi23EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 22)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi24EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %62

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -23
  %9 = icmp sgt i32 %1, 23
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %58, %7
  %13 = phi i32 [ 0, %7 ], [ %59, %58 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi i32 [ %35, %22 ]
  %.lcssa = phi i64 [ %36, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i32 [ 0, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %48

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %38

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %36, %22 ], [ 0, %12 ]
  %24 = phi i32 [ %35, %22 ], [ 0, %12 ]
  %25 = getelementptr inbounds i32, ptr %0, i64 %23
  %26 = load <16 x i32>, ptr %25, align 4, !tbaa !11
  %27 = add nuw nsw i64 %23, 16
  %28 = getelementptr inbounds i32, ptr %0, i64 %27
  %29 = load <8 x i32>, ptr %28, align 4, !tbaa !11
  %30 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %26)
  %31 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %29)
  %32 = add i32 %30, %31
  %33 = mul i32 %32, 269850533
  %34 = add i32 %24, -1549997760
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %23, 24
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %22, label %14, !llvm.loop !493

38:                                               ; preds = %38, %20
  %39 = phi i64 [ %21, %20 ], [ %46, %38 ]
  %40 = phi i32 [ %17, %20 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38, !llvm.loop !494

48:                                               ; preds = %38, %16
  %49 = phi i32 [ %17, %16 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %58, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  br label %58

58:                                               ; preds = %55, %48
  %59 = add nuw nsw i32 %13, 1
  %60 = load i32, ptr @iterations, align 4, !tbaa !11
  %61 = icmp slt i32 %59, %60
  br i1 %61, label %12, label %62, !llvm.loop !495

62:                                               ; preds = %58, %3
  %63 = tail call i64 @clock() #15
  store i64 %63, ptr @end_time, align 8, !tbaa !23
  %64 = load i64, ptr @start_time, align 8, !tbaa !23
  %65 = sub nsw i64 %63, %64
  %66 = sitofp i64 %65 to double
  %67 = fdiv double %66, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %67, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi25EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %66

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -24
  %9 = icmp sgt i32 %1, 24
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %62, %7
  %13 = phi i32 [ 0, %7 ], [ %63, %62 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi i32 [ %39, %22 ]
  %.lcssa = phi i64 [ %40, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i32 [ 0, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %52

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %42

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %40, %22 ], [ 0, %12 ]
  %24 = phi i32 [ %39, %22 ], [ 0, %12 ]
  %25 = getelementptr inbounds i32, ptr %0, i64 %23
  %26 = load <16 x i32>, ptr %25, align 4, !tbaa !11
  %27 = add nuw nsw i64 %23, 16
  %28 = getelementptr inbounds i32, ptr %0, i64 %27
  %29 = load <8 x i32>, ptr %28, align 4, !tbaa !11
  %30 = add nuw nsw i64 %23, 24
  %31 = getelementptr inbounds i32, ptr %0, i64 %30
  %32 = load i32, ptr %31, align 4, !tbaa !11
  %33 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %26)
  %34 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %29)
  %35 = add i32 %33, %34
  %36 = add i32 %35, %32
  %37 = mul i32 %36, 269850533
  %38 = add i32 %24, 1606644472
  %39 = add i32 %38, %37
  %40 = add nuw nsw i64 %23, 25
  %41 = icmp slt i64 %40, %10
  br i1 %41, label %22, label %14, !llvm.loop !496

42:                                               ; preds = %42, %20
  %43 = phi i64 [ %21, %20 ], [ %50, %42 ]
  %44 = phi i32 [ %17, %20 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42, !llvm.loop !497

52:                                               ; preds = %42, %16
  %53 = phi i32 [ %17, %16 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %62, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  br label %62

62:                                               ; preds = %59, %52
  %63 = add nuw nsw i32 %13, 1
  %64 = load i32, ptr @iterations, align 4, !tbaa !11
  %65 = icmp slt i32 %63, %64
  br i1 %65, label %12, label %66, !llvm.loop !498

66:                                               ; preds = %62, %3
  %67 = tail call i64 @clock() #15
  store i64 %67, ptr @end_time, align 8, !tbaa !23
  %68 = load i64, ptr @start_time, align 8, !tbaa !23
  %69 = sub nsw i64 %67, %68
  %70 = sitofp i64 %69 to double
  %71 = fdiv double %70, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %71, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi21EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi19EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi20EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 19)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi21EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 20)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi22EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %72

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -21
  %9 = icmp sgt i32 %1, 21
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %68, %7
  %13 = phi i32 [ %5, %7 ], [ %69, %68 ]
  %14 = phi i32 [ 0, %7 ], [ %70, %68 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %44, %23 ]
  %.lcssa = phi i64 [ %45, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %57

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %47

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %45, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %44, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 16
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 20
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add nuw nsw i64 %24, 21
  %35 = getelementptr inbounds i32, ptr %0, i64 %34
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %38 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %39 = add i32 %37, %38
  %40 = add i32 %39, %33
  %41 = add i32 %40, %36
  %42 = mul i32 %41, 269850533
  %43 = add i32 %25, 726652368
  %44 = add i32 %43, %42
  %45 = add nuw nsw i64 %24, 22
  %46 = icmp slt i64 %45, %10
  br i1 %46, label %23, label %15, !llvm.loop !499

47:                                               ; preds = %47, %21
  %48 = phi i64 [ %22, %21 ], [ %55, %47 ]
  %49 = phi i32 [ %18, %21 ], [ %54, %47 ]
  %50 = getelementptr inbounds i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !11
  %52 = mul i32 %51, 269850533
  %53 = add i32 %49, -1138325064
  %54 = add i32 %53, %52
  %55 = add nuw nsw i64 %48, 1
  %56 = icmp eq i64 %55, %11
  br i1 %56, label %57, label %47, !llvm.loop !500

57:                                               ; preds = %47, %17
  %58 = phi i32 [ %18, %17 ], [ %54, %47 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !17
  %60 = fptosi double %59 to i32
  %61 = mul i32 %60, -1564285888
  %62 = add i32 %61, -1269844480
  %63 = icmp eq i32 %62, %58
  br i1 %63, label %68, label %64

64:                                               ; preds = %57
  %65 = load i32, ptr @current_test, align 4, !tbaa !11
  %66 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %65) #12
  %67 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %68

68:                                               ; preds = %64, %57
  %69 = phi i32 [ %13, %57 ], [ %67, %64 ]
  %70 = add nuw nsw i32 %14, 1
  %71 = icmp slt i32 %70, %69
  br i1 %71, label %12, label %72, !llvm.loop !501

72:                                               ; preds = %68, %3
  %73 = tail call i64 @clock() #15
  store i64 %73, ptr @end_time, align 8, !tbaa !23
  %74 = load i64, ptr @start_time, align 8, !tbaa !23
  %75 = sub nsw i64 %73, %74
  %76 = sitofp i64 %75 to double
  %77 = fdiv double %76, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %77, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi23EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %76

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -22
  %9 = icmp sgt i32 %1, 22
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %72, %7
  %13 = phi i32 [ %5, %7 ], [ %73, %72 ]
  %14 = phi i32 [ 0, %7 ], [ %74, %72 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %48, %23 ]
  %.lcssa = phi i64 [ %49, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %61

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %51

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %49, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %48, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 16
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 20
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add nuw nsw i64 %24, 21
  %35 = getelementptr inbounds i32, ptr %0, i64 %34
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = add nuw nsw i64 %24, 22
  %38 = getelementptr inbounds i32, ptr %0, i64 %37
  %39 = load i32, ptr %38, align 4, !tbaa !11
  %40 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %41 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %42 = add i32 %40, %41
  %43 = add i32 %42, %33
  %44 = add i32 %36, %39
  %45 = add i32 %43, %44
  %46 = mul i32 %45, 269850533
  %47 = add i32 %25, -411672696
  %48 = add i32 %47, %46
  %49 = add nuw nsw i64 %24, 23
  %50 = icmp slt i64 %49, %10
  br i1 %50, label %23, label %15, !llvm.loop !502

51:                                               ; preds = %51, %21
  %52 = phi i64 [ %22, %21 ], [ %59, %51 ]
  %53 = phi i32 [ %18, %21 ], [ %58, %51 ]
  %54 = getelementptr inbounds i32, ptr %0, i64 %52
  %55 = load i32, ptr %54, align 4, !tbaa !11
  %56 = mul i32 %55, 269850533
  %57 = add i32 %53, -1138325064
  %58 = add i32 %57, %56
  %59 = add nuw nsw i64 %52, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %51, !llvm.loop !503

61:                                               ; preds = %51, %17
  %62 = phi i32 [ %18, %17 ], [ %58, %51 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !17
  %64 = fptosi double %63 to i32
  %65 = mul i32 %64, -1564285888
  %66 = add i32 %65, -1269844480
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %72, label %68

68:                                               ; preds = %61
  %69 = load i32, ptr @current_test, align 4, !tbaa !11
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %69) #12
  %71 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %72

72:                                               ; preds = %68, %61
  %73 = phi i32 [ %13, %61 ], [ %71, %68 ]
  %74 = add nuw nsw i32 %14, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %12, label %76, !llvm.loop !504

76:                                               ; preds = %72, %3
  %77 = tail call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi19EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi17EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi18EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 17)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi19EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 18)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi20EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %64

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -19
  %9 = icmp sgt i32 %1, 19
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %60, %7
  %13 = phi i32 [ %5, %7 ], [ %61, %60 ]
  %14 = phi i32 [ 0, %7 ], [ %62, %60 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %36, %23 ]
  %.lcssa = phi i64 [ %37, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %49

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %39

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %37, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %36, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 16
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %32 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %33 = add i32 %31, %32
  %34 = mul i32 %33, 269850533
  %35 = add i32 %25, -1291664800
  %36 = add i32 %35, %34
  %37 = add nuw nsw i64 %24, 20
  %38 = icmp slt i64 %37, %10
  br i1 %38, label %23, label %15, !llvm.loop !505

39:                                               ; preds = %39, %21
  %40 = phi i64 [ %22, %21 ], [ %47, %39 ]
  %41 = phi i32 [ %18, %21 ], [ %46, %39 ]
  %42 = getelementptr inbounds i32, ptr %0, i64 %40
  %43 = load i32, ptr %42, align 4, !tbaa !11
  %44 = mul i32 %43, 269850533
  %45 = add i32 %41, -1138325064
  %46 = add i32 %45, %44
  %47 = add nuw nsw i64 %40, 1
  %48 = icmp eq i64 %47, %11
  br i1 %48, label %49, label %39, !llvm.loop !506

49:                                               ; preds = %39, %17
  %50 = phi i32 [ %18, %17 ], [ %46, %39 ]
  %51 = load double, ptr @init_value, align 8, !tbaa !17
  %52 = fptosi double %51 to i32
  %53 = mul i32 %52, -1564285888
  %54 = add i32 %53, -1269844480
  %55 = icmp eq i32 %54, %50
  br i1 %55, label %60, label %56

56:                                               ; preds = %49
  %57 = load i32, ptr @current_test, align 4, !tbaa !11
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %57) #12
  %59 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %60

60:                                               ; preds = %56, %49
  %61 = phi i32 [ %13, %49 ], [ %59, %56 ]
  %62 = add nuw nsw i32 %14, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %12, label %64, !llvm.loop !507

64:                                               ; preds = %60, %3
  %65 = tail call i64 @clock() #15
  store i64 %65, ptr @end_time, align 8, !tbaa !23
  %66 = load i64, ptr @start_time, align 8, !tbaa !23
  %67 = sub nsw i64 %65, %66
  %68 = sitofp i64 %67 to double
  %69 = fdiv double %68, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %69, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi21EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %68

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -20
  %9 = icmp sgt i32 %1, 20
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %64, %7
  %13 = phi i32 [ %5, %7 ], [ %65, %64 ]
  %14 = phi i32 [ 0, %7 ], [ %66, %64 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %40, %23 ]
  %.lcssa = phi i64 [ %41, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %53

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %43

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %41, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %40, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 16
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 20
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %35 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %36 = add i32 %34, %35
  %37 = add i32 %36, %33
  %38 = mul i32 %37, 269850533
  %39 = add i32 %25, 1864977432
  %40 = add i32 %39, %38
  %41 = add nuw nsw i64 %24, 21
  %42 = icmp slt i64 %41, %10
  br i1 %42, label %23, label %15, !llvm.loop !508

43:                                               ; preds = %43, %21
  %44 = phi i64 [ %22, %21 ], [ %51, %43 ]
  %45 = phi i32 [ %18, %21 ], [ %50, %43 ]
  %46 = getelementptr inbounds i32, ptr %0, i64 %44
  %47 = load i32, ptr %46, align 4, !tbaa !11
  %48 = mul i32 %47, 269850533
  %49 = add i32 %45, -1138325064
  %50 = add i32 %49, %48
  %51 = add nuw nsw i64 %44, 1
  %52 = icmp eq i64 %51, %11
  br i1 %52, label %53, label %43, !llvm.loop !509

53:                                               ; preds = %43, %17
  %54 = phi i32 [ %18, %17 ], [ %50, %43 ]
  %55 = load double, ptr @init_value, align 8, !tbaa !17
  %56 = fptosi double %55 to i32
  %57 = mul i32 %56, -1564285888
  %58 = add i32 %57, -1269844480
  %59 = icmp eq i32 %58, %54
  br i1 %59, label %64, label %60

60:                                               ; preds = %53
  %61 = load i32, ptr @current_test, align 4, !tbaa !11
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %61) #12
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %64

64:                                               ; preds = %60, %53
  %65 = phi i32 [ %13, %53 ], [ %63, %60 ]
  %66 = add nuw nsw i32 %14, 1
  %67 = icmp slt i32 %66, %65
  br i1 %67, label %12, label %68, !llvm.loop !510

68:                                               ; preds = %64, %3
  %69 = tail call i64 @clock() #15
  store i64 %69, ptr @end_time, align 8, !tbaa !23
  %70 = load i64, ptr @start_time, align 8, !tbaa !23
  %71 = sub nsw i64 %69, %70
  %72 = sitofp i64 %71 to double
  %73 = fdiv double %72, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %73, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi17EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi15EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi16EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 15)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi17EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 16)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi18EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -17
  %9 = icmp sgt i32 %1, 17
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ %5, %7 ], [ %64, %63 ]
  %14 = phi i32 [ 0, %7 ], [ %65, %63 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %39, %23 ]
  %.lcssa = phi i64 [ %40, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %52

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %42

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %40, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %39, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 16
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 17
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %35 = add i32 %34, %30
  %36 = add i32 %35, %33
  %37 = mul i32 %36, 269850533
  %38 = add i32 %25, 984985328
  %39 = add i32 %38, %37
  %40 = add nuw nsw i64 %24, 18
  %41 = icmp slt i64 %40, %10
  br i1 %41, label %23, label %15, !llvm.loop !511

42:                                               ; preds = %42, %21
  %43 = phi i64 [ %22, %21 ], [ %50, %42 ]
  %44 = phi i32 [ %18, %21 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42, !llvm.loop !512

52:                                               ; preds = %42, %17
  %53 = phi i32 [ %18, %17 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %63, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  %62 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %63

63:                                               ; preds = %59, %52
  %64 = phi i32 [ %13, %52 ], [ %62, %59 ]
  %65 = add nuw nsw i32 %14, 1
  %66 = icmp slt i32 %65, %64
  br i1 %66, label %12, label %67, !llvm.loop !513

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi19EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -18
  %9 = icmp sgt i32 %1, 18
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ %5, %7 ], [ %68, %67 ]
  %14 = phi i32 [ 0, %7 ], [ %69, %67 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %43, %23 ]
  %.lcssa = phi i64 [ %44, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %56

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %46

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %44, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %43, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 16
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 17
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add nuw nsw i64 %24, 18
  %35 = getelementptr inbounds i32, ptr %0, i64 %34
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %38 = add i32 %37, %30
  %39 = add i32 %33, %36
  %40 = add i32 %38, %39
  %41 = mul i32 %40, 269850533
  %42 = add i32 %25, -153339736
  %43 = add i32 %42, %41
  %44 = add nuw nsw i64 %24, 19
  %45 = icmp slt i64 %44, %10
  br i1 %45, label %23, label %15, !llvm.loop !514

46:                                               ; preds = %46, %21
  %47 = phi i64 [ %22, %21 ], [ %54, %46 ]
  %48 = phi i32 [ %18, %21 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46, !llvm.loop !515

56:                                               ; preds = %46, %17
  %57 = phi i32 [ %18, %17 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %67, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %56
  %68 = phi i32 [ %13, %56 ], [ %66, %63 ]
  %69 = add nuw nsw i32 %14, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %12, label %71, !llvm.loop !516

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi15EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi13EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi14EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 13)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi15EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 14)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi16EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %59

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -15
  %9 = icmp sgt i32 %1, 15
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %55, %7
  %13 = phi i32 [ %5, %7 ], [ %56, %55 ]
  %14 = phi i32 [ 0, %7 ], [ %57, %55 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %31, %23 ]
  %.lcssa = phi i64 [ %32, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %44

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %34

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %32, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %31, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %29 = mul i32 %28, 269850533
  %30 = add i32 %25, -1033331840
  %31 = add i32 %30, %29
  %32 = add nuw nsw i64 %24, 16
  %33 = icmp slt i64 %32, %10
  br i1 %33, label %23, label %15, !llvm.loop !517

34:                                               ; preds = %34, %21
  %35 = phi i64 [ %22, %21 ], [ %42, %34 ]
  %36 = phi i32 [ %18, %21 ], [ %41, %34 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %35
  %38 = load i32, ptr %37, align 4, !tbaa !11
  %39 = mul i32 %38, 269850533
  %40 = add i32 %36, -1138325064
  %41 = add i32 %40, %39
  %42 = add nuw nsw i64 %35, 1
  %43 = icmp eq i64 %42, %11
  br i1 %43, label %44, label %34, !llvm.loop !518

44:                                               ; preds = %34, %17
  %45 = phi i32 [ %18, %17 ], [ %41, %34 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %55, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %44
  %56 = phi i32 [ %13, %44 ], [ %54, %51 ]
  %57 = add nuw nsw i32 %14, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %12, label %59, !llvm.loop !519

59:                                               ; preds = %55, %3
  %60 = tail call i64 @clock() #15
  store i64 %60, ptr @end_time, align 8, !tbaa !23
  %61 = load i64, ptr @start_time, align 8, !tbaa !23
  %62 = sub nsw i64 %60, %61
  %63 = sitofp i64 %62 to double
  %64 = fdiv double %63, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %64, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi17EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %63

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -16
  %9 = icmp sgt i32 %1, 16
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %59, %7
  %13 = phi i32 [ %5, %7 ], [ %60, %59 ]
  %14 = phi i32 [ 0, %7 ], [ %61, %59 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %35, %23 ]
  %.lcssa = phi i64 [ %36, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %48

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %38

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %36, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %35, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 16
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %32 = add i32 %31, %30
  %33 = mul i32 %32, 269850533
  %34 = add i32 %25, 2123310392
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %24, 17
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %23, label %15, !llvm.loop !520

38:                                               ; preds = %38, %21
  %39 = phi i64 [ %22, %21 ], [ %46, %38 ]
  %40 = phi i32 [ %18, %21 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38, !llvm.loop !521

48:                                               ; preds = %38, %17
  %49 = phi i32 [ %18, %17 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %59, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  %58 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %59

59:                                               ; preds = %55, %48
  %60 = phi i32 [ %13, %48 ], [ %58, %55 ]
  %61 = add nuw nsw i32 %14, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %12, label %63, !llvm.loop !522

63:                                               ; preds = %59, %3
  %64 = tail call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi13EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi11EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi12EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 11)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi13EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 12)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi14EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %72

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -13
  %9 = icmp sgt i32 %1, 13
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %68, %7
  %13 = phi i32 [ %5, %7 ], [ %69, %68 ]
  %14 = phi i32 [ 0, %7 ], [ %70, %68 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %44, %23 ]
  %.lcssa = phi i64 [ %45, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %57

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %47

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %45, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %44, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 8
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 12
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add nuw nsw i64 %24, 13
  %35 = getelementptr inbounds i32, ptr %0, i64 %34
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %38 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %39 = add i32 %37, %38
  %40 = add i32 %39, %33
  %41 = add i32 %40, %36
  %42 = mul i32 %41, 269850533
  %43 = add i32 %25, 1243318288
  %44 = add i32 %43, %42
  %45 = add nuw nsw i64 %24, 14
  %46 = icmp slt i64 %45, %10
  br i1 %46, label %23, label %15, !llvm.loop !523

47:                                               ; preds = %47, %21
  %48 = phi i64 [ %22, %21 ], [ %55, %47 ]
  %49 = phi i32 [ %18, %21 ], [ %54, %47 ]
  %50 = getelementptr inbounds i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !11
  %52 = mul i32 %51, 269850533
  %53 = add i32 %49, -1138325064
  %54 = add i32 %53, %52
  %55 = add nuw nsw i64 %48, 1
  %56 = icmp eq i64 %55, %11
  br i1 %56, label %57, label %47, !llvm.loop !524

57:                                               ; preds = %47, %17
  %58 = phi i32 [ %18, %17 ], [ %54, %47 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !17
  %60 = fptosi double %59 to i32
  %61 = mul i32 %60, -1564285888
  %62 = add i32 %61, -1269844480
  %63 = icmp eq i32 %62, %58
  br i1 %63, label %68, label %64

64:                                               ; preds = %57
  %65 = load i32, ptr @current_test, align 4, !tbaa !11
  %66 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %65) #12
  %67 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %68

68:                                               ; preds = %64, %57
  %69 = phi i32 [ %13, %57 ], [ %67, %64 ]
  %70 = add nuw nsw i32 %14, 1
  %71 = icmp slt i32 %70, %69
  br i1 %71, label %12, label %72, !llvm.loop !525

72:                                               ; preds = %68, %3
  %73 = tail call i64 @clock() #15
  store i64 %73, ptr @end_time, align 8, !tbaa !23
  %74 = load i64, ptr @start_time, align 8, !tbaa !23
  %75 = sub nsw i64 %73, %74
  %76 = sitofp i64 %75 to double
  %77 = fdiv double %76, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %77, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi15EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %76

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -14
  %9 = icmp sgt i32 %1, 14
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %72, %7
  %13 = phi i32 [ %5, %7 ], [ %73, %72 ]
  %14 = phi i32 [ 0, %7 ], [ %74, %72 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %48, %23 ]
  %.lcssa = phi i64 [ %49, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %61

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %51

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %49, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %48, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 8
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 12
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add nuw nsw i64 %24, 13
  %35 = getelementptr inbounds i32, ptr %0, i64 %34
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = add nuw nsw i64 %24, 14
  %38 = getelementptr inbounds i32, ptr %0, i64 %37
  %39 = load i32, ptr %38, align 4, !tbaa !11
  %40 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %41 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %42 = add i32 %40, %41
  %43 = add i32 %42, %33
  %44 = add i32 %36, %39
  %45 = add i32 %43, %44
  %46 = mul i32 %45, 269850533
  %47 = add i32 %25, 104993224
  %48 = add i32 %47, %46
  %49 = add nuw nsw i64 %24, 15
  %50 = icmp slt i64 %49, %10
  br i1 %50, label %23, label %15, !llvm.loop !526

51:                                               ; preds = %51, %21
  %52 = phi i64 [ %22, %21 ], [ %59, %51 ]
  %53 = phi i32 [ %18, %21 ], [ %58, %51 ]
  %54 = getelementptr inbounds i32, ptr %0, i64 %52
  %55 = load i32, ptr %54, align 4, !tbaa !11
  %56 = mul i32 %55, 269850533
  %57 = add i32 %53, -1138325064
  %58 = add i32 %57, %56
  %59 = add nuw nsw i64 %52, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %51, !llvm.loop !527

61:                                               ; preds = %51, %17
  %62 = phi i32 [ %18, %17 ], [ %58, %51 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !17
  %64 = fptosi double %63 to i32
  %65 = mul i32 %64, -1564285888
  %66 = add i32 %65, -1269844480
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %72, label %68

68:                                               ; preds = %61
  %69 = load i32, ptr @current_test, align 4, !tbaa !11
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %69) #12
  %71 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %72

72:                                               ; preds = %68, %61
  %73 = phi i32 [ %13, %61 ], [ %71, %68 ]
  %74 = add nuw nsw i32 %14, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %12, label %76, !llvm.loop !528

76:                                               ; preds = %72, %3
  %77 = tail call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi11EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi9EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi10EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 9)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi11EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 10)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi12EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %64

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -11
  %9 = icmp sgt i32 %1, 11
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %60, %7
  %13 = phi i32 [ %5, %7 ], [ %61, %60 ]
  %14 = phi i32 [ 0, %7 ], [ %62, %60 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %36, %23 ]
  %.lcssa = phi i64 [ %37, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %49

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %39

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %37, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %36, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 8
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %32 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %33 = add i32 %31, %32
  %34 = mul i32 %33, 269850533
  %35 = add i32 %25, -774998880
  %36 = add i32 %35, %34
  %37 = add nuw nsw i64 %24, 12
  %38 = icmp slt i64 %37, %10
  br i1 %38, label %23, label %15, !llvm.loop !529

39:                                               ; preds = %39, %21
  %40 = phi i64 [ %22, %21 ], [ %47, %39 ]
  %41 = phi i32 [ %18, %21 ], [ %46, %39 ]
  %42 = getelementptr inbounds i32, ptr %0, i64 %40
  %43 = load i32, ptr %42, align 4, !tbaa !11
  %44 = mul i32 %43, 269850533
  %45 = add i32 %41, -1138325064
  %46 = add i32 %45, %44
  %47 = add nuw nsw i64 %40, 1
  %48 = icmp eq i64 %47, %11
  br i1 %48, label %49, label %39, !llvm.loop !530

49:                                               ; preds = %39, %17
  %50 = phi i32 [ %18, %17 ], [ %46, %39 ]
  %51 = load double, ptr @init_value, align 8, !tbaa !17
  %52 = fptosi double %51 to i32
  %53 = mul i32 %52, -1564285888
  %54 = add i32 %53, -1269844480
  %55 = icmp eq i32 %54, %50
  br i1 %55, label %60, label %56

56:                                               ; preds = %49
  %57 = load i32, ptr @current_test, align 4, !tbaa !11
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %57) #12
  %59 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %60

60:                                               ; preds = %56, %49
  %61 = phi i32 [ %13, %49 ], [ %59, %56 ]
  %62 = add nuw nsw i32 %14, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %12, label %64, !llvm.loop !531

64:                                               ; preds = %60, %3
  %65 = tail call i64 @clock() #15
  store i64 %65, ptr @end_time, align 8, !tbaa !23
  %66 = load i64, ptr @start_time, align 8, !tbaa !23
  %67 = sub nsw i64 %65, %66
  %68 = sitofp i64 %67 to double
  %69 = fdiv double %68, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %69, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi13EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %68

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -12
  %9 = icmp sgt i32 %1, 12
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %64, %7
  %13 = phi i32 [ %5, %7 ], [ %65, %64 ]
  %14 = phi i32 [ 0, %7 ], [ %66, %64 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %40, %23 ]
  %.lcssa = phi i64 [ %41, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %53

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %43

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %41, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %40, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 8
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 12
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %35 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %36 = add i32 %34, %35
  %37 = add i32 %36, %33
  %38 = mul i32 %37, 269850533
  %39 = add i32 %25, -1913323944
  %40 = add i32 %39, %38
  %41 = add nuw nsw i64 %24, 13
  %42 = icmp slt i64 %41, %10
  br i1 %42, label %23, label %15, !llvm.loop !532

43:                                               ; preds = %43, %21
  %44 = phi i64 [ %22, %21 ], [ %51, %43 ]
  %45 = phi i32 [ %18, %21 ], [ %50, %43 ]
  %46 = getelementptr inbounds i32, ptr %0, i64 %44
  %47 = load i32, ptr %46, align 4, !tbaa !11
  %48 = mul i32 %47, 269850533
  %49 = add i32 %45, -1138325064
  %50 = add i32 %49, %48
  %51 = add nuw nsw i64 %44, 1
  %52 = icmp eq i64 %51, %11
  br i1 %52, label %53, label %43, !llvm.loop !533

53:                                               ; preds = %43, %17
  %54 = phi i32 [ %18, %17 ], [ %50, %43 ]
  %55 = load double, ptr @init_value, align 8, !tbaa !17
  %56 = fptosi double %55 to i32
  %57 = mul i32 %56, -1564285888
  %58 = add i32 %57, -1269844480
  %59 = icmp eq i32 %58, %54
  br i1 %59, label %64, label %60

60:                                               ; preds = %53
  %61 = load i32, ptr @current_test, align 4, !tbaa !11
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %61) #12
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %64

64:                                               ; preds = %60, %53
  %65 = phi i32 [ %13, %53 ], [ %63, %60 ]
  %66 = add nuw nsw i32 %14, 1
  %67 = icmp slt i32 %66, %65
  br i1 %67, label %12, label %68, !llvm.loop !534

68:                                               ; preds = %64, %3
  %69 = tail call i64 @clock() #15
  store i64 %69, ptr @end_time, align 8, !tbaa !23
  %70 = load i64, ptr @start_time, align 8, !tbaa !23
  %71 = sub nsw i64 %69, %70
  %72 = sitofp i64 %71 to double
  %73 = fdiv double %72, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %73, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi9EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi7EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi8EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 7)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi9EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 8)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi10EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -9
  %9 = icmp sgt i32 %1, 9
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ %5, %7 ], [ %64, %63 ]
  %14 = phi i32 [ 0, %7 ], [ %65, %63 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %39, %23 ]
  %.lcssa = phi i64 [ %40, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %52

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %42

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %40, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %39, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 8
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 9
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %35 = add i32 %34, %30
  %36 = add i32 %35, %33
  %37 = mul i32 %36, 269850533
  %38 = add i32 %25, 1501651248
  %39 = add i32 %38, %37
  %40 = add nuw nsw i64 %24, 10
  %41 = icmp slt i64 %40, %10
  br i1 %41, label %23, label %15, !llvm.loop !535

42:                                               ; preds = %42, %21
  %43 = phi i64 [ %22, %21 ], [ %50, %42 ]
  %44 = phi i32 [ %18, %21 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42, !llvm.loop !536

52:                                               ; preds = %42, %17
  %53 = phi i32 [ %18, %17 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %63, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  %62 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %63

63:                                               ; preds = %59, %52
  %64 = phi i32 [ %13, %52 ], [ %62, %59 ]
  %65 = add nuw nsw i32 %14, 1
  %66 = icmp slt i32 %65, %64
  br i1 %66, label %12, label %67, !llvm.loop !537

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi11EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -10
  %9 = icmp sgt i32 %1, 10
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ %5, %7 ], [ %68, %67 ]
  %14 = phi i32 [ 0, %7 ], [ %69, %67 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %43, %23 ]
  %.lcssa = phi i64 [ %44, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %56

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %46

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %44, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %43, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 8
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 9
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add nuw nsw i64 %24, 10
  %35 = getelementptr inbounds i32, ptr %0, i64 %34
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %38 = add i32 %37, %30
  %39 = add i32 %33, %36
  %40 = add i32 %38, %39
  %41 = mul i32 %40, 269850533
  %42 = add i32 %25, 363326184
  %43 = add i32 %42, %41
  %44 = add nuw nsw i64 %24, 11
  %45 = icmp slt i64 %44, %10
  br i1 %45, label %23, label %15, !llvm.loop !538

46:                                               ; preds = %46, %21
  %47 = phi i64 [ %22, %21 ], [ %54, %46 ]
  %48 = phi i32 [ %18, %21 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46, !llvm.loop !539

56:                                               ; preds = %46, %17
  %57 = phi i32 [ %18, %17 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %67, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %56
  %68 = phi i32 [ %13, %56 ], [ %66, %63 ]
  %69 = add nuw nsw i32 %14, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %12, label %71, !llvm.loop !540

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi7EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi5EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi6EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 5)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi7EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 6)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi8EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %59

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -7
  %9 = icmp sgt i32 %1, 7
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %55, %7
  %13 = phi i32 [ %5, %7 ], [ %56, %55 ]
  %14 = phi i32 [ 0, %7 ], [ %57, %55 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %31, %23 ]
  %.lcssa = phi i64 [ %32, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %44

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %34

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %32, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %31, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %29 = mul i32 %28, 269850533
  %30 = add i32 %25, -516665920
  %31 = add i32 %30, %29
  %32 = add nuw nsw i64 %24, 8
  %33 = icmp slt i64 %32, %10
  br i1 %33, label %23, label %15, !llvm.loop !541

34:                                               ; preds = %34, %21
  %35 = phi i64 [ %22, %21 ], [ %42, %34 ]
  %36 = phi i32 [ %18, %21 ], [ %41, %34 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %35
  %38 = load i32, ptr %37, align 4, !tbaa !11
  %39 = mul i32 %38, 269850533
  %40 = add i32 %36, -1138325064
  %41 = add i32 %40, %39
  %42 = add nuw nsw i64 %35, 1
  %43 = icmp eq i64 %42, %11
  br i1 %43, label %44, label %34, !llvm.loop !542

44:                                               ; preds = %34, %17
  %45 = phi i32 [ %18, %17 ], [ %41, %34 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %55, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %44
  %56 = phi i32 [ %13, %44 ], [ %54, %51 ]
  %57 = add nuw nsw i32 %14, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %12, label %59, !llvm.loop !543

59:                                               ; preds = %55, %3
  %60 = tail call i64 @clock() #15
  store i64 %60, ptr @end_time, align 8, !tbaa !23
  %61 = load i64, ptr @start_time, align 8, !tbaa !23
  %62 = sub nsw i64 %60, %61
  %63 = sitofp i64 %62 to double
  %64 = fdiv double %63, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %64, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi9EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %63

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -8
  %9 = icmp sgt i32 %1, 8
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %59, %7
  %13 = phi i32 [ %5, %7 ], [ %60, %59 ]
  %14 = phi i32 [ 0, %7 ], [ %61, %59 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %35, %23 ]
  %.lcssa = phi i64 [ %36, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %48

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %38

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %36, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %35, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 8
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %32 = add i32 %31, %30
  %33 = mul i32 %32, 269850533
  %34 = add i32 %25, -1654990984
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %24, 9
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %23, label %15, !llvm.loop !544

38:                                               ; preds = %38, %21
  %39 = phi i64 [ %22, %21 ], [ %46, %38 ]
  %40 = phi i32 [ %18, %21 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38, !llvm.loop !545

48:                                               ; preds = %38, %17
  %49 = phi i32 [ %18, %17 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %59, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  %58 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %59

59:                                               ; preds = %55, %48
  %60 = phi i32 [ %13, %48 ], [ %58, %55 ]
  %61 = add nuw nsw i32 %14, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %12, label %63, !llvm.loop !546

63:                                               ; preds = %59, %3
  %64 = tail call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi5EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN16while_loop_testsILi3EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z29test_while_loop_unroll_factorILi4EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 3)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi5EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 4)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi6EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -5
  %9 = icmp sgt i32 %1, 5
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ %5, %7 ], [ %64, %63 ]
  %14 = phi i32 [ 0, %7 ], [ %65, %63 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %39, %23 ]
  %.lcssa = phi i64 [ %40, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %52

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %42

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %40, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %39, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 4
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 5
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %27)
  %35 = add i32 %34, %30
  %36 = add i32 %35, %33
  %37 = mul i32 %36, 269850533
  %38 = add i32 %25, 1759984208
  %39 = add i32 %38, %37
  %40 = add nuw nsw i64 %24, 6
  %41 = icmp slt i64 %40, %10
  br i1 %41, label %23, label %15, !llvm.loop !547

42:                                               ; preds = %42, %21
  %43 = phi i64 [ %22, %21 ], [ %50, %42 ]
  %44 = phi i32 [ %18, %21 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42, !llvm.loop !548

52:                                               ; preds = %42, %17
  %53 = phi i32 [ %18, %17 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %63, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  %62 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %63

63:                                               ; preds = %59, %52
  %64 = phi i32 [ %13, %52 ], [ %62, %59 ]
  %65 = add nuw nsw i32 %14, 1
  %66 = icmp slt i32 %65, %64
  br i1 %66, label %12, label %67, !llvm.loop !549

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi7EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -6
  %9 = icmp sgt i32 %1, 6
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ %5, %7 ], [ %68, %67 ]
  %14 = phi i32 [ 0, %7 ], [ %69, %67 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %43, %23 ]
  %.lcssa = phi i64 [ %44, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %56

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %46

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %44, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %43, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 4
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 5
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add nuw nsw i64 %24, 6
  %35 = getelementptr inbounds i32, ptr %0, i64 %34
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %27)
  %38 = add i32 %37, %30
  %39 = add i32 %33, %36
  %40 = add i32 %38, %39
  %41 = mul i32 %40, 269850533
  %42 = add i32 %25, 621659144
  %43 = add i32 %42, %41
  %44 = add nuw nsw i64 %24, 7
  %45 = icmp slt i64 %44, %10
  br i1 %45, label %23, label %15, !llvm.loop !550

46:                                               ; preds = %46, %21
  %47 = phi i64 [ %22, %21 ], [ %54, %46 ]
  %48 = phi i32 [ %18, %21 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46, !llvm.loop !551

56:                                               ; preds = %46, %17
  %57 = phi i32 [ %18, %17 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %67, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %56
  %68 = phi i32 [ %13, %56 ], [ %66, %63 ]
  %69 = add nuw nsw i32 %14, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %12, label %71, !llvm.loop !552

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN16while_loop_testsILi3EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_Z29test_while_loop_unroll_factorILi1EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull @temp_string) #12
  tail call void @_Z29test_while_loop_unroll_factorILi2EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 1)) #12
  tail call void @_Z29test_while_loop_unroll_factorILi3EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 2)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi4EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %59

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -3
  %9 = icmp sgt i32 %1, 3
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %55, %7
  %13 = phi i32 [ %5, %7 ], [ %56, %55 ]
  %14 = phi i32 [ 0, %7 ], [ %57, %55 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %31, %23 ]
  %.lcssa = phi i64 [ %32, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %44

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %34

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %32, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %31, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %28 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %27)
  %29 = mul i32 %28, 269850533
  %30 = add i32 %25, -258332960
  %31 = add i32 %30, %29
  %32 = add nuw nsw i64 %24, 4
  %33 = icmp slt i64 %32, %10
  br i1 %33, label %23, label %15, !llvm.loop !553

34:                                               ; preds = %34, %21
  %35 = phi i64 [ %22, %21 ], [ %42, %34 ]
  %36 = phi i32 [ %18, %21 ], [ %41, %34 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %35
  %38 = load i32, ptr %37, align 4, !tbaa !11
  %39 = mul i32 %38, 269850533
  %40 = add i32 %36, -1138325064
  %41 = add i32 %40, %39
  %42 = add nuw nsw i64 %35, 1
  %43 = icmp eq i64 %42, %11
  br i1 %43, label %44, label %34, !llvm.loop !554

44:                                               ; preds = %34, %17
  %45 = phi i32 [ %18, %17 ], [ %41, %34 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %55, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %44
  %56 = phi i32 [ %13, %44 ], [ %54, %51 ]
  %57 = add nuw nsw i32 %14, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %12, label %59, !llvm.loop !555

59:                                               ; preds = %55, %3
  %60 = tail call i64 @clock() #15
  store i64 %60, ptr @end_time, align 8, !tbaa !23
  %61 = load i64, ptr @start_time, align 8, !tbaa !23
  %62 = sub nsw i64 %60, %61
  %63 = sitofp i64 %62 to double
  %64 = fdiv double %63, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %64, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi5EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %63

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -4
  %9 = icmp sgt i32 %1, 4
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %59, %7
  %13 = phi i32 [ %5, %7 ], [ %60, %59 ]
  %14 = phi i32 [ 0, %7 ], [ %61, %59 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %35, %23 ]
  %.lcssa = phi i64 [ %36, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %48

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %38

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %36, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %35, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 4
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %27)
  %32 = add i32 %31, %30
  %33 = mul i32 %32, 269850533
  %34 = add i32 %25, -1396658024
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %24, 5
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %23, label %15, !llvm.loop !556

38:                                               ; preds = %38, %21
  %39 = phi i64 [ %22, %21 ], [ %46, %38 ]
  %40 = phi i32 [ %18, %21 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38, !llvm.loop !557

48:                                               ; preds = %38, %17
  %49 = phi i32 [ %18, %17 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %59, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  %58 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %59

59:                                               ; preds = %55, %48
  %60 = phi i32 [ %13, %48 ], [ %58, %55 ]
  %61 = add nuw nsw i32 %14, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %12, label %63, !llvm.loop !558

63:                                               ; preds = %59, %3
  %64 = tail call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi1EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %38

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 0
  %9 = zext i32 %1 to i64
  br label %10

10:                                               ; preds = %34, %7
  %11 = phi i32 [ %5, %7 ], [ %35, %34 ]
  %12 = phi i32 [ 0, %7 ], [ %36, %34 ]
  br i1 %8, label %13, label %23

13:                                               ; preds = %13, %10
  %14 = phi i64 [ %21, %13 ], [ 0, %10 ]
  %15 = phi i32 [ %20, %13 ], [ 0, %10 ]
  %16 = getelementptr inbounds i32, ptr %0, i64 %14
  %17 = load i32, ptr %16, align 4, !tbaa !11
  %18 = mul i32 %17, 269850533
  %19 = add i32 %15, -1138325064
  %20 = add i32 %19, %18
  %21 = add nuw nsw i64 %14, 1
  %22 = icmp eq i64 %21, %9
  br i1 %22, label %23, label %13, !llvm.loop !559

23:                                               ; preds = %13, %10
  %24 = phi i32 [ 0, %10 ], [ %20, %13 ]
  %25 = load double, ptr @init_value, align 8, !tbaa !17
  %26 = fptosi double %25 to i32
  %27 = mul i32 %26, -1564285888
  %28 = add i32 %27, -1269844480
  %29 = icmp eq i32 %28, %24
  br i1 %29, label %34, label %30

30:                                               ; preds = %23
  %31 = load i32, ptr @current_test, align 4, !tbaa !11
  %32 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %31) #12
  %33 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %34

34:                                               ; preds = %30, %23
  %35 = phi i32 [ %11, %23 ], [ %33, %30 ]
  %36 = add nuw nsw i32 %12, 1
  %37 = icmp slt i32 %36, %35
  br i1 %37, label %10, label %38, !llvm.loop !560

38:                                               ; preds = %34, %3
  %39 = tail call i64 @clock() #15
  store i64 %39, ptr @end_time, align 8, !tbaa !23
  %40 = load i64, ptr @start_time, align 8, !tbaa !23
  %41 = sub nsw i64 %39, %40
  %42 = sitofp i64 %41 to double
  %43 = fdiv double %42, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %43, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi2EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %62

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -1
  %9 = icmp sgt i32 %1, 1
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %58, %7
  %13 = phi i32 [ %5, %7 ], [ %59, %58 ]
  %14 = phi i32 [ 0, %7 ], [ %60, %58 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %34, %23 ]
  %.lcssa = phi i64 [ %35, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %47

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %37

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %35, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %34, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load i32, ptr %26, align 4, !tbaa !11
  %28 = or i64 %24, 1
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add i32 %30, %27
  %32 = mul i32 %31, 269850533
  %33 = add i32 %25, 2018317168
  %34 = add i32 %33, %32
  %35 = add nuw nsw i64 %24, 2
  %36 = icmp slt i64 %35, %10
  br i1 %36, label %23, label %15, !llvm.loop !561

37:                                               ; preds = %37, %21
  %38 = phi i64 [ %22, %21 ], [ %45, %37 ]
  %39 = phi i32 [ %18, %21 ], [ %44, %37 ]
  %40 = getelementptr inbounds i32, ptr %0, i64 %38
  %41 = load i32, ptr %40, align 4, !tbaa !11
  %42 = mul i32 %41, 269850533
  %43 = add i32 %39, -1138325064
  %44 = add i32 %43, %42
  %45 = add nuw nsw i64 %38, 1
  %46 = icmp eq i64 %45, %11
  br i1 %46, label %47, label %37, !llvm.loop !562

47:                                               ; preds = %37, %17
  %48 = phi i32 [ %18, %17 ], [ %44, %37 ]
  %49 = load double, ptr @init_value, align 8, !tbaa !17
  %50 = fptosi double %49 to i32
  %51 = mul i32 %50, -1564285888
  %52 = add i32 %51, -1269844480
  %53 = icmp eq i32 %52, %48
  br i1 %53, label %58, label %54

54:                                               ; preds = %47
  %55 = load i32, ptr @current_test, align 4, !tbaa !11
  %56 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %55) #12
  %57 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %58

58:                                               ; preds = %54, %47
  %59 = phi i32 [ %13, %47 ], [ %57, %54 ]
  %60 = add nuw nsw i32 %14, 1
  %61 = icmp slt i32 %60, %59
  br i1 %61, label %12, label %62, !llvm.loop !563

62:                                               ; preds = %58, %3
  %63 = tail call i64 @clock() #15
  store i64 %63, ptr @end_time, align 8, !tbaa !23
  %64 = load i64, ptr @start_time, align 8, !tbaa !23
  %65 = sub nsw i64 %63, %64
  %66 = sitofp i64 %65 to double
  %67 = fdiv double %66, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %67, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z29test_while_loop_unroll_factorILi3EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %66

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -2
  %9 = icmp sgt i32 %1, 2
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %62, %7
  %13 = phi i32 [ %5, %7 ], [ %63, %62 ]
  %14 = phi i32 [ 0, %7 ], [ %64, %62 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %38, %23 ]
  %.lcssa = phi i64 [ %39, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %51

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %41

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %39, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %38, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load i32, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 1
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 2
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add i32 %30, %27
  %35 = add i32 %34, %33
  %36 = mul i32 %35, 269850533
  %37 = add i32 %25, 879992104
  %38 = add i32 %37, %36
  %39 = add nuw nsw i64 %24, 3
  %40 = icmp slt i64 %39, %10
  br i1 %40, label %23, label %15, !llvm.loop !564

41:                                               ; preds = %41, %21
  %42 = phi i64 [ %22, %21 ], [ %49, %41 ]
  %43 = phi i32 [ %18, %21 ], [ %48, %41 ]
  %44 = getelementptr inbounds i32, ptr %0, i64 %42
  %45 = load i32, ptr %44, align 4, !tbaa !11
  %46 = mul i32 %45, 269850533
  %47 = add i32 %43, -1138325064
  %48 = add i32 %47, %46
  %49 = add nuw nsw i64 %42, 1
  %50 = icmp eq i64 %49, %11
  br i1 %50, label %51, label %41, !llvm.loop !565

51:                                               ; preds = %41, %17
  %52 = phi i32 [ %18, %17 ], [ %48, %41 ]
  %53 = load double, ptr @init_value, align 8, !tbaa !17
  %54 = fptosi double %53 to i32
  %55 = mul i32 %54, -1564285888
  %56 = add i32 %55, -1269844480
  %57 = icmp eq i32 %56, %52
  br i1 %57, label %62, label %58

58:                                               ; preds = %51
  %59 = load i32, ptr @current_test, align 4, !tbaa !11
  %60 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %59) #12
  %61 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %62

62:                                               ; preds = %58, %51
  %63 = phi i32 [ %13, %51 ], [ %61, %58 ]
  %64 = add nuw nsw i32 %14, 1
  %65 = icmp slt i32 %64, %63
  br i1 %65, label %12, label %66, !llvm.loop !566

66:                                               ; preds = %62, %3
  %67 = tail call i64 @clock() #15
  store i64 %67, ptr @end_time, align 8, !tbaa !23
  %68 = load i64, ptr @start_time, align 8, !tbaa !23
  %69 = sub nsw i64 %67, %68
  %70 = sitofp i64 %69 to double
  %71 = fdiv double %70, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %71, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi29EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi27EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi28EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 27)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi29EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 28)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi30EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca i32, align 4
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %51

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -29
  %10 = icmp sgt i32 %1, 29
  br label %11

11:                                               ; preds = %47, %8
  %12 = phi i32 [ 0, %8 ], [ %48, %47 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #16
  store i32 0, ptr %4, align 4, !tbaa !11
  br i1 %10, label %21, label %15

13:                                               ; preds = %21
  %.lcssa = phi i32 [ %23, %21 ]
  %14 = load i32, ptr %4, align 4, !tbaa !11
  br label %15

15:                                               ; preds = %13, %11
  %16 = phi i32 [ 0, %11 ], [ %14, %13 ]
  %17 = phi i32 [ 0, %11 ], [ %.lcssa, %13 ]
  %18 = icmp slt i32 %17, %1
  br i1 %18, label %19, label %37

19:                                               ; preds = %15
  %20 = zext i32 %17 to i64
  br label %25

21:                                               ; preds = %21, %11
  %22 = phi i32 [ %23, %21 ], [ 0, %11 ]
  call void @_ZN15loop_inner_bodyILi30EiE7do_workERiPKii(ptr noundef nonnull align 4 dereferenceable(4) %4, ptr noundef %0, i32 noundef %22) #12
  %23 = add nuw nsw i32 %22, 30
  %24 = icmp slt i32 %23, %9
  br i1 %24, label %21, label %13, !llvm.loop !567

25:                                               ; preds = %25, %19
  %26 = phi i64 [ %20, %19 ], [ %33, %25 ]
  %27 = phi i32 [ %16, %19 ], [ %32, %25 ]
  %28 = getelementptr inbounds i32, ptr %0, i64 %26
  %29 = load i32, ptr %28, align 4, !tbaa !11
  %30 = mul i32 %29, 269850533
  %31 = add i32 %30, -1138325064
  %32 = add nsw i32 %31, %27
  %33 = add nuw nsw i64 %26, 1
  %34 = trunc i64 %33 to i32
  %35 = icmp eq i32 %34, %1
  br i1 %35, label %36, label %25, !llvm.loop !568

36:                                               ; preds = %25
  %.lcssa1 = phi i32 [ %32, %25 ]
  store i32 %.lcssa1, ptr %4, align 4, !tbaa !11
  br label %37

37:                                               ; preds = %36, %15
  %38 = phi i32 [ %.lcssa1, %36 ], [ %16, %15 ]
  %39 = load double, ptr @init_value, align 8, !tbaa !17
  %40 = fptosi double %39 to i32
  %41 = mul i32 %40, -1564285888
  %42 = add i32 %41, -1269844480
  %43 = icmp eq i32 %42, %38
  br i1 %43, label %47, label %44

44:                                               ; preds = %37
  %45 = load i32, ptr @current_test, align 4, !tbaa !11
  %46 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %45) #12
  br label %47

47:                                               ; preds = %44, %37
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #16
  %48 = add nuw nsw i32 %12, 1
  %49 = load i32, ptr @iterations, align 4, !tbaa !11
  %50 = icmp slt i32 %48, %49
  br i1 %50, label %11, label %51, !llvm.loop !569

51:                                               ; preds = %47, %3
  %52 = call i64 @clock() #15
  store i64 %52, ptr @end_time, align 8, !tbaa !23
  %53 = load i64, ptr @start_time, align 8, !tbaa !23
  %54 = sub nsw i64 %52, %53
  %55 = sitofp i64 %54 to double
  %56 = fdiv double %55, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %56, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi31EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = alloca i32, align 4
  %5 = tail call i64 @clock() #15
  store i64 %5, ptr @start_time, align 8, !tbaa !23
  %6 = load i32, ptr @iterations, align 4, !tbaa !11
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %58

8:                                                ; preds = %3
  %9 = add nsw i32 %1, -30
  %10 = icmp sgt i32 %1, 30
  br label %11

11:                                               ; preds = %54, %8
  %12 = phi i32 [ 0, %8 ], [ %55, %54 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #16
  store i32 0, ptr %4, align 4, !tbaa !11
  br i1 %10, label %19, label %13

13:                                               ; preds = %19, %11
  %14 = phi i32 [ 0, %11 ], [ %28, %19 ]
  %15 = phi i32 [ 0, %11 ], [ %30, %19 ]
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %17, label %44

17:                                               ; preds = %13
  %18 = zext i32 %15 to i64
  br label %32

19:                                               ; preds = %19, %11
  %20 = phi i64 [ %29, %19 ], [ 0, %11 ]
  %21 = trunc i64 %20 to i32
  call void @_ZN15loop_inner_bodyILi30EiE7do_workERiPKii(ptr noundef nonnull align 4 dereferenceable(4) %4, ptr noundef %0, i32 noundef %21) #12
  %22 = add nuw nsw i64 %20, 30
  %23 = getelementptr inbounds i32, ptr %0, i64 %22
  %24 = load i32, ptr %23, align 4, !tbaa !11
  %25 = mul i32 %24, 269850533
  %26 = add i32 %25, -1138325064
  %27 = load i32, ptr %4, align 4, !tbaa !11
  %28 = add nsw i32 %26, %27
  store i32 %28, ptr %4, align 4, !tbaa !11
  %29 = add nuw i64 %20, 31
  %30 = trunc i64 %29 to i32
  %31 = icmp sgt i32 %9, %30
  br i1 %31, label %19, label %13, !llvm.loop !570

32:                                               ; preds = %32, %17
  %33 = phi i64 [ %18, %17 ], [ %40, %32 ]
  %34 = phi i32 [ %14, %17 ], [ %39, %32 ]
  %35 = getelementptr inbounds i32, ptr %0, i64 %33
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = mul i32 %36, 269850533
  %38 = add i32 %37, -1138325064
  %39 = add nsw i32 %38, %34
  %40 = add nuw nsw i64 %33, 1
  %41 = trunc i64 %40 to i32
  %42 = icmp slt i32 %41, %1
  br i1 %42, label %32, label %43, !llvm.loop !571

43:                                               ; preds = %32
  %.lcssa = phi i32 [ %39, %32 ]
  store i32 %.lcssa, ptr %4, align 4, !tbaa !11
  br label %44

44:                                               ; preds = %43, %13
  %45 = phi i32 [ %.lcssa, %43 ], [ %14, %13 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %54, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  br label %54

54:                                               ; preds = %51, %44
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #16
  %55 = add nuw nsw i32 %12, 1
  %56 = load i32, ptr @iterations, align 4, !tbaa !11
  %57 = icmp slt i32 %55, %56
  br i1 %57, label %11, label %58, !llvm.loop !572

58:                                               ; preds = %54, %3
  %59 = call i64 @clock() #15
  store i64 %59, ptr @end_time, align 8, !tbaa !23
  %60 = load i64, ptr @start_time, align 8, !tbaa !23
  %61 = sub nsw i64 %59, %60
  %62 = sitofp i64 %61 to double
  %63 = fdiv double %62, 1.000000e+06
  call void @_Z13record_resultdPKc(double noundef %63, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi27EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi25EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi26EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 25)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi27EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 26)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi28EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -27
  %9 = icmp sgt i32 %1, 27
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ 0, %7 ], [ %64, %63 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi i32 [ %40, %22 ]
  %.lcssa = phi i64 [ %41, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i32 [ 0, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %53

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %43

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %41, %22 ], [ 0, %12 ]
  %24 = phi i32 [ %40, %22 ], [ 0, %12 ]
  %25 = getelementptr inbounds i32, ptr %0, i64 %23
  %26 = load <16 x i32>, ptr %25, align 4, !tbaa !11
  %27 = add nuw nsw i64 %23, 16
  %28 = getelementptr inbounds i32, ptr %0, i64 %27
  %29 = load <8 x i32>, ptr %28, align 4, !tbaa !11
  %30 = add nuw nsw i64 %23, 24
  %31 = getelementptr inbounds i32, ptr %0, i64 %30
  %32 = load <4 x i32>, ptr %31, align 4, !tbaa !11
  %33 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %26)
  %34 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %29)
  %35 = add i32 %33, %34
  %36 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %32)
  %37 = add i32 %35, %36
  %38 = mul i32 %37, 269850533
  %39 = add i32 %24, -1808330720
  %40 = add i32 %39, %38
  %41 = add nuw nsw i64 %23, 28
  %42 = icmp slt i64 %41, %10
  br i1 %42, label %22, label %14, !llvm.loop !573

43:                                               ; preds = %43, %20
  %44 = phi i64 [ %21, %20 ], [ %51, %43 ]
  %45 = phi i32 [ %17, %20 ], [ %50, %43 ]
  %46 = getelementptr inbounds i32, ptr %0, i64 %44
  %47 = load i32, ptr %46, align 4, !tbaa !11
  %48 = mul i32 %47, 269850533
  %49 = add i32 %45, -1138325064
  %50 = add i32 %49, %48
  %51 = add nuw nsw i64 %44, 1
  %52 = icmp eq i64 %51, %11
  br i1 %52, label %53, label %43, !llvm.loop !574

53:                                               ; preds = %43, %16
  %54 = phi i32 [ %17, %16 ], [ %50, %43 ]
  %55 = load double, ptr @init_value, align 8, !tbaa !17
  %56 = fptosi double %55 to i32
  %57 = mul i32 %56, -1564285888
  %58 = add i32 %57, -1269844480
  %59 = icmp eq i32 %58, %54
  br i1 %59, label %63, label %60

60:                                               ; preds = %53
  %61 = load i32, ptr @current_test, align 4, !tbaa !11
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %61) #12
  br label %63

63:                                               ; preds = %60, %53
  %64 = add nuw nsw i32 %13, 1
  %65 = load i32, ptr @iterations, align 4, !tbaa !11
  %66 = icmp slt i32 %64, %65
  br i1 %66, label %12, label %67, !llvm.loop !575

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi29EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -28
  %9 = icmp sgt i32 %1, 28
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ 0, %7 ], [ %68, %67 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi i32 [ %44, %22 ]
  %.lcssa = phi i64 [ %45, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i32 [ 0, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %57

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %47

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %45, %22 ], [ 0, %12 ]
  %24 = phi i32 [ %44, %22 ], [ 0, %12 ]
  %25 = getelementptr inbounds i32, ptr %0, i64 %23
  %26 = load <16 x i32>, ptr %25, align 4, !tbaa !11
  %27 = add nuw nsw i64 %23, 16
  %28 = getelementptr inbounds i32, ptr %0, i64 %27
  %29 = load <8 x i32>, ptr %28, align 4, !tbaa !11
  %30 = add nuw nsw i64 %23, 24
  %31 = getelementptr inbounds i32, ptr %0, i64 %30
  %32 = load <4 x i32>, ptr %31, align 4, !tbaa !11
  %33 = add nuw nsw i64 %23, 28
  %34 = getelementptr inbounds i32, ptr %0, i64 %33
  %35 = load i32, ptr %34, align 4, !tbaa !11
  %36 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %26)
  %37 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %29)
  %38 = add i32 %36, %37
  %39 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %32)
  %40 = add i32 %38, %39
  %41 = add i32 %40, %35
  %42 = mul i32 %41, 269850533
  %43 = add i32 %24, 1348311512
  %44 = add i32 %43, %42
  %45 = add nuw nsw i64 %23, 29
  %46 = icmp slt i64 %45, %10
  br i1 %46, label %22, label %14, !llvm.loop !576

47:                                               ; preds = %47, %20
  %48 = phi i64 [ %21, %20 ], [ %55, %47 ]
  %49 = phi i32 [ %17, %20 ], [ %54, %47 ]
  %50 = getelementptr inbounds i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !11
  %52 = mul i32 %51, 269850533
  %53 = add i32 %49, -1138325064
  %54 = add i32 %53, %52
  %55 = add nuw nsw i64 %48, 1
  %56 = icmp eq i64 %55, %11
  br i1 %56, label %57, label %47, !llvm.loop !577

57:                                               ; preds = %47, %16
  %58 = phi i32 [ %17, %16 ], [ %54, %47 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !17
  %60 = fptosi double %59 to i32
  %61 = mul i32 %60, -1564285888
  %62 = add i32 %61, -1269844480
  %63 = icmp eq i32 %62, %58
  br i1 %63, label %67, label %64

64:                                               ; preds = %57
  %65 = load i32, ptr @current_test, align 4, !tbaa !11
  %66 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %65) #12
  br label %67

67:                                               ; preds = %64, %57
  %68 = add nuw nsw i32 %13, 1
  %69 = load i32, ptr @iterations, align 4, !tbaa !11
  %70 = icmp slt i32 %68, %69
  br i1 %70, label %12, label %71, !llvm.loop !578

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi25EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi23EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi24EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 23)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi25EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 24)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi26EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %70

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -25
  %9 = icmp sgt i32 %1, 25
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %66, %7
  %13 = phi i32 [ 0, %7 ], [ %67, %66 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi i32 [ %43, %22 ]
  %.lcssa = phi i64 [ %44, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i32 [ 0, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %56

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %46

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %44, %22 ], [ 0, %12 ]
  %24 = phi i32 [ %43, %22 ], [ 0, %12 ]
  %25 = getelementptr inbounds i32, ptr %0, i64 %23
  %26 = load <16 x i32>, ptr %25, align 4, !tbaa !11
  %27 = add nuw nsw i64 %23, 16
  %28 = getelementptr inbounds i32, ptr %0, i64 %27
  %29 = load <8 x i32>, ptr %28, align 4, !tbaa !11
  %30 = add nuw nsw i64 %23, 24
  %31 = getelementptr inbounds i32, ptr %0, i64 %30
  %32 = load i32, ptr %31, align 4, !tbaa !11
  %33 = add nuw nsw i64 %23, 25
  %34 = getelementptr inbounds i32, ptr %0, i64 %33
  %35 = load i32, ptr %34, align 4, !tbaa !11
  %36 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %26)
  %37 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %29)
  %38 = add i32 %36, %37
  %39 = add i32 %38, %32
  %40 = add i32 %39, %35
  %41 = mul i32 %40, 269850533
  %42 = add i32 %24, 468319408
  %43 = add i32 %42, %41
  %44 = add nuw nsw i64 %23, 26
  %45 = icmp slt i64 %44, %10
  br i1 %45, label %22, label %14, !llvm.loop !579

46:                                               ; preds = %46, %20
  %47 = phi i64 [ %21, %20 ], [ %54, %46 ]
  %48 = phi i32 [ %17, %20 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46, !llvm.loop !580

56:                                               ; preds = %46, %16
  %57 = phi i32 [ %17, %16 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %66, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  br label %66

66:                                               ; preds = %63, %56
  %67 = add nuw nsw i32 %13, 1
  %68 = load i32, ptr @iterations, align 4, !tbaa !11
  %69 = icmp slt i32 %67, %68
  br i1 %69, label %12, label %70, !llvm.loop !581

70:                                               ; preds = %66, %3
  %71 = tail call i64 @clock() #15
  store i64 %71, ptr @end_time, align 8, !tbaa !23
  %72 = load i64, ptr @start_time, align 8, !tbaa !23
  %73 = sub nsw i64 %71, %72
  %74 = sitofp i64 %73 to double
  %75 = fdiv double %74, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %75, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi27EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %74

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -26
  %9 = icmp sgt i32 %1, 26
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %70, %7
  %13 = phi i32 [ 0, %7 ], [ %71, %70 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi i32 [ %47, %22 ]
  %.lcssa = phi i64 [ %48, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i32 [ 0, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %60

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %50

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %48, %22 ], [ 0, %12 ]
  %24 = phi i32 [ %47, %22 ], [ 0, %12 ]
  %25 = getelementptr inbounds i32, ptr %0, i64 %23
  %26 = load <16 x i32>, ptr %25, align 4, !tbaa !11
  %27 = add nuw nsw i64 %23, 16
  %28 = getelementptr inbounds i32, ptr %0, i64 %27
  %29 = load <8 x i32>, ptr %28, align 4, !tbaa !11
  %30 = add nuw nsw i64 %23, 24
  %31 = getelementptr inbounds i32, ptr %0, i64 %30
  %32 = load i32, ptr %31, align 4, !tbaa !11
  %33 = add nuw nsw i64 %23, 25
  %34 = getelementptr inbounds i32, ptr %0, i64 %33
  %35 = load i32, ptr %34, align 4, !tbaa !11
  %36 = add nuw nsw i64 %23, 26
  %37 = getelementptr inbounds i32, ptr %0, i64 %36
  %38 = load i32, ptr %37, align 4, !tbaa !11
  %39 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %26)
  %40 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %29)
  %41 = add i32 %39, %40
  %42 = add i32 %41, %32
  %43 = add i32 %35, %38
  %44 = add i32 %42, %43
  %45 = mul i32 %44, 269850533
  %46 = add i32 %24, -670005656
  %47 = add i32 %46, %45
  %48 = add nuw nsw i64 %23, 27
  %49 = icmp slt i64 %48, %10
  br i1 %49, label %22, label %14, !llvm.loop !582

50:                                               ; preds = %50, %20
  %51 = phi i64 [ %21, %20 ], [ %58, %50 ]
  %52 = phi i32 [ %17, %20 ], [ %57, %50 ]
  %53 = getelementptr inbounds i32, ptr %0, i64 %51
  %54 = load i32, ptr %53, align 4, !tbaa !11
  %55 = mul i32 %54, 269850533
  %56 = add i32 %52, -1138325064
  %57 = add i32 %56, %55
  %58 = add nuw nsw i64 %51, 1
  %59 = icmp eq i64 %58, %11
  br i1 %59, label %60, label %50, !llvm.loop !583

60:                                               ; preds = %50, %16
  %61 = phi i32 [ %17, %16 ], [ %57, %50 ]
  %62 = load double, ptr @init_value, align 8, !tbaa !17
  %63 = fptosi double %62 to i32
  %64 = mul i32 %63, -1564285888
  %65 = add i32 %64, -1269844480
  %66 = icmp eq i32 %65, %61
  br i1 %66, label %70, label %67

67:                                               ; preds = %60
  %68 = load i32, ptr @current_test, align 4, !tbaa !11
  %69 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %68) #12
  br label %70

70:                                               ; preds = %67, %60
  %71 = add nuw nsw i32 %13, 1
  %72 = load i32, ptr @iterations, align 4, !tbaa !11
  %73 = icmp slt i32 %71, %72
  br i1 %73, label %12, label %74, !llvm.loop !584

74:                                               ; preds = %70, %3
  %75 = tail call i64 @clock() #15
  store i64 %75, ptr @end_time, align 8, !tbaa !23
  %76 = load i64, ptr @start_time, align 8, !tbaa !23
  %77 = sub nsw i64 %75, %76
  %78 = sitofp i64 %77 to double
  %79 = fdiv double %78, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %79, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi23EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi21EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi22EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 21)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi23EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 22)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi24EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %62

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -23
  %9 = icmp sgt i32 %1, 23
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %58, %7
  %13 = phi i32 [ 0, %7 ], [ %59, %58 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi i32 [ %35, %22 ]
  %.lcssa = phi i64 [ %36, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i32 [ 0, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %48

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %38

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %36, %22 ], [ 0, %12 ]
  %24 = phi i32 [ %35, %22 ], [ 0, %12 ]
  %25 = getelementptr inbounds i32, ptr %0, i64 %23
  %26 = load <16 x i32>, ptr %25, align 4, !tbaa !11
  %27 = add nuw nsw i64 %23, 16
  %28 = getelementptr inbounds i32, ptr %0, i64 %27
  %29 = load <8 x i32>, ptr %28, align 4, !tbaa !11
  %30 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %26)
  %31 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %29)
  %32 = add i32 %30, %31
  %33 = mul i32 %32, 269850533
  %34 = add i32 %24, -1549997760
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %23, 24
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %22, label %14, !llvm.loop !585

38:                                               ; preds = %38, %20
  %39 = phi i64 [ %21, %20 ], [ %46, %38 ]
  %40 = phi i32 [ %17, %20 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38, !llvm.loop !586

48:                                               ; preds = %38, %16
  %49 = phi i32 [ %17, %16 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %58, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  br label %58

58:                                               ; preds = %55, %48
  %59 = add nuw nsw i32 %13, 1
  %60 = load i32, ptr @iterations, align 4, !tbaa !11
  %61 = icmp slt i32 %59, %60
  br i1 %61, label %12, label %62, !llvm.loop !587

62:                                               ; preds = %58, %3
  %63 = tail call i64 @clock() #15
  store i64 %63, ptr @end_time, align 8, !tbaa !23
  %64 = load i64, ptr @start_time, align 8, !tbaa !23
  %65 = sub nsw i64 %63, %64
  %66 = sitofp i64 %65 to double
  %67 = fdiv double %66, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %67, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi25EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %66

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -24
  %9 = icmp sgt i32 %1, 24
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %62, %7
  %13 = phi i32 [ 0, %7 ], [ %63, %62 ]
  br i1 %9, label %22, label %16

14:                                               ; preds = %22
  %.lcssa1 = phi i32 [ %39, %22 ]
  %.lcssa = phi i64 [ %40, %22 ]
  %15 = trunc i64 %.lcssa to i32
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i32 [ 0, %12 ], [ %.lcssa1, %14 ]
  %18 = phi i32 [ 0, %12 ], [ %15, %14 ]
  %19 = icmp slt i32 %18, %1
  br i1 %19, label %20, label %52

20:                                               ; preds = %16
  %21 = zext i32 %18 to i64
  br label %42

22:                                               ; preds = %22, %12
  %23 = phi i64 [ %40, %22 ], [ 0, %12 ]
  %24 = phi i32 [ %39, %22 ], [ 0, %12 ]
  %25 = getelementptr inbounds i32, ptr %0, i64 %23
  %26 = load <16 x i32>, ptr %25, align 4, !tbaa !11
  %27 = add nuw nsw i64 %23, 16
  %28 = getelementptr inbounds i32, ptr %0, i64 %27
  %29 = load <8 x i32>, ptr %28, align 4, !tbaa !11
  %30 = add nuw nsw i64 %23, 24
  %31 = getelementptr inbounds i32, ptr %0, i64 %30
  %32 = load i32, ptr %31, align 4, !tbaa !11
  %33 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %26)
  %34 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %29)
  %35 = add i32 %33, %34
  %36 = add i32 %35, %32
  %37 = mul i32 %36, 269850533
  %38 = add i32 %24, 1606644472
  %39 = add i32 %38, %37
  %40 = add nuw nsw i64 %23, 25
  %41 = icmp slt i64 %40, %10
  br i1 %41, label %22, label %14, !llvm.loop !588

42:                                               ; preds = %42, %20
  %43 = phi i64 [ %21, %20 ], [ %50, %42 ]
  %44 = phi i32 [ %17, %20 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42, !llvm.loop !589

52:                                               ; preds = %42, %16
  %53 = phi i32 [ %17, %16 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %62, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  br label %62

62:                                               ; preds = %59, %52
  %63 = add nuw nsw i32 %13, 1
  %64 = load i32, ptr @iterations, align 4, !tbaa !11
  %65 = icmp slt i32 %63, %64
  br i1 %65, label %12, label %66, !llvm.loop !590

66:                                               ; preds = %62, %3
  %67 = tail call i64 @clock() #15
  store i64 %67, ptr @end_time, align 8, !tbaa !23
  %68 = load i64, ptr @start_time, align 8, !tbaa !23
  %69 = sub nsw i64 %67, %68
  %70 = sitofp i64 %69 to double
  %71 = fdiv double %70, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %71, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi21EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi19EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi20EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 19)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi21EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 20)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi22EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %72

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -21
  %9 = icmp sgt i32 %1, 21
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %68, %7
  %13 = phi i32 [ %5, %7 ], [ %69, %68 ]
  %14 = phi i32 [ 0, %7 ], [ %70, %68 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %44, %23 ]
  %.lcssa = phi i64 [ %45, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %57

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %47

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %45, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %44, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 16
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 20
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add nuw nsw i64 %24, 21
  %35 = getelementptr inbounds i32, ptr %0, i64 %34
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %38 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %39 = add i32 %37, %38
  %40 = add i32 %39, %33
  %41 = add i32 %40, %36
  %42 = mul i32 %41, 269850533
  %43 = add i32 %25, 726652368
  %44 = add i32 %43, %42
  %45 = add nuw nsw i64 %24, 22
  %46 = icmp slt i64 %45, %10
  br i1 %46, label %23, label %15, !llvm.loop !591

47:                                               ; preds = %47, %21
  %48 = phi i64 [ %22, %21 ], [ %55, %47 ]
  %49 = phi i32 [ %18, %21 ], [ %54, %47 ]
  %50 = getelementptr inbounds i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !11
  %52 = mul i32 %51, 269850533
  %53 = add i32 %49, -1138325064
  %54 = add i32 %53, %52
  %55 = add nuw nsw i64 %48, 1
  %56 = icmp eq i64 %55, %11
  br i1 %56, label %57, label %47, !llvm.loop !592

57:                                               ; preds = %47, %17
  %58 = phi i32 [ %18, %17 ], [ %54, %47 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !17
  %60 = fptosi double %59 to i32
  %61 = mul i32 %60, -1564285888
  %62 = add i32 %61, -1269844480
  %63 = icmp eq i32 %62, %58
  br i1 %63, label %68, label %64

64:                                               ; preds = %57
  %65 = load i32, ptr @current_test, align 4, !tbaa !11
  %66 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %65) #12
  %67 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %68

68:                                               ; preds = %64, %57
  %69 = phi i32 [ %13, %57 ], [ %67, %64 ]
  %70 = add nuw nsw i32 %14, 1
  %71 = icmp slt i32 %70, %69
  br i1 %71, label %12, label %72, !llvm.loop !593

72:                                               ; preds = %68, %3
  %73 = tail call i64 @clock() #15
  store i64 %73, ptr @end_time, align 8, !tbaa !23
  %74 = load i64, ptr @start_time, align 8, !tbaa !23
  %75 = sub nsw i64 %73, %74
  %76 = sitofp i64 %75 to double
  %77 = fdiv double %76, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %77, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi23EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %76

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -22
  %9 = icmp sgt i32 %1, 22
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %72, %7
  %13 = phi i32 [ %5, %7 ], [ %73, %72 ]
  %14 = phi i32 [ 0, %7 ], [ %74, %72 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %48, %23 ]
  %.lcssa = phi i64 [ %49, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %61

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %51

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %49, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %48, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 16
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 20
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add nuw nsw i64 %24, 21
  %35 = getelementptr inbounds i32, ptr %0, i64 %34
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = add nuw nsw i64 %24, 22
  %38 = getelementptr inbounds i32, ptr %0, i64 %37
  %39 = load i32, ptr %38, align 4, !tbaa !11
  %40 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %41 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %42 = add i32 %40, %41
  %43 = add i32 %42, %33
  %44 = add i32 %36, %39
  %45 = add i32 %43, %44
  %46 = mul i32 %45, 269850533
  %47 = add i32 %25, -411672696
  %48 = add i32 %47, %46
  %49 = add nuw nsw i64 %24, 23
  %50 = icmp slt i64 %49, %10
  br i1 %50, label %23, label %15, !llvm.loop !594

51:                                               ; preds = %51, %21
  %52 = phi i64 [ %22, %21 ], [ %59, %51 ]
  %53 = phi i32 [ %18, %21 ], [ %58, %51 ]
  %54 = getelementptr inbounds i32, ptr %0, i64 %52
  %55 = load i32, ptr %54, align 4, !tbaa !11
  %56 = mul i32 %55, 269850533
  %57 = add i32 %53, -1138325064
  %58 = add i32 %57, %56
  %59 = add nuw nsw i64 %52, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %51, !llvm.loop !595

61:                                               ; preds = %51, %17
  %62 = phi i32 [ %18, %17 ], [ %58, %51 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !17
  %64 = fptosi double %63 to i32
  %65 = mul i32 %64, -1564285888
  %66 = add i32 %65, -1269844480
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %72, label %68

68:                                               ; preds = %61
  %69 = load i32, ptr @current_test, align 4, !tbaa !11
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %69) #12
  %71 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %72

72:                                               ; preds = %68, %61
  %73 = phi i32 [ %13, %61 ], [ %71, %68 ]
  %74 = add nuw nsw i32 %14, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %12, label %76, !llvm.loop !596

76:                                               ; preds = %72, %3
  %77 = tail call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi19EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi17EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi18EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 17)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi19EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 18)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi20EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %64

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -19
  %9 = icmp sgt i32 %1, 19
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %60, %7
  %13 = phi i32 [ %5, %7 ], [ %61, %60 ]
  %14 = phi i32 [ 0, %7 ], [ %62, %60 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %36, %23 ]
  %.lcssa = phi i64 [ %37, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %49

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %39

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %37, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %36, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 16
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %32 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %33 = add i32 %31, %32
  %34 = mul i32 %33, 269850533
  %35 = add i32 %25, -1291664800
  %36 = add i32 %35, %34
  %37 = add nuw nsw i64 %24, 20
  %38 = icmp slt i64 %37, %10
  br i1 %38, label %23, label %15, !llvm.loop !597

39:                                               ; preds = %39, %21
  %40 = phi i64 [ %22, %21 ], [ %47, %39 ]
  %41 = phi i32 [ %18, %21 ], [ %46, %39 ]
  %42 = getelementptr inbounds i32, ptr %0, i64 %40
  %43 = load i32, ptr %42, align 4, !tbaa !11
  %44 = mul i32 %43, 269850533
  %45 = add i32 %41, -1138325064
  %46 = add i32 %45, %44
  %47 = add nuw nsw i64 %40, 1
  %48 = icmp eq i64 %47, %11
  br i1 %48, label %49, label %39, !llvm.loop !598

49:                                               ; preds = %39, %17
  %50 = phi i32 [ %18, %17 ], [ %46, %39 ]
  %51 = load double, ptr @init_value, align 8, !tbaa !17
  %52 = fptosi double %51 to i32
  %53 = mul i32 %52, -1564285888
  %54 = add i32 %53, -1269844480
  %55 = icmp eq i32 %54, %50
  br i1 %55, label %60, label %56

56:                                               ; preds = %49
  %57 = load i32, ptr @current_test, align 4, !tbaa !11
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %57) #12
  %59 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %60

60:                                               ; preds = %56, %49
  %61 = phi i32 [ %13, %49 ], [ %59, %56 ]
  %62 = add nuw nsw i32 %14, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %12, label %64, !llvm.loop !599

64:                                               ; preds = %60, %3
  %65 = tail call i64 @clock() #15
  store i64 %65, ptr @end_time, align 8, !tbaa !23
  %66 = load i64, ptr @start_time, align 8, !tbaa !23
  %67 = sub nsw i64 %65, %66
  %68 = sitofp i64 %67 to double
  %69 = fdiv double %68, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %69, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi21EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %68

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -20
  %9 = icmp sgt i32 %1, 20
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %64, %7
  %13 = phi i32 [ %5, %7 ], [ %65, %64 ]
  %14 = phi i32 [ 0, %7 ], [ %66, %64 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %40, %23 ]
  %.lcssa = phi i64 [ %41, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %53

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %43

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %41, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %40, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 16
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 20
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %35 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %36 = add i32 %34, %35
  %37 = add i32 %36, %33
  %38 = mul i32 %37, 269850533
  %39 = add i32 %25, 1864977432
  %40 = add i32 %39, %38
  %41 = add nuw nsw i64 %24, 21
  %42 = icmp slt i64 %41, %10
  br i1 %42, label %23, label %15, !llvm.loop !600

43:                                               ; preds = %43, %21
  %44 = phi i64 [ %22, %21 ], [ %51, %43 ]
  %45 = phi i32 [ %18, %21 ], [ %50, %43 ]
  %46 = getelementptr inbounds i32, ptr %0, i64 %44
  %47 = load i32, ptr %46, align 4, !tbaa !11
  %48 = mul i32 %47, 269850533
  %49 = add i32 %45, -1138325064
  %50 = add i32 %49, %48
  %51 = add nuw nsw i64 %44, 1
  %52 = icmp eq i64 %51, %11
  br i1 %52, label %53, label %43, !llvm.loop !601

53:                                               ; preds = %43, %17
  %54 = phi i32 [ %18, %17 ], [ %50, %43 ]
  %55 = load double, ptr @init_value, align 8, !tbaa !17
  %56 = fptosi double %55 to i32
  %57 = mul i32 %56, -1564285888
  %58 = add i32 %57, -1269844480
  %59 = icmp eq i32 %58, %54
  br i1 %59, label %64, label %60

60:                                               ; preds = %53
  %61 = load i32, ptr @current_test, align 4, !tbaa !11
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %61) #12
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %64

64:                                               ; preds = %60, %53
  %65 = phi i32 [ %13, %53 ], [ %63, %60 ]
  %66 = add nuw nsw i32 %14, 1
  %67 = icmp slt i32 %66, %65
  br i1 %67, label %12, label %68, !llvm.loop !602

68:                                               ; preds = %64, %3
  %69 = tail call i64 @clock() #15
  store i64 %69, ptr @end_time, align 8, !tbaa !23
  %70 = load i64, ptr @start_time, align 8, !tbaa !23
  %71 = sub nsw i64 %69, %70
  %72 = sitofp i64 %71 to double
  %73 = fdiv double %72, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %73, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi17EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi15EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi16EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 15)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi17EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 16)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi18EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -17
  %9 = icmp sgt i32 %1, 17
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ %5, %7 ], [ %64, %63 ]
  %14 = phi i32 [ 0, %7 ], [ %65, %63 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %39, %23 ]
  %.lcssa = phi i64 [ %40, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %52

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %42

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %40, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %39, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 16
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 17
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %35 = add i32 %34, %30
  %36 = add i32 %35, %33
  %37 = mul i32 %36, 269850533
  %38 = add i32 %25, 984985328
  %39 = add i32 %38, %37
  %40 = add nuw nsw i64 %24, 18
  %41 = icmp slt i64 %40, %10
  br i1 %41, label %23, label %15, !llvm.loop !603

42:                                               ; preds = %42, %21
  %43 = phi i64 [ %22, %21 ], [ %50, %42 ]
  %44 = phi i32 [ %18, %21 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42, !llvm.loop !604

52:                                               ; preds = %42, %17
  %53 = phi i32 [ %18, %17 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %63, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  %62 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %63

63:                                               ; preds = %59, %52
  %64 = phi i32 [ %13, %52 ], [ %62, %59 ]
  %65 = add nuw nsw i32 %14, 1
  %66 = icmp slt i32 %65, %64
  br i1 %66, label %12, label %67, !llvm.loop !605

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi19EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -18
  %9 = icmp sgt i32 %1, 18
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ %5, %7 ], [ %68, %67 ]
  %14 = phi i32 [ 0, %7 ], [ %69, %67 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %43, %23 ]
  %.lcssa = phi i64 [ %44, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %56

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %46

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %44, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %43, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 16
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 17
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add nuw nsw i64 %24, 18
  %35 = getelementptr inbounds i32, ptr %0, i64 %34
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %38 = add i32 %37, %30
  %39 = add i32 %33, %36
  %40 = add i32 %38, %39
  %41 = mul i32 %40, 269850533
  %42 = add i32 %25, -153339736
  %43 = add i32 %42, %41
  %44 = add nuw nsw i64 %24, 19
  %45 = icmp slt i64 %44, %10
  br i1 %45, label %23, label %15, !llvm.loop !606

46:                                               ; preds = %46, %21
  %47 = phi i64 [ %22, %21 ], [ %54, %46 ]
  %48 = phi i32 [ %18, %21 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46, !llvm.loop !607

56:                                               ; preds = %46, %17
  %57 = phi i32 [ %18, %17 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %67, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %56
  %68 = phi i32 [ %13, %56 ], [ %66, %63 ]
  %69 = add nuw nsw i32 %14, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %12, label %71, !llvm.loop !608

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi15EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi13EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi14EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 13)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi15EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 14)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi16EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %59

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -15
  %9 = icmp sgt i32 %1, 15
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %55, %7
  %13 = phi i32 [ %5, %7 ], [ %56, %55 ]
  %14 = phi i32 [ 0, %7 ], [ %57, %55 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %31, %23 ]
  %.lcssa = phi i64 [ %32, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %44

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %34

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %32, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %31, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %29 = mul i32 %28, 269850533
  %30 = add i32 %25, -1033331840
  %31 = add i32 %30, %29
  %32 = add nuw nsw i64 %24, 16
  %33 = icmp slt i64 %32, %10
  br i1 %33, label %23, label %15, !llvm.loop !609

34:                                               ; preds = %34, %21
  %35 = phi i64 [ %22, %21 ], [ %42, %34 ]
  %36 = phi i32 [ %18, %21 ], [ %41, %34 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %35
  %38 = load i32, ptr %37, align 4, !tbaa !11
  %39 = mul i32 %38, 269850533
  %40 = add i32 %36, -1138325064
  %41 = add i32 %40, %39
  %42 = add nuw nsw i64 %35, 1
  %43 = icmp eq i64 %42, %11
  br i1 %43, label %44, label %34, !llvm.loop !610

44:                                               ; preds = %34, %17
  %45 = phi i32 [ %18, %17 ], [ %41, %34 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %55, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %44
  %56 = phi i32 [ %13, %44 ], [ %54, %51 ]
  %57 = add nuw nsw i32 %14, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %12, label %59, !llvm.loop !611

59:                                               ; preds = %55, %3
  %60 = tail call i64 @clock() #15
  store i64 %60, ptr @end_time, align 8, !tbaa !23
  %61 = load i64, ptr @start_time, align 8, !tbaa !23
  %62 = sub nsw i64 %60, %61
  %63 = sitofp i64 %62 to double
  %64 = fdiv double %63, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %64, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi17EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %63

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -16
  %9 = icmp sgt i32 %1, 16
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %59, %7
  %13 = phi i32 [ %5, %7 ], [ %60, %59 ]
  %14 = phi i32 [ 0, %7 ], [ %61, %59 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %35, %23 ]
  %.lcssa = phi i64 [ %36, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %48

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %38

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %36, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %35, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <16 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 16
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = tail call i32 @llvm.vector.reduce.add.v16i32(<16 x i32> %27)
  %32 = add i32 %31, %30
  %33 = mul i32 %32, 269850533
  %34 = add i32 %25, 2123310392
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %24, 17
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %23, label %15, !llvm.loop !612

38:                                               ; preds = %38, %21
  %39 = phi i64 [ %22, %21 ], [ %46, %38 ]
  %40 = phi i32 [ %18, %21 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38, !llvm.loop !613

48:                                               ; preds = %38, %17
  %49 = phi i32 [ %18, %17 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %59, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  %58 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %59

59:                                               ; preds = %55, %48
  %60 = phi i32 [ %13, %48 ], [ %58, %55 ]
  %61 = add nuw nsw i32 %14, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %12, label %63, !llvm.loop !614

63:                                               ; preds = %59, %3
  %64 = tail call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi13EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi11EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi12EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 11)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi13EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 12)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi14EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %72

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -13
  %9 = icmp sgt i32 %1, 13
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %68, %7
  %13 = phi i32 [ %5, %7 ], [ %69, %68 ]
  %14 = phi i32 [ 0, %7 ], [ %70, %68 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %44, %23 ]
  %.lcssa = phi i64 [ %45, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %57

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %47

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %45, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %44, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 8
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 12
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add nuw nsw i64 %24, 13
  %35 = getelementptr inbounds i32, ptr %0, i64 %34
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %38 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %39 = add i32 %37, %38
  %40 = add i32 %39, %33
  %41 = add i32 %40, %36
  %42 = mul i32 %41, 269850533
  %43 = add i32 %25, 1243318288
  %44 = add i32 %43, %42
  %45 = add nuw nsw i64 %24, 14
  %46 = icmp slt i64 %45, %10
  br i1 %46, label %23, label %15, !llvm.loop !615

47:                                               ; preds = %47, %21
  %48 = phi i64 [ %22, %21 ], [ %55, %47 ]
  %49 = phi i32 [ %18, %21 ], [ %54, %47 ]
  %50 = getelementptr inbounds i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !11
  %52 = mul i32 %51, 269850533
  %53 = add i32 %49, -1138325064
  %54 = add i32 %53, %52
  %55 = add nuw nsw i64 %48, 1
  %56 = icmp eq i64 %55, %11
  br i1 %56, label %57, label %47, !llvm.loop !616

57:                                               ; preds = %47, %17
  %58 = phi i32 [ %18, %17 ], [ %54, %47 ]
  %59 = load double, ptr @init_value, align 8, !tbaa !17
  %60 = fptosi double %59 to i32
  %61 = mul i32 %60, -1564285888
  %62 = add i32 %61, -1269844480
  %63 = icmp eq i32 %62, %58
  br i1 %63, label %68, label %64

64:                                               ; preds = %57
  %65 = load i32, ptr @current_test, align 4, !tbaa !11
  %66 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %65) #12
  %67 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %68

68:                                               ; preds = %64, %57
  %69 = phi i32 [ %13, %57 ], [ %67, %64 ]
  %70 = add nuw nsw i32 %14, 1
  %71 = icmp slt i32 %70, %69
  br i1 %71, label %12, label %72, !llvm.loop !617

72:                                               ; preds = %68, %3
  %73 = tail call i64 @clock() #15
  store i64 %73, ptr @end_time, align 8, !tbaa !23
  %74 = load i64, ptr @start_time, align 8, !tbaa !23
  %75 = sub nsw i64 %73, %74
  %76 = sitofp i64 %75 to double
  %77 = fdiv double %76, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %77, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi15EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %76

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -14
  %9 = icmp sgt i32 %1, 14
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %72, %7
  %13 = phi i32 [ %5, %7 ], [ %73, %72 ]
  %14 = phi i32 [ 0, %7 ], [ %74, %72 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %48, %23 ]
  %.lcssa = phi i64 [ %49, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %61

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %51

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %49, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %48, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 8
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 12
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add nuw nsw i64 %24, 13
  %35 = getelementptr inbounds i32, ptr %0, i64 %34
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = add nuw nsw i64 %24, 14
  %38 = getelementptr inbounds i32, ptr %0, i64 %37
  %39 = load i32, ptr %38, align 4, !tbaa !11
  %40 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %41 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %42 = add i32 %40, %41
  %43 = add i32 %42, %33
  %44 = add i32 %36, %39
  %45 = add i32 %43, %44
  %46 = mul i32 %45, 269850533
  %47 = add i32 %25, 104993224
  %48 = add i32 %47, %46
  %49 = add nuw nsw i64 %24, 15
  %50 = icmp slt i64 %49, %10
  br i1 %50, label %23, label %15, !llvm.loop !618

51:                                               ; preds = %51, %21
  %52 = phi i64 [ %22, %21 ], [ %59, %51 ]
  %53 = phi i32 [ %18, %21 ], [ %58, %51 ]
  %54 = getelementptr inbounds i32, ptr %0, i64 %52
  %55 = load i32, ptr %54, align 4, !tbaa !11
  %56 = mul i32 %55, 269850533
  %57 = add i32 %53, -1138325064
  %58 = add i32 %57, %56
  %59 = add nuw nsw i64 %52, 1
  %60 = icmp eq i64 %59, %11
  br i1 %60, label %61, label %51, !llvm.loop !619

61:                                               ; preds = %51, %17
  %62 = phi i32 [ %18, %17 ], [ %58, %51 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !17
  %64 = fptosi double %63 to i32
  %65 = mul i32 %64, -1564285888
  %66 = add i32 %65, -1269844480
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %72, label %68

68:                                               ; preds = %61
  %69 = load i32, ptr @current_test, align 4, !tbaa !11
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %69) #12
  %71 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %72

72:                                               ; preds = %68, %61
  %73 = phi i32 [ %13, %61 ], [ %71, %68 ]
  %74 = add nuw nsw i32 %14, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %12, label %76, !llvm.loop !620

76:                                               ; preds = %72, %3
  %77 = tail call i64 @clock() #15
  store i64 %77, ptr @end_time, align 8, !tbaa !23
  %78 = load i64, ptr @start_time, align 8, !tbaa !23
  %79 = sub nsw i64 %77, %78
  %80 = sitofp i64 %79 to double
  %81 = fdiv double %80, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %81, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi11EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi9EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi10EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 9)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi11EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 10)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi12EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %64

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -11
  %9 = icmp sgt i32 %1, 11
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %60, %7
  %13 = phi i32 [ %5, %7 ], [ %61, %60 ]
  %14 = phi i32 [ 0, %7 ], [ %62, %60 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %36, %23 ]
  %.lcssa = phi i64 [ %37, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %49

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %39

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %37, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %36, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 8
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %32 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %33 = add i32 %31, %32
  %34 = mul i32 %33, 269850533
  %35 = add i32 %25, -774998880
  %36 = add i32 %35, %34
  %37 = add nuw nsw i64 %24, 12
  %38 = icmp slt i64 %37, %10
  br i1 %38, label %23, label %15, !llvm.loop !621

39:                                               ; preds = %39, %21
  %40 = phi i64 [ %22, %21 ], [ %47, %39 ]
  %41 = phi i32 [ %18, %21 ], [ %46, %39 ]
  %42 = getelementptr inbounds i32, ptr %0, i64 %40
  %43 = load i32, ptr %42, align 4, !tbaa !11
  %44 = mul i32 %43, 269850533
  %45 = add i32 %41, -1138325064
  %46 = add i32 %45, %44
  %47 = add nuw nsw i64 %40, 1
  %48 = icmp eq i64 %47, %11
  br i1 %48, label %49, label %39, !llvm.loop !622

49:                                               ; preds = %39, %17
  %50 = phi i32 [ %18, %17 ], [ %46, %39 ]
  %51 = load double, ptr @init_value, align 8, !tbaa !17
  %52 = fptosi double %51 to i32
  %53 = mul i32 %52, -1564285888
  %54 = add i32 %53, -1269844480
  %55 = icmp eq i32 %54, %50
  br i1 %55, label %60, label %56

56:                                               ; preds = %49
  %57 = load i32, ptr @current_test, align 4, !tbaa !11
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %57) #12
  %59 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %60

60:                                               ; preds = %56, %49
  %61 = phi i32 [ %13, %49 ], [ %59, %56 ]
  %62 = add nuw nsw i32 %14, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %12, label %64, !llvm.loop !623

64:                                               ; preds = %60, %3
  %65 = tail call i64 @clock() #15
  store i64 %65, ptr @end_time, align 8, !tbaa !23
  %66 = load i64, ptr @start_time, align 8, !tbaa !23
  %67 = sub nsw i64 %65, %66
  %68 = sitofp i64 %67 to double
  %69 = fdiv double %68, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %69, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi13EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %68

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -12
  %9 = icmp sgt i32 %1, 12
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %64, %7
  %13 = phi i32 [ %5, %7 ], [ %65, %64 ]
  %14 = phi i32 [ 0, %7 ], [ %66, %64 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %40, %23 ]
  %.lcssa = phi i64 [ %41, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %53

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %43

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %41, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %40, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 8
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 12
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %35 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %30)
  %36 = add i32 %34, %35
  %37 = add i32 %36, %33
  %38 = mul i32 %37, 269850533
  %39 = add i32 %25, -1913323944
  %40 = add i32 %39, %38
  %41 = add nuw nsw i64 %24, 13
  %42 = icmp slt i64 %41, %10
  br i1 %42, label %23, label %15, !llvm.loop !624

43:                                               ; preds = %43, %21
  %44 = phi i64 [ %22, %21 ], [ %51, %43 ]
  %45 = phi i32 [ %18, %21 ], [ %50, %43 ]
  %46 = getelementptr inbounds i32, ptr %0, i64 %44
  %47 = load i32, ptr %46, align 4, !tbaa !11
  %48 = mul i32 %47, 269850533
  %49 = add i32 %45, -1138325064
  %50 = add i32 %49, %48
  %51 = add nuw nsw i64 %44, 1
  %52 = icmp eq i64 %51, %11
  br i1 %52, label %53, label %43, !llvm.loop !625

53:                                               ; preds = %43, %17
  %54 = phi i32 [ %18, %17 ], [ %50, %43 ]
  %55 = load double, ptr @init_value, align 8, !tbaa !17
  %56 = fptosi double %55 to i32
  %57 = mul i32 %56, -1564285888
  %58 = add i32 %57, -1269844480
  %59 = icmp eq i32 %58, %54
  br i1 %59, label %64, label %60

60:                                               ; preds = %53
  %61 = load i32, ptr @current_test, align 4, !tbaa !11
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %61) #12
  %63 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %64

64:                                               ; preds = %60, %53
  %65 = phi i32 [ %13, %53 ], [ %63, %60 ]
  %66 = add nuw nsw i32 %14, 1
  %67 = icmp slt i32 %66, %65
  br i1 %67, label %12, label %68, !llvm.loop !626

68:                                               ; preds = %64, %3
  %69 = tail call i64 @clock() #15
  store i64 %69, ptr @end_time, align 8, !tbaa !23
  %70 = load i64, ptr @start_time, align 8, !tbaa !23
  %71 = sub nsw i64 %69, %70
  %72 = sitofp i64 %71 to double
  %73 = fdiv double %72, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %73, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi9EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi7EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi8EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 7)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi9EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 8)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi10EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -9
  %9 = icmp sgt i32 %1, 9
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ %5, %7 ], [ %64, %63 ]
  %14 = phi i32 [ 0, %7 ], [ %65, %63 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %39, %23 ]
  %.lcssa = phi i64 [ %40, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %52

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %42

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %40, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %39, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 8
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 9
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %35 = add i32 %34, %30
  %36 = add i32 %35, %33
  %37 = mul i32 %36, 269850533
  %38 = add i32 %25, 1501651248
  %39 = add i32 %38, %37
  %40 = add nuw nsw i64 %24, 10
  %41 = icmp slt i64 %40, %10
  br i1 %41, label %23, label %15, !llvm.loop !627

42:                                               ; preds = %42, %21
  %43 = phi i64 [ %22, %21 ], [ %50, %42 ]
  %44 = phi i32 [ %18, %21 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42, !llvm.loop !628

52:                                               ; preds = %42, %17
  %53 = phi i32 [ %18, %17 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %63, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  %62 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %63

63:                                               ; preds = %59, %52
  %64 = phi i32 [ %13, %52 ], [ %62, %59 ]
  %65 = add nuw nsw i32 %14, 1
  %66 = icmp slt i32 %65, %64
  br i1 %66, label %12, label %67, !llvm.loop !629

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi11EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -10
  %9 = icmp sgt i32 %1, 10
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ %5, %7 ], [ %68, %67 ]
  %14 = phi i32 [ 0, %7 ], [ %69, %67 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %43, %23 ]
  %.lcssa = phi i64 [ %44, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %56

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %46

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %44, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %43, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 8
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 9
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add nuw nsw i64 %24, 10
  %35 = getelementptr inbounds i32, ptr %0, i64 %34
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %38 = add i32 %37, %30
  %39 = add i32 %33, %36
  %40 = add i32 %38, %39
  %41 = mul i32 %40, 269850533
  %42 = add i32 %25, 363326184
  %43 = add i32 %42, %41
  %44 = add nuw nsw i64 %24, 11
  %45 = icmp slt i64 %44, %10
  br i1 %45, label %23, label %15, !llvm.loop !630

46:                                               ; preds = %46, %21
  %47 = phi i64 [ %22, %21 ], [ %54, %46 ]
  %48 = phi i32 [ %18, %21 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46, !llvm.loop !631

56:                                               ; preds = %46, %17
  %57 = phi i32 [ %18, %17 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %67, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %56
  %68 = phi i32 [ %13, %56 ], [ %66, %63 ]
  %69 = add nuw nsw i32 %14, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %12, label %71, !llvm.loop !632

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi7EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi5EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi6EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 5)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi7EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 6)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi8EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %59

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -7
  %9 = icmp sgt i32 %1, 7
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %55, %7
  %13 = phi i32 [ %5, %7 ], [ %56, %55 ]
  %14 = phi i32 [ 0, %7 ], [ %57, %55 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %31, %23 ]
  %.lcssa = phi i64 [ %32, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %44

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %34

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %32, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %31, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %29 = mul i32 %28, 269850533
  %30 = add i32 %25, -516665920
  %31 = add i32 %30, %29
  %32 = add nuw nsw i64 %24, 8
  %33 = icmp slt i64 %32, %10
  br i1 %33, label %23, label %15, !llvm.loop !633

34:                                               ; preds = %34, %21
  %35 = phi i64 [ %22, %21 ], [ %42, %34 ]
  %36 = phi i32 [ %18, %21 ], [ %41, %34 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %35
  %38 = load i32, ptr %37, align 4, !tbaa !11
  %39 = mul i32 %38, 269850533
  %40 = add i32 %36, -1138325064
  %41 = add i32 %40, %39
  %42 = add nuw nsw i64 %35, 1
  %43 = icmp eq i64 %42, %11
  br i1 %43, label %44, label %34, !llvm.loop !634

44:                                               ; preds = %34, %17
  %45 = phi i32 [ %18, %17 ], [ %41, %34 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %55, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %44
  %56 = phi i32 [ %13, %44 ], [ %54, %51 ]
  %57 = add nuw nsw i32 %14, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %12, label %59, !llvm.loop !635

59:                                               ; preds = %55, %3
  %60 = tail call i64 @clock() #15
  store i64 %60, ptr @end_time, align 8, !tbaa !23
  %61 = load i64, ptr @start_time, align 8, !tbaa !23
  %62 = sub nsw i64 %60, %61
  %63 = sitofp i64 %62 to double
  %64 = fdiv double %63, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %64, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi9EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %63

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -8
  %9 = icmp sgt i32 %1, 8
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %59, %7
  %13 = phi i32 [ %5, %7 ], [ %60, %59 ]
  %14 = phi i32 [ 0, %7 ], [ %61, %59 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %35, %23 ]
  %.lcssa = phi i64 [ %36, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %48

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %38

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %36, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %35, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <8 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 8
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %27)
  %32 = add i32 %31, %30
  %33 = mul i32 %32, 269850533
  %34 = add i32 %25, -1654990984
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %24, 9
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %23, label %15, !llvm.loop !636

38:                                               ; preds = %38, %21
  %39 = phi i64 [ %22, %21 ], [ %46, %38 ]
  %40 = phi i32 [ %18, %21 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38, !llvm.loop !637

48:                                               ; preds = %38, %17
  %49 = phi i32 [ %18, %17 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %59, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  %58 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %59

59:                                               ; preds = %55, %48
  %60 = phi i32 [ %13, %48 ], [ %58, %55 ]
  %61 = add nuw nsw i32 %14, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %12, label %63, !llvm.loop !638

63:                                               ; preds = %59, %3
  %64 = tail call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi5EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_ZN14for_loop_testsILi3EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #12
  tail call void @_Z27test_for_loop_unroll_factorILi4EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 3)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi5EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 4)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi6EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %67

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -5
  %9 = icmp sgt i32 %1, 5
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %63, %7
  %13 = phi i32 [ %5, %7 ], [ %64, %63 ]
  %14 = phi i32 [ 0, %7 ], [ %65, %63 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %39, %23 ]
  %.lcssa = phi i64 [ %40, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %52

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %42

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %40, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %39, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 4
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 5
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %27)
  %35 = add i32 %34, %30
  %36 = add i32 %35, %33
  %37 = mul i32 %36, 269850533
  %38 = add i32 %25, 1759984208
  %39 = add i32 %38, %37
  %40 = add nuw nsw i64 %24, 6
  %41 = icmp slt i64 %40, %10
  br i1 %41, label %23, label %15, !llvm.loop !639

42:                                               ; preds = %42, %21
  %43 = phi i64 [ %22, %21 ], [ %50, %42 ]
  %44 = phi i32 [ %18, %21 ], [ %49, %42 ]
  %45 = getelementptr inbounds i32, ptr %0, i64 %43
  %46 = load i32, ptr %45, align 4, !tbaa !11
  %47 = mul i32 %46, 269850533
  %48 = add i32 %44, -1138325064
  %49 = add i32 %48, %47
  %50 = add nuw nsw i64 %43, 1
  %51 = icmp eq i64 %50, %11
  br i1 %51, label %52, label %42, !llvm.loop !640

52:                                               ; preds = %42, %17
  %53 = phi i32 [ %18, %17 ], [ %49, %42 ]
  %54 = load double, ptr @init_value, align 8, !tbaa !17
  %55 = fptosi double %54 to i32
  %56 = mul i32 %55, -1564285888
  %57 = add i32 %56, -1269844480
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %63, label %59

59:                                               ; preds = %52
  %60 = load i32, ptr @current_test, align 4, !tbaa !11
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %60) #12
  %62 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %63

63:                                               ; preds = %59, %52
  %64 = phi i32 [ %13, %52 ], [ %62, %59 ]
  %65 = add nuw nsw i32 %14, 1
  %66 = icmp slt i32 %65, %64
  br i1 %66, label %12, label %67, !llvm.loop !641

67:                                               ; preds = %63, %3
  %68 = tail call i64 @clock() #15
  store i64 %68, ptr @end_time, align 8, !tbaa !23
  %69 = load i64, ptr @start_time, align 8, !tbaa !23
  %70 = sub nsw i64 %68, %69
  %71 = sitofp i64 %70 to double
  %72 = fdiv double %71, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %72, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi7EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %71

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -6
  %9 = icmp sgt i32 %1, 6
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %67, %7
  %13 = phi i32 [ %5, %7 ], [ %68, %67 ]
  %14 = phi i32 [ 0, %7 ], [ %69, %67 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %43, %23 ]
  %.lcssa = phi i64 [ %44, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %56

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %46

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %44, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %43, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 4
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 5
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add nuw nsw i64 %24, 6
  %35 = getelementptr inbounds i32, ptr %0, i64 %34
  %36 = load i32, ptr %35, align 4, !tbaa !11
  %37 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %27)
  %38 = add i32 %37, %30
  %39 = add i32 %33, %36
  %40 = add i32 %38, %39
  %41 = mul i32 %40, 269850533
  %42 = add i32 %25, 621659144
  %43 = add i32 %42, %41
  %44 = add nuw nsw i64 %24, 7
  %45 = icmp slt i64 %44, %10
  br i1 %45, label %23, label %15, !llvm.loop !642

46:                                               ; preds = %46, %21
  %47 = phi i64 [ %22, %21 ], [ %54, %46 ]
  %48 = phi i32 [ %18, %21 ], [ %53, %46 ]
  %49 = getelementptr inbounds i32, ptr %0, i64 %47
  %50 = load i32, ptr %49, align 4, !tbaa !11
  %51 = mul i32 %50, 269850533
  %52 = add i32 %48, -1138325064
  %53 = add i32 %52, %51
  %54 = add nuw nsw i64 %47, 1
  %55 = icmp eq i64 %54, %11
  br i1 %55, label %56, label %46, !llvm.loop !643

56:                                               ; preds = %46, %17
  %57 = phi i32 [ %18, %17 ], [ %53, %46 ]
  %58 = load double, ptr @init_value, align 8, !tbaa !17
  %59 = fptosi double %58 to i32
  %60 = mul i32 %59, -1564285888
  %61 = add i32 %60, -1269844480
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %67, label %63

63:                                               ; preds = %56
  %64 = load i32, ptr @current_test, align 4, !tbaa !11
  %65 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %64) #12
  %66 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %67

67:                                               ; preds = %63, %56
  %68 = phi i32 [ %13, %56 ], [ %66, %63 ]
  %69 = add nuw nsw i32 %14, 1
  %70 = icmp slt i32 %69, %68
  br i1 %70, label %12, label %71, !llvm.loop !644

71:                                               ; preds = %67, %3
  %72 = tail call i64 @clock() #15
  store i64 %72, ptr @end_time, align 8, !tbaa !23
  %73 = load i64, ptr @start_time, align 8, !tbaa !23
  %74 = sub nsw i64 %72, %73
  %75 = sitofp i64 %74 to double
  %76 = fdiv double %75, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %76, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_ZN14for_loop_testsILi3EiE7do_testEPKiPKc(ptr noundef %0, ptr noundef %1) #6 comdat align 2 {
  tail call void @_Z27test_for_loop_unroll_factorILi1EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull @temp_string) #12
  tail call void @_Z27test_for_loop_unroll_factorILi2EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 1)) #12
  tail call void @_Z27test_for_loop_unroll_factorILi3EiEvPKT0_iPKc(ptr noundef %0, i32 noundef 8000, ptr noundef nonnull getelementptr inbounds ([32 x [100 x i8]], ptr @temp_string, i64 0, i64 2)) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi4EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %59

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -3
  %9 = icmp sgt i32 %1, 3
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %55, %7
  %13 = phi i32 [ %5, %7 ], [ %56, %55 ]
  %14 = phi i32 [ 0, %7 ], [ %57, %55 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %31, %23 ]
  %.lcssa = phi i64 [ %32, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %44

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %34

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %32, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %31, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %28 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %27)
  %29 = mul i32 %28, 269850533
  %30 = add i32 %25, -258332960
  %31 = add i32 %30, %29
  %32 = add nuw nsw i64 %24, 4
  %33 = icmp slt i64 %32, %10
  br i1 %33, label %23, label %15, !llvm.loop !645

34:                                               ; preds = %34, %21
  %35 = phi i64 [ %22, %21 ], [ %42, %34 ]
  %36 = phi i32 [ %18, %21 ], [ %41, %34 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %35
  %38 = load i32, ptr %37, align 4, !tbaa !11
  %39 = mul i32 %38, 269850533
  %40 = add i32 %36, -1138325064
  %41 = add i32 %40, %39
  %42 = add nuw nsw i64 %35, 1
  %43 = icmp eq i64 %42, %11
  br i1 %43, label %44, label %34, !llvm.loop !646

44:                                               ; preds = %34, %17
  %45 = phi i32 [ %18, %17 ], [ %41, %34 ]
  %46 = load double, ptr @init_value, align 8, !tbaa !17
  %47 = fptosi double %46 to i32
  %48 = mul i32 %47, -1564285888
  %49 = add i32 %48, -1269844480
  %50 = icmp eq i32 %49, %45
  br i1 %50, label %55, label %51

51:                                               ; preds = %44
  %52 = load i32, ptr @current_test, align 4, !tbaa !11
  %53 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %52) #12
  %54 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %55

55:                                               ; preds = %51, %44
  %56 = phi i32 [ %13, %44 ], [ %54, %51 ]
  %57 = add nuw nsw i32 %14, 1
  %58 = icmp slt i32 %57, %56
  br i1 %58, label %12, label %59, !llvm.loop !647

59:                                               ; preds = %55, %3
  %60 = tail call i64 @clock() #15
  store i64 %60, ptr @end_time, align 8, !tbaa !23
  %61 = load i64, ptr @start_time, align 8, !tbaa !23
  %62 = sub nsw i64 %60, %61
  %63 = sitofp i64 %62 to double
  %64 = fdiv double %63, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %64, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi5EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %63

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -4
  %9 = icmp sgt i32 %1, 4
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %59, %7
  %13 = phi i32 [ %5, %7 ], [ %60, %59 ]
  %14 = phi i32 [ 0, %7 ], [ %61, %59 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %35, %23 ]
  %.lcssa = phi i64 [ %36, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %48

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %38

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %36, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %35, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load <4 x i32>, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 4
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %27)
  %32 = add i32 %31, %30
  %33 = mul i32 %32, 269850533
  %34 = add i32 %25, -1396658024
  %35 = add i32 %34, %33
  %36 = add nuw nsw i64 %24, 5
  %37 = icmp slt i64 %36, %10
  br i1 %37, label %23, label %15, !llvm.loop !648

38:                                               ; preds = %38, %21
  %39 = phi i64 [ %22, %21 ], [ %46, %38 ]
  %40 = phi i32 [ %18, %21 ], [ %45, %38 ]
  %41 = getelementptr inbounds i32, ptr %0, i64 %39
  %42 = load i32, ptr %41, align 4, !tbaa !11
  %43 = mul i32 %42, 269850533
  %44 = add i32 %40, -1138325064
  %45 = add i32 %44, %43
  %46 = add nuw nsw i64 %39, 1
  %47 = icmp eq i64 %46, %11
  br i1 %47, label %48, label %38, !llvm.loop !649

48:                                               ; preds = %38, %17
  %49 = phi i32 [ %18, %17 ], [ %45, %38 ]
  %50 = load double, ptr @init_value, align 8, !tbaa !17
  %51 = fptosi double %50 to i32
  %52 = mul i32 %51, -1564285888
  %53 = add i32 %52, -1269844480
  %54 = icmp eq i32 %53, %49
  br i1 %54, label %59, label %55

55:                                               ; preds = %48
  %56 = load i32, ptr @current_test, align 4, !tbaa !11
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %56) #12
  %58 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %59

59:                                               ; preds = %55, %48
  %60 = phi i32 [ %13, %48 ], [ %58, %55 ]
  %61 = add nuw nsw i32 %14, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %12, label %63, !llvm.loop !650

63:                                               ; preds = %59, %3
  %64 = tail call i64 @clock() #15
  store i64 %64, ptr @end_time, align 8, !tbaa !23
  %65 = load i64, ptr @start_time, align 8, !tbaa !23
  %66 = sub nsw i64 %64, %65
  %67 = sitofp i64 %66 to double
  %68 = fdiv double %67, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %68, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi1EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %38

7:                                                ; preds = %3
  %8 = icmp sgt i32 %1, 0
  %9 = zext i32 %1 to i64
  br label %10

10:                                               ; preds = %34, %7
  %11 = phi i32 [ %5, %7 ], [ %35, %34 ]
  %12 = phi i32 [ 0, %7 ], [ %36, %34 ]
  br i1 %8, label %13, label %23

13:                                               ; preds = %13, %10
  %14 = phi i64 [ %21, %13 ], [ 0, %10 ]
  %15 = phi i32 [ %20, %13 ], [ 0, %10 ]
  %16 = getelementptr inbounds i32, ptr %0, i64 %14
  %17 = load i32, ptr %16, align 4, !tbaa !11
  %18 = mul i32 %17, 269850533
  %19 = add i32 %15, -1138325064
  %20 = add i32 %19, %18
  %21 = add nuw nsw i64 %14, 1
  %22 = icmp eq i64 %21, %9
  br i1 %22, label %23, label %13, !llvm.loop !651

23:                                               ; preds = %13, %10
  %24 = phi i32 [ 0, %10 ], [ %20, %13 ]
  %25 = load double, ptr @init_value, align 8, !tbaa !17
  %26 = fptosi double %25 to i32
  %27 = mul i32 %26, -1564285888
  %28 = add i32 %27, -1269844480
  %29 = icmp eq i32 %28, %24
  br i1 %29, label %34, label %30

30:                                               ; preds = %23
  %31 = load i32, ptr @current_test, align 4, !tbaa !11
  %32 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %31) #12
  %33 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %34

34:                                               ; preds = %30, %23
  %35 = phi i32 [ %11, %23 ], [ %33, %30 ]
  %36 = add nuw nsw i32 %12, 1
  %37 = icmp slt i32 %36, %35
  br i1 %37, label %10, label %38, !llvm.loop !652

38:                                               ; preds = %34, %3
  %39 = tail call i64 @clock() #15
  store i64 %39, ptr @end_time, align 8, !tbaa !23
  %40 = load i64, ptr @start_time, align 8, !tbaa !23
  %41 = sub nsw i64 %39, %40
  %42 = sitofp i64 %41 to double
  %43 = fdiv double %42, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %43, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi2EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %62

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -1
  %9 = icmp sgt i32 %1, 1
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %58, %7
  %13 = phi i32 [ %5, %7 ], [ %59, %58 ]
  %14 = phi i32 [ 0, %7 ], [ %60, %58 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %34, %23 ]
  %.lcssa = phi i64 [ %35, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %47

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %37

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %35, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %34, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load i32, ptr %26, align 4, !tbaa !11
  %28 = or i64 %24, 1
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add i32 %30, %27
  %32 = mul i32 %31, 269850533
  %33 = add i32 %25, 2018317168
  %34 = add i32 %33, %32
  %35 = add nuw nsw i64 %24, 2
  %36 = icmp slt i64 %35, %10
  br i1 %36, label %23, label %15, !llvm.loop !653

37:                                               ; preds = %37, %21
  %38 = phi i64 [ %22, %21 ], [ %45, %37 ]
  %39 = phi i32 [ %18, %21 ], [ %44, %37 ]
  %40 = getelementptr inbounds i32, ptr %0, i64 %38
  %41 = load i32, ptr %40, align 4, !tbaa !11
  %42 = mul i32 %41, 269850533
  %43 = add i32 %39, -1138325064
  %44 = add i32 %43, %42
  %45 = add nuw nsw i64 %38, 1
  %46 = icmp eq i64 %45, %11
  br i1 %46, label %47, label %37, !llvm.loop !654

47:                                               ; preds = %37, %17
  %48 = phi i32 [ %18, %17 ], [ %44, %37 ]
  %49 = load double, ptr @init_value, align 8, !tbaa !17
  %50 = fptosi double %49 to i32
  %51 = mul i32 %50, -1564285888
  %52 = add i32 %51, -1269844480
  %53 = icmp eq i32 %52, %48
  br i1 %53, label %58, label %54

54:                                               ; preds = %47
  %55 = load i32, ptr @current_test, align 4, !tbaa !11
  %56 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %55) #12
  %57 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %58

58:                                               ; preds = %54, %47
  %59 = phi i32 [ %13, %47 ], [ %57, %54 ]
  %60 = add nuw nsw i32 %14, 1
  %61 = icmp slt i32 %60, %59
  br i1 %61, label %12, label %62, !llvm.loop !655

62:                                               ; preds = %58, %3
  %63 = tail call i64 @clock() #15
  store i64 %63, ptr @end_time, align 8, !tbaa !23
  %64 = load i64, ptr @start_time, align 8, !tbaa !23
  %65 = sub nsw i64 %63, %64
  %66 = sitofp i64 %65 to double
  %67 = fdiv double %66, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %67, ptr noundef %2) #12
  ret void
}

; Function Attrs: mustprogress optsize uwtable
define internal void @_Z27test_for_loop_unroll_factorILi3EiEvPKT0_iPKc(ptr noundef %0, i32 noundef %1, ptr noundef %2) #6 comdat {
  %4 = tail call i64 @clock() #15
  store i64 %4, ptr @start_time, align 8, !tbaa !23
  %5 = load i32, ptr @iterations, align 4, !tbaa !11
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %66

7:                                                ; preds = %3
  %8 = add nsw i32 %1, -2
  %9 = icmp sgt i32 %1, 2
  %10 = sext i32 %8 to i64
  %11 = zext i32 %1 to i64
  br label %12

12:                                               ; preds = %62, %7
  %13 = phi i32 [ %5, %7 ], [ %63, %62 ]
  %14 = phi i32 [ 0, %7 ], [ %64, %62 ]
  br i1 %9, label %23, label %17

15:                                               ; preds = %23
  %.lcssa1 = phi i32 [ %38, %23 ]
  %.lcssa = phi i64 [ %39, %23 ]
  %16 = trunc i64 %.lcssa to i32
  br label %17

17:                                               ; preds = %15, %12
  %18 = phi i32 [ 0, %12 ], [ %.lcssa1, %15 ]
  %19 = phi i32 [ 0, %12 ], [ %16, %15 ]
  %20 = icmp slt i32 %19, %1
  br i1 %20, label %21, label %51

21:                                               ; preds = %17
  %22 = zext i32 %19 to i64
  br label %41

23:                                               ; preds = %23, %12
  %24 = phi i64 [ %39, %23 ], [ 0, %12 ]
  %25 = phi i32 [ %38, %23 ], [ 0, %12 ]
  %26 = getelementptr inbounds i32, ptr %0, i64 %24
  %27 = load i32, ptr %26, align 4, !tbaa !11
  %28 = add nuw nsw i64 %24, 1
  %29 = getelementptr inbounds i32, ptr %0, i64 %28
  %30 = load i32, ptr %29, align 4, !tbaa !11
  %31 = add nuw nsw i64 %24, 2
  %32 = getelementptr inbounds i32, ptr %0, i64 %31
  %33 = load i32, ptr %32, align 4, !tbaa !11
  %34 = add i32 %30, %27
  %35 = add i32 %34, %33
  %36 = mul i32 %35, 269850533
  %37 = add i32 %25, 879992104
  %38 = add i32 %37, %36
  %39 = add nuw nsw i64 %24, 3
  %40 = icmp slt i64 %39, %10
  br i1 %40, label %23, label %15, !llvm.loop !656

41:                                               ; preds = %41, %21
  %42 = phi i64 [ %22, %21 ], [ %49, %41 ]
  %43 = phi i32 [ %18, %21 ], [ %48, %41 ]
  %44 = getelementptr inbounds i32, ptr %0, i64 %42
  %45 = load i32, ptr %44, align 4, !tbaa !11
  %46 = mul i32 %45, 269850533
  %47 = add i32 %43, -1138325064
  %48 = add i32 %47, %46
  %49 = add nuw nsw i64 %42, 1
  %50 = icmp eq i64 %49, %11
  br i1 %50, label %51, label %41, !llvm.loop !657

51:                                               ; preds = %41, %17
  %52 = phi i32 [ %18, %17 ], [ %48, %41 ]
  %53 = load double, ptr @init_value, align 8, !tbaa !17
  %54 = fptosi double %53 to i32
  %55 = mul i32 %54, -1564285888
  %56 = add i32 %55, -1269844480
  %57 = icmp eq i32 %56, %52
  br i1 %57, label %62, label %58

58:                                               ; preds = %51
  %59 = load i32, ptr @current_test, align 4, !tbaa !11
  %60 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.19, i32 noundef %59) #12
  %61 = load i32, ptr @iterations, align 4, !tbaa !11
  br label %62

62:                                               ; preds = %58, %51
  %63 = phi i32 [ %13, %51 ], [ %61, %58 ]
  %64 = add nuw nsw i32 %14, 1
  %65 = icmp slt i32 %64, %63
  br i1 %65, label %12, label %66, !llvm.loop !658

66:                                               ; preds = %62, %3
  %67 = tail call i64 @clock() #15
  store i64 %67, ptr @end_time, align 8, !tbaa !23
  %68 = load i64, ptr @start_time, align 8, !tbaa !23
  %69 = sub nsw i64 %67, %68
  %70 = sitofp i64 %69 to double
  %71 = fdiv double %70, 1.000000e+06
  tail call void @_Z13record_resultdPKc(double noundef %71, ptr noundef %2) #12
  ret void
}

attributes #0 = { mustprogress nounwind optsize uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nounwind optsize willreturn allockind("realloc") allocsize(1) memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { nofree nounwind optsize "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { noreturn nounwind optsize "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { mustprogress norecurse optsize uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { mustprogress nofree nounwind optsize willreturn memory(read) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { mustprogress optsize uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { nounwind optsize "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #9 = { inlinehint mustprogress optsize uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #11 = { nounwind optsize allocsize(1) }
attributes #12 = { optsize }
attributes #13 = { noreturn nounwind optsize }
attributes #14 = { nounwind optsize willreturn memory(read) }
attributes #15 = { nounwind optsize }
attributes #16 = { nounwind }

!llvm.ident = !{!0}
!llvm.module.flags = !{!1, !2, !3, !4, !5, !6}

!0 = !{!"clang version 17.0.6 (https://github.com/Casperento/llvm-project.git 9b0073551ece0d22bf3378af2b03e456a26031b6)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"uwtable", i32 2}
!5 = !{i32 1, !"ThinLTO", i32 0}
!6 = !{i32 1, !"EnableSplitLTOUnit", i32 1}
!7 = !{!8, !8, i64 0}
!8 = !{!"any pointer", !9, i64 0}
!9 = !{!"omnipotent char", !10, i64 0}
!10 = !{!"Simple C++ TBAA"}
!11 = !{!12, !12, i64 0}
!12 = !{!"int", !9, i64 0}
!13 = !{!14, !15, i64 0}
!14 = !{!"_ZTS10one_result", !15, i64 0, !8, i64 8}
!15 = !{!"double", !9, i64 0}
!16 = !{!14, !8, i64 8}
!17 = !{!15, !15, i64 0}
!18 = distinct !{!18, !19, !20, !21}
!19 = !{!"llvm.loop.mustprogress"}
!20 = !{!"llvm.loop.isvectorized", i32 1}
!21 = !{!"llvm.loop.unroll.runtime.disable"}
!22 = distinct !{!22, !19, !20, !21}
!23 = !{!24, !24, i64 0}
!24 = !{!"long", !9, i64 0}
!25 = distinct !{!25, !19}
!26 = distinct !{!26, !19}
!27 = distinct !{!27, !19}
!28 = distinct !{!28, !19}
!29 = distinct !{!29, !19}
!30 = distinct !{!30, !19}
!31 = distinct !{!31, !19}
!32 = distinct !{!32, !19}
!33 = distinct !{!33, !19}
!34 = distinct !{!34, !19}
!35 = distinct !{!35, !19}
!36 = distinct !{!36, !19}
!37 = distinct !{!37, !19}
!38 = distinct !{!38, !19}
!39 = distinct !{!39, !19}
!40 = distinct !{!40, !19}
!41 = distinct !{!41, !19}
!42 = distinct !{!42, !19}
!43 = distinct !{!43, !19}
!44 = distinct !{!44, !19}
!45 = distinct !{!45, !19}
!46 = distinct !{!46, !19}
!47 = distinct !{!47, !19}
!48 = distinct !{!48, !19}
!49 = distinct !{!49, !19}
!50 = distinct !{!50, !19}
!51 = distinct !{!51, !19}
!52 = distinct !{!52, !19}
!53 = distinct !{!53, !19}
!54 = distinct !{!54, !19}
!55 = distinct !{!55, !19}
!56 = distinct !{!56, !19}
!57 = distinct !{!57, !19}
!58 = distinct !{!58, !19}
!59 = distinct !{!59, !19}
!60 = distinct !{!60, !19}
!61 = distinct !{!61, !19}
!62 = distinct !{!62, !19}
!63 = distinct !{!63, !19}
!64 = distinct !{!64, !19}
!65 = distinct !{!65, !19}
!66 = distinct !{!66, !19}
!67 = distinct !{!67, !19}
!68 = distinct !{!68, !19}
!69 = distinct !{!69, !19}
!70 = distinct !{!70, !19}
!71 = distinct !{!71, !19}
!72 = distinct !{!72, !19}
!73 = distinct !{!73, !19}
!74 = distinct !{!74, !19}
!75 = distinct !{!75, !19}
!76 = distinct !{!76, !19}
!77 = distinct !{!77, !19}
!78 = distinct !{!78, !19}
!79 = distinct !{!79, !19}
!80 = distinct !{!80, !19}
!81 = distinct !{!81, !19}
!82 = distinct !{!82, !19}
!83 = distinct !{!83, !19}
!84 = distinct !{!84, !19}
!85 = distinct !{!85, !19}
!86 = distinct !{!86, !19}
!87 = distinct !{!87, !19}
!88 = distinct !{!88, !19}
!89 = distinct !{!89, !19}
!90 = distinct !{!90, !19}
!91 = distinct !{!91, !19}
!92 = distinct !{!92, !19}
!93 = distinct !{!93, !19}
!94 = distinct !{!94, !19}
!95 = distinct !{!95, !19}
!96 = distinct !{!96, !19}
!97 = distinct !{!97, !19}
!98 = distinct !{!98, !19}
!99 = distinct !{!99, !19}
!100 = distinct !{!100, !19}
!101 = distinct !{!101, !19}
!102 = distinct !{!102, !19}
!103 = distinct !{!103, !19}
!104 = distinct !{!104, !19}
!105 = distinct !{!105, !19}
!106 = distinct !{!106, !19}
!107 = distinct !{!107, !19}
!108 = distinct !{!108, !19}
!109 = distinct !{!109, !19}
!110 = distinct !{!110, !19}
!111 = distinct !{!111, !19}
!112 = distinct !{!112, !19}
!113 = distinct !{!113, !19}
!114 = distinct !{!114, !19}
!115 = distinct !{!115, !19}
!116 = distinct !{!116, !19}
!117 = distinct !{!117, !19}
!118 = distinct !{!118, !19}
!119 = distinct !{!119, !19}
!120 = distinct !{!120, !19}
!121 = distinct !{!121, !19}
!122 = distinct !{!122, !19}
!123 = distinct !{!123, !19}
!124 = distinct !{!124, !19}
!125 = distinct !{!125, !19}
!126 = distinct !{!126, !19}
!127 = distinct !{!127, !19}
!128 = distinct !{!128, !19}
!129 = distinct !{!129, !19}
!130 = distinct !{!130, !19}
!131 = distinct !{!131, !19}
!132 = distinct !{!132, !19}
!133 = distinct !{!133, !19}
!134 = distinct !{!134, !19}
!135 = distinct !{!135, !19}
!136 = distinct !{!136, !19}
!137 = distinct !{!137, !19}
!138 = distinct !{!138, !19}
!139 = distinct !{!139, !19}
!140 = distinct !{!140, !19}
!141 = distinct !{!141, !19}
!142 = distinct !{!142, !19}
!143 = distinct !{!143, !19}
!144 = distinct !{!144, !19}
!145 = distinct !{!145, !19}
!146 = distinct !{!146, !19}
!147 = distinct !{!147, !19}
!148 = distinct !{!148, !19}
!149 = distinct !{!149, !19}
!150 = distinct !{!150, !19}
!151 = distinct !{!151, !19}
!152 = distinct !{!152, !19}
!153 = distinct !{!153, !19}
!154 = distinct !{!154, !19}
!155 = distinct !{!155, !19}
!156 = distinct !{!156, !19}
!157 = distinct !{!157, !19}
!158 = distinct !{!158, !19}
!159 = distinct !{!159, !19}
!160 = distinct !{!160, !19}
!161 = distinct !{!161, !19}
!162 = distinct !{!162, !19}
!163 = distinct !{!163, !19}
!164 = distinct !{!164, !19}
!165 = distinct !{!165, !19}
!166 = distinct !{!166, !19}
!167 = distinct !{!167, !19}
!168 = distinct !{!168, !19}
!169 = distinct !{!169, !19}
!170 = distinct !{!170, !19}
!171 = distinct !{!171, !19}
!172 = distinct !{!172, !19}
!173 = distinct !{!173, !19}
!174 = distinct !{!174, !19}
!175 = distinct !{!175, !19}
!176 = distinct !{!176, !19}
!177 = distinct !{!177, !19}
!178 = distinct !{!178, !19}
!179 = distinct !{!179, !19}
!180 = distinct !{!180, !19}
!181 = distinct !{!181, !19}
!182 = distinct !{!182, !19}
!183 = distinct !{!183, !19}
!184 = distinct !{!184, !19}
!185 = distinct !{!185, !19}
!186 = distinct !{!186, !19}
!187 = distinct !{!187, !19}
!188 = distinct !{!188, !19}
!189 = distinct !{!189, !19}
!190 = distinct !{!190, !19}
!191 = distinct !{!191, !19}
!192 = distinct !{!192, !19}
!193 = distinct !{!193, !19}
!194 = distinct !{!194, !19}
!195 = distinct !{!195, !19}
!196 = distinct !{!196, !19}
!197 = distinct !{!197, !19}
!198 = distinct !{!198, !19}
!199 = distinct !{!199, !19}
!200 = distinct !{!200, !19}
!201 = distinct !{!201, !19}
!202 = distinct !{!202, !19}
!203 = distinct !{!203, !19}
!204 = distinct !{!204, !19}
!205 = distinct !{!205, !19}
!206 = distinct !{!206, !19}
!207 = distinct !{!207, !19}
!208 = distinct !{!208, !19}
!209 = distinct !{!209, !19}
!210 = distinct !{!210, !19}
!211 = distinct !{!211, !19}
!212 = distinct !{!212, !19}
!213 = distinct !{!213, !19}
!214 = distinct !{!214, !19}
!215 = distinct !{!215, !19}
!216 = distinct !{!216, !19}
!217 = distinct !{!217, !19}
!218 = distinct !{!218, !19}
!219 = distinct !{!219, !19}
!220 = distinct !{!220, !19}
!221 = distinct !{!221, !19}
!222 = distinct !{!222, !19}
!223 = distinct !{!223, !19}
!224 = distinct !{!224, !19}
!225 = distinct !{!225, !19}
!226 = distinct !{!226, !19}
!227 = distinct !{!227, !19}
!228 = distinct !{!228, !19}
!229 = distinct !{!229, !19}
!230 = distinct !{!230, !19}
!231 = distinct !{!231, !19}
!232 = distinct !{!232, !19}
!233 = distinct !{!233, !19}
!234 = distinct !{!234, !19}
!235 = distinct !{!235, !19}
!236 = distinct !{!236, !19}
!237 = distinct !{!237, !19}
!238 = distinct !{!238, !19}
!239 = distinct !{!239, !19}
!240 = distinct !{!240, !19}
!241 = distinct !{!241, !19}
!242 = distinct !{!242, !19}
!243 = distinct !{!243, !19}
!244 = distinct !{!244, !19}
!245 = distinct !{!245, !19}
!246 = distinct !{!246, !19}
!247 = distinct !{!247, !19}
!248 = distinct !{!248, !19}
!249 = distinct !{!249, !19}
!250 = distinct !{!250, !19}
!251 = distinct !{!251, !19}
!252 = distinct !{!252, !19}
!253 = distinct !{!253, !19}
!254 = distinct !{!254, !19}
!255 = distinct !{!255, !19}
!256 = distinct !{!256, !19}
!257 = distinct !{!257, !19}
!258 = distinct !{!258, !19}
!259 = distinct !{!259, !19}
!260 = distinct !{!260, !19}
!261 = distinct !{!261, !19}
!262 = distinct !{!262, !19}
!263 = distinct !{!263, !19}
!264 = distinct !{!264, !19}
!265 = distinct !{!265, !19}
!266 = distinct !{!266, !19}
!267 = distinct !{!267, !19}
!268 = distinct !{!268, !19}
!269 = distinct !{!269, !19}
!270 = distinct !{!270, !19}
!271 = distinct !{!271, !19}
!272 = distinct !{!272, !19}
!273 = distinct !{!273, !19}
!274 = distinct !{!274, !19}
!275 = distinct !{!275, !19}
!276 = distinct !{!276, !19}
!277 = distinct !{!277, !19}
!278 = distinct !{!278, !19}
!279 = distinct !{!279, !19}
!280 = distinct !{!280, !19}
!281 = distinct !{!281, !19}
!282 = distinct !{!282, !19}
!283 = distinct !{!283, !19}
!284 = distinct !{!284, !19}
!285 = distinct !{!285, !19}
!286 = distinct !{!286, !19}
!287 = distinct !{!287, !19}
!288 = distinct !{!288, !19}
!289 = distinct !{!289, !19}
!290 = distinct !{!290, !19}
!291 = distinct !{!291, !19}
!292 = distinct !{!292, !19}
!293 = distinct !{!293, !19}
!294 = distinct !{!294, !19}
!295 = distinct !{!295, !19}
!296 = distinct !{!296, !19}
!297 = distinct !{!297, !19}
!298 = distinct !{!298, !19}
!299 = distinct !{!299, !19}
!300 = distinct !{!300, !19}
!301 = distinct !{!301, !19}
!302 = distinct !{!302, !19}
!303 = distinct !{!303, !19}
!304 = distinct !{!304, !19}
!305 = distinct !{!305, !19}
!306 = distinct !{!306, !19}
!307 = distinct !{!307, !19}
!308 = distinct !{!308, !19}
!309 = distinct !{!309, !19}
!310 = distinct !{!310, !19}
!311 = distinct !{!311, !19}
!312 = distinct !{!312, !19}
!313 = distinct !{!313, !19}
!314 = distinct !{!314, !19}
!315 = distinct !{!315, !19}
!316 = distinct !{!316, !19}
!317 = distinct !{!317, !19}
!318 = distinct !{!318, !19}
!319 = distinct !{!319, !19}
!320 = distinct !{!320, !19}
!321 = distinct !{!321, !19}
!322 = distinct !{!322, !19}
!323 = distinct !{!323, !19}
!324 = distinct !{!324, !19}
!325 = distinct !{!325, !19}
!326 = distinct !{!326, !19}
!327 = distinct !{!327, !19}
!328 = distinct !{!328, !19}
!329 = distinct !{!329, !19}
!330 = distinct !{!330, !19}
!331 = distinct !{!331, !19}
!332 = distinct !{!332, !19}
!333 = distinct !{!333, !19}
!334 = distinct !{!334, !19}
!335 = distinct !{!335, !19}
!336 = distinct !{!336, !19}
!337 = distinct !{!337, !19}
!338 = distinct !{!338, !19}
!339 = distinct !{!339, !19}
!340 = distinct !{!340, !19}
!341 = distinct !{!341, !19}
!342 = distinct !{!342, !19}
!343 = distinct !{!343, !19}
!344 = distinct !{!344, !19}
!345 = distinct !{!345, !19}
!346 = distinct !{!346, !19}
!347 = distinct !{!347, !19}
!348 = distinct !{!348, !19}
!349 = distinct !{!349, !19}
!350 = distinct !{!350, !19}
!351 = distinct !{!351, !19}
!352 = distinct !{!352, !19}
!353 = distinct !{!353, !19}
!354 = distinct !{!354, !19}
!355 = distinct !{!355, !19}
!356 = distinct !{!356, !19}
!357 = distinct !{!357, !19}
!358 = distinct !{!358, !19}
!359 = distinct !{!359, !19}
!360 = distinct !{!360, !19}
!361 = distinct !{!361, !19}
!362 = distinct !{!362, !19}
!363 = distinct !{!363, !19}
!364 = distinct !{!364, !19}
!365 = distinct !{!365, !19}
!366 = distinct !{!366, !19}
!367 = distinct !{!367, !19}
!368 = distinct !{!368, !19}
!369 = distinct !{!369, !19}
!370 = distinct !{!370, !19}
!371 = distinct !{!371, !19}
!372 = distinct !{!372, !19}
!373 = distinct !{!373, !19}
!374 = distinct !{!374, !19}
!375 = distinct !{!375, !19}
!376 = distinct !{!376, !19}
!377 = distinct !{!377, !19}
!378 = distinct !{!378, !19}
!379 = distinct !{!379, !19}
!380 = distinct !{!380, !19}
!381 = distinct !{!381, !19}
!382 = distinct !{!382, !19}
!383 = distinct !{!383, !19}
!384 = distinct !{!384, !19}
!385 = distinct !{!385, !19}
!386 = distinct !{!386, !19}
!387 = distinct !{!387, !19}
!388 = distinct !{!388, !19}
!389 = distinct !{!389, !19}
!390 = distinct !{!390, !19}
!391 = distinct !{!391, !19}
!392 = distinct !{!392, !19}
!393 = distinct !{!393, !19}
!394 = distinct !{!394, !19}
!395 = distinct !{!395, !19}
!396 = distinct !{!396, !19}
!397 = distinct !{!397, !19}
!398 = distinct !{!398, !19}
!399 = distinct !{!399, !19}
!400 = distinct !{!400, !19}
!401 = distinct !{!401, !19}
!402 = distinct !{!402, !19}
!403 = distinct !{!403, !19}
!404 = distinct !{!404, !19}
!405 = distinct !{!405, !19}
!406 = distinct !{!406, !19}
!407 = distinct !{!407, !19}
!408 = distinct !{!408, !19}
!409 = distinct !{!409, !19}
!410 = distinct !{!410, !19}
!411 = distinct !{!411, !19}
!412 = distinct !{!412, !19}
!413 = distinct !{!413, !19}
!414 = distinct !{!414, !19}
!415 = distinct !{!415, !19}
!416 = distinct !{!416, !19}
!417 = distinct !{!417, !19}
!418 = distinct !{!418, !19}
!419 = distinct !{!419, !19}
!420 = distinct !{!420, !19}
!421 = distinct !{!421, !19}
!422 = distinct !{!422, !19}
!423 = distinct !{!423, !19}
!424 = distinct !{!424, !19}
!425 = distinct !{!425, !19}
!426 = distinct !{!426, !19}
!427 = distinct !{!427, !19}
!428 = distinct !{!428, !19}
!429 = distinct !{!429, !19}
!430 = distinct !{!430, !19}
!431 = distinct !{!431, !19}
!432 = distinct !{!432, !19}
!433 = distinct !{!433, !19}
!434 = distinct !{!434, !19}
!435 = distinct !{!435, !19}
!436 = distinct !{!436, !19}
!437 = distinct !{!437, !19}
!438 = distinct !{!438, !19}
!439 = distinct !{!439, !19}
!440 = distinct !{!440, !19}
!441 = distinct !{!441, !19}
!442 = distinct !{!442, !19}
!443 = distinct !{!443, !19}
!444 = distinct !{!444, !19}
!445 = distinct !{!445, !19}
!446 = distinct !{!446, !19}
!447 = distinct !{!447, !19}
!448 = distinct !{!448, !19}
!449 = distinct !{!449, !19}
!450 = distinct !{!450, !19}
!451 = distinct !{!451, !19}
!452 = distinct !{!452, !19}
!453 = distinct !{!453, !19}
!454 = distinct !{!454, !19}
!455 = distinct !{!455, !19}
!456 = distinct !{!456, !19}
!457 = distinct !{!457, !19}
!458 = distinct !{!458, !19}
!459 = distinct !{!459, !19}
!460 = distinct !{!460, !19}
!461 = distinct !{!461, !19}
!462 = distinct !{!462, !19}
!463 = distinct !{!463, !19}
!464 = distinct !{!464, !19}
!465 = distinct !{!465, !19}
!466 = distinct !{!466, !19}
!467 = distinct !{!467, !19}
!468 = distinct !{!468, !19}
!469 = distinct !{!469, !19}
!470 = distinct !{!470, !19}
!471 = distinct !{!471, !19}
!472 = distinct !{!472, !19}
!473 = distinct !{!473, !19}
!474 = distinct !{!474, !19}
!475 = distinct !{!475, !19}
!476 = distinct !{!476, !19}
!477 = distinct !{!477, !19}
!478 = distinct !{!478, !19}
!479 = distinct !{!479, !19}
!480 = distinct !{!480, !19}
!481 = distinct !{!481, !19}
!482 = distinct !{!482, !19}
!483 = distinct !{!483, !19}
!484 = distinct !{!484, !19}
!485 = distinct !{!485, !19}
!486 = distinct !{!486, !19}
!487 = distinct !{!487, !19}
!488 = distinct !{!488, !19}
!489 = distinct !{!489, !19}
!490 = distinct !{!490, !19}
!491 = distinct !{!491, !19}
!492 = distinct !{!492, !19}
!493 = distinct !{!493, !19}
!494 = distinct !{!494, !19}
!495 = distinct !{!495, !19}
!496 = distinct !{!496, !19}
!497 = distinct !{!497, !19}
!498 = distinct !{!498, !19}
!499 = distinct !{!499, !19}
!500 = distinct !{!500, !19}
!501 = distinct !{!501, !19}
!502 = distinct !{!502, !19}
!503 = distinct !{!503, !19}
!504 = distinct !{!504, !19}
!505 = distinct !{!505, !19}
!506 = distinct !{!506, !19}
!507 = distinct !{!507, !19}
!508 = distinct !{!508, !19}
!509 = distinct !{!509, !19}
!510 = distinct !{!510, !19}
!511 = distinct !{!511, !19}
!512 = distinct !{!512, !19}
!513 = distinct !{!513, !19}
!514 = distinct !{!514, !19}
!515 = distinct !{!515, !19}
!516 = distinct !{!516, !19}
!517 = distinct !{!517, !19}
!518 = distinct !{!518, !19}
!519 = distinct !{!519, !19}
!520 = distinct !{!520, !19}
!521 = distinct !{!521, !19}
!522 = distinct !{!522, !19}
!523 = distinct !{!523, !19}
!524 = distinct !{!524, !19}
!525 = distinct !{!525, !19}
!526 = distinct !{!526, !19}
!527 = distinct !{!527, !19}
!528 = distinct !{!528, !19}
!529 = distinct !{!529, !19}
!530 = distinct !{!530, !19}
!531 = distinct !{!531, !19}
!532 = distinct !{!532, !19}
!533 = distinct !{!533, !19}
!534 = distinct !{!534, !19}
!535 = distinct !{!535, !19}
!536 = distinct !{!536, !19}
!537 = distinct !{!537, !19}
!538 = distinct !{!538, !19}
!539 = distinct !{!539, !19}
!540 = distinct !{!540, !19}
!541 = distinct !{!541, !19}
!542 = distinct !{!542, !19}
!543 = distinct !{!543, !19}
!544 = distinct !{!544, !19}
!545 = distinct !{!545, !19}
!546 = distinct !{!546, !19}
!547 = distinct !{!547, !19}
!548 = distinct !{!548, !19}
!549 = distinct !{!549, !19}
!550 = distinct !{!550, !19}
!551 = distinct !{!551, !19}
!552 = distinct !{!552, !19}
!553 = distinct !{!553, !19}
!554 = distinct !{!554, !19}
!555 = distinct !{!555, !19}
!556 = distinct !{!556, !19}
!557 = distinct !{!557, !19}
!558 = distinct !{!558, !19}
!559 = distinct !{!559, !19}
!560 = distinct !{!560, !19}
!561 = distinct !{!561, !19}
!562 = distinct !{!562, !19}
!563 = distinct !{!563, !19}
!564 = distinct !{!564, !19}
!565 = distinct !{!565, !19}
!566 = distinct !{!566, !19}
!567 = distinct !{!567, !19}
!568 = distinct !{!568, !19}
!569 = distinct !{!569, !19}
!570 = distinct !{!570, !19}
!571 = distinct !{!571, !19}
!572 = distinct !{!572, !19}
!573 = distinct !{!573, !19}
!574 = distinct !{!574, !19}
!575 = distinct !{!575, !19}
!576 = distinct !{!576, !19}
!577 = distinct !{!577, !19}
!578 = distinct !{!578, !19}
!579 = distinct !{!579, !19}
!580 = distinct !{!580, !19}
!581 = distinct !{!581, !19}
!582 = distinct !{!582, !19}
!583 = distinct !{!583, !19}
!584 = distinct !{!584, !19}
!585 = distinct !{!585, !19}
!586 = distinct !{!586, !19}
!587 = distinct !{!587, !19}
!588 = distinct !{!588, !19}
!589 = distinct !{!589, !19}
!590 = distinct !{!590, !19}
!591 = distinct !{!591, !19}
!592 = distinct !{!592, !19}
!593 = distinct !{!593, !19}
!594 = distinct !{!594, !19}
!595 = distinct !{!595, !19}
!596 = distinct !{!596, !19}
!597 = distinct !{!597, !19}
!598 = distinct !{!598, !19}
!599 = distinct !{!599, !19}
!600 = distinct !{!600, !19}
!601 = distinct !{!601, !19}
!602 = distinct !{!602, !19}
!603 = distinct !{!603, !19}
!604 = distinct !{!604, !19}
!605 = distinct !{!605, !19}
!606 = distinct !{!606, !19}
!607 = distinct !{!607, !19}
!608 = distinct !{!608, !19}
!609 = distinct !{!609, !19}
!610 = distinct !{!610, !19}
!611 = distinct !{!611, !19}
!612 = distinct !{!612, !19}
!613 = distinct !{!613, !19}
!614 = distinct !{!614, !19}
!615 = distinct !{!615, !19}
!616 = distinct !{!616, !19}
!617 = distinct !{!617, !19}
!618 = distinct !{!618, !19}
!619 = distinct !{!619, !19}
!620 = distinct !{!620, !19}
!621 = distinct !{!621, !19}
!622 = distinct !{!622, !19}
!623 = distinct !{!623, !19}
!624 = distinct !{!624, !19}
!625 = distinct !{!625, !19}
!626 = distinct !{!626, !19}
!627 = distinct !{!627, !19}
!628 = distinct !{!628, !19}
!629 = distinct !{!629, !19}
!630 = distinct !{!630, !19}
!631 = distinct !{!631, !19}
!632 = distinct !{!632, !19}
!633 = distinct !{!633, !19}
!634 = distinct !{!634, !19}
!635 = distinct !{!635, !19}
!636 = distinct !{!636, !19}
!637 = distinct !{!637, !19}
!638 = distinct !{!638, !19}
!639 = distinct !{!639, !19}
!640 = distinct !{!640, !19}
!641 = distinct !{!641, !19}
!642 = distinct !{!642, !19}
!643 = distinct !{!643, !19}
!644 = distinct !{!644, !19}
!645 = distinct !{!645, !19}
!646 = distinct !{!646, !19}
!647 = distinct !{!647, !19}
!648 = distinct !{!648, !19}
!649 = distinct !{!649, !19}
!650 = distinct !{!650, !19}
!651 = distinct !{!651, !19}
!652 = distinct !{!652, !19}
!653 = distinct !{!653, !19}
!654 = distinct !{!654, !19}
!655 = distinct !{!655, !19}
!656 = distinct !{!656, !19}
!657 = distinct !{!657, !19}
!658 = distinct !{!658, !19}
