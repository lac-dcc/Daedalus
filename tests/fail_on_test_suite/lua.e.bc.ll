; ModuleID = '/src/llvm-test-suite/build/MultiSource/Applications/lua/lua.e.bc'
source_filename = "ld-temp.o"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.upvaldesc = type { i8, i8 }
%struct.Node = type { %struct.lua_TValue, %union.TKey }
%struct.lua_TValue = type { %union.Value, i32 }
%union.Value = type { ptr }
%union.TKey = type { %struct.anon.2 }
%struct.anon.2 = type { %union.Value, i32, ptr }
%struct.CCallS = type { ptr, ptr }
%struct.lua_State = type { ptr, i8, i8, i8, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i16, i16, i8, i8, i32, i32, ptr, %struct.lua_TValue, %struct.lua_TValue, ptr, ptr, ptr, i64 }
%struct.CallInfo = type { ptr, ptr, ptr, ptr, i32, i32 }
%struct.global_State = type { %struct.stringtable, ptr, ptr, i8, i8, i32, ptr, ptr, ptr, ptr, ptr, ptr, %struct.Mbuffer, i64, i64, i64, i64, i32, i32, ptr, %struct.lua_TValue, ptr, %struct.UpVal, [9 x ptr], [17 x ptr] }
%struct.stringtable = type { ptr, i32, i32 }
%struct.Mbuffer = type { ptr, i64, i64 }
%struct.UpVal = type { ptr, i8, i8, ptr, %union.anon }
%union.anon = type { %struct.lua_TValue }
%struct.CClosure = type { ptr, i8, i8, i8, i8, ptr, ptr, ptr, [1 x %struct.lua_TValue] }
%struct.GCheader = type { ptr, i8, i8 }
%struct.anon.0 = type { ptr, i8, i8, i8, i32, i64 }
%union.TString = type { %struct.anon.0 }
%struct.anon.1 = type { ptr, i8, i8, ptr, ptr, i64 }
%union.Udata = type { %struct.anon.1 }
%struct.__va_list_tag = type { i32, i32, ptr, ptr }
%struct.Table = type { ptr, i8, i8, i8, i8, ptr, ptr, ptr, ptr, ptr, i32 }
%struct.CallS = type { ptr, i32 }
%struct.Zio = type { i64, ptr, ptr, ptr, ptr }
%struct.LClosure = type { ptr, i8, i8, i8, i8, ptr, ptr, ptr, [1 x ptr] }
%struct.Proto = type { ptr, i8, i8, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i32, i32, i32, i32, i32, ptr, i8, i8, i8, i8 }
%struct.FuncState = type { ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i32, i32, i32, i16, i8, [60 x %struct.upvaldesc], [200 x i16] }
%struct.LexState = type { i32, i32, i32, %struct.Token, %struct.Token, ptr, ptr, ptr, ptr, ptr, i8 }
%struct.Token = type { i32, %union.SemInfo }
%union.SemInfo = type { double }
%struct.expdesc = type { i32, %union.SemInfo, i32, i32 }
%struct.lua_Debug = type { i32, ptr, ptr, ptr, ptr, i32, i32, i32, i32, [60 x i8], i32 }
%struct.lua_longjmp = type { ptr, [1 x %struct.__jmp_buf_tag], i32 }
%struct.__jmp_buf_tag = type { [8 x i64], i32, %struct.__sigset_t }
%struct.__sigset_t = type { [16 x i64] }
%struct.SParser = type { ptr, %struct.Mbuffer, ptr }
%struct.DumpState = type { ptr, ptr, ptr, i32, i32 }
%struct.BlockCnt = type { ptr, i32, i8, i8, i8 }
%struct.LHS_assign = type { ptr, %struct.expdesc }
%struct.ConsControl = type { %struct.expdesc, ptr, i32, i32, i32 }
%struct.LG = type { %struct.lua_State, %struct.global_State }
%struct.LoadState = type { ptr, ptr, ptr, ptr }
%struct.luaL_Buffer = type { ptr, i32, ptr, [8192 x i8] }
%struct.LoadF = type { i32, ptr, [8192 x i8] }
%struct.LoadS = type { ptr, i64 }
%struct.tm = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, ptr }
%struct.MatchState = type { ptr, ptr, ptr, i32, [32 x %struct.LoadS] }
%struct.Smain = type { i32, ptr, i32 }

@.str = private unnamed_addr constant [23 x i8] c"no calling environment\00", align 1
@.str.1 = private unnamed_addr constant [9 x i8] c"no value\00", align 1
@.str.2 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.3 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.4 = private unnamed_addr constant [35 x i8] c"function or expression too complex\00", align 1
@.str.1.2 = private unnamed_addr constant [27 x i8] c"control structure too long\00", align 1
@.str.2.5 = private unnamed_addr constant [24 x i8] c"constant table overflow\00", align 1
@.str.3.1 = private unnamed_addr constant [19 x i8] c"code size overflow\00", align 1
@.str.20 = private unnamed_addr constant [35 x i8] c"attempt to %s %s '%s' (a %s value)\00", align 1
@.str.1.23 = private unnamed_addr constant [25 x i8] c"attempt to %s a %s value\00", align 1
@.str.2.27 = private unnamed_addr constant [12 x i8] c"concatenate\00", align 1
@.str.3.28 = private unnamed_addr constant [22 x i8] c"perform arithmetic on\00", align 1
@.str.4.29 = private unnamed_addr constant [33 x i8] c"attempt to compare two %s values\00", align 1
@.str.5 = private unnamed_addr constant [30 x i8] c"attempt to compare %s with %s\00", align 1
@.str.6 = private unnamed_addr constant [13 x i8] c"(*temporary)\00", align 1
@.str.7 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.8 = private unnamed_addr constant [5 x i8] c"tail\00", align 1
@.str.9 = private unnamed_addr constant [13 x i8] c"=(tail call)\00", align 1
@.str.10 = private unnamed_addr constant [5 x i8] c"=[C]\00", align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"C\00", align 1
@.str.12 = private unnamed_addr constant [5 x i8] c"main\00", align 1
@.str.13 = private unnamed_addr constant [4 x i8] c"Lua\00", align 1
@.str.14 = private unnamed_addr constant [6 x i8] c"local\00", align 1
@.str.15 = private unnamed_addr constant [7 x i8] c"global\00", align 1
@.str.16 = private unnamed_addr constant [6 x i8] c"field\00", align 1
@.str.17 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.18 = private unnamed_addr constant [8 x i8] c"upvalue\00", align 1
@.str.19 = private unnamed_addr constant [7 x i8] c"method\00", align 1
@.str.20.24 = private unnamed_addr constant [10 x i8] c"%s:%d: %s\00", align 1
@.str.30 = private unnamed_addr constant [18 x i8] c"not enough memory\00", align 1
@.str.1.31 = private unnamed_addr constant [24 x i8] c"error in error handling\00", align 1
@.str.2.41 = private unnamed_addr constant [17 x i8] c"C stack overflow\00", align 1
@.str.3.42 = private unnamed_addr constant [38 x i8] c"cannot resume non-suspended coroutine\00", align 1
@.str.4.43 = private unnamed_addr constant [51 x i8] c"attempt to yield across metamethod/C-call boundary\00", align 1
@.str.5.36 = private unnamed_addr constant [5 x i8] c"call\00", align 1
@.str.6.37 = private unnamed_addr constant [2 x i8] c"n\00", align 1
@.str.7.38 = private unnamed_addr constant [15 x i8] c"stack overflow\00", align 1
@.str.72 = private unnamed_addr constant [4 x i8] c"and\00", align 1
@.str.1.73 = private unnamed_addr constant [6 x i8] c"break\00", align 1
@.str.2.74 = private unnamed_addr constant [3 x i8] c"do\00", align 1
@.str.3.75 = private unnamed_addr constant [5 x i8] c"else\00", align 1
@.str.4.76 = private unnamed_addr constant [7 x i8] c"elseif\00", align 1
@.str.5.77 = private unnamed_addr constant [4 x i8] c"end\00", align 1
@.str.6.78 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@.str.7.79 = private unnamed_addr constant [4 x i8] c"for\00", align 1
@.str.8.80 = private unnamed_addr constant [9 x i8] c"function\00", align 1
@.str.9.81 = private unnamed_addr constant [3 x i8] c"if\00", align 1
@.str.10.82 = private unnamed_addr constant [3 x i8] c"in\00", align 1
@.str.11.83 = private unnamed_addr constant [6 x i8] c"local\00", align 1
@.str.12.84 = private unnamed_addr constant [4 x i8] c"nil\00", align 1
@.str.13.85 = private unnamed_addr constant [4 x i8] c"not\00", align 1
@.str.14.86 = private unnamed_addr constant [3 x i8] c"or\00", align 1
@.str.15.87 = private unnamed_addr constant [7 x i8] c"repeat\00", align 1
@.str.16.88 = private unnamed_addr constant [7 x i8] c"return\00", align 1
@.str.17.89 = private unnamed_addr constant [5 x i8] c"then\00", align 1
@.str.18.90 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@.str.19.91 = private unnamed_addr constant [6 x i8] c"until\00", align 1
@.str.20.92 = private unnamed_addr constant [6 x i8] c"while\00", align 1
@.str.21 = private unnamed_addr constant [3 x i8] c"..\00", align 1
@.str.22 = private unnamed_addr constant [4 x i8] c"...\00", align 1
@.str.23 = private unnamed_addr constant [3 x i8] c"==\00", align 1
@.str.24 = private unnamed_addr constant [3 x i8] c">=\00", align 1
@.str.25 = private unnamed_addr constant [3 x i8] c"<=\00", align 1
@.str.26 = private unnamed_addr constant [3 x i8] c"~=\00", align 1
@.str.27 = private unnamed_addr constant [9 x i8] c"<number>\00", align 1
@.str.28 = private unnamed_addr constant [7 x i8] c"<name>\00", align 1
@.str.29 = private unnamed_addr constant [9 x i8] c"<string>\00", align 1
@.str.30.93 = private unnamed_addr constant [6 x i8] c"<eof>\00", align 1
@luaX_tokens = internal constant [32 x ptr] [ptr @.str.72, ptr @.str.1.73, ptr @.str.2.74, ptr @.str.3.75, ptr @.str.4.76, ptr @.str.5.77, ptr @.str.6.78, ptr @.str.7.79, ptr @.str.8.80, ptr @.str.9.81, ptr @.str.10.82, ptr @.str.11.83, ptr @.str.12.84, ptr @.str.13.85, ptr @.str.14.86, ptr @.str.15.87, ptr @.str.16.88, ptr @.str.17.89, ptr @.str.18.90, ptr @.str.19.91, ptr @.str.20.92, ptr @.str.21, ptr @.str.22, ptr @.str.23, ptr @.str.24, ptr @.str.25, ptr @.str.26, ptr @.str.27, ptr @.str.28, ptr @.str.29, ptr @.str.30.93, ptr null], align 16
@.str.31 = private unnamed_addr constant [9 x i8] c"char(%d)\00", align 1
@.str.32 = private unnamed_addr constant [3 x i8] c"%c\00", align 1
@.str.33 = private unnamed_addr constant [10 x i8] c"%s:%d: %s\00", align 1
@.str.34 = private unnamed_addr constant [13 x i8] c"%s near '%s'\00", align 1
@.str.35 = private unnamed_addr constant [25 x i8] c"lexical element too long\00", align 1
@.str.36 = private unnamed_addr constant [30 x i8] c"invalid long string delimiter\00", align 1
@.str.37 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str.38 = private unnamed_addr constant [25 x i8] c"chunk has too many lines\00", align 1
@.str.39 = private unnamed_addr constant [23 x i8] c"unfinished long string\00", align 1
@.str.40 = private unnamed_addr constant [24 x i8] c"unfinished long comment\00", align 1
@.str.41 = private unnamed_addr constant [33 x i8] c"nesting of [[...]] is deprecated\00", align 1
@.str.42 = private unnamed_addr constant [18 x i8] c"unfinished string\00", align 1
@.str.43 = private unnamed_addr constant [26 x i8] c"escape sequence too large\00", align 1
@.str.44 = private unnamed_addr constant [3 x i8] c"Ee\00", align 1
@.str.45 = private unnamed_addr constant [3 x i8] c"+-\00", align 1
@.str.46 = private unnamed_addr constant [17 x i8] c"malformed number\00", align 1
@.str.100 = private unnamed_addr constant [39 x i8] c"memory allocation error: block too big\00", align 1
@luaO_log2.log_2 = internal unnamed_addr constant [256 x i8] c"\00\01\02\02\03\03\03\03\04\04\04\04\04\04\04\04\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08", align 16
@.str.109 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.1.110 = private unnamed_addr constant [7 x i8] c"(null)\00", align 1
@.str.2.111 = private unnamed_addr constant [3 x i8] c"%p\00", align 1
@.str.3.112 = private unnamed_addr constant [2 x i8] c"%\00", align 1
@.str.5.117 = private unnamed_addr constant [3 x i8] c"\0A\0D\00", align 1
@.str.6.118 = private unnamed_addr constant [10 x i8] c"[string \22\00", align 1
@.str.7.119 = private unnamed_addr constant [3 x i8] c"\22]\00", align 1
@luaP_opmodes = internal constant [38 x i8] c"`qT`Pql1\10<Tl||||||```h\22\BC\BC\BC\E4\E4TT\10bb\84\14\00QP", align 16
@.str.126 = private unnamed_addr constant [14 x i8] c"'%s' expected\00", align 1
@.str.1.127 = private unnamed_addr constant [33 x i8] c"chunk has too many syntax levels\00", align 1
@priority = internal unnamed_addr constant [15 x %struct.upvaldesc] [%struct.upvaldesc { i8 6, i8 6 }, %struct.upvaldesc { i8 6, i8 6 }, %struct.upvaldesc { i8 7, i8 7 }, %struct.upvaldesc { i8 7, i8 7 }, %struct.upvaldesc { i8 7, i8 7 }, %struct.upvaldesc { i8 10, i8 9 }, %struct.upvaldesc { i8 5, i8 4 }, %struct.upvaldesc { i8 3, i8 3 }, %struct.upvaldesc { i8 3, i8 3 }, %struct.upvaldesc { i8 3, i8 3 }, %struct.upvaldesc { i8 3, i8 3 }, %struct.upvaldesc { i8 3, i8 3 }, %struct.upvaldesc { i8 3, i8 3 }, %struct.upvaldesc { i8 2, i8 2 }, %struct.upvaldesc { i8 1, i8 1 }], align 16
@.str.2.150 = private unnamed_addr constant [43 x i8] c"cannot use '...' outside a vararg function\00", align 1
@.str.3.142 = private unnamed_addr constant [23 x i8] c"items in a constructor\00", align 1
@.str.4.137 = private unnamed_addr constant [34 x i8] c"main function has more than %d %s\00", align 1
@.str.5.138 = private unnamed_addr constant [40 x i8] c"function at line %d has more than %d %s\00", align 1
@.str.6.143 = private unnamed_addr constant [5 x i8] c"self\00", align 1
@.str.7.151 = private unnamed_addr constant [16 x i8] c"local variables\00", align 1
@.str.8.152 = private unnamed_addr constant [25 x i8] c"too many local variables\00", align 1
@.str.9.144 = private unnamed_addr constant [4 x i8] c"arg\00", align 1
@.str.10.145 = private unnamed_addr constant [25 x i8] c"<name> or '...' expected\00", align 1
@.str.11.146 = private unnamed_addr constant [24 x i8] c"constant table overflow\00", align 1
@.str.12.139 = private unnamed_addr constant [18 x i8] c"unexpected symbol\00", align 1
@.str.13.147 = private unnamed_addr constant [9 x i8] c"upvalues\00", align 1
@.str.14.148 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.15.140 = private unnamed_addr constant [49 x i8] c"ambiguous syntax (function call x new statement)\00", align 1
@.str.16.141 = private unnamed_addr constant [28 x i8] c"function arguments expected\00", align 1
@.str.17.153 = private unnamed_addr constant [41 x i8] c"'%s' expected (to close '%s' at line %d)\00", align 1
@.str.18.134 = private unnamed_addr constant [21 x i8] c"'=' or 'in' expected\00", align 1
@.str.19.128 = private unnamed_addr constant [12 x i8] c"(for index)\00", align 1
@.str.20.129 = private unnamed_addr constant [12 x i8] c"(for limit)\00", align 1
@.str.21.130 = private unnamed_addr constant [11 x i8] c"(for step)\00", align 1
@.str.22.131 = private unnamed_addr constant [16 x i8] c"(for generator)\00", align 1
@.str.23.132 = private unnamed_addr constant [12 x i8] c"(for state)\00", align 1
@.str.24.133 = private unnamed_addr constant [14 x i8] c"(for control)\00", align 1
@.str.25.149 = private unnamed_addr constant [17 x i8] c"no loop to break\00", align 1
@.str.26.135 = private unnamed_addr constant [13 x i8] c"syntax error\00", align 1
@.str.27.136 = private unnamed_addr constant [24 x i8] c"variables in assignment\00", align 1
@.str.158 = private unnamed_addr constant [18 x i8] c"not enough memory\00", align 1
@dummynode_ = internal constant %struct.Node zeroinitializer, align 8
@.str.174 = private unnamed_addr constant [19 x i8] c"table index is nil\00", align 1
@.str.1.175 = private unnamed_addr constant [19 x i8] c"table index is NaN\00", align 1
@.str.2.167 = private unnamed_addr constant [22 x i8] c"invalid key to 'next'\00", align 1
@.str.3.178 = private unnamed_addr constant [15 x i8] c"table overflow\00", align 1
@.str.212 = private unnamed_addr constant [4 x i8] c"nil\00", align 1
@.str.1.213 = private unnamed_addr constant [8 x i8] c"boolean\00", align 1
@.str.2.214 = private unnamed_addr constant [9 x i8] c"userdata\00", align 1
@.str.3.215 = private unnamed_addr constant [7 x i8] c"number\00", align 1
@.str.4.216 = private unnamed_addr constant [7 x i8] c"string\00", align 1
@.str.5.217 = private unnamed_addr constant [6 x i8] c"table\00", align 1
@.str.6.218 = private unnamed_addr constant [9 x i8] c"function\00", align 1
@.str.7.219 = private unnamed_addr constant [7 x i8] c"thread\00", align 1
@.str.8.220 = private unnamed_addr constant [6 x i8] c"proto\00", align 1
@.str.9.221 = private unnamed_addr constant [6 x i8] c"upval\00", align 1
@luaT_typenames = internal constant [11 x ptr] [ptr @.str.212, ptr @.str.1.213, ptr @.str.2.214, ptr @.str.3.215, ptr @.str.4.216, ptr @.str.5.217, ptr @.str.6.218, ptr @.str.2.214, ptr @.str.7.219, ptr @.str.8.220, ptr @.str.9.221], align 16
@luaT_init.luaT_eventname = internal unnamed_addr constant [17 x ptr] [ptr @.str.10.189, ptr @.str.11.190, ptr @.str.12.191, ptr @.str.13.192, ptr @.str.14.193, ptr @.str.15.194, ptr @.str.16.195, ptr @.str.17.196, ptr @.str.18.197, ptr @.str.19.198, ptr @.str.20.199, ptr @.str.21.200, ptr @.str.22.201, ptr @.str.23.202, ptr @.str.24.203, ptr @.str.25.204, ptr @.str.26.205], align 16
@.str.10.189 = private unnamed_addr constant [8 x i8] c"__index\00", align 1
@.str.11.190 = private unnamed_addr constant [11 x i8] c"__newindex\00", align 1
@.str.12.191 = private unnamed_addr constant [5 x i8] c"__gc\00", align 1
@.str.13.192 = private unnamed_addr constant [7 x i8] c"__mode\00", align 1
@.str.14.193 = private unnamed_addr constant [5 x i8] c"__eq\00", align 1
@.str.15.194 = private unnamed_addr constant [6 x i8] c"__add\00", align 1
@.str.16.195 = private unnamed_addr constant [6 x i8] c"__sub\00", align 1
@.str.17.196 = private unnamed_addr constant [6 x i8] c"__mul\00", align 1
@.str.18.197 = private unnamed_addr constant [6 x i8] c"__div\00", align 1
@.str.19.198 = private unnamed_addr constant [6 x i8] c"__mod\00", align 1
@.str.20.199 = private unnamed_addr constant [6 x i8] c"__pow\00", align 1
@.str.21.200 = private unnamed_addr constant [6 x i8] c"__unm\00", align 1
@.str.22.201 = private unnamed_addr constant [6 x i8] c"__len\00", align 1
@.str.23.202 = private unnamed_addr constant [5 x i8] c"__lt\00", align 1
@.str.24.203 = private unnamed_addr constant [5 x i8] c"__le\00", align 1
@.str.25.204 = private unnamed_addr constant [9 x i8] c"__concat\00", align 1
@.str.26.205 = private unnamed_addr constant [7 x i8] c"__call\00", align 1
@.str.1.224 = private unnamed_addr constant [14 x i8] c"binary string\00", align 1
@.str.2.227 = private unnamed_addr constant [3 x i8] c"=?\00", align 1
@.str.3.226 = private unnamed_addr constant [11 x i8] c"bad header\00", align 1
@.str.4.232 = private unnamed_addr constant [15 x i8] c"unexpected end\00", align 1
@.str.5.225 = private unnamed_addr constant [28 x i8] c"%s: %s in precompiled chunk\00", align 1
@.str.6.228 = private unnamed_addr constant [14 x i8] c"code too deep\00", align 1
@.str.7.230 = private unnamed_addr constant [9 x i8] c"bad code\00", align 1
@.str.8.231 = private unnamed_addr constant [12 x i8] c"bad integer\00", align 1
@.str.9.229 = private unnamed_addr constant [13 x i8] c"bad constant\00", align 1
@.str.239 = private unnamed_addr constant [6 x i8] c"%.14g\00", align 1
@.str.1.242 = private unnamed_addr constant [6 x i8] c"index\00", align 1
@.str.2.243 = private unnamed_addr constant [17 x i8] c"loop in gettable\00", align 1
@.str.3.246 = private unnamed_addr constant [17 x i8] c"loop in settable\00", align 1
@.str.4.251 = private unnamed_addr constant [23 x i8] c"string length overflow\00", align 1
@luaO_nilobject_ = internal constant %struct.lua_TValue zeroinitializer, align 8
@.str.5.254 = private unnamed_addr constant [14 x i8] c"get length of\00", align 1
@.str.6.256 = private unnamed_addr constant [37 x i8] c"'for' initial value must be a number\00", align 1
@.str.7.257 = private unnamed_addr constant [29 x i8] c"'for' limit must be a number\00", align 1
@.str.8.255 = private unnamed_addr constant [28 x i8] c"'for' step must be a number\00", align 1
@.str.268 = private unnamed_addr constant [22 x i8] c"bad argument #%d (%s)\00", align 1
@.str.1.269 = private unnamed_addr constant [2 x i8] c"n\00", align 1
@.str.2.270 = private unnamed_addr constant [7 x i8] c"method\00", align 1
@.str.3.271 = private unnamed_addr constant [30 x i8] c"calling '%s' on bad self (%s)\00", align 1
@.str.4.272 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.5.273 = private unnamed_addr constant [30 x i8] c"bad argument #%d to '%s' (%s)\00", align 1
@.str.6.277 = private unnamed_addr constant [20 x i8] c"%s expected, got %s\00", align 1
@.str.7.274 = private unnamed_addr constant [3 x i8] c"Sl\00", align 1
@.str.8.275 = private unnamed_addr constant [8 x i8] c"%s:%d: \00", align 1
@.str.9.276 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.10.278 = private unnamed_addr constant [20 x i8] c"invalid option '%s'\00", align 1
@.str.11.279 = private unnamed_addr constant [20 x i8] c"stack overflow (%s)\00", align 1
@.str.12.280 = private unnamed_addr constant [15 x i8] c"value expected\00", align 1
@.str.13.281 = private unnamed_addr constant [8 x i8] c"_LOADED\00", align 1
@.str.14.282 = private unnamed_addr constant [30 x i8] c"name conflict for module '%s'\00", align 1
@.str.15.283 = private unnamed_addr constant [7 x i8] c"=stdin\00", align 1
@.str.16.284 = private unnamed_addr constant [4 x i8] c"@%s\00", align 1
@.str.17.285 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.18.286 = private unnamed_addr constant [5 x i8] c"open\00", align 1
@.str.20.287 = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@.str.21.288 = private unnamed_addr constant [7 x i8] c"reopen\00", align 1
@.str.22.289 = private unnamed_addr constant [5 x i8] c"read\00", align 1
@.str.23.291 = private unnamed_addr constant [17 x i8] c"cannot %s %s: %s\00", align 1
@.str.24.290 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.25.292 = private unnamed_addr constant [50 x i8] c"PANIC: unprotected error in call to Lua API (%s)\0A\00", align 1
@.str.301 = private unnamed_addr constant [10 x i8] c"coroutine\00", align 1
@co_funcs = internal constant [7 x %struct.CCallS] [%struct.CCallS { ptr @.str.65, ptr @luaB_cocreate }, %struct.CCallS { ptr @.str.66, ptr @luaB_coresume }, %struct.CCallS { ptr @.str.67, ptr @luaB_corunning }, %struct.CCallS { ptr @.str.68, ptr @luaB_costatus }, %struct.CCallS { ptr @.str.69, ptr @luaB_cowrap }, %struct.CCallS { ptr @.str.70, ptr @luaB_yield }, %struct.CCallS zeroinitializer], align 16
@.str.1.293 = private unnamed_addr constant [3 x i8] c"_G\00", align 1
@base_funcs = internal constant [25 x %struct.CCallS] [%struct.CCallS { ptr @.str.9.303, ptr @luaB_assert }, %struct.CCallS { ptr @.str.10.304, ptr @luaB_collectgarbage }, %struct.CCallS { ptr @.str.11.305, ptr @luaB_dofile }, %struct.CCallS { ptr @.str.12.306, ptr @luaB_error }, %struct.CCallS { ptr @.str.13.307, ptr @luaB_gcinfo }, %struct.CCallS { ptr @.str.14.308, ptr @luaB_getfenv }, %struct.CCallS { ptr @.str.15.309, ptr @luaB_getmetatable }, %struct.CCallS { ptr @.str.16.310, ptr @luaB_loadfile }, %struct.CCallS { ptr @.str.17.311, ptr @luaB_load }, %struct.CCallS { ptr @.str.18.312, ptr @luaB_loadstring }, %struct.CCallS { ptr @.str.19.313, ptr @luaB_next }, %struct.CCallS { ptr @.str.20.314, ptr @luaB_pcall }, %struct.CCallS { ptr @.str.21.315, ptr @luaB_print }, %struct.CCallS { ptr @.str.22.316, ptr @luaB_rawequal }, %struct.CCallS { ptr @.str.23.317, ptr @luaB_rawget }, %struct.CCallS { ptr @.str.24.318, ptr @luaB_rawset }, %struct.CCallS { ptr @.str.25.319, ptr @luaB_select }, %struct.CCallS { ptr @.str.26.320, ptr @luaB_setfenv }, %struct.CCallS { ptr @.str.27.321, ptr @luaB_setmetatable }, %struct.CCallS { ptr @.str.28.322, ptr @luaB_tonumber }, %struct.CCallS { ptr @.str.29.323, ptr @luaB_tostring }, %struct.CCallS { ptr @.str.30.324, ptr @luaB_type }, %struct.CCallS { ptr @.str.31.325, ptr @luaB_unpack }, %struct.CCallS { ptr @.str.32.326, ptr @luaB_xpcall }, %struct.CCallS zeroinitializer], align 16
@.str.2.294 = private unnamed_addr constant [8 x i8] c"Lua 5.1\00", align 1
@.str.3.295 = private unnamed_addr constant [9 x i8] c"_VERSION\00", align 1
@.str.4.296 = private unnamed_addr constant [7 x i8] c"ipairs\00", align 1
@.str.5.297 = private unnamed_addr constant [6 x i8] c"pairs\00", align 1
@.str.6.298 = private unnamed_addr constant [3 x i8] c"kv\00", align 1
@.str.7.299 = private unnamed_addr constant [7 x i8] c"__mode\00", align 1
@.str.8.300 = private unnamed_addr constant [9 x i8] c"newproxy\00", align 1
@.str.9.303 = private unnamed_addr constant [7 x i8] c"assert\00", align 1
@.str.10.304 = private unnamed_addr constant [15 x i8] c"collectgarbage\00", align 1
@.str.11.305 = private unnamed_addr constant [7 x i8] c"dofile\00", align 1
@.str.12.306 = private unnamed_addr constant [6 x i8] c"error\00", align 1
@.str.13.307 = private unnamed_addr constant [7 x i8] c"gcinfo\00", align 1
@.str.14.308 = private unnamed_addr constant [8 x i8] c"getfenv\00", align 1
@.str.15.309 = private unnamed_addr constant [13 x i8] c"getmetatable\00", align 1
@.str.16.310 = private unnamed_addr constant [9 x i8] c"loadfile\00", align 1
@.str.17.311 = private unnamed_addr constant [5 x i8] c"load\00", align 1
@.str.18.312 = private unnamed_addr constant [11 x i8] c"loadstring\00", align 1
@.str.19.313 = private unnamed_addr constant [5 x i8] c"next\00", align 1
@.str.20.314 = private unnamed_addr constant [6 x i8] c"pcall\00", align 1
@.str.21.315 = private unnamed_addr constant [6 x i8] c"print\00", align 1
@.str.22.316 = private unnamed_addr constant [9 x i8] c"rawequal\00", align 1
@.str.23.317 = private unnamed_addr constant [7 x i8] c"rawget\00", align 1
@.str.24.318 = private unnamed_addr constant [7 x i8] c"rawset\00", align 1
@.str.25.319 = private unnamed_addr constant [7 x i8] c"select\00", align 1
@.str.26.320 = private unnamed_addr constant [8 x i8] c"setfenv\00", align 1
@.str.27.321 = private unnamed_addr constant [13 x i8] c"setmetatable\00", align 1
@.str.28.322 = private unnamed_addr constant [9 x i8] c"tonumber\00", align 1
@.str.29.323 = private unnamed_addr constant [9 x i8] c"tostring\00", align 1
@.str.30.324 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.31.325 = private unnamed_addr constant [7 x i8] c"unpack\00", align 1
@.str.32.326 = private unnamed_addr constant [7 x i8] c"xpcall\00", align 1
@.str.33.340 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.34.339 = private unnamed_addr constant [18 x i8] c"assertion failed!\00", align 1
@luaB_collectgarbage.opts = internal constant [8 x ptr] [ptr @.str.35.333, ptr @.str.36.334, ptr @.str.37.332, ptr @.str.38.335, ptr @.str.39.336, ptr @.str.40.337, ptr @.str.41.338, ptr null], align 16
@.str.35.333 = private unnamed_addr constant [5 x i8] c"stop\00", align 1
@.str.36.334 = private unnamed_addr constant [8 x i8] c"restart\00", align 1
@.str.37.332 = private unnamed_addr constant [8 x i8] c"collect\00", align 1
@.str.38.335 = private unnamed_addr constant [6 x i8] c"count\00", align 1
@.str.39.336 = private unnamed_addr constant [5 x i8] c"step\00", align 1
@.str.40.337 = private unnamed_addr constant [9 x i8] c"setpause\00", align 1
@.str.41.338 = private unnamed_addr constant [11 x i8] c"setstepmul\00", align 1
@luaB_collectgarbage.optsnum = internal unnamed_addr constant [7 x i32] [i32 0, i32 1, i32 2, i32 3, i32 5, i32 6, i32 7], align 16
@.str.42.328 = private unnamed_addr constant [27 x i8] c"level must be non-negative\00", align 1
@.str.43.329 = private unnamed_addr constant [14 x i8] c"invalid level\00", align 1
@.str.44.330 = private unnamed_addr constant [2 x i8] c"f\00", align 1
@.str.45.331 = private unnamed_addr constant [50 x i8] c"no function environment for tail call at level %d\00", align 1
@.str.46.327 = private unnamed_addr constant [12 x i8] c"__metatable\00", align 1
@.str.47 = private unnamed_addr constant [8 x i8] c"=(load)\00", align 1
@.str.48 = private unnamed_addr constant [26 x i8] c"too many nested functions\00", align 1
@.str.49 = private unnamed_addr constant [37 x i8] c"reader function must return a string\00", align 1
@.str.50 = private unnamed_addr constant [43 x i8] c"'tostring' must return a string to 'print'\00", align 1
@.str.51 = private unnamed_addr constant [2 x i8] c"\09\00", align 1
@.str.52 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.53 = private unnamed_addr constant [19 x i8] c"index out of range\00", align 1
@.str.54 = private unnamed_addr constant [52 x i8] c"'setfenv' cannot change environment of given object\00", align 1
@.str.55 = private unnamed_addr constant [22 x i8] c"nil or table expected\00", align 1
@.str.56 = private unnamed_addr constant [36 x i8] c"cannot change a protected metatable\00", align 1
@.str.57 = private unnamed_addr constant [18 x i8] c"base out of range\00", align 1
@.str.58 = private unnamed_addr constant [11 x i8] c"__tostring\00", align 1
@.str.59 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@.str.60 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@.str.61 = private unnamed_addr constant [4 x i8] c"nil\00", align 1
@.str.62 = private unnamed_addr constant [7 x i8] c"%s: %p\00", align 1
@.str.63 = private unnamed_addr constant [27 x i8] c"too many results to unpack\00", align 1
@.str.64 = private unnamed_addr constant [26 x i8] c"boolean or proxy expected\00", align 1
@.str.65 = private unnamed_addr constant [7 x i8] c"create\00", align 1
@.str.66 = private unnamed_addr constant [7 x i8] c"resume\00", align 1
@.str.67 = private unnamed_addr constant [8 x i8] c"running\00", align 1
@.str.68 = private unnamed_addr constant [7 x i8] c"status\00", align 1
@.str.69 = private unnamed_addr constant [5 x i8] c"wrap\00", align 1
@.str.70 = private unnamed_addr constant [6 x i8] c"yield\00", align 1
@.str.71 = private unnamed_addr constant [22 x i8] c"Lua function expected\00", align 1
@.str.72.302 = private unnamed_addr constant [19 x i8] c"coroutine expected\00", align 1
@.str.73 = private unnamed_addr constant [29 x i8] c"too many arguments to resume\00", align 1
@.str.74 = private unnamed_addr constant [27 x i8] c"cannot resume %s coroutine\00", align 1
@statnames = internal unnamed_addr constant [4 x ptr] [ptr @.str.67, ptr @.str.76, ptr @.str.77, ptr @.str.78], align 16
@.str.75 = private unnamed_addr constant [27 x i8] c"too many results to resume\00", align 1
@.str.76 = private unnamed_addr constant [10 x i8] c"suspended\00", align 1
@.str.77 = private unnamed_addr constant [7 x i8] c"normal\00", align 1
@.str.78 = private unnamed_addr constant [5 x i8] c"dead\00", align 1
@.str.341 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@dblib = internal constant [15 x %struct.CCallS] [%struct.CCallS { ptr @.str.341, ptr @db_debug }, %struct.CCallS { ptr @.str.1.342, ptr @db_getfenv }, %struct.CCallS { ptr @.str.2.343, ptr @db_gethook }, %struct.CCallS { ptr @.str.3.344, ptr @db_getinfo }, %struct.CCallS { ptr @.str.4.345, ptr @db_getlocal }, %struct.CCallS { ptr @.str.5.346, ptr @db_getregistry }, %struct.CCallS { ptr @.str.6.347, ptr @db_getmetatable }, %struct.CCallS { ptr @.str.7.348, ptr @db_getupvalue }, %struct.CCallS { ptr @.str.8.349, ptr @db_setfenv }, %struct.CCallS { ptr @.str.9.350, ptr @db_sethook }, %struct.CCallS { ptr @.str.10.351, ptr @db_setlocal }, %struct.CCallS { ptr @.str.11.352, ptr @db_setmetatable }, %struct.CCallS { ptr @.str.12.353, ptr @db_setupvalue }, %struct.CCallS { ptr @.str.13.354, ptr @db_errorfb }, %struct.CCallS zeroinitializer], align 16
@.str.1.342 = private unnamed_addr constant [8 x i8] c"getfenv\00", align 1
@.str.2.343 = private unnamed_addr constant [8 x i8] c"gethook\00", align 1
@.str.3.344 = private unnamed_addr constant [8 x i8] c"getinfo\00", align 1
@.str.4.345 = private unnamed_addr constant [9 x i8] c"getlocal\00", align 1
@.str.5.346 = private unnamed_addr constant [12 x i8] c"getregistry\00", align 1
@.str.6.347 = private unnamed_addr constant [13 x i8] c"getmetatable\00", align 1
@.str.7.348 = private unnamed_addr constant [11 x i8] c"getupvalue\00", align 1
@.str.8.349 = private unnamed_addr constant [8 x i8] c"setfenv\00", align 1
@.str.9.350 = private unnamed_addr constant [8 x i8] c"sethook\00", align 1
@.str.10.351 = private unnamed_addr constant [9 x i8] c"setlocal\00", align 1
@.str.11.352 = private unnamed_addr constant [13 x i8] c"setmetatable\00", align 1
@.str.12.353 = private unnamed_addr constant [11 x i8] c"setupvalue\00", align 1
@.str.13.354 = private unnamed_addr constant [10 x i8] c"traceback\00", align 1
@.str.14.391 = private unnamed_addr constant [12 x i8] c"lua_debug> \00", align 1
@.str.15.392 = private unnamed_addr constant [6 x i8] c"cont\0A\00", align 1
@.str.16.393 = private unnamed_addr constant [17 x i8] c"=(debug command)\00", align 1
@.str.17.356 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.18.390 = private unnamed_addr constant [14 x i8] c"external hook\00", align 1
@hookf.hooknames = internal unnamed_addr constant [5 x ptr] [ptr @.str.19.369, ptr @.str.20.370, ptr @.str.21.371, ptr @.str.22.372, ptr @.str.23.373], align 16
@.str.19.369 = private unnamed_addr constant [5 x i8] c"call\00", align 1
@.str.20.370 = private unnamed_addr constant [7 x i8] c"return\00", align 1
@.str.21.371 = private unnamed_addr constant [5 x i8] c"line\00", align 1
@.str.22.372 = private unnamed_addr constant [6 x i8] c"count\00", align 1
@.str.23.373 = private unnamed_addr constant [12 x i8] c"tail return\00", align 1
@KEY_HOOK = internal constant i8 104, align 1
@.str.24.375 = private unnamed_addr constant [6 x i8] c"flnSu\00", align 1
@.str.25.376 = private unnamed_addr constant [4 x i8] c">%s\00", align 1
@.str.26.377 = private unnamed_addr constant [27 x i8] c"function or level expected\00", align 1
@.str.27.378 = private unnamed_addr constant [15 x i8] c"invalid option\00", align 1
@.str.28.379 = private unnamed_addr constant [7 x i8] c"source\00", align 1
@.str.29.380 = private unnamed_addr constant [10 x i8] c"short_src\00", align 1
@.str.30.381 = private unnamed_addr constant [12 x i8] c"linedefined\00", align 1
@.str.31.382 = private unnamed_addr constant [16 x i8] c"lastlinedefined\00", align 1
@.str.32.383 = private unnamed_addr constant [5 x i8] c"what\00", align 1
@.str.33.384 = private unnamed_addr constant [12 x i8] c"currentline\00", align 1
@.str.34.385 = private unnamed_addr constant [5 x i8] c"nups\00", align 1
@.str.35.386 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.36.387 = private unnamed_addr constant [9 x i8] c"namewhat\00", align 1
@.str.37.388 = private unnamed_addr constant [12 x i8] c"activelines\00", align 1
@.str.38.389 = private unnamed_addr constant [5 x i8] c"func\00", align 1
@.str.39.368 = private unnamed_addr constant [19 x i8] c"level out of range\00", align 1
@.str.40.374 = private unnamed_addr constant [52 x i8] c"'setfenv' cannot change environment of given object\00", align 1
@.str.41.367 = private unnamed_addr constant [22 x i8] c"nil or table expected\00", align 1
@.str.42.355 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.43.357 = private unnamed_addr constant [17 x i8] c"stack traceback:\00", align 1
@.str.44.358 = private unnamed_addr constant [6 x i8] c"\0A\09...\00", align 1
@.str.45.359 = private unnamed_addr constant [3 x i8] c"\0A\09\00", align 1
@.str.46.360 = private unnamed_addr constant [4 x i8] c"Snl\00", align 1
@.str.47.361 = private unnamed_addr constant [4 x i8] c"%s:\00", align 1
@.str.48.362 = private unnamed_addr constant [4 x i8] c"%d:\00", align 1
@.str.49.363 = private unnamed_addr constant [18 x i8] c" in function '%s'\00", align 1
@.str.50.364 = private unnamed_addr constant [15 x i8] c" in main chunk\00", align 1
@.str.51.365 = private unnamed_addr constant [3 x i8] c" ?\00", align 1
@.str.52.366 = private unnamed_addr constant [21 x i8] c" in function <%s:%d>\00", align 1
@.str.396 = private unnamed_addr constant [3 x i8] c"io\00", align 1
@iolib = internal constant [12 x %struct.CCallS] [%struct.CCallS { ptr @.str.7.404, ptr @io_close }, %struct.CCallS { ptr @.str.8.405, ptr @io_flush }, %struct.CCallS { ptr @.str.34.406, ptr @io_input }, %struct.CCallS { ptr @.str.9.407, ptr @io_lines }, %struct.CCallS { ptr @.str.35.408, ptr @io_open }, %struct.CCallS { ptr @.str.36.409, ptr @io_output }, %struct.CCallS { ptr @.str.4.400, ptr @io_popen }, %struct.CCallS { ptr @.str.10.410, ptr @io_read }, %struct.CCallS { ptr @.str.37.411, ptr @io_tmpfile }, %struct.CCallS { ptr @.str.38.412, ptr @io_type }, %struct.CCallS { ptr @.str.13.413, ptr @io_write }, %struct.CCallS zeroinitializer], align 16
@.str.1.397 = private unnamed_addr constant [6 x i8] c"stdin\00", align 1
@.str.2.398 = private unnamed_addr constant [7 x i8] c"stdout\00", align 1
@.str.3.399 = private unnamed_addr constant [7 x i8] c"stderr\00", align 1
@.str.4.400 = private unnamed_addr constant [6 x i8] c"popen\00", align 1
@.str.5.394 = private unnamed_addr constant [6 x i8] c"FILE*\00", align 1
@.str.6.395 = private unnamed_addr constant [8 x i8] c"__index\00", align 1
@flib = internal constant [10 x %struct.CCallS] [%struct.CCallS { ptr @.str.7.404, ptr @io_close }, %struct.CCallS { ptr @.str.8.405, ptr @f_flush }, %struct.CCallS { ptr @.str.9.407, ptr @f_lines }, %struct.CCallS { ptr @.str.10.410, ptr @f_read }, %struct.CCallS { ptr @.str.11.427, ptr @f_seek }, %struct.CCallS { ptr @.str.12.428, ptr @f_setvbuf }, %struct.CCallS { ptr @.str.13.413, ptr @f_write }, %struct.CCallS { ptr @.str.14.429, ptr @io_gc }, %struct.CCallS { ptr @.str.15.430, ptr @io_tostring }, %struct.CCallS zeroinitializer], align 16
@.str.7.404 = private unnamed_addr constant [6 x i8] c"close\00", align 1
@.str.8.405 = private unnamed_addr constant [6 x i8] c"flush\00", align 1
@.str.9.407 = private unnamed_addr constant [6 x i8] c"lines\00", align 1
@.str.10.410 = private unnamed_addr constant [5 x i8] c"read\00", align 1
@.str.11.427 = private unnamed_addr constant [5 x i8] c"seek\00", align 1
@.str.12.428 = private unnamed_addr constant [8 x i8] c"setvbuf\00", align 1
@.str.13.413 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@.str.14.429 = private unnamed_addr constant [5 x i8] c"__gc\00", align 1
@.str.15.430 = private unnamed_addr constant [11 x i8] c"__tostring\00", align 1
@.str.16.424 = private unnamed_addr constant [29 x i8] c"attempt to use a closed file\00", align 1
@.str.17.426 = private unnamed_addr constant [8 x i8] c"__close\00", align 1
@.str.18.401 = private unnamed_addr constant [7 x i8] c"%s: %s\00", align 1
@.str.19.402 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.20.425 = private unnamed_addr constant [23 x i8] c"file is already closed\00", align 1
@.str.21.418 = private unnamed_addr constant [19 x i8] c"too many arguments\00", align 1
@.str.22.419 = private unnamed_addr constant [15 x i8] c"invalid option\00", align 1
@.str.23.421 = private unnamed_addr constant [15 x i8] c"invalid format\00", align 1
@.str.24.420 = private unnamed_addr constant [4 x i8] c"%lf\00", align 1
@f_seek.mode = internal unnamed_addr constant [3 x i32] [i32 0, i32 1, i32 2], align 4
@f_seek.modenames = internal constant [4 x ptr] [ptr @.str.25.437, ptr @.str.26.436, ptr @.str.27.438, ptr null], align 16
@.str.25.437 = private unnamed_addr constant [4 x i8] c"set\00", align 1
@.str.26.436 = private unnamed_addr constant [4 x i8] c"cur\00", align 1
@.str.27.438 = private unnamed_addr constant [4 x i8] c"end\00", align 1
@f_setvbuf.mode = internal unnamed_addr constant [3 x i32] [i32 2, i32 0, i32 1], align 4
@f_setvbuf.modenames = internal constant [4 x ptr] [ptr @.str.28.433, ptr @.str.29.434, ptr @.str.30.435, ptr null], align 16
@.str.28.433 = private unnamed_addr constant [3 x i8] c"no\00", align 1
@.str.29.434 = private unnamed_addr constant [5 x i8] c"full\00", align 1
@.str.30.435 = private unnamed_addr constant [5 x i8] c"line\00", align 1
@.str.31.414 = private unnamed_addr constant [6 x i8] c"%.14g\00", align 1
@.str.32.431 = private unnamed_addr constant [14 x i8] c"file (closed)\00", align 1
@.str.33.432 = private unnamed_addr constant [10 x i8] c"file (%p)\00", align 1
@.str.34.406 = private unnamed_addr constant [6 x i8] c"input\00", align 1
@.str.35.408 = private unnamed_addr constant [5 x i8] c"open\00", align 1
@.str.36.409 = private unnamed_addr constant [7 x i8] c"output\00", align 1
@.str.37.411 = private unnamed_addr constant [8 x i8] c"tmpfile\00", align 1
@.str.38.412 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.39.415 = private unnamed_addr constant [27 x i8] c"standard %s file is closed\00", align 1
@fnames = internal unnamed_addr constant [2 x ptr] [ptr @.str.34.406, ptr @.str.36.409], align 16
@.str.40.422 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.41.423 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.42.416 = private unnamed_addr constant [12 x i8] c"closed file\00", align 1
@.str.43.417 = private unnamed_addr constant [5 x i8] c"file\00", align 1
@.str.44.403 = private unnamed_addr constant [27 x i8] c"cannot close standard file\00", align 1
@.str.439 = private unnamed_addr constant [5 x i8] c"math\00", align 1
@mathlib = internal constant [29 x %struct.CCallS] [%struct.CCallS { ptr @.str.5.444, ptr @math_abs }, %struct.CCallS { ptr @.str.6.445, ptr @math_acos }, %struct.CCallS { ptr @.str.7.446, ptr @math_asin }, %struct.CCallS { ptr @.str.8.447, ptr @math_atan2 }, %struct.CCallS { ptr @.str.9.448, ptr @math_atan }, %struct.CCallS { ptr @.str.10.449, ptr @math_ceil }, %struct.CCallS { ptr @.str.11.450, ptr @math_cosh }, %struct.CCallS { ptr @.str.12.451, ptr @math_cos }, %struct.CCallS { ptr @.str.13.452, ptr @math_deg }, %struct.CCallS { ptr @.str.14.453, ptr @math_exp }, %struct.CCallS { ptr @.str.15.454, ptr @math_floor }, %struct.CCallS { ptr @.str.3.442, ptr @math_fmod }, %struct.CCallS { ptr @.str.16.455, ptr @math_frexp }, %struct.CCallS { ptr @.str.17.456, ptr @math_ldexp }, %struct.CCallS { ptr @.str.18.457, ptr @math_log10 }, %struct.CCallS { ptr @.str.19.458, ptr @math_log }, %struct.CCallS { ptr @.str.20.459, ptr @math_max }, %struct.CCallS { ptr @.str.21.460, ptr @math_min }, %struct.CCallS { ptr @.str.22.461, ptr @math_modf }, %struct.CCallS { ptr @.str.23.462, ptr @math_pow }, %struct.CCallS { ptr @.str.24.463, ptr @math_rad }, %struct.CCallS { ptr @.str.25.464, ptr @math_random }, %struct.CCallS { ptr @.str.26.465, ptr @math_randomseed }, %struct.CCallS { ptr @.str.27.466, ptr @math_sinh }, %struct.CCallS { ptr @.str.28.467, ptr @math_sin }, %struct.CCallS { ptr @.str.29.468, ptr @math_sqrt }, %struct.CCallS { ptr @.str.30.469, ptr @math_tanh }, %struct.CCallS { ptr @.str.31.470, ptr @math_tan }, %struct.CCallS zeroinitializer], align 16
@.str.1.440 = private unnamed_addr constant [3 x i8] c"pi\00", align 1
@.str.2.441 = private unnamed_addr constant [5 x i8] c"huge\00", align 1
@.str.3.442 = private unnamed_addr constant [5 x i8] c"fmod\00", align 1
@.str.4.443 = private unnamed_addr constant [4 x i8] c"mod\00", align 1
@.str.5.444 = private unnamed_addr constant [4 x i8] c"abs\00", align 1
@.str.6.445 = private unnamed_addr constant [5 x i8] c"acos\00", align 1
@.str.7.446 = private unnamed_addr constant [5 x i8] c"asin\00", align 1
@.str.8.447 = private unnamed_addr constant [6 x i8] c"atan2\00", align 1
@.str.9.448 = private unnamed_addr constant [5 x i8] c"atan\00", align 1
@.str.10.449 = private unnamed_addr constant [5 x i8] c"ceil\00", align 1
@.str.11.450 = private unnamed_addr constant [5 x i8] c"cosh\00", align 1
@.str.12.451 = private unnamed_addr constant [4 x i8] c"cos\00", align 1
@.str.13.452 = private unnamed_addr constant [4 x i8] c"deg\00", align 1
@.str.14.453 = private unnamed_addr constant [4 x i8] c"exp\00", align 1
@.str.15.454 = private unnamed_addr constant [6 x i8] c"floor\00", align 1
@.str.16.455 = private unnamed_addr constant [6 x i8] c"frexp\00", align 1
@.str.17.456 = private unnamed_addr constant [6 x i8] c"ldexp\00", align 1
@.str.18.457 = private unnamed_addr constant [6 x i8] c"log10\00", align 1
@.str.19.458 = private unnamed_addr constant [4 x i8] c"log\00", align 1
@.str.20.459 = private unnamed_addr constant [4 x i8] c"max\00", align 1
@.str.21.460 = private unnamed_addr constant [4 x i8] c"min\00", align 1
@.str.22.461 = private unnamed_addr constant [5 x i8] c"modf\00", align 1
@.str.23.462 = private unnamed_addr constant [4 x i8] c"pow\00", align 1
@.str.24.463 = private unnamed_addr constant [4 x i8] c"rad\00", align 1
@.str.25.464 = private unnamed_addr constant [7 x i8] c"random\00", align 1
@.str.26.465 = private unnamed_addr constant [11 x i8] c"randomseed\00", align 1
@.str.27.466 = private unnamed_addr constant [5 x i8] c"sinh\00", align 1
@.str.28.467 = private unnamed_addr constant [4 x i8] c"sin\00", align 1
@.str.29.468 = private unnamed_addr constant [5 x i8] c"sqrt\00", align 1
@.str.30.469 = private unnamed_addr constant [5 x i8] c"tanh\00", align 1
@.str.31.470 = private unnamed_addr constant [4 x i8] c"tan\00", align 1
@.str.32.471 = private unnamed_addr constant [18 x i8] c"interval is empty\00", align 1
@.str.33.472 = private unnamed_addr constant [26 x i8] c"wrong number of arguments\00", align 1
@.str.473 = private unnamed_addr constant [3 x i8] c"os\00", align 1
@syslib = internal constant [12 x %struct.CCallS] [%struct.CCallS { ptr @.str.1.474, ptr @os_clock }, %struct.CCallS { ptr @.str.2.475, ptr @os_date }, %struct.CCallS { ptr @.str.3.476, ptr @os_difftime }, %struct.CCallS { ptr @.str.4.477, ptr @os_execute }, %struct.CCallS { ptr @.str.5.478, ptr @os_exit }, %struct.CCallS { ptr @.str.6.479, ptr @os_getenv }, %struct.CCallS { ptr @.str.7.480, ptr @os_remove }, %struct.CCallS { ptr @.str.8.481, ptr @os_rename }, %struct.CCallS { ptr @.str.9.482, ptr @os_setlocale }, %struct.CCallS { ptr @.str.10.483, ptr @os_time }, %struct.CCallS { ptr @.str.11.484, ptr @os_tmpname }, %struct.CCallS zeroinitializer], align 16
@.str.1.474 = private unnamed_addr constant [6 x i8] c"clock\00", align 1
@.str.2.475 = private unnamed_addr constant [5 x i8] c"date\00", align 1
@.str.3.476 = private unnamed_addr constant [9 x i8] c"difftime\00", align 1
@.str.4.477 = private unnamed_addr constant [8 x i8] c"execute\00", align 1
@.str.5.478 = private unnamed_addr constant [5 x i8] c"exit\00", align 1
@.str.6.479 = private unnamed_addr constant [7 x i8] c"getenv\00", align 1
@.str.7.480 = private unnamed_addr constant [7 x i8] c"remove\00", align 1
@.str.8.481 = private unnamed_addr constant [7 x i8] c"rename\00", align 1
@.str.9.482 = private unnamed_addr constant [10 x i8] c"setlocale\00", align 1
@.str.10.483 = private unnamed_addr constant [5 x i8] c"time\00", align 1
@.str.11.484 = private unnamed_addr constant [8 x i8] c"tmpname\00", align 1
@.str.12.502 = private unnamed_addr constant [3 x i8] c"%c\00", align 1
@.str.13.503 = private unnamed_addr constant [3 x i8] c"*t\00", align 1
@.str.14.487 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
@.str.15.488 = private unnamed_addr constant [4 x i8] c"min\00", align 1
@.str.16.489 = private unnamed_addr constant [5 x i8] c"hour\00", align 1
@.str.17.490 = private unnamed_addr constant [4 x i8] c"day\00", align 1
@.str.18.491 = private unnamed_addr constant [6 x i8] c"month\00", align 1
@.str.19.492 = private unnamed_addr constant [5 x i8] c"year\00", align 1
@.str.20.504 = private unnamed_addr constant [5 x i8] c"wday\00", align 1
@.str.21.505 = private unnamed_addr constant [5 x i8] c"yday\00", align 1
@.str.22.493 = private unnamed_addr constant [6 x i8] c"isdst\00", align 1
@.str.23.501 = private unnamed_addr constant [30 x i8] c"Cannot execute system calls!\0A\00", align 1
@.str.24.500 = private unnamed_addr constant [7 x i8] c"%s: %s\00", align 1
@os_setlocale.cat = internal unnamed_addr constant [6 x i32] [i32 6, i32 3, i32 0, i32 4, i32 1, i32 2], align 16
@os_setlocale.catnames = internal constant [7 x ptr] [ptr @.str.25.495, ptr @.str.26.496, ptr @.str.27.497, ptr @.str.28.498, ptr @.str.29.499, ptr @.str.10.483, ptr null], align 16
@.str.25.495 = private unnamed_addr constant [4 x i8] c"all\00", align 1
@.str.26.496 = private unnamed_addr constant [8 x i8] c"collate\00", align 1
@.str.27.497 = private unnamed_addr constant [6 x i8] c"ctype\00", align 1
@.str.28.498 = private unnamed_addr constant [9 x i8] c"monetary\00", align 1
@.str.29.499 = private unnamed_addr constant [8 x i8] c"numeric\00", align 1
@.str.30.494 = private unnamed_addr constant [33 x i8] c"field '%s' missing in date table\00", align 1
@.str.31.485 = private unnamed_addr constant [16 x i8] c"/tmp/lua_XXXXXX\00", align 1
@.str.32.486 = private unnamed_addr constant [37 x i8] c"unable to generate a unique filename\00", align 1
@.str.506 = private unnamed_addr constant [6 x i8] c"table\00", align 1
@tab_funcs = internal constant [10 x %struct.CCallS] [%struct.CCallS { ptr @.str.1.507, ptr @tconcat }, %struct.CCallS { ptr @.str.2.508, ptr @foreach }, %struct.CCallS { ptr @.str.3.509, ptr @foreachi }, %struct.CCallS { ptr @.str.4.510, ptr @getn }, %struct.CCallS { ptr @.str.5.511, ptr @maxn }, %struct.CCallS { ptr @.str.6.512, ptr @tinsert }, %struct.CCallS { ptr @.str.7.513, ptr @tremove }, %struct.CCallS { ptr @.str.8.514, ptr @setn }, %struct.CCallS { ptr @.str.9.515, ptr @sort }, %struct.CCallS zeroinitializer], align 16
@.str.1.507 = private unnamed_addr constant [7 x i8] c"concat\00", align 1
@.str.2.508 = private unnamed_addr constant [8 x i8] c"foreach\00", align 1
@.str.3.509 = private unnamed_addr constant [9 x i8] c"foreachi\00", align 1
@.str.4.510 = private unnamed_addr constant [5 x i8] c"getn\00", align 1
@.str.5.511 = private unnamed_addr constant [5 x i8] c"maxn\00", align 1
@.str.6.512 = private unnamed_addr constant [7 x i8] c"insert\00", align 1
@.str.7.513 = private unnamed_addr constant [7 x i8] c"remove\00", align 1
@.str.8.514 = private unnamed_addr constant [5 x i8] c"setn\00", align 1
@.str.9.515 = private unnamed_addr constant [5 x i8] c"sort\00", align 1
@.str.10.516 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.11.520 = private unnamed_addr constant [53 x i8] c"invalid value (%s) at index %d in table for 'concat'\00", align 1
@.str.12.519 = private unnamed_addr constant [38 x i8] c"wrong number of arguments to 'insert'\00", align 1
@.str.13.518 = private unnamed_addr constant [19 x i8] c"'setn' is obsolete\00", align 1
@.str.14.517 = private unnamed_addr constant [35 x i8] c"invalid order function for sorting\00", align 1
@.str.521 = private unnamed_addr constant [7 x i8] c"string\00", align 1
@strlib = internal constant [16 x %struct.CCallS] [%struct.CCallS { ptr @.str.3.526, ptr @str_byte }, %struct.CCallS { ptr @.str.4.527, ptr @str_char }, %struct.CCallS { ptr @.str.5.528, ptr @str_dump }, %struct.CCallS { ptr @.str.6.529, ptr @str_find }, %struct.CCallS { ptr @.str.7.530, ptr @str_format }, %struct.CCallS { ptr @.str.2.523, ptr @gfind_nodef }, %struct.CCallS { ptr @.str.1.522, ptr @gmatch }, %struct.CCallS { ptr @.str.8.531, ptr @str_gsub }, %struct.CCallS { ptr @.str.9.532, ptr @str_len }, %struct.CCallS { ptr @.str.10.533, ptr @str_lower }, %struct.CCallS { ptr @.str.11.534, ptr @str_match }, %struct.CCallS { ptr @.str.12.535, ptr @str_rep }, %struct.CCallS { ptr @.str.13.536, ptr @str_reverse }, %struct.CCallS { ptr @.str.14.537, ptr @str_sub }, %struct.CCallS { ptr @.str.15.538, ptr @str_upper }, %struct.CCallS zeroinitializer], align 16
@.str.1.522 = private unnamed_addr constant [7 x i8] c"gmatch\00", align 1
@.str.2.523 = private unnamed_addr constant [6 x i8] c"gfind\00", align 1
@.str.3.526 = private unnamed_addr constant [5 x i8] c"byte\00", align 1
@.str.4.527 = private unnamed_addr constant [5 x i8] c"char\00", align 1
@.str.5.528 = private unnamed_addr constant [5 x i8] c"dump\00", align 1
@.str.6.529 = private unnamed_addr constant [5 x i8] c"find\00", align 1
@.str.7.530 = private unnamed_addr constant [7 x i8] c"format\00", align 1
@.str.8.531 = private unnamed_addr constant [5 x i8] c"gsub\00", align 1
@.str.9.532 = private unnamed_addr constant [4 x i8] c"len\00", align 1
@.str.10.533 = private unnamed_addr constant [6 x i8] c"lower\00", align 1
@.str.11.534 = private unnamed_addr constant [6 x i8] c"match\00", align 1
@.str.12.535 = private unnamed_addr constant [4 x i8] c"rep\00", align 1
@.str.13.536 = private unnamed_addr constant [8 x i8] c"reverse\00", align 1
@.str.14.537 = private unnamed_addr constant [4 x i8] c"sub\00", align 1
@.str.15.538 = private unnamed_addr constant [6 x i8] c"upper\00", align 1
@.str.16.559 = private unnamed_addr constant [22 x i8] c"string slice too long\00", align 1
@.str.17.558 = private unnamed_addr constant [14 x i8] c"invalid value\00", align 1
@.str.18.557 = private unnamed_addr constant [30 x i8] c"unable to dump given function\00", align 1
@.str.19.539 = private unnamed_addr constant [11 x i8] c"^$*+?.([%-\00", align 1
@.str.20.545 = private unnamed_addr constant [35 x i8] c"missing '[' after '%%f' in pattern\00", align 1
@.str.21.540 = private unnamed_addr constant [18 x i8] c"too many captures\00", align 1
@.str.22.543 = private unnamed_addr constant [24 x i8] c"invalid pattern capture\00", align 1
@.str.23.544 = private unnamed_addr constant [19 x i8] c"unbalanced pattern\00", align 1
@.str.24.546 = private unnamed_addr constant [35 x i8] c"malformed pattern (ends with '%%')\00", align 1
@.str.25.547 = private unnamed_addr constant [32 x i8] c"malformed pattern (missing ']')\00", align 1
@.str.26.541 = private unnamed_addr constant [22 x i8] c"invalid capture index\00", align 1
@.str.27.542 = private unnamed_addr constant [19 x i8] c"unfinished capture\00", align 1
@.str.28.556 = private unnamed_addr constant [34 x i8] c"invalid option '%%%c' to 'format'\00", align 1
@.str.29.551 = private unnamed_addr constant [6 x i8] c"-+ #0\00", align 1
@.str.30.552 = private unnamed_addr constant [32 x i8] c"invalid format (repeated flags)\00", align 1
@.str.31.553 = private unnamed_addr constant [45 x i8] c"invalid format (width or precision too long)\00", align 1
@.str.33.554 = private unnamed_addr constant [3 x i8] c"\\r\00", align 1
@.str.34.555 = private unnamed_addr constant [5 x i8] c"\\000\00", align 1
@.str.35.550 = private unnamed_addr constant [46 x i8] c"'string.gfind' was renamed to 'string.gmatch'\00", align 1
@.str.36.548 = private unnamed_addr constant [31 x i8] c"string/function/table expected\00", align 1
@.str.37.549 = private unnamed_addr constant [33 x i8] c"invalid replacement value (a %s)\00", align 1
@.str.38.524 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.39.525 = private unnamed_addr constant [8 x i8] c"__index\00", align 1
@.str.560 = private unnamed_addr constant [9 x i8] c"_LOADLIB\00", align 1
@.str.1.561 = private unnamed_addr constant [5 x i8] c"__gc\00", align 1
@.str.2.562 = private unnamed_addr constant [8 x i8] c"package\00", align 1
@pk_funcs = internal constant [3 x %struct.CCallS] [%struct.CCallS { ptr @.str.15.605, ptr @ll_loadlib }, %struct.CCallS { ptr @.str.16.606, ptr @ll_seeall }, %struct.CCallS zeroinitializer], align 16
@loaders = internal unnamed_addr constant [5 x ptr] [ptr @loader_preload, ptr @loader_Lua, ptr @loader_C, ptr @loader_Croot, ptr null], align 16
@.str.3.563 = private unnamed_addr constant [8 x i8] c"loaders\00", align 1
@.str.4.564 = private unnamed_addr constant [5 x i8] c"path\00", align 1
@.str.5.565 = private unnamed_addr constant [9 x i8] c"LUA_PATH\00", align 1
@.str.6.566 = private unnamed_addr constant [138 x i8] c"./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua\00", align 1
@.str.7.567 = private unnamed_addr constant [6 x i8] c"cpath\00", align 1
@.str.8.568 = private unnamed_addr constant [10 x i8] c"LUA_CPATH\00", align 1
@.str.9.569 = private unnamed_addr constant [69 x i8] c"./?.so;/usr/local/lib/lua/5.1/?.so;/usr/local/lib/lua/5.1/loadall.so\00", align 1
@.str.10.570 = private unnamed_addr constant [10 x i8] c"/\0A;\0A?\0A!\0A-\00", align 1
@.str.11.571 = private unnamed_addr constant [7 x i8] c"config\00", align 1
@.str.12.572 = private unnamed_addr constant [8 x i8] c"_LOADED\00", align 1
@.str.13.573 = private unnamed_addr constant [7 x i8] c"loaded\00", align 1
@.str.14.574 = private unnamed_addr constant [8 x i8] c"preload\00", align 1
@ll_funcs = internal constant [3 x %struct.CCallS] [%struct.CCallS { ptr @.str.41.575, ptr @ll_module }, %struct.CCallS { ptr @.str.42.576, ptr @ll_require }, %struct.CCallS zeroinitializer], align 16
@.str.15.605 = private unnamed_addr constant [8 x i8] c"loadlib\00", align 1
@.str.16.606 = private unnamed_addr constant [7 x i8] c"seeall\00", align 1
@.str.17.608 = private unnamed_addr constant [7 x i8] c"absent\00", align 1
@.str.18.609 = private unnamed_addr constant [5 x i8] c"init\00", align 1
@.str.19.592 = private unnamed_addr constant [5 x i8] c"%s%s\00", align 1
@.str.20.593 = private unnamed_addr constant [10 x i8] c"LOADLIB: \00", align 1
@.str.21.594 = private unnamed_addr constant [59 x i8] c"dynamic libraries not enabled; check your Lua installation\00", align 1
@.str.22.607 = private unnamed_addr constant [8 x i8] c"__index\00", align 1
@.str.23.603 = private unnamed_addr constant [34 x i8] c"'package.preload' must be a table\00", align 1
@.str.24.604 = private unnamed_addr constant [33 x i8] c"\0A\09no field package.preload['%s']\00", align 1
@.str.25.595 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str.26.598 = private unnamed_addr constant [2 x i8] c"/\00", align 1
@.str.27.599 = private unnamed_addr constant [30 x i8] c"'package.%s' must be a string\00", align 1
@.str.28.579 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.29.600 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.30.602 = private unnamed_addr constant [15 x i8] c"\0A\09no file '%s'\00", align 1
@.str.32.601 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.33.591 = private unnamed_addr constant [46 x i8] c"error loading module '%s' from file '%s':\0A\09%s\00", align 1
@.str.35.596 = private unnamed_addr constant [2 x i8] c"_\00", align 1
@.str.36.597 = private unnamed_addr constant [11 x i8] c"luaopen_%s\00", align 1
@.str.37.590 = private unnamed_addr constant [30 x i8] c"\0A\09no module '%s' in file '%s'\00", align 1
@.str.38.587 = private unnamed_addr constant [3 x i8] c";;\00", align 1
@.str.39.588 = private unnamed_addr constant [4 x i8] c";\01;\00", align 1
@.str.40.589 = private unnamed_addr constant [2 x i8] c"\01\00", align 1
@.str.41.575 = private unnamed_addr constant [7 x i8] c"module\00", align 1
@.str.42.576 = private unnamed_addr constant [8 x i8] c"require\00", align 1
@.str.43.581 = private unnamed_addr constant [30 x i8] c"name conflict for module '%s'\00", align 1
@.str.44.582 = private unnamed_addr constant [6 x i8] c"_NAME\00", align 1
@.str.45.583 = private unnamed_addr constant [3 x i8] c"_M\00", align 1
@.str.46.584 = private unnamed_addr constant [9 x i8] c"_PACKAGE\00", align 1
@.str.47.585 = private unnamed_addr constant [2 x i8] c"f\00", align 1
@.str.48.586 = private unnamed_addr constant [40 x i8] c"'module' not called from a Lua function\00", align 1
@sentinel_ = internal constant i32 0, align 4
@.str.49.577 = private unnamed_addr constant [43 x i8] c"loop or previous error loading module '%s'\00", align 1
@.str.50.578 = private unnamed_addr constant [34 x i8] c"'package.loaders' must be a table\00", align 1
@.str.51.580 = private unnamed_addr constant [25 x i8] c"module '%s' not found:%s\00", align 1
@lualibs = internal unnamed_addr constant [9 x %struct.CCallS] [%struct.CCallS { ptr @.str.610, ptr @luaopen_base }, %struct.CCallS { ptr @.str.1.611, ptr @luaopen_package }, %struct.CCallS { ptr @.str.2.612, ptr @luaopen_table }, %struct.CCallS { ptr @.str.3.613, ptr @luaopen_io }, %struct.CCallS { ptr @.str.4.614, ptr @luaopen_os }, %struct.CCallS { ptr @.str.5.615, ptr @luaopen_string }, %struct.CCallS { ptr @.str.6.616, ptr @luaopen_math }, %struct.CCallS { ptr @.str.7.617, ptr @luaopen_debug }, %struct.CCallS zeroinitializer], align 16
@.str.610 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.1.611 = private unnamed_addr constant [8 x i8] c"package\00", align 1
@.str.2.612 = private unnamed_addr constant [6 x i8] c"table\00", align 1
@.str.3.613 = private unnamed_addr constant [3 x i8] c"io\00", align 1
@.str.4.614 = private unnamed_addr constant [3 x i8] c"os\00", align 1
@.str.5.615 = private unnamed_addr constant [7 x i8] c"string\00", align 1
@.str.6.616 = private unnamed_addr constant [5 x i8] c"math\00", align 1
@.str.7.617 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str.618 = private unnamed_addr constant [39 x i8] c"cannot create state: not enough memory\00", align 1
@.str.1.619 = private unnamed_addr constant [4 x i8] c"lua\00", align 1
@stderr = external local_unnamed_addr global ptr, align 8
@.str.2.645 = private unnamed_addr constant [5 x i8] c"%s: \00", align 1
@.str.3.624 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@globalL = internal unnamed_addr global ptr null, align 8
@progname = internal unnamed_addr global ptr @.str.1.619, align 8
@.str.4.621 = private unnamed_addr constant [9 x i8] c"LUA_INIT\00", align 1
@.str.5.622 = private unnamed_addr constant [10 x i8] c"=LUA_INIT\00", align 1
@.str.6.643 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str.7.644 = private unnamed_addr constant [10 x i8] c"traceback\00", align 1
@.str.8.642 = private unnamed_addr constant [13 x i8] c"interrupted!\00", align 1
@.str.9.623 = private unnamed_addr constant [307 x i8] c"usage: %s [options] [script [args]].\0AAvailable options are:\0A  -e stat  execute string 'stat'\0A  -l name  require library 'name'\0A  -i       enter interactive mode after executing 'script'\0A  -v       show version information\0A  --       stop handling options\0A  -        execute stdin and stop handling options\0A\00", align 1
@.str.10.625 = private unnamed_addr constant [52 x i8] c"Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio\00", align 1
@.str.11.626 = private unnamed_addr constant [16 x i8] c"=(command line)\00", align 1
@.str.12.627 = private unnamed_addr constant [8 x i8] c"require\00", align 1
@.str.13.629 = private unnamed_addr constant [4 x i8] c"arg\00", align 1
@.str.14.630 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.15.631 = private unnamed_addr constant [3 x i8] c"--\00", align 1
@.str.16.628 = private unnamed_addr constant [29 x i8] c"too many arguments to script\00", align 1
@.str.17.635 = private unnamed_addr constant [6 x i8] c"print\00", align 1
@.str.18.636 = private unnamed_addr constant [27 x i8] c"error calling 'print' (%s)\00", align 1
@.str.19.634 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@stdout = external local_unnamed_addr global ptr, align 8
@.str.20.632 = private unnamed_addr constant [7 x i8] c"=stdin\00", align 1
@stdin = external local_unnamed_addr global ptr, align 8
@.str.21.641 = private unnamed_addr constant [10 x i8] c"return %s\00", align 1
@.str.22.638 = private unnamed_addr constant [8 x i8] c"_PROMPT\00", align 1
@.str.23.637 = private unnamed_addr constant [9 x i8] c"_PROMPT2\00", align 1
@.str.24.640 = private unnamed_addr constant [3 x i8] c"> \00", align 1
@.str.25.639 = private unnamed_addr constant [4 x i8] c">> \00", align 1
@.str.26.633 = private unnamed_addr constant [8 x i8] c"'<eof>'\00", align 1
@.str.27.620 = private unnamed_addr constant [31 x i8] c"(error object is not a string)\00", align 1

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(write, argmem: readwrite, inaccessiblemem: none) uwtable
define internal void @luaA_pushobject(ptr nocapture noundef %0, ptr nocapture noundef readonly %1) #0 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %4 = load ptr, ptr %3, align 8, !tbaa !7
  %5 = load i64, ptr %1, align 8
  store i64 %5, ptr %4, align 8
  %6 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  %7 = load i32, ptr %6, align 8, !tbaa !16
  %8 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  store i32 %7, ptr %8, align 8, !tbaa !16
  %9 = load ptr, ptr %3, align 8, !tbaa !7
  %10 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 1
  store ptr %10, ptr %3, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_checkstack(ptr noundef %0, i32 noundef %1) #1 {
  %3 = icmp sgt i32 %1, 8000
  br i1 %3, label %37, label %4

4:                                                ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %6 = load ptr, ptr %5, align 8, !tbaa !7
  %7 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  %8 = load ptr, ptr %7, align 8, !tbaa !17
  %9 = ptrtoint ptr %6 to i64
  %10 = ptrtoint ptr %8 to i64
  %11 = sub i64 %9, %10
  %12 = ashr exact i64 %11, 4
  %13 = sext i32 %1 to i64
  %14 = add nsw i64 %12, %13
  %15 = icmp sgt i64 %14, 8000
  br i1 %15, label %37, label %16

16:                                               ; preds = %4
  %17 = icmp sgt i32 %1, 0
  br i1 %17, label %18, label %37

18:                                               ; preds = %16
  %19 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %20 = load ptr, ptr %19, align 8, !tbaa !18
  %21 = ptrtoint ptr %20 to i64
  %22 = sub i64 %21, %9
  %23 = shl nuw nsw i32 %1, 4
  %24 = zext i32 %23 to i64
  %25 = icmp sgt i64 %22, %24
  br i1 %25, label %28, label %26

26:                                               ; preds = %18
  tail call void @luaD_growstack(ptr noundef nonnull %0, i32 noundef %1) #46
  %27 = load ptr, ptr %5, align 8, !tbaa !7
  br label %28

28:                                               ; preds = %26, %18
  %29 = phi ptr [ %6, %18 ], [ %27, %26 ]
  %30 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %31 = load ptr, ptr %30, align 8, !tbaa !19
  %32 = getelementptr inbounds %struct.CallInfo, ptr %31, i64 0, i32 2
  %33 = load ptr, ptr %32, align 8, !tbaa !20
  %34 = getelementptr inbounds %struct.lua_TValue, ptr %29, i64 %13
  %35 = icmp ult ptr %33, %34
  br i1 %35, label %36, label %37

36:                                               ; preds = %28
  store ptr %34, ptr %32, align 8, !tbaa !20
  br label %37

37:                                               ; preds = %36, %28, %16, %4, %2
  %38 = phi i32 [ 1, %36 ], [ 1, %28 ], [ 1, %16 ], [ 0, %4 ], [ 0, %2 ]
  ret i32 %38
}

; Function Attrs: nofree norecurse nosync nounwind optsize memory(readwrite, inaccessiblemem: none) uwtable
define internal void @lua_xmove(ptr noundef %0, ptr noundef %1, i32 noundef %2) #2 {
  %4 = icmp eq ptr %0, %1
  br i1 %4, label %27, label %5

5:                                                ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %7 = load ptr, ptr %6, align 8, !tbaa !7
  %8 = sext i32 %2 to i64
  %9 = sub nsw i64 0, %8
  %10 = getelementptr inbounds %struct.lua_TValue, ptr %7, i64 %9
  store ptr %10, ptr %6, align 8, !tbaa !7
  %11 = icmp sgt i32 %2, 0
  br i1 %11, label %12, label %27

12:                                               ; preds = %5
  %13 = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 4
  %14 = zext i32 %2 to i64
  br label %15

15:                                               ; preds = %15, %12
  %16 = phi i64 [ 0, %12 ], [ %25, %15 ]
  %17 = load ptr, ptr %6, align 8, !tbaa !7
  %18 = getelementptr inbounds %struct.lua_TValue, ptr %17, i64 %16
  %19 = load ptr, ptr %13, align 8, !tbaa !7
  %20 = getelementptr inbounds %struct.lua_TValue, ptr %19, i64 1
  store ptr %20, ptr %13, align 8, !tbaa !7
  %21 = load i64, ptr %18, align 8
  store i64 %21, ptr %19, align 8
  %22 = getelementptr inbounds %struct.lua_TValue, ptr %17, i64 %16, i32 1
  %23 = load i32, ptr %22, align 8, !tbaa !16
  %24 = getelementptr inbounds %struct.lua_TValue, ptr %19, i64 0, i32 1
  store i32 %23, ptr %24, align 8, !tbaa !16
  %25 = add nuw nsw i64 %16, 1
  %26 = icmp eq i64 %25, %14
  br i1 %26, label %27, label %15, !llvm.loop !22

27:                                               ; preds = %15, %5, %3
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: readwrite) uwtable
define internal void @lua_setlevel(ptr nocapture noundef readonly %0, ptr nocapture noundef writeonly %1) #3 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 15
  %4 = load i16, ptr %3, align 8, !tbaa !24
  %5 = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 15
  store i16 %4, ptr %5, align 8, !tbaa !24
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable
define internal ptr @lua_atpanic(ptr nocapture noundef readonly %0, ptr noundef %1) #4 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %4 = load ptr, ptr %3, align 8, !tbaa !25
  %5 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 19
  %6 = load ptr, ptr %5, align 8, !tbaa !26
  store ptr %1, ptr %5, align 8, !tbaa !26
  ret ptr %6
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @lua_newthread(ptr noundef %0) #1 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %3 = load ptr, ptr %2, align 8, !tbaa !25
  %4 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 14
  %5 = load i64, ptr %4, align 8, !tbaa !31
  %6 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 13
  %7 = load i64, ptr %6, align 8, !tbaa !32
  %8 = icmp ult i64 %5, %7
  br i1 %8, label %10, label %9

9:                                                ; preds = %1
  tail call void @luaC_step(ptr noundef nonnull %0) #46
  br label %10

10:                                               ; preds = %9, %1
  %11 = tail call ptr @luaE_newthread(ptr noundef nonnull %0) #46
  %12 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %13 = load ptr, ptr %12, align 8, !tbaa !7
  store ptr %11, ptr %13, align 8, !tbaa !33
  %14 = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 0, i32 1
  store i32 8, ptr %14, align 8, !tbaa !16
  %15 = load ptr, ptr %12, align 8, !tbaa !7
  %16 = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 1
  store ptr %16, ptr %12, align 8, !tbaa !7
  ret ptr %11
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: read) uwtable
define internal i32 @lua_gettop(ptr nocapture noundef readonly %0) #5 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %3 = load ptr, ptr %2, align 8, !tbaa !7
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  %5 = load ptr, ptr %4, align 8, !tbaa !17
  %6 = ptrtoint ptr %3 to i64
  %7 = ptrtoint ptr %5 to i64
  %8 = sub i64 %6, %7
  %9 = lshr exact i64 %8, 4
  %10 = trunc i64 %9 to i32
  ret i32 %10
}

; Function Attrs: nofree norecurse nosync nounwind optsize memory(write, argmem: readwrite, inaccessiblemem: none) uwtable
define internal void @lua_settop(ptr nocapture noundef %0, i32 noundef %1) #6 {
  %3 = icmp sgt i32 %1, -1
  br i1 %3, label %4, label %18

4:                                                ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %6 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  %7 = load ptr, ptr %6, align 8, !tbaa !17
  %8 = zext i32 %1 to i64
  %9 = getelementptr inbounds %struct.lua_TValue, ptr %7, i64 %8
  %10 = load ptr, ptr %5, align 8, !tbaa !7
  %11 = icmp ult ptr %10, %9
  br i1 %11, label %12, label %17

12:                                               ; preds = %12, %4
  %13 = phi ptr [ %14, %12 ], [ %10, %4 ]
  %14 = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 1
  %15 = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 0, i32 1
  store i32 0, ptr %15, align 8, !tbaa !16
  %16 = icmp ult ptr %14, %9
  br i1 %16, label %12, label %17, !llvm.loop !34

17:                                               ; preds = %12, %4
  store ptr %9, ptr %5, align 8, !tbaa !7
  br label %24

18:                                               ; preds = %2
  %19 = add nsw i32 %1, 1
  %20 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %21 = load ptr, ptr %20, align 8, !tbaa !7
  %22 = sext i32 %19 to i64
  %23 = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 %22
  store ptr %23, ptr %20, align 8, !tbaa !7
  br label %24

24:                                               ; preds = %18, %17
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind optsize memory(readwrite, inaccessiblemem: none) uwtable
define internal void @lua_remove(ptr noundef %0, i32 noundef %1) #2 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %5 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 1
  %6 = load ptr, ptr %4, align 8, !tbaa !7
  %7 = icmp ult ptr %5, %6
  br i1 %7, label %8, label %18

8:                                                ; preds = %8, %2
  %9 = phi ptr [ %15, %8 ], [ %5, %2 ]
  %10 = phi ptr [ %9, %8 ], [ %3, %2 ]
  %11 = load i64, ptr %9, align 8
  store i64 %11, ptr %10, align 8
  %12 = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 1, i32 1
  %13 = load i32, ptr %12, align 8, !tbaa !16
  %14 = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 0, i32 1
  store i32 %13, ptr %14, align 8, !tbaa !16
  %15 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 1
  %16 = load ptr, ptr %4, align 8, !tbaa !7
  %17 = icmp ult ptr %15, %16
  br i1 %17, label %8, label %18, !llvm.loop !35

18:                                               ; preds = %8, %2
  %19 = phi ptr [ %6, %2 ], [ %16, %8 ]
  %20 = getelementptr inbounds %struct.lua_TValue, ptr %19, i64 -1
  store ptr %20, ptr %4, align 8, !tbaa !7
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define internal fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) unnamed_addr #7 {
  %3 = icmp sgt i32 %1, 0
  br i1 %3, label %4, label %14

4:                                                ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  %6 = load ptr, ptr %5, align 8, !tbaa !17
  %7 = add nsw i32 %1, -1
  %8 = zext i32 %7 to i64
  %9 = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 %8
  %10 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %11 = load ptr, ptr %10, align 8, !tbaa !7
  %12 = icmp ult ptr %9, %11
  %13 = select i1 %12, ptr %9, ptr @luaO_nilobject_
  br label %53

14:                                               ; preds = %2
  %15 = icmp sgt i32 %1, -10000
  br i1 %15, label %16, label %21

16:                                               ; preds = %14
  %17 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %18 = load ptr, ptr %17, align 8, !tbaa !7
  %19 = sext i32 %1 to i64
  %20 = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 %19
  br label %53

21:                                               ; preds = %14
  switch i32 %1, label %38 [
    i32 -10000, label %22
    i32 -10001, label %26
    i32 -10002, label %36
  ]

22:                                               ; preds = %21
  %23 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %24 = load ptr, ptr %23, align 8, !tbaa !25
  %25 = getelementptr inbounds %struct.global_State, ptr %24, i64 0, i32 20
  br label %53

26:                                               ; preds = %21
  %27 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %28 = load ptr, ptr %27, align 8, !tbaa !19
  %29 = getelementptr inbounds %struct.CallInfo, ptr %28, i64 0, i32 1
  %30 = load ptr, ptr %29, align 8, !tbaa !36
  %31 = load ptr, ptr %30, align 8, !tbaa !33
  %32 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 23
  %33 = getelementptr inbounds %struct.CClosure, ptr %31, i64 0, i32 6
  %34 = load ptr, ptr %33, align 8, !tbaa !33
  store ptr %34, ptr %32, align 8, !tbaa !33
  %35 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 23, i32 1
  store i32 5, ptr %35, align 8, !tbaa !16
  br label %53

36:                                               ; preds = %21
  %37 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 22
  br label %53

38:                                               ; preds = %21
  %39 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %40 = load ptr, ptr %39, align 8, !tbaa !19
  %41 = getelementptr inbounds %struct.CallInfo, ptr %40, i64 0, i32 1
  %42 = load ptr, ptr %41, align 8, !tbaa !36
  %43 = load ptr, ptr %42, align 8, !tbaa !33
  %44 = sub nuw nsw i32 -10002, %1
  %45 = getelementptr inbounds %struct.CClosure, ptr %43, i64 0, i32 4
  %46 = load i8, ptr %45, align 1, !tbaa !33
  %47 = zext i8 %46 to i32
  %48 = icmp ugt i32 %44, %47
  %49 = sub nuw nsw i32 -10003, %1
  %50 = zext i32 %49 to i64
  %51 = getelementptr inbounds %struct.CClosure, ptr %43, i64 0, i32 8, i64 %50
  %52 = select i1 %48, ptr @luaO_nilobject_, ptr %51
  br label %53

53:                                               ; preds = %38, %36, %26, %22, %16, %4
  %54 = phi ptr [ %13, %4 ], [ %20, %16 ], [ %52, %38 ], [ %37, %36 ], [ %32, %26 ], [ %25, %22 ]
  ret ptr %54
}

; Function Attrs: nofree norecurse nosync nounwind optsize memory(readwrite, inaccessiblemem: none) uwtable
define internal void @lua_insert(ptr noundef %0, i32 noundef %1) #2 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %5 = load ptr, ptr %4, align 8, !tbaa !7
  %6 = icmp ugt ptr %5, %3
  br i1 %6, label %7, label %17

7:                                                ; preds = %7, %2
  %8 = phi ptr [ %9, %7 ], [ %5, %2 ]
  %9 = getelementptr inbounds %struct.lua_TValue, ptr %8, i64 -1
  %10 = load i64, ptr %9, align 8
  store i64 %10, ptr %8, align 8
  %11 = getelementptr %struct.lua_TValue, ptr %8, i64 -1, i32 1
  %12 = load i32, ptr %11, align 8, !tbaa !16
  %13 = getelementptr inbounds %struct.lua_TValue, ptr %8, i64 0, i32 1
  store i32 %12, ptr %13, align 8, !tbaa !16
  %14 = icmp ugt ptr %9, %3
  br i1 %14, label %7, label %15, !llvm.loop !37

15:                                               ; preds = %7
  %16 = load ptr, ptr %4, align 8, !tbaa !7
  br label %17

17:                                               ; preds = %15, %2
  %18 = phi ptr [ %16, %15 ], [ %5, %2 ]
  %19 = load i64, ptr %18, align 8
  store i64 %19, ptr %3, align 8
  %20 = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 0, i32 1
  %21 = load i32, ptr %20, align 8, !tbaa !16
  %22 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  store i32 %21, ptr %22, align 8, !tbaa !16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @lua_replace(ptr noundef %0, i32 noundef %1) #1 {
  %3 = icmp eq i32 %1, -10001
  br i1 %3, label %4, label %39

4:                                                ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %6 = load ptr, ptr %5, align 8, !tbaa !19
  %7 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %8 = load ptr, ptr %7, align 8, !tbaa !38
  %9 = icmp eq ptr %6, %8
  br i1 %9, label %10, label %11

10:                                               ; preds = %4
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %0, ptr noundef nonnull @.str) #46
  br label %11

11:                                               ; preds = %10, %4
  %12 = tail call fastcc ptr @index2adr(ptr noundef nonnull %0, i32 noundef -10001) #47
  %13 = load ptr, ptr %5, align 8, !tbaa !19
  %14 = getelementptr inbounds %struct.CallInfo, ptr %13, i64 0, i32 1
  %15 = load ptr, ptr %14, align 8, !tbaa !36
  %16 = load ptr, ptr %15, align 8, !tbaa !33
  %17 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %18 = load ptr, ptr %17, align 8, !tbaa !7
  %19 = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 -1
  %20 = load ptr, ptr %19, align 8, !tbaa !33
  %21 = getelementptr inbounds %struct.CClosure, ptr %16, i64 0, i32 6
  store ptr %20, ptr %21, align 8, !tbaa !33
  %22 = load ptr, ptr %17, align 8, !tbaa !7
  %23 = getelementptr %struct.lua_TValue, ptr %22, i64 -1, i32 1
  %24 = load i32, ptr %23, align 8, !tbaa !16
  %25 = icmp sgt i32 %24, 3
  br i1 %25, label %26, label %72

26:                                               ; preds = %11
  %27 = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 -1
  %28 = load ptr, ptr %27, align 8, !tbaa !33
  %29 = getelementptr inbounds %struct.GCheader, ptr %28, i64 0, i32 2
  %30 = load i8, ptr %29, align 1, !tbaa !33
  %31 = and i8 %30, 3
  %32 = icmp eq i8 %31, 0
  br i1 %32, label %72, label %33

33:                                               ; preds = %26
  %34 = getelementptr inbounds %struct.GCheader, ptr %16, i64 0, i32 2
  %35 = load i8, ptr %34, align 1, !tbaa !33
  %36 = and i8 %35, 4
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %72, label %38

38:                                               ; preds = %33
  tail call void @luaC_barrierf(ptr noundef nonnull %0, ptr noundef nonnull %16, ptr noundef nonnull %28) #46
  br label %72

39:                                               ; preds = %2
  %40 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %41 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %42 = load ptr, ptr %41, align 8, !tbaa !7
  %43 = getelementptr inbounds %struct.lua_TValue, ptr %42, i64 -1
  %44 = load i64, ptr %43, align 8
  store i64 %44, ptr %40, align 8
  %45 = getelementptr %struct.lua_TValue, ptr %42, i64 -1, i32 1
  %46 = load i32, ptr %45, align 8, !tbaa !16
  %47 = getelementptr inbounds %struct.lua_TValue, ptr %40, i64 0, i32 1
  store i32 %46, ptr %47, align 8, !tbaa !16
  %48 = icmp slt i32 %1, -10002
  br i1 %48, label %49, label %72

49:                                               ; preds = %39
  %50 = load ptr, ptr %41, align 8, !tbaa !7
  %51 = getelementptr %struct.lua_TValue, ptr %50, i64 -1, i32 1
  %52 = load i32, ptr %51, align 8, !tbaa !16
  %53 = icmp sgt i32 %52, 3
  br i1 %53, label %54, label %72

54:                                               ; preds = %49
  %55 = getelementptr inbounds %struct.lua_TValue, ptr %50, i64 -1
  %56 = load ptr, ptr %55, align 8, !tbaa !33
  %57 = getelementptr inbounds %struct.GCheader, ptr %56, i64 0, i32 2
  %58 = load i8, ptr %57, align 1, !tbaa !33
  %59 = and i8 %58, 3
  %60 = icmp eq i8 %59, 0
  br i1 %60, label %72, label %61

61:                                               ; preds = %54
  %62 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %63 = load ptr, ptr %62, align 8, !tbaa !19
  %64 = getelementptr inbounds %struct.CallInfo, ptr %63, i64 0, i32 1
  %65 = load ptr, ptr %64, align 8, !tbaa !36
  %66 = load ptr, ptr %65, align 8, !tbaa !33
  %67 = getelementptr inbounds %struct.GCheader, ptr %66, i64 0, i32 2
  %68 = load i8, ptr %67, align 1, !tbaa !33
  %69 = and i8 %68, 4
  %70 = icmp eq i8 %69, 0
  br i1 %70, label %72, label %71

71:                                               ; preds = %61
  tail call void @luaC_barrierf(ptr noundef nonnull %0, ptr noundef nonnull %66, ptr noundef nonnull %56) #46
  br label %72

72:                                               ; preds = %71, %61, %54, %49, %39, %38, %33, %26, %11
  %73 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %74 = load ptr, ptr %73, align 8, !tbaa !7
  %75 = getelementptr inbounds %struct.lua_TValue, ptr %74, i64 -1
  store ptr %75, ptr %73, align 8, !tbaa !7
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable
define internal void @lua_pushvalue(ptr noundef %0, i32 noundef %1) #4 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %5 = load ptr, ptr %4, align 8, !tbaa !7
  %6 = load i64, ptr %3, align 8
  store i64 %6, ptr %5, align 8
  %7 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %8 = load i32, ptr %7, align 8, !tbaa !16
  %9 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 0, i32 1
  store i32 %8, ptr %9, align 8, !tbaa !16
  %10 = load ptr, ptr %4, align 8, !tbaa !7
  %11 = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 1
  store ptr %11, ptr %4, align 8, !tbaa !7
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define internal i32 @lua_type(ptr noundef %0, i32 noundef %1) #7 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = icmp eq ptr %3, @luaO_nilobject_
  br i1 %4, label %8, label %5

5:                                                ; preds = %2
  %6 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %7 = load i32, ptr %6, align 8, !tbaa !16
  br label %8

8:                                                ; preds = %5, %2
  %9 = phi i32 [ %7, %5 ], [ -1, %2 ]
  ret i32 %9
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable
define internal ptr @lua_typename(ptr nocapture noundef readnone %0, i32 noundef %1) #8 {
  %3 = icmp eq i32 %1, -1
  br i1 %3, label %8, label %4

4:                                                ; preds = %2
  %5 = sext i32 %1 to i64
  %6 = getelementptr inbounds [0 x ptr], ptr @luaT_typenames, i64 0, i64 %5
  %7 = load ptr, ptr %6, align 8, !tbaa !39
  br label %8

8:                                                ; preds = %4, %2
  %9 = phi ptr [ %7, %4 ], [ @.str.1, %2 ]
  ret ptr %9
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define internal i32 @lua_iscfunction(ptr noundef %0, i32 noundef %1) #7 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  %6 = icmp eq i32 %5, 6
  br i1 %6, label %7, label %13

7:                                                ; preds = %2
  %8 = load ptr, ptr %3, align 8, !tbaa !33
  %9 = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 3
  %10 = load i8, ptr %9, align 2, !tbaa !33
  %11 = icmp ne i8 %10, 0
  %12 = zext i1 %11 to i32
  br label %13

13:                                               ; preds = %7, %2
  %14 = phi i32 [ 0, %2 ], [ %12, %7 ]
  ret i32 %14
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_isnumber(ptr noundef %0, i32 noundef %1) #1 {
  %3 = alloca %struct.lua_TValue, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %3) #48
  %4 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %5 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  %6 = load i32, ptr %5, align 8, !tbaa !16
  %7 = icmp eq i32 %6, 3
  br i1 %7, label %12, label %8

8:                                                ; preds = %2
  %9 = call ptr @luaV_tonumber(ptr noundef nonnull %4, ptr noundef nonnull %3) #46
  %10 = icmp ne ptr %9, null
  %11 = zext i1 %10 to i32
  br label %12

12:                                               ; preds = %8, %2
  %13 = phi i32 [ 1, %2 ], [ %11, %8 ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %3) #48
  ret i32 %13
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #9

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #9

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define internal i32 @lua_isstring(ptr noundef %0, i32 noundef %1) #7 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = icmp eq ptr %3, @luaO_nilobject_
  br i1 %4, label %11, label %5

5:                                                ; preds = %2
  %6 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %7 = load i32, ptr %6, align 8, !tbaa !16
  %8 = add i32 %7, -3
  %9 = icmp ult i32 %8, 2
  %10 = zext i1 %9 to i32
  br label %11

11:                                               ; preds = %5, %2
  %12 = phi i32 [ %10, %5 ], [ 0, %2 ]
  ret i32 %12
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_rawequal(ptr noundef %0, i32 noundef %1, i32 noundef %2) #1 {
  %4 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %5 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %2) #47
  %6 = icmp eq ptr %4, @luaO_nilobject_
  %7 = icmp eq ptr %5, @luaO_nilobject_
  %8 = select i1 %6, i1 true, i1 %7
  br i1 %8, label %11, label %9

9:                                                ; preds = %3
  %10 = tail call i32 @luaO_rawequalObj(ptr noundef %4, ptr noundef %5) #46
  br label %11

11:                                               ; preds = %9, %3
  %12 = phi i32 [ %10, %9 ], [ 0, %3 ]
  ret i32 %12
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_lessthan(ptr noundef %0, i32 noundef %1, i32 noundef %2) #1 {
  %4 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %5 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %2) #47
  %6 = icmp eq ptr %4, @luaO_nilobject_
  %7 = icmp eq ptr %5, @luaO_nilobject_
  %8 = select i1 %6, i1 true, i1 %7
  br i1 %8, label %11, label %9

9:                                                ; preds = %3
  %10 = tail call i32 @luaV_lessthan(ptr noundef %0, ptr noundef %4, ptr noundef %5) #46
  br label %11

11:                                               ; preds = %9, %3
  %12 = phi i32 [ %10, %9 ], [ 0, %3 ]
  ret i32 %12
}

; Function Attrs: nounwind optsize uwtable
define internal double @lua_tonumber(ptr noundef %0, i32 noundef %1) #1 {
  %3 = alloca %struct.lua_TValue, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %3) #48
  %4 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %5 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  %6 = load i32, ptr %5, align 8, !tbaa !16
  %7 = icmp eq i32 %6, 3
  br i1 %7, label %11, label %8

8:                                                ; preds = %2
  %9 = call ptr @luaV_tonumber(ptr noundef nonnull %4, ptr noundef nonnull %3) #46
  %10 = icmp eq ptr %9, null
  br i1 %10, label %14, label %11

11:                                               ; preds = %8, %2
  %12 = phi ptr [ %4, %2 ], [ %9, %8 ]
  %13 = load double, ptr %12, align 8, !tbaa !33
  br label %14

14:                                               ; preds = %11, %8
  %15 = phi double [ %13, %11 ], [ 0.000000e+00, %8 ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %3) #48
  ret double %15
}

; Function Attrs: nounwind optsize uwtable
define internal i64 @lua_tointeger(ptr noundef %0, i32 noundef %1) #1 {
  %3 = alloca %struct.lua_TValue, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %3) #48
  %4 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %5 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  %6 = load i32, ptr %5, align 8, !tbaa !16
  %7 = icmp eq i32 %6, 3
  br i1 %7, label %11, label %8

8:                                                ; preds = %2
  %9 = call ptr @luaV_tonumber(ptr noundef nonnull %4, ptr noundef nonnull %3) #46
  %10 = icmp eq ptr %9, null
  br i1 %10, label %15, label %11

11:                                               ; preds = %8, %2
  %12 = phi ptr [ %4, %2 ], [ %9, %8 ]
  %13 = load double, ptr %12, align 8, !tbaa !33
  %14 = fptosi double %13 to i64
  br label %15

15:                                               ; preds = %11, %8
  %16 = phi i64 [ %14, %11 ], [ 0, %8 ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %3) #48
  ret i64 %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define internal i32 @lua_toboolean(ptr noundef %0, i32 noundef %1) #7 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  switch i32 %5, label %10 [
    i32 0, label %11
    i32 1, label %6
  ]

6:                                                ; preds = %2
  %7 = load i32, ptr %3, align 8, !tbaa !33
  %8 = icmp ne i32 %7, 0
  %9 = zext i1 %8 to i32
  br label %11

10:                                               ; preds = %2
  br label %11

11:                                               ; preds = %10, %6, %2
  %12 = phi i32 [ %5, %2 ], [ %9, %6 ], [ 1, %10 ]
  ret i32 %12
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @lua_tolstring(ptr noundef %0, i32 noundef %1, ptr noundef writeonly %2) #1 {
  %4 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %5 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  %6 = load i32, ptr %5, align 8, !tbaa !16
  %7 = icmp eq i32 %6, 4
  br i1 %7, label %25, label %8

8:                                                ; preds = %3
  %9 = tail call i32 @luaV_tostring(ptr noundef %0, ptr noundef nonnull %4) #46
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %11, label %14

11:                                               ; preds = %8
  %12 = icmp eq ptr %2, null
  br i1 %12, label %35, label %13

13:                                               ; preds = %11
  store i64 0, ptr %2, align 8, !tbaa !40
  br label %35

14:                                               ; preds = %8
  %15 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %16 = load ptr, ptr %15, align 8, !tbaa !25
  %17 = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 14
  %18 = load i64, ptr %17, align 8, !tbaa !31
  %19 = getelementptr inbounds %struct.global_State, ptr %16, i64 0, i32 13
  %20 = load i64, ptr %19, align 8, !tbaa !32
  %21 = icmp ult i64 %18, %20
  br i1 %21, label %23, label %22

22:                                               ; preds = %14
  tail call void @luaC_step(ptr noundef nonnull %0) #46
  br label %23

23:                                               ; preds = %22, %14
  %24 = tail call fastcc ptr @index2adr(ptr noundef nonnull %0, i32 noundef %1) #47
  br label %25

25:                                               ; preds = %23, %3
  %26 = phi ptr [ %4, %3 ], [ %24, %23 ]
  %27 = icmp eq ptr %2, null
  br i1 %27, label %32, label %28

28:                                               ; preds = %25
  %29 = load ptr, ptr %26, align 8, !tbaa !33
  %30 = getelementptr inbounds %struct.anon.0, ptr %29, i64 0, i32 5
  %31 = load i64, ptr %30, align 8, !tbaa !33
  store i64 %31, ptr %2, align 8, !tbaa !40
  br label %32

32:                                               ; preds = %28, %25
  %33 = load ptr, ptr %26, align 8, !tbaa !33
  %34 = getelementptr inbounds %union.TString, ptr %33, i64 1
  br label %35

35:                                               ; preds = %32, %13, %11
  %36 = phi ptr [ %34, %32 ], [ null, %13 ], [ null, %11 ]
  ret ptr %36
}

; Function Attrs: nounwind optsize uwtable
define internal i64 @lua_objlen(ptr noundef %0, i32 noundef %1) #1 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  switch i32 %5, label %25 [
    i32 4, label %6
    i32 7, label %10
    i32 5, label %14
    i32 3, label %18
  ]

6:                                                ; preds = %2
  %7 = load ptr, ptr %3, align 8, !tbaa !33
  %8 = getelementptr inbounds %struct.anon.0, ptr %7, i64 0, i32 5
  %9 = load i64, ptr %8, align 8, !tbaa !33
  br label %25

10:                                               ; preds = %2
  %11 = load ptr, ptr %3, align 8, !tbaa !33
  %12 = getelementptr inbounds %struct.anon.1, ptr %11, i64 0, i32 5
  %13 = load i64, ptr %12, align 8, !tbaa !33
  br label %25

14:                                               ; preds = %2
  %15 = load ptr, ptr %3, align 8, !tbaa !33
  %16 = tail call i32 @luaH_getn(ptr noundef %15) #46
  %17 = sext i32 %16 to i64
  br label %25

18:                                               ; preds = %2
  %19 = tail call i32 @luaV_tostring(ptr noundef %0, ptr noundef nonnull %3) #46
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %25, label %21

21:                                               ; preds = %18
  %22 = load ptr, ptr %3, align 8, !tbaa !33
  %23 = getelementptr inbounds %struct.anon.0, ptr %22, i64 0, i32 5
  %24 = load i64, ptr %23, align 8, !tbaa !33
  br label %25

25:                                               ; preds = %21, %18, %14, %10, %6, %2
  %26 = phi i64 [ %17, %14 ], [ %13, %10 ], [ %9, %6 ], [ %24, %21 ], [ 0, %18 ], [ 0, %2 ]
  ret i64 %26
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define internal ptr @lua_tocfunction(ptr noundef %0, i32 noundef %1) #7 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  %6 = icmp eq i32 %5, 6
  br i1 %6, label %7, label %15

7:                                                ; preds = %2
  %8 = load ptr, ptr %3, align 8, !tbaa !33
  %9 = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 3
  %10 = load i8, ptr %9, align 2, !tbaa !33
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %15, label %12

12:                                               ; preds = %7
  %13 = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 7
  %14 = load ptr, ptr %13, align 8, !tbaa !33
  br label %15

15:                                               ; preds = %12, %7, %2
  %16 = phi ptr [ %14, %12 ], [ null, %7 ], [ null, %2 ]
  ret ptr %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define internal ptr @lua_touserdata(ptr noundef %0, i32 noundef %1) #7 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  switch i32 %5, label %11 [
    i32 7, label %6
    i32 2, label %9
  ]

6:                                                ; preds = %2
  %7 = load ptr, ptr %3, align 8, !tbaa !33
  %8 = getelementptr inbounds %union.Udata, ptr %7, i64 1
  br label %11

9:                                                ; preds = %2
  %10 = load ptr, ptr %3, align 8, !tbaa !33
  br label %11

11:                                               ; preds = %9, %6, %2
  %12 = phi ptr [ %10, %9 ], [ %8, %6 ], [ null, %2 ]
  ret ptr %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define internal ptr @lua_tothread(ptr noundef %0, i32 noundef %1) #7 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  %6 = icmp eq i32 %5, 8
  br i1 %6, label %7, label %9

7:                                                ; preds = %2
  %8 = load ptr, ptr %3, align 8, !tbaa !33
  br label %9

9:                                                ; preds = %7, %2
  %10 = phi ptr [ %8, %7 ], [ null, %2 ]
  ret ptr %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define internal ptr @lua_topointer(ptr noundef %0, i32 noundef %1) #7 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  switch i32 %5, label %21 [
    i32 5, label %6
    i32 6, label %8
    i32 8, label %10
    i32 7, label %12
    i32 2, label %12
  ]

6:                                                ; preds = %2
  %7 = load ptr, ptr %3, align 8, !tbaa !33
  br label %21

8:                                                ; preds = %2
  %9 = load ptr, ptr %3, align 8, !tbaa !33
  br label %21

10:                                               ; preds = %2
  %11 = load ptr, ptr %3, align 8, !tbaa !33
  br label %21

12:                                               ; preds = %2, %2
  %13 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %14 = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 0, i32 1
  %15 = load i32, ptr %14, align 8, !tbaa !16
  switch i32 %15, label %21 [
    i32 7, label %16
    i32 2, label %19
  ]

16:                                               ; preds = %12
  %17 = load ptr, ptr %13, align 8, !tbaa !33
  %18 = getelementptr inbounds %union.Udata, ptr %17, i64 1
  br label %21

19:                                               ; preds = %12
  %20 = load ptr, ptr %13, align 8, !tbaa !33
  br label %21

21:                                               ; preds = %19, %16, %12, %10, %8, %6, %2
  %22 = phi ptr [ %11, %10 ], [ %9, %8 ], [ %7, %6 ], [ null, %2 ], [ %20, %19 ], [ %18, %16 ], [ null, %12 ]
  ret ptr %22
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(write, argmem: readwrite, inaccessiblemem: none) uwtable
define internal void @lua_pushnil(ptr nocapture noundef %0) #0 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %3 = load ptr, ptr %2, align 8, !tbaa !7
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  store i32 0, ptr %4, align 8, !tbaa !16
  %5 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 1
  store ptr %5, ptr %2, align 8, !tbaa !7
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(write, argmem: readwrite, inaccessiblemem: none) uwtable
define internal void @lua_pushnumber(ptr nocapture noundef %0, double noundef %1) #0 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %4 = load ptr, ptr %3, align 8, !tbaa !7
  store double %1, ptr %4, align 8, !tbaa !33
  %5 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  store i32 3, ptr %5, align 8, !tbaa !16
  %6 = load ptr, ptr %3, align 8, !tbaa !7
  %7 = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 1
  store ptr %7, ptr %3, align 8, !tbaa !7
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(write, argmem: readwrite, inaccessiblemem: none) uwtable
define internal void @lua_pushinteger(ptr nocapture noundef %0, i64 noundef %1) #0 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %4 = load ptr, ptr %3, align 8, !tbaa !7
  %5 = sitofp i64 %1 to double
  store double %5, ptr %4, align 8, !tbaa !33
  %6 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  store i32 3, ptr %6, align 8, !tbaa !16
  %7 = load ptr, ptr %3, align 8, !tbaa !7
  %8 = getelementptr inbounds %struct.lua_TValue, ptr %7, i64 1
  store ptr %8, ptr %3, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @lua_pushlstring(ptr noundef %0, ptr noundef %1, i64 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %5 = load ptr, ptr %4, align 8, !tbaa !25
  %6 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 14
  %7 = load i64, ptr %6, align 8, !tbaa !31
  %8 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 13
  %9 = load i64, ptr %8, align 8, !tbaa !32
  %10 = icmp ult i64 %7, %9
  br i1 %10, label %12, label %11

11:                                               ; preds = %3
  tail call void @luaC_step(ptr noundef nonnull %0) #46
  br label %12

12:                                               ; preds = %11, %3
  %13 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %14 = load ptr, ptr %13, align 8, !tbaa !7
  %15 = tail call ptr @luaS_newlstr(ptr noundef nonnull %0, ptr noundef %1, i64 noundef %2) #46
  store ptr %15, ptr %14, align 8, !tbaa !33
  %16 = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 0, i32 1
  store i32 4, ptr %16, align 8, !tbaa !16
  %17 = load ptr, ptr %13, align 8, !tbaa !7
  %18 = getelementptr inbounds %struct.lua_TValue, ptr %17, i64 1
  store ptr %18, ptr %13, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @lua_pushstring(ptr noundef %0, ptr noundef %1) #1 {
  %3 = icmp eq ptr %1, null
  br i1 %3, label %4, label %9

4:                                                ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %6 = load ptr, ptr %5, align 8, !tbaa !7
  %7 = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 0, i32 1
  store i32 0, ptr %7, align 8, !tbaa !16
  %8 = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 1
  store ptr %8, ptr %5, align 8, !tbaa !7
  br label %11

9:                                                ; preds = %2
  %10 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %1) #49
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull %1, i64 noundef %10) #47
  br label %11

11:                                               ; preds = %9, %4
  ret void
}

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(argmem: read)
declare i64 @strlen(ptr nocapture noundef) local_unnamed_addr #10

; Function Attrs: nounwind optsize uwtable
define internal ptr @lua_pushvfstring(ptr noundef %0, ptr noundef %1, ptr noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %5 = load ptr, ptr %4, align 8, !tbaa !25
  %6 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 14
  %7 = load i64, ptr %6, align 8, !tbaa !31
  %8 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 13
  %9 = load i64, ptr %8, align 8, !tbaa !32
  %10 = icmp ult i64 %7, %9
  br i1 %10, label %12, label %11

11:                                               ; preds = %3
  tail call void @luaC_step(ptr noundef nonnull %0) #46
  br label %12

12:                                               ; preds = %11, %3
  %13 = tail call ptr @luaO_pushvfstring(ptr noundef nonnull %0, ptr noundef %1, ptr noundef %2) #46
  ret ptr %13
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @lua_pushfstring(ptr noundef %0, ptr noundef %1, ...) #1 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3) #48
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %5 = load ptr, ptr %4, align 8, !tbaa !25
  %6 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 14
  %7 = load i64, ptr %6, align 8, !tbaa !31
  %8 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 13
  %9 = load i64, ptr %8, align 8, !tbaa !32
  %10 = icmp ult i64 %7, %9
  br i1 %10, label %12, label %11

11:                                               ; preds = %2
  tail call void @luaC_step(ptr noundef nonnull %0) #46
  br label %12

12:                                               ; preds = %11, %2
  call void @llvm.va_start(ptr nonnull %3)
  %13 = call ptr @luaO_pushvfstring(ptr noundef nonnull %0, ptr noundef %1, ptr noundef nonnull %3) #46
  call void @llvm.va_end(ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3) #48
  ret ptr %13
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_start(ptr) #11

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_end(ptr) #11

; Function Attrs: nounwind optsize uwtable
define internal void @lua_pushcclosure(ptr noundef %0, ptr noundef %1, i32 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %5 = load ptr, ptr %4, align 8, !tbaa !25
  %6 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 14
  %7 = load i64, ptr %6, align 8, !tbaa !31
  %8 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 13
  %9 = load i64, ptr %8, align 8, !tbaa !32
  %10 = icmp ult i64 %7, %9
  br i1 %10, label %12, label %11

11:                                               ; preds = %3
  tail call void @luaC_step(ptr noundef nonnull %0) #46
  br label %12

12:                                               ; preds = %11, %3
  %13 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %14 = load ptr, ptr %13, align 8, !tbaa !19
  %15 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %16 = load ptr, ptr %15, align 8, !tbaa !38
  %17 = icmp eq ptr %14, %16
  br i1 %17, label %18, label %20

18:                                               ; preds = %12
  %19 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 22
  br label %25

20:                                               ; preds = %12
  %21 = getelementptr inbounds %struct.CallInfo, ptr %14, i64 0, i32 1
  %22 = load ptr, ptr %21, align 8, !tbaa !36
  %23 = load ptr, ptr %22, align 8, !tbaa !33
  %24 = getelementptr inbounds %struct.CClosure, ptr %23, i64 0, i32 6
  br label %25

25:                                               ; preds = %20, %18
  %26 = phi ptr [ %19, %18 ], [ %24, %20 ]
  %27 = load ptr, ptr %26, align 8, !tbaa !33
  %28 = tail call ptr @luaF_newCclosure(ptr noundef nonnull %0, i32 noundef %2, ptr noundef %27) #46
  %29 = getelementptr inbounds %struct.CClosure, ptr %28, i64 0, i32 7
  store ptr %1, ptr %29, align 8, !tbaa !33
  %30 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %31 = load ptr, ptr %30, align 8, !tbaa !7
  %32 = sext i32 %2 to i64
  %33 = sub nsw i64 0, %32
  %34 = getelementptr inbounds %struct.lua_TValue, ptr %31, i64 %33
  store ptr %34, ptr %30, align 8, !tbaa !7
  %35 = icmp eq i32 %2, 0
  br i1 %35, label %50, label %36

36:                                               ; preds = %36, %25
  %37 = phi i64 [ %38, %36 ], [ %32, %25 ]
  %38 = add nsw i64 %37, -1
  %39 = load ptr, ptr %30, align 8, !tbaa !7
  %40 = getelementptr inbounds %struct.lua_TValue, ptr %39, i64 %38
  %41 = getelementptr inbounds %struct.CClosure, ptr %28, i64 0, i32 8, i64 %38
  %42 = load i64, ptr %40, align 8
  store i64 %42, ptr %41, align 8
  %43 = getelementptr inbounds %struct.lua_TValue, ptr %39, i64 %38, i32 1
  %44 = load i32, ptr %43, align 8, !tbaa !16
  %45 = getelementptr inbounds %struct.CClosure, ptr %28, i64 0, i32 8, i64 %38, i32 1
  store i32 %44, ptr %45, align 8, !tbaa !16
  %46 = and i64 %38, 4294967295
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %48, label %36, !llvm.loop !41

48:                                               ; preds = %36
  %49 = load ptr, ptr %30, align 8, !tbaa !7
  br label %50

50:                                               ; preds = %48, %25
  %51 = phi ptr [ %49, %48 ], [ %34, %25 ]
  store ptr %28, ptr %51, align 8, !tbaa !33
  %52 = getelementptr inbounds %struct.lua_TValue, ptr %51, i64 0, i32 1
  store i32 6, ptr %52, align 8, !tbaa !16
  %53 = load ptr, ptr %30, align 8, !tbaa !7
  %54 = getelementptr inbounds %struct.lua_TValue, ptr %53, i64 1
  store ptr %54, ptr %30, align 8, !tbaa !7
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(write, argmem: readwrite, inaccessiblemem: none) uwtable
define internal void @lua_pushboolean(ptr nocapture noundef %0, i32 noundef %1) #0 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %4 = load ptr, ptr %3, align 8, !tbaa !7
  %5 = icmp ne i32 %1, 0
  %6 = zext i1 %5 to i32
  store i32 %6, ptr %4, align 8, !tbaa !33
  %7 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  store i32 1, ptr %7, align 8, !tbaa !16
  %8 = load ptr, ptr %3, align 8, !tbaa !7
  %9 = getelementptr inbounds %struct.lua_TValue, ptr %8, i64 1
  store ptr %9, ptr %3, align 8, !tbaa !7
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(write, argmem: readwrite, inaccessiblemem: none) uwtable
define internal void @lua_pushlightuserdata(ptr nocapture noundef %0, ptr noundef %1) #0 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %4 = load ptr, ptr %3, align 8, !tbaa !7
  store ptr %1, ptr %4, align 8, !tbaa !33
  %5 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  store i32 2, ptr %5, align 8, !tbaa !16
  %6 = load ptr, ptr %3, align 8, !tbaa !7
  %7 = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 1
  store ptr %7, ptr %3, align 8, !tbaa !7
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable
define internal i32 @lua_pushthread(ptr noundef %0) #4 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %3 = load ptr, ptr %2, align 8, !tbaa !7
  store ptr %0, ptr %3, align 8, !tbaa !33
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  store i32 8, ptr %4, align 8, !tbaa !16
  %5 = load ptr, ptr %2, align 8, !tbaa !7
  %6 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 1
  store ptr %6, ptr %2, align 8, !tbaa !7
  %7 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %8 = load ptr, ptr %7, align 8, !tbaa !25
  %9 = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 21
  %10 = load ptr, ptr %9, align 8, !tbaa !42
  %11 = icmp eq ptr %10, %0
  %12 = zext i1 %11 to i32
  ret i32 %12
}

; Function Attrs: nounwind optsize uwtable
define internal void @lua_gettable(ptr noundef %0, i32 noundef %1) #1 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %5 = load ptr, ptr %4, align 8, !tbaa !7
  %6 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 -1
  tail call void @luaV_gettable(ptr noundef %0, ptr noundef %3, ptr noundef nonnull %6, ptr noundef nonnull %6) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @lua_getfield(ptr noundef %0, i32 noundef %1, ptr noundef %2) #1 {
  %4 = alloca %struct.lua_TValue, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %4) #48
  %5 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %6 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %2) #49
  %7 = tail call ptr @luaS_newlstr(ptr noundef %0, ptr noundef %2, i64 noundef %6) #46
  store ptr %7, ptr %4, align 8, !tbaa !33
  %8 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  store i32 4, ptr %8, align 8, !tbaa !16
  %9 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %10 = load ptr, ptr %9, align 8, !tbaa !7
  call void @luaV_gettable(ptr noundef %0, ptr noundef %5, ptr noundef nonnull %4, ptr noundef %10) #46
  %11 = load ptr, ptr %9, align 8, !tbaa !7
  %12 = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 1
  store ptr %12, ptr %9, align 8, !tbaa !7
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %4) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @lua_rawget(ptr noundef %0, i32 noundef %1) #1 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = load ptr, ptr %3, align 8, !tbaa !33
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %6 = load ptr, ptr %5, align 8, !tbaa !7
  %7 = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 -1
  %8 = tail call ptr @luaH_get(ptr noundef %4, ptr noundef nonnull %7) #46
  %9 = load ptr, ptr %5, align 8, !tbaa !7
  %10 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 -1
  %11 = load i64, ptr %8, align 8
  store i64 %11, ptr %10, align 8
  %12 = getelementptr inbounds %struct.lua_TValue, ptr %8, i64 0, i32 1
  %13 = load i32, ptr %12, align 8, !tbaa !16
  %14 = getelementptr %struct.lua_TValue, ptr %9, i64 -1, i32 1
  store i32 %13, ptr %14, align 8, !tbaa !16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @lua_rawgeti(ptr noundef %0, i32 noundef %1, i32 noundef %2) #1 {
  %4 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %5 = load ptr, ptr %4, align 8, !tbaa !33
  %6 = tail call ptr @luaH_getnum(ptr noundef %5, i32 noundef %2) #46
  %7 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %8 = load ptr, ptr %7, align 8, !tbaa !7
  %9 = load i64, ptr %6, align 8
  store i64 %9, ptr %8, align 8
  %10 = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 0, i32 1
  %11 = load i32, ptr %10, align 8, !tbaa !16
  %12 = getelementptr inbounds %struct.lua_TValue, ptr %8, i64 0, i32 1
  store i32 %11, ptr %12, align 8, !tbaa !16
  %13 = load ptr, ptr %7, align 8, !tbaa !7
  %14 = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 1
  store ptr %14, ptr %7, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @lua_createtable(ptr noundef %0, i32 noundef %1, i32 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %5 = load ptr, ptr %4, align 8, !tbaa !25
  %6 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 14
  %7 = load i64, ptr %6, align 8, !tbaa !31
  %8 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 13
  %9 = load i64, ptr %8, align 8, !tbaa !32
  %10 = icmp ult i64 %7, %9
  br i1 %10, label %12, label %11

11:                                               ; preds = %3
  tail call void @luaC_step(ptr noundef nonnull %0) #46
  br label %12

12:                                               ; preds = %11, %3
  %13 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %14 = load ptr, ptr %13, align 8, !tbaa !7
  %15 = tail call ptr @luaH_new(ptr noundef nonnull %0, i32 noundef %1, i32 noundef %2) #46
  store ptr %15, ptr %14, align 8, !tbaa !33
  %16 = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 0, i32 1
  store i32 5, ptr %16, align 8, !tbaa !16
  %17 = load ptr, ptr %13, align 8, !tbaa !7
  %18 = getelementptr inbounds %struct.lua_TValue, ptr %17, i64 1
  store ptr %18, ptr %13, align 8, !tbaa !7
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable
define internal i32 @lua_getmetatable(ptr noundef %0, i32 noundef %1) #4 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  switch i32 %5, label %12 [
    i32 5, label %6
    i32 7, label %9
  ]

6:                                                ; preds = %2
  %7 = load ptr, ptr %3, align 8, !tbaa !33
  %8 = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 5
  br label %17

9:                                                ; preds = %2
  %10 = load ptr, ptr %3, align 8, !tbaa !33
  %11 = getelementptr inbounds %struct.anon.1, ptr %10, i64 0, i32 3
  br label %17

12:                                               ; preds = %2
  %13 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %14 = load ptr, ptr %13, align 8, !tbaa !25
  %15 = sext i32 %5 to i64
  %16 = getelementptr inbounds %struct.global_State, ptr %14, i64 0, i32 23, i64 %15
  br label %17

17:                                               ; preds = %12, %9, %6
  %18 = phi ptr [ %16, %12 ], [ %11, %9 ], [ %8, %6 ]
  %19 = load ptr, ptr %18, align 8, !tbaa !33
  %20 = icmp eq ptr %19, null
  br i1 %20, label %27, label %21

21:                                               ; preds = %17
  %22 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %23 = load ptr, ptr %22, align 8, !tbaa !7
  store ptr %19, ptr %23, align 8, !tbaa !33
  %24 = getelementptr inbounds %struct.lua_TValue, ptr %23, i64 0, i32 1
  store i32 5, ptr %24, align 8, !tbaa !16
  %25 = load ptr, ptr %22, align 8, !tbaa !7
  %26 = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 1
  store ptr %26, ptr %22, align 8, !tbaa !7
  br label %27

27:                                               ; preds = %21, %17
  %28 = phi i32 [ 1, %21 ], [ 0, %17 ]
  ret i32 %28
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable
define internal void @lua_getfenv(ptr noundef %0, i32 noundef %1) #4 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  switch i32 %5, label %26 [
    i32 6, label %6
    i32 7, label %12
    i32 8, label %18
  ]

6:                                                ; preds = %2
  %7 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %8 = load ptr, ptr %7, align 8, !tbaa !7
  %9 = load ptr, ptr %3, align 8, !tbaa !33
  %10 = getelementptr inbounds %struct.CClosure, ptr %9, i64 0, i32 6
  %11 = load ptr, ptr %10, align 8, !tbaa !33
  store ptr %11, ptr %8, align 8, !tbaa !33
  br label %29

12:                                               ; preds = %2
  %13 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %14 = load ptr, ptr %13, align 8, !tbaa !7
  %15 = load ptr, ptr %3, align 8, !tbaa !33
  %16 = getelementptr inbounds %struct.anon.1, ptr %15, i64 0, i32 4
  %17 = load ptr, ptr %16, align 8, !tbaa !33
  store ptr %17, ptr %14, align 8, !tbaa !33
  br label %29

18:                                               ; preds = %2
  %19 = load ptr, ptr %3, align 8, !tbaa !33
  %20 = getelementptr inbounds %struct.lua_State, ptr %19, i64 0, i32 22
  %21 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %22 = load ptr, ptr %21, align 8, !tbaa !7
  %23 = load i64, ptr %20, align 8
  store i64 %23, ptr %22, align 8
  %24 = getelementptr inbounds %struct.lua_State, ptr %19, i64 0, i32 22, i32 1
  %25 = load i32, ptr %24, align 8, !tbaa !16
  br label %29

26:                                               ; preds = %2
  %27 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %28 = load ptr, ptr %27, align 8, !tbaa !7
  br label %29

29:                                               ; preds = %26, %18, %12, %6
  %30 = phi ptr [ %28, %26 ], [ %22, %18 ], [ %14, %12 ], [ %8, %6 ]
  %31 = phi i32 [ 0, %26 ], [ %25, %18 ], [ 5, %12 ], [ 5, %6 ]
  %32 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 0, i32 1
  store i32 %31, ptr %32, align 8, !tbaa !16
  %33 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %34 = load ptr, ptr %33, align 8, !tbaa !7
  %35 = getelementptr inbounds %struct.lua_TValue, ptr %34, i64 1
  store ptr %35, ptr %33, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @lua_settable(ptr noundef %0, i32 noundef %1) #1 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %5 = load ptr, ptr %4, align 8, !tbaa !7
  %6 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 -2
  %7 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 -1
  tail call void @luaV_settable(ptr noundef %0, ptr noundef %3, ptr noundef nonnull %6, ptr noundef nonnull %7) #46
  %8 = load ptr, ptr %4, align 8, !tbaa !7
  %9 = getelementptr inbounds %struct.lua_TValue, ptr %8, i64 -2
  store ptr %9, ptr %4, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @lua_setfield(ptr noundef %0, i32 noundef %1, ptr noundef %2) #1 {
  %4 = alloca %struct.lua_TValue, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %4) #48
  %5 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %6 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %2) #49
  %7 = tail call ptr @luaS_newlstr(ptr noundef %0, ptr noundef %2, i64 noundef %6) #46
  store ptr %7, ptr %4, align 8, !tbaa !33
  %8 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  store i32 4, ptr %8, align 8, !tbaa !16
  %9 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %10 = load ptr, ptr %9, align 8, !tbaa !7
  %11 = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 -1
  call void @luaV_settable(ptr noundef %0, ptr noundef %5, ptr noundef nonnull %4, ptr noundef nonnull %11) #46
  %12 = load ptr, ptr %9, align 8, !tbaa !7
  %13 = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 -1
  store ptr %13, ptr %9, align 8, !tbaa !7
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %4) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @lua_rawset(ptr noundef %0, i32 noundef %1) #1 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %5 = load ptr, ptr %4, align 8, !tbaa !7
  %6 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 -1
  %7 = load ptr, ptr %3, align 8, !tbaa !33
  %8 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 -2
  %9 = tail call ptr @luaH_set(ptr noundef %0, ptr noundef %7, ptr noundef nonnull %8) #46
  %10 = load i64, ptr %6, align 8
  store i64 %10, ptr %9, align 8
  %11 = getelementptr %struct.lua_TValue, ptr %5, i64 -1, i32 1
  %12 = load i32, ptr %11, align 8, !tbaa !16
  %13 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 0, i32 1
  store i32 %12, ptr %13, align 8, !tbaa !16
  %14 = load ptr, ptr %4, align 8, !tbaa !7
  %15 = getelementptr %struct.lua_TValue, ptr %14, i64 -1, i32 1
  %16 = load i32, ptr %15, align 8, !tbaa !16
  %17 = icmp sgt i32 %16, 3
  br i1 %17, label %18, label %33

18:                                               ; preds = %2
  %19 = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 -1
  %20 = load ptr, ptr %19, align 8, !tbaa !33
  %21 = getelementptr inbounds %struct.GCheader, ptr %20, i64 0, i32 2
  %22 = load i8, ptr %21, align 1, !tbaa !33
  %23 = and i8 %22, 3
  %24 = icmp eq i8 %23, 0
  br i1 %24, label %33, label %25

25:                                               ; preds = %18
  %26 = load ptr, ptr %3, align 8, !tbaa !33
  %27 = getelementptr inbounds %struct.GCheader, ptr %26, i64 0, i32 2
  %28 = load i8, ptr %27, align 1, !tbaa !33
  %29 = and i8 %28, 4
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %33, label %31

31:                                               ; preds = %25
  tail call void @luaC_barrierback(ptr noundef nonnull %0, ptr noundef nonnull %26) #46
  %32 = load ptr, ptr %4, align 8, !tbaa !7
  br label %33

33:                                               ; preds = %31, %25, %18, %2
  %34 = phi ptr [ %32, %31 ], [ %14, %25 ], [ %14, %18 ], [ %14, %2 ]
  %35 = getelementptr inbounds %struct.lua_TValue, ptr %34, i64 -2
  store ptr %35, ptr %4, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @lua_rawseti(ptr noundef %0, i32 noundef %1, i32 noundef %2) #1 {
  %4 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %6 = load ptr, ptr %5, align 8, !tbaa !7
  %7 = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 -1
  %8 = load ptr, ptr %4, align 8, !tbaa !33
  %9 = tail call ptr @luaH_setnum(ptr noundef %0, ptr noundef %8, i32 noundef %2) #46
  %10 = load i64, ptr %7, align 8
  store i64 %10, ptr %9, align 8
  %11 = getelementptr %struct.lua_TValue, ptr %6, i64 -1, i32 1
  %12 = load i32, ptr %11, align 8, !tbaa !16
  %13 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 0, i32 1
  store i32 %12, ptr %13, align 8, !tbaa !16
  %14 = load ptr, ptr %5, align 8, !tbaa !7
  %15 = getelementptr %struct.lua_TValue, ptr %14, i64 -1, i32 1
  %16 = load i32, ptr %15, align 8, !tbaa !16
  %17 = icmp sgt i32 %16, 3
  br i1 %17, label %18, label %33

18:                                               ; preds = %3
  %19 = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 -1
  %20 = load ptr, ptr %19, align 8, !tbaa !33
  %21 = getelementptr inbounds %struct.GCheader, ptr %20, i64 0, i32 2
  %22 = load i8, ptr %21, align 1, !tbaa !33
  %23 = and i8 %22, 3
  %24 = icmp eq i8 %23, 0
  br i1 %24, label %33, label %25

25:                                               ; preds = %18
  %26 = load ptr, ptr %4, align 8, !tbaa !33
  %27 = getelementptr inbounds %struct.GCheader, ptr %26, i64 0, i32 2
  %28 = load i8, ptr %27, align 1, !tbaa !33
  %29 = and i8 %28, 4
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %33, label %31

31:                                               ; preds = %25
  tail call void @luaC_barrierback(ptr noundef nonnull %0, ptr noundef nonnull %26) #46
  %32 = load ptr, ptr %5, align 8, !tbaa !7
  br label %33

33:                                               ; preds = %31, %25, %18, %3
  %34 = phi ptr [ %32, %31 ], [ %14, %25 ], [ %14, %18 ], [ %14, %3 ]
  %35 = getelementptr inbounds %struct.lua_TValue, ptr %34, i64 -1
  store ptr %35, ptr %5, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_setmetatable(ptr noundef %0, i32 noundef %1) #1 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %5 = load ptr, ptr %4, align 8, !tbaa !7
  %6 = getelementptr %struct.lua_TValue, ptr %5, i64 -1, i32 1
  %7 = load i32, ptr %6, align 8, !tbaa !16
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %12, label %9

9:                                                ; preds = %2
  %10 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 -1
  %11 = load ptr, ptr %10, align 8, !tbaa !33
  br label %12

12:                                               ; preds = %9, %2
  %13 = phi ptr [ %11, %9 ], [ null, %2 ]
  %14 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %15 = load i32, ptr %14, align 8, !tbaa !16
  switch i32 %15, label %48 [
    i32 5, label %16
    i32 7, label %32
  ]

16:                                               ; preds = %12
  %17 = load ptr, ptr %3, align 8, !tbaa !33
  %18 = getelementptr inbounds %struct.Table, ptr %17, i64 0, i32 5
  store ptr %13, ptr %18, align 8, !tbaa !33
  %19 = icmp eq ptr %13, null
  br i1 %19, label %53, label %20

20:                                               ; preds = %16
  %21 = getelementptr inbounds %struct.GCheader, ptr %13, i64 0, i32 2
  %22 = load i8, ptr %21, align 1, !tbaa !33
  %23 = and i8 %22, 3
  %24 = icmp eq i8 %23, 0
  br i1 %24, label %53, label %25

25:                                               ; preds = %20
  %26 = load ptr, ptr %3, align 8, !tbaa !33
  %27 = getelementptr inbounds %struct.GCheader, ptr %26, i64 0, i32 2
  %28 = load i8, ptr %27, align 1, !tbaa !33
  %29 = and i8 %28, 4
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %53, label %31

31:                                               ; preds = %25
  tail call void @luaC_barrierback(ptr noundef nonnull %0, ptr noundef nonnull %26) #46
  br label %53

32:                                               ; preds = %12
  %33 = load ptr, ptr %3, align 8, !tbaa !33
  %34 = getelementptr inbounds %struct.anon.1, ptr %33, i64 0, i32 3
  store ptr %13, ptr %34, align 8, !tbaa !33
  %35 = icmp eq ptr %13, null
  br i1 %35, label %53, label %36

36:                                               ; preds = %32
  %37 = getelementptr inbounds %struct.GCheader, ptr %13, i64 0, i32 2
  %38 = load i8, ptr %37, align 1, !tbaa !33
  %39 = and i8 %38, 3
  %40 = icmp eq i8 %39, 0
  br i1 %40, label %53, label %41

41:                                               ; preds = %36
  %42 = load ptr, ptr %3, align 8, !tbaa !33
  %43 = getelementptr inbounds %struct.GCheader, ptr %42, i64 0, i32 2
  %44 = load i8, ptr %43, align 1, !tbaa !33
  %45 = and i8 %44, 4
  %46 = icmp eq i8 %45, 0
  br i1 %46, label %53, label %47

47:                                               ; preds = %41
  tail call void @luaC_barrierf(ptr noundef nonnull %0, ptr noundef nonnull %42, ptr noundef nonnull %13) #46
  br label %53

48:                                               ; preds = %12
  %49 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %50 = load ptr, ptr %49, align 8, !tbaa !25
  %51 = sext i32 %15 to i64
  %52 = getelementptr inbounds %struct.global_State, ptr %50, i64 0, i32 23, i64 %51
  store ptr %13, ptr %52, align 8, !tbaa !39
  br label %53

53:                                               ; preds = %48, %47, %41, %36, %32, %31, %25, %20, %16
  %54 = load ptr, ptr %4, align 8, !tbaa !7
  %55 = getelementptr inbounds %struct.lua_TValue, ptr %54, i64 -1
  store ptr %55, ptr %4, align 8, !tbaa !7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_setfenv(ptr noundef %0, i32 noundef %1) #1 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  switch i32 %5, label %44 [
    i32 6, label %6
    i32 7, label %13
    i32 8, label %20
  ]

6:                                                ; preds = %2
  %7 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %8 = load ptr, ptr %7, align 8, !tbaa !7
  %9 = getelementptr inbounds %struct.lua_TValue, ptr %8, i64 -1
  %10 = load ptr, ptr %9, align 8, !tbaa !33
  %11 = load ptr, ptr %3, align 8, !tbaa !33
  %12 = getelementptr inbounds %struct.CClosure, ptr %11, i64 0, i32 6
  store ptr %10, ptr %12, align 8, !tbaa !33
  br label %28

13:                                               ; preds = %2
  %14 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %15 = load ptr, ptr %14, align 8, !tbaa !7
  %16 = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 -1
  %17 = load ptr, ptr %16, align 8, !tbaa !33
  %18 = load ptr, ptr %3, align 8, !tbaa !33
  %19 = getelementptr inbounds %struct.anon.1, ptr %18, i64 0, i32 4
  store ptr %17, ptr %19, align 8, !tbaa !33
  br label %28

20:                                               ; preds = %2
  %21 = load ptr, ptr %3, align 8, !tbaa !33
  %22 = getelementptr inbounds %struct.lua_State, ptr %21, i64 0, i32 22
  %23 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %24 = load ptr, ptr %23, align 8, !tbaa !7
  %25 = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 -1
  %26 = load ptr, ptr %25, align 8, !tbaa !33
  store ptr %26, ptr %22, align 8, !tbaa !33
  %27 = getelementptr inbounds %struct.lua_State, ptr %21, i64 0, i32 22, i32 1
  store i32 5, ptr %27, align 8, !tbaa !16
  br label %28

28:                                               ; preds = %20, %13, %6
  %29 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %30 = load ptr, ptr %29, align 8, !tbaa !7
  %31 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 -1
  %32 = load ptr, ptr %31, align 8, !tbaa !33
  %33 = getelementptr inbounds %struct.GCheader, ptr %32, i64 0, i32 2
  %34 = load i8, ptr %33, align 1, !tbaa !33
  %35 = and i8 %34, 3
  %36 = icmp eq i8 %35, 0
  br i1 %36, label %44, label %37

37:                                               ; preds = %28
  %38 = load ptr, ptr %3, align 8, !tbaa !33
  %39 = getelementptr inbounds %struct.GCheader, ptr %38, i64 0, i32 2
  %40 = load i8, ptr %39, align 1, !tbaa !33
  %41 = and i8 %40, 4
  %42 = icmp eq i8 %41, 0
  br i1 %42, label %44, label %43

43:                                               ; preds = %37
  tail call void @luaC_barrierf(ptr noundef nonnull %0, ptr noundef nonnull %38, ptr noundef nonnull %32) #46
  br label %44

44:                                               ; preds = %43, %37, %28, %2
  %45 = phi i32 [ 1, %28 ], [ 1, %37 ], [ 1, %43 ], [ 0, %2 ]
  %46 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %47 = load ptr, ptr %46, align 8, !tbaa !7
  %48 = getelementptr inbounds %struct.lua_TValue, ptr %47, i64 -1
  store ptr %48, ptr %46, align 8, !tbaa !7
  ret i32 %45
}

; Function Attrs: nounwind optsize uwtable
define internal void @lua_call(ptr noundef %0, i32 noundef %1, i32 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %5 = load ptr, ptr %4, align 8, !tbaa !7
  %6 = xor i32 %1, -1
  %7 = sext i32 %6 to i64
  %8 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 %7
  tail call void @luaD_call(ptr noundef %0, ptr noundef %8, i32 noundef %2) #46
  %9 = icmp eq i32 %2, -1
  br i1 %9, label %10, label %18

10:                                               ; preds = %3
  %11 = load ptr, ptr %4, align 8, !tbaa !7
  %12 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %13 = load ptr, ptr %12, align 8, !tbaa !19
  %14 = getelementptr inbounds %struct.CallInfo, ptr %13, i64 0, i32 2
  %15 = load ptr, ptr %14, align 8, !tbaa !20
  %16 = icmp ult ptr %11, %15
  br i1 %16, label %18, label %17

17:                                               ; preds = %10
  store ptr %11, ptr %14, align 8, !tbaa !20
  br label %18

18:                                               ; preds = %17, %10, %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_pcall(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) #1 {
  %5 = alloca %struct.CallS, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %5) #48
  %6 = icmp eq i32 %3, 0
  br i1 %6, label %7, label %11

7:                                                ; preds = %4
  %8 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 10
  %9 = load ptr, ptr %8, align 8, !tbaa !43
  %10 = ptrtoint ptr %9 to i64
  br label %18

11:                                               ; preds = %4
  %12 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %3) #47
  %13 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 10
  %14 = load ptr, ptr %13, align 8, !tbaa !43
  %15 = ptrtoint ptr %12 to i64
  %16 = ptrtoint ptr %14 to i64
  %17 = sub i64 %15, %16
  br label %18

18:                                               ; preds = %11, %7
  %19 = phi i64 [ %10, %7 ], [ %16, %11 ]
  %20 = phi i64 [ 0, %7 ], [ %17, %11 ]
  %21 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %22 = load ptr, ptr %21, align 8, !tbaa !7
  %23 = xor i32 %1, -1
  %24 = sext i32 %23 to i64
  %25 = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 %24
  store ptr %25, ptr %5, align 8, !tbaa !44
  %26 = getelementptr inbounds %struct.CallS, ptr %5, i64 0, i32 1
  store i32 %2, ptr %26, align 8, !tbaa !46
  %27 = ptrtoint ptr %25 to i64
  %28 = sub i64 %27, %19
  %29 = call i32 @luaD_pcall(ptr noundef nonnull %0, ptr noundef nonnull @f_call, ptr noundef nonnull %5, i64 noundef %28, i64 noundef %20) #46
  %30 = icmp eq i32 %2, -1
  br i1 %30, label %31, label %39

31:                                               ; preds = %18
  %32 = load ptr, ptr %21, align 8, !tbaa !7
  %33 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %34 = load ptr, ptr %33, align 8, !tbaa !19
  %35 = getelementptr inbounds %struct.CallInfo, ptr %34, i64 0, i32 2
  %36 = load ptr, ptr %35, align 8, !tbaa !20
  %37 = icmp ult ptr %32, %36
  br i1 %37, label %39, label %38

38:                                               ; preds = %31
  store ptr %32, ptr %35, align 8, !tbaa !20
  br label %39

39:                                               ; preds = %38, %31, %18
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %5) #48
  ret i32 %29
}

; Function Attrs: nounwind optsize uwtable
define internal void @f_call(ptr noundef %0, ptr nocapture noundef readonly %1) #1 {
  %3 = load ptr, ptr %1, align 8, !tbaa !44
  %4 = getelementptr inbounds %struct.CallS, ptr %1, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !46
  tail call void @luaD_call(ptr noundef %0, ptr noundef %3, i32 noundef %5) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_cpcall(ptr noundef %0, ptr noundef %1, ptr noundef %2) #1 {
  %4 = alloca %struct.CCallS, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %4) #48
  store ptr %1, ptr %4, align 8, !tbaa !47
  %5 = getelementptr inbounds %struct.CCallS, ptr %4, i64 0, i32 1
  store ptr %2, ptr %5, align 8, !tbaa !49
  %6 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %7 = load ptr, ptr %6, align 8, !tbaa !7
  %8 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 10
  %9 = load ptr, ptr %8, align 8, !tbaa !43
  %10 = ptrtoint ptr %7 to i64
  %11 = ptrtoint ptr %9 to i64
  %12 = sub i64 %10, %11
  %13 = call i32 @luaD_pcall(ptr noundef %0, ptr noundef nonnull @f_Ccall, ptr noundef nonnull %4, i64 noundef %12, i64 noundef 0) #46
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %4) #48
  ret i32 %13
}

; Function Attrs: nounwind optsize uwtable
define internal void @f_Ccall(ptr noundef %0, ptr nocapture noundef readonly %1) #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %4 = load ptr, ptr %3, align 8, !tbaa !19
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %6 = load ptr, ptr %5, align 8, !tbaa !38
  %7 = icmp eq ptr %4, %6
  br i1 %7, label %8, label %10

8:                                                ; preds = %2
  %9 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 22
  br label %15

10:                                               ; preds = %2
  %11 = getelementptr inbounds %struct.CallInfo, ptr %4, i64 0, i32 1
  %12 = load ptr, ptr %11, align 8, !tbaa !36
  %13 = load ptr, ptr %12, align 8, !tbaa !33
  %14 = getelementptr inbounds %struct.CClosure, ptr %13, i64 0, i32 6
  br label %15

15:                                               ; preds = %10, %8
  %16 = phi ptr [ %9, %8 ], [ %14, %10 ]
  %17 = load ptr, ptr %16, align 8, !tbaa !33
  %18 = tail call ptr @luaF_newCclosure(ptr noundef nonnull %0, i32 noundef 0, ptr noundef %17) #46
  %19 = load ptr, ptr %1, align 8, !tbaa !47
  %20 = getelementptr inbounds %struct.CClosure, ptr %18, i64 0, i32 7
  store ptr %19, ptr %20, align 8, !tbaa !33
  %21 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %22 = load ptr, ptr %21, align 8, !tbaa !7
  store ptr %18, ptr %22, align 8, !tbaa !33
  %23 = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 0, i32 1
  store i32 6, ptr %23, align 8, !tbaa !16
  %24 = load ptr, ptr %21, align 8, !tbaa !7
  %25 = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 1
  store ptr %25, ptr %21, align 8, !tbaa !7
  %26 = getelementptr inbounds %struct.CCallS, ptr %1, i64 0, i32 1
  %27 = load ptr, ptr %26, align 8, !tbaa !49
  store ptr %27, ptr %25, align 8, !tbaa !33
  %28 = getelementptr inbounds %struct.lua_TValue, ptr %24, i64 1, i32 1
  store i32 2, ptr %28, align 8, !tbaa !16
  %29 = load ptr, ptr %21, align 8, !tbaa !7
  %30 = getelementptr inbounds %struct.lua_TValue, ptr %29, i64 1
  store ptr %30, ptr %21, align 8, !tbaa !7
  %31 = getelementptr inbounds %struct.lua_TValue, ptr %29, i64 -1
  tail call void @luaD_call(ptr noundef nonnull %0, ptr noundef nonnull %31, i32 noundef 0) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_load(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3) #1 {
  %5 = alloca %struct.Zio, align 8
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %5) #48
  %6 = icmp eq ptr %3, null
  %7 = select i1 %6, ptr @.str.2, ptr %3
  call void @luaZ_init(ptr noundef %0, ptr noundef nonnull %5, ptr noundef %1, ptr noundef %2) #46
  %8 = call i32 @luaD_protectedparser(ptr noundef %0, ptr noundef nonnull %5, ptr noundef nonnull %7) #46
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %5) #48
  ret i32 %8
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_dump(ptr noundef %0, ptr noundef %1, ptr noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %5 = load ptr, ptr %4, align 8, !tbaa !7
  %6 = getelementptr %struct.lua_TValue, ptr %5, i64 -1, i32 1
  %7 = load i32, ptr %6, align 8, !tbaa !16
  %8 = icmp eq i32 %7, 6
  br i1 %8, label %9, label %19

9:                                                ; preds = %3
  %10 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 -1
  %11 = load ptr, ptr %10, align 8, !tbaa !33
  %12 = getelementptr inbounds %struct.CClosure, ptr %11, i64 0, i32 3
  %13 = load i8, ptr %12, align 2, !tbaa !33
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %15, label %19

15:                                               ; preds = %9
  %16 = getelementptr inbounds %struct.LClosure, ptr %11, i64 0, i32 7
  %17 = load ptr, ptr %16, align 8, !tbaa !33
  %18 = tail call i32 @luaU_dump(ptr noundef nonnull %0, ptr noundef %17, ptr noundef %1, ptr noundef %2, i32 noundef 0) #46
  br label %19

19:                                               ; preds = %15, %9, %3
  %20 = phi i32 [ %18, %15 ], [ 1, %9 ], [ 1, %3 ]
  ret i32 %20
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: read) uwtable
define internal i32 @lua_status(ptr nocapture noundef readonly %0) #5 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 3
  %3 = load i8, ptr %2, align 2, !tbaa !50
  %4 = zext i8 %3 to i32
  ret i32 %4
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_gc(ptr noundef %0, i32 noundef %1, i32 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %5 = load ptr, ptr %4, align 8, !tbaa !25
  switch i32 %1, label %44 [
    i32 0, label %6
    i32 1, label %8
    i32 2, label %12
    i32 3, label %13
    i32 4, label %18
    i32 5, label %23
    i32 6, label %38
    i32 7, label %41
  ]

6:                                                ; preds = %3
  %7 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 13
  store i64 -3, ptr %7, align 8, !tbaa !32
  br label %44

8:                                                ; preds = %3
  %9 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 14
  %10 = load i64, ptr %9, align 8, !tbaa !31
  %11 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 13
  store i64 %10, ptr %11, align 8, !tbaa !32
  br label %44

12:                                               ; preds = %3
  tail call void @luaC_fullgc(ptr noundef nonnull %0) #46
  br label %44

13:                                               ; preds = %3
  %14 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 14
  %15 = load i64, ptr %14, align 8, !tbaa !31
  %16 = lshr i64 %15, 10
  %17 = trunc i64 %16 to i32
  br label %44

18:                                               ; preds = %3
  %19 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 14
  %20 = load i64, ptr %19, align 8, !tbaa !31
  %21 = trunc i64 %20 to i32
  %22 = and i32 %21, 1023
  br label %44

23:                                               ; preds = %3
  %24 = sext i32 %2 to i64
  %25 = shl nsw i64 %24, 10
  %26 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 14
  %27 = load i64, ptr %26, align 8, !tbaa !31
  %28 = tail call i64 @llvm.usub.sat.i64(i64 %27, i64 %25)
  %29 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 13
  store i64 %28, ptr %29, align 8
  %30 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 4
  br label %31

31:                                               ; preds = %35, %23
  %32 = load i64, ptr %29, align 8, !tbaa !32
  %33 = load i64, ptr %26, align 8, !tbaa !31
  %34 = icmp ugt i64 %32, %33
  br i1 %34, label %44, label %35

35:                                               ; preds = %31
  tail call void @luaC_step(ptr noundef %0) #46
  %36 = load i8, ptr %30, align 1, !tbaa !51
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %44, label %31, !llvm.loop !52

38:                                               ; preds = %3
  %39 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 17
  %40 = load i32, ptr %39, align 8, !tbaa !53
  store i32 %2, ptr %39, align 8, !tbaa !53
  br label %44

41:                                               ; preds = %3
  %42 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 18
  %43 = load i32, ptr %42, align 4, !tbaa !54
  store i32 %2, ptr %42, align 4, !tbaa !54
  br label %44

44:                                               ; preds = %41, %38, %35, %31, %18, %13, %12, %8, %6, %3
  %45 = phi i32 [ %43, %41 ], [ %40, %38 ], [ %22, %18 ], [ %17, %13 ], [ 0, %12 ], [ 0, %8 ], [ 0, %6 ], [ -1, %3 ], [ 1, %35 ], [ 0, %31 ]
  ret i32 %45
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.usub.sat.i64(i64, i64) #12

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_error(ptr noundef %0) #1 {
  tail call void @luaG_errormsg(ptr noundef %0) #46
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_next(ptr noundef %0, i32 noundef %1) #1 {
  %3 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %4 = load ptr, ptr %3, align 8, !tbaa !33
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %6 = load ptr, ptr %5, align 8, !tbaa !7
  %7 = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 -1
  %8 = tail call i32 @luaH_next(ptr noundef %0, ptr noundef %4, ptr noundef nonnull %7) #46
  %9 = icmp eq i32 %8, 0
  %10 = load ptr, ptr %5, align 8, !tbaa !7
  %11 = select i1 %9, i64 -1, i64 1
  %12 = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 %11
  store ptr %12, ptr %5, align 8, !tbaa !7
  ret i32 %8
}

; Function Attrs: nounwind optsize uwtable
define internal void @lua_concat(ptr noundef %0, i32 noundef %1) #1 {
  %3 = icmp sgt i32 %1, 1
  br i1 %3, label %4, label %29

4:                                                ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %6 = load ptr, ptr %5, align 8, !tbaa !25
  %7 = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 14
  %8 = load i64, ptr %7, align 8, !tbaa !31
  %9 = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 13
  %10 = load i64, ptr %9, align 8, !tbaa !32
  %11 = icmp ult i64 %8, %10
  br i1 %11, label %13, label %12

12:                                               ; preds = %4
  tail call void @luaC_step(ptr noundef nonnull %0) #46
  br label %13

13:                                               ; preds = %12, %4
  %14 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %15 = load ptr, ptr %14, align 8, !tbaa !7
  %16 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  %17 = load ptr, ptr %16, align 8, !tbaa !17
  %18 = ptrtoint ptr %15 to i64
  %19 = ptrtoint ptr %17 to i64
  %20 = sub i64 %18, %19
  %21 = lshr exact i64 %20, 4
  %22 = trunc i64 %21 to i32
  %23 = add nsw i32 %22, -1
  tail call void @luaV_concat(ptr noundef nonnull %0, i32 noundef %1, i32 noundef %23) #46
  %24 = add nsw i32 %1, -1
  %25 = load ptr, ptr %14, align 8, !tbaa !7
  %26 = zext i32 %24 to i64
  %27 = sub nsw i64 0, %26
  %28 = getelementptr inbounds %struct.lua_TValue, ptr %25, i64 %27
  store ptr %28, ptr %14, align 8, !tbaa !7
  br label %38

29:                                               ; preds = %2
  %30 = icmp eq i32 %1, 0
  br i1 %30, label %31, label %38

31:                                               ; preds = %29
  %32 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %33 = load ptr, ptr %32, align 8, !tbaa !7
  %34 = tail call ptr @luaS_newlstr(ptr noundef %0, ptr noundef nonnull @.str.3, i64 noundef 0) #46
  store ptr %34, ptr %33, align 8, !tbaa !33
  %35 = getelementptr inbounds %struct.lua_TValue, ptr %33, i64 0, i32 1
  store i32 4, ptr %35, align 8, !tbaa !16
  %36 = load ptr, ptr %32, align 8, !tbaa !7
  %37 = getelementptr inbounds %struct.lua_TValue, ptr %36, i64 1
  store ptr %37, ptr %32, align 8, !tbaa !7
  br label %38

38:                                               ; preds = %31, %29, %13
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal nonnull ptr @lua_newuserdata(ptr noundef %0, i64 noundef %1) #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %4 = load ptr, ptr %3, align 8, !tbaa !25
  %5 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 14
  %6 = load i64, ptr %5, align 8, !tbaa !31
  %7 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 13
  %8 = load i64, ptr %7, align 8, !tbaa !32
  %9 = icmp ult i64 %6, %8
  br i1 %9, label %11, label %10

10:                                               ; preds = %2
  tail call void @luaC_step(ptr noundef nonnull %0) #46
  br label %11

11:                                               ; preds = %10, %2
  %12 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %13 = load ptr, ptr %12, align 8, !tbaa !19
  %14 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %15 = load ptr, ptr %14, align 8, !tbaa !38
  %16 = icmp eq ptr %13, %15
  br i1 %16, label %17, label %19

17:                                               ; preds = %11
  %18 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 22
  br label %24

19:                                               ; preds = %11
  %20 = getelementptr inbounds %struct.CallInfo, ptr %13, i64 0, i32 1
  %21 = load ptr, ptr %20, align 8, !tbaa !36
  %22 = load ptr, ptr %21, align 8, !tbaa !33
  %23 = getelementptr inbounds %struct.CClosure, ptr %22, i64 0, i32 6
  br label %24

24:                                               ; preds = %19, %17
  %25 = phi ptr [ %18, %17 ], [ %23, %19 ]
  %26 = load ptr, ptr %25, align 8, !tbaa !33
  %27 = tail call ptr @luaS_newudata(ptr noundef nonnull %0, i64 noundef %1, ptr noundef %26) #46
  %28 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %29 = load ptr, ptr %28, align 8, !tbaa !7
  store ptr %27, ptr %29, align 8, !tbaa !33
  %30 = getelementptr inbounds %struct.lua_TValue, ptr %29, i64 0, i32 1
  store i32 7, ptr %30, align 8, !tbaa !16
  %31 = load ptr, ptr %28, align 8, !tbaa !7
  %32 = getelementptr inbounds %struct.lua_TValue, ptr %31, i64 1
  store ptr %32, ptr %28, align 8, !tbaa !7
  %33 = getelementptr inbounds %union.Udata, ptr %27, i64 1
  ret ptr %33
}

; Function Attrs: mustprogress nofree nosync nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable
define internal ptr @lua_getupvalue(ptr noundef %0, i32 noundef %1, i32 noundef %2) #13 {
  %4 = alloca ptr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #48
  %5 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %6 = call fastcc ptr @aux_upvalue(ptr noundef %5, i32 noundef %2, ptr noundef nonnull %4) #47
  %7 = icmp eq ptr %6, null
  br i1 %7, label %18, label %8

8:                                                ; preds = %3
  %9 = load ptr, ptr %4, align 8, !tbaa !39
  %10 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %11 = load ptr, ptr %10, align 8, !tbaa !7
  %12 = load i64, ptr %9, align 8
  store i64 %12, ptr %11, align 8
  %13 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 0, i32 1
  %14 = load i32, ptr %13, align 8, !tbaa !16
  %15 = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 0, i32 1
  store i32 %14, ptr %15, align 8, !tbaa !16
  %16 = load ptr, ptr %10, align 8, !tbaa !7
  %17 = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 1
  store ptr %17, ptr %10, align 8, !tbaa !7
  br label %18

18:                                               ; preds = %8, %3
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #48
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define internal fastcc ptr @aux_upvalue(ptr nocapture noundef readonly %0, i32 noundef %1, ptr nocapture noundef writeonly %2) unnamed_addr #7 {
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  %6 = icmp eq i32 %5, 6
  br i1 %6, label %7, label %43

7:                                                ; preds = %3
  %8 = load ptr, ptr %0, align 8, !tbaa !33
  %9 = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 3
  %10 = load i8, ptr %9, align 2, !tbaa !33
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %23, label %12

12:                                               ; preds = %7
  %13 = icmp sgt i32 %1, 0
  br i1 %13, label %14, label %43

14:                                               ; preds = %12
  %15 = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 4
  %16 = load i8, ptr %15, align 1, !tbaa !33
  %17 = zext i8 %16 to i32
  %18 = icmp ult i32 %17, %1
  br i1 %18, label %43, label %19

19:                                               ; preds = %14
  %20 = add nsw i32 %1, -1
  %21 = zext i32 %20 to i64
  %22 = getelementptr inbounds %struct.CClosure, ptr %8, i64 0, i32 8, i64 %21
  store ptr %22, ptr %2, align 8, !tbaa !39
  br label %43

23:                                               ; preds = %7
  %24 = getelementptr inbounds %struct.LClosure, ptr %8, i64 0, i32 7
  %25 = load ptr, ptr %24, align 8, !tbaa !33
  %26 = icmp sgt i32 %1, 0
  br i1 %26, label %27, label %43

27:                                               ; preds = %23
  %28 = getelementptr inbounds %struct.Proto, ptr %25, i64 0, i32 10
  %29 = load i32, ptr %28, align 8, !tbaa !55
  %30 = icmp slt i32 %29, %1
  br i1 %30, label %43, label %31

31:                                               ; preds = %27
  %32 = add nsw i32 %1, -1
  %33 = zext i32 %32 to i64
  %34 = getelementptr inbounds %struct.LClosure, ptr %8, i64 0, i32 8, i64 %33
  %35 = load ptr, ptr %34, align 8, !tbaa !33
  %36 = getelementptr inbounds %struct.UpVal, ptr %35, i64 0, i32 3
  %37 = load ptr, ptr %36, align 8, !tbaa !57
  store ptr %37, ptr %2, align 8, !tbaa !39
  %38 = getelementptr inbounds %struct.Proto, ptr %25, i64 0, i32 8
  %39 = load ptr, ptr %38, align 8, !tbaa !58
  %40 = getelementptr inbounds ptr, ptr %39, i64 %33
  %41 = load ptr, ptr %40, align 8, !tbaa !39
  %42 = getelementptr inbounds %union.TString, ptr %41, i64 1
  br label %43

43:                                               ; preds = %31, %27, %23, %19, %14, %12, %3
  %44 = phi ptr [ @.str.3, %19 ], [ null, %3 ], [ null, %14 ], [ null, %12 ], [ %42, %31 ], [ null, %27 ], [ null, %23 ]
  ret ptr %44
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @lua_setupvalue(ptr noundef %0, i32 noundef %1, i32 noundef %2) #1 {
  %4 = alloca ptr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #48
  %5 = tail call fastcc ptr @index2adr(ptr noundef %0, i32 noundef %1) #47
  %6 = call fastcc ptr @aux_upvalue(ptr noundef %5, i32 noundef %2, ptr noundef nonnull %4) #47
  %7 = icmp eq ptr %6, null
  br i1 %7, label %34, label %8

8:                                                ; preds = %3
  %9 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %10 = load ptr, ptr %9, align 8, !tbaa !7
  %11 = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 -1
  store ptr %11, ptr %9, align 8, !tbaa !7
  %12 = load ptr, ptr %4, align 8, !tbaa !39
  %13 = load i64, ptr %11, align 8
  store i64 %13, ptr %12, align 8
  %14 = getelementptr %struct.lua_TValue, ptr %10, i64 -1, i32 1
  %15 = load i32, ptr %14, align 8, !tbaa !16
  %16 = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 0, i32 1
  store i32 %15, ptr %16, align 8, !tbaa !16
  %17 = load ptr, ptr %9, align 8, !tbaa !7
  %18 = getelementptr inbounds %struct.lua_TValue, ptr %17, i64 0, i32 1
  %19 = load i32, ptr %18, align 8, !tbaa !16
  %20 = icmp sgt i32 %19, 3
  br i1 %20, label %21, label %34

21:                                               ; preds = %8
  %22 = load ptr, ptr %17, align 8, !tbaa !33
  %23 = getelementptr inbounds %struct.GCheader, ptr %22, i64 0, i32 2
  %24 = load i8, ptr %23, align 1, !tbaa !33
  %25 = and i8 %24, 3
  %26 = icmp eq i8 %25, 0
  br i1 %26, label %34, label %27

27:                                               ; preds = %21
  %28 = load ptr, ptr %5, align 8, !tbaa !33
  %29 = getelementptr inbounds %struct.GCheader, ptr %28, i64 0, i32 2
  %30 = load i8, ptr %29, align 1, !tbaa !33
  %31 = and i8 %30, 4
  %32 = icmp eq i8 %31, 0
  br i1 %32, label %34, label %33

33:                                               ; preds = %27
  tail call void @luaC_barrierf(ptr noundef nonnull %0, ptr noundef nonnull %28, ptr noundef nonnull %22) #46
  br label %34

34:                                               ; preds = %33, %27, %21, %8, %3
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #48
  ret ptr %6
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_nil(ptr nocapture noundef %0, i32 noundef %1, i32 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 6
  %5 = load i32, ptr %4, align 8, !tbaa !59
  %6 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 7
  %7 = load i32, ptr %6, align 4, !tbaa !61
  %8 = icmp sgt i32 %5, %7
  br i1 %8, label %9, label %42

9:                                                ; preds = %3
  %10 = icmp eq i32 %5, 0
  br i1 %10, label %11, label %16

11:                                               ; preds = %9
  %12 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %13 = load i8, ptr %12, align 2, !tbaa !62
  %14 = zext i8 %13 to i32
  %15 = icmp sgt i32 %14, %1
  br i1 %15, label %42, label %54

16:                                               ; preds = %9
  %17 = load ptr, ptr %0, align 8, !tbaa !63
  %18 = getelementptr inbounds %struct.Proto, ptr %17, i64 0, i32 4
  %19 = load ptr, ptr %18, align 8, !tbaa !64
  %20 = add nsw i32 %5, -1
  %21 = sext i32 %20 to i64
  %22 = getelementptr inbounds i32, ptr %19, i64 %21
  %23 = load i32, ptr %22, align 4, !tbaa !65
  %24 = and i32 %23, 63
  %25 = icmp eq i32 %24, 3
  br i1 %25, label %26, label %42

26:                                               ; preds = %16
  %27 = lshr i32 %23, 6
  %28 = and i32 %27, 255
  %29 = lshr i32 %23, 23
  %30 = icmp sgt i32 %28, %1
  %31 = add nuw nsw i32 %29, 1
  %32 = icmp slt i32 %31, %1
  %33 = select i1 %30, i1 true, i1 %32
  br i1 %33, label %42, label %34

34:                                               ; preds = %26
  %35 = add nsw i32 %2, %1
  %36 = add nsw i32 %35, -1
  %37 = icmp sgt i32 %36, %29
  br i1 %37, label %38, label %54

38:                                               ; preds = %34
  %39 = and i32 %23, 8388607
  %40 = shl i32 %36, 23
  %41 = or i32 %39, %40
  store i32 %41, ptr %22, align 4, !tbaa !65
  br label %54

42:                                               ; preds = %26, %16, %11, %3
  %43 = add nsw i32 %2, %1
  %44 = shl i32 %1, 6
  %45 = shl i32 %43, 23
  %46 = add i32 %45, -8388608
  %47 = or i32 %44, %46
  %48 = or i32 %47, 3
  %49 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %50 = load ptr, ptr %49, align 8, !tbaa !66
  %51 = getelementptr inbounds %struct.LexState, ptr %50, i64 0, i32 2
  %52 = load i32, ptr %51, align 8, !tbaa !67
  %53 = tail call fastcc i32 @luaK_code(ptr noundef nonnull %0, i32 noundef %48, i32 noundef %52) #47
  br label %54

54:                                               ; preds = %42, %38, %34, %11
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaK_code(ptr nocapture noundef %0, i32 noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = load ptr, ptr %0, align 8, !tbaa !63
  %5 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 8
  %6 = load i32, ptr %5, align 8, !tbaa !70
  %7 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 6
  %8 = load i32, ptr %7, align 8, !tbaa !59
  tail call fastcc void @patchlistaux(ptr noundef nonnull %0, i32 noundef %6, i32 noundef %8, i32 noundef 255, i32 noundef %8) #47
  store i32 -1, ptr %5, align 8, !tbaa !70
  %9 = load i32, ptr %7, align 8, !tbaa !59
  %10 = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 12
  %11 = load i32, ptr %10, align 8, !tbaa !71
  %12 = icmp slt i32 %9, %11
  br i1 %12, label %13, label %16

13:                                               ; preds = %3
  %14 = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 4
  %15 = load ptr, ptr %14, align 8, !tbaa !64
  br label %23

16:                                               ; preds = %3
  %17 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 4
  %18 = load ptr, ptr %17, align 8, !tbaa !72
  %19 = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 4
  %20 = load ptr, ptr %19, align 8, !tbaa !64
  %21 = tail call ptr @luaM_growaux_(ptr noundef %18, ptr noundef %20, ptr noundef nonnull %10, i64 noundef 4, i32 noundef 2147483645, ptr noundef nonnull @.str.3.1) #46
  store ptr %21, ptr %19, align 8, !tbaa !64
  %22 = load i32, ptr %7, align 8, !tbaa !59
  br label %23

23:                                               ; preds = %16, %13
  %24 = phi i32 [ %9, %13 ], [ %22, %16 ]
  %25 = phi ptr [ %15, %13 ], [ %21, %16 ]
  %26 = sext i32 %24 to i64
  %27 = getelementptr inbounds i32, ptr %25, i64 %26
  store i32 %1, ptr %27, align 4, !tbaa !65
  %28 = load i32, ptr %7, align 8, !tbaa !59
  %29 = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 13
  %30 = load i32, ptr %29, align 4, !tbaa !73
  %31 = icmp slt i32 %28, %30
  br i1 %31, label %32, label %35

32:                                               ; preds = %23
  %33 = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 6
  %34 = load ptr, ptr %33, align 8, !tbaa !74
  br label %42

35:                                               ; preds = %23
  %36 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 4
  %37 = load ptr, ptr %36, align 8, !tbaa !72
  %38 = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 6
  %39 = load ptr, ptr %38, align 8, !tbaa !74
  %40 = tail call ptr @luaM_growaux_(ptr noundef %37, ptr noundef %39, ptr noundef nonnull %29, i64 noundef 4, i32 noundef 2147483645, ptr noundef nonnull @.str.3.1) #46
  store ptr %40, ptr %38, align 8, !tbaa !74
  %41 = load i32, ptr %7, align 8, !tbaa !59
  br label %42

42:                                               ; preds = %35, %32
  %43 = phi i32 [ %28, %32 ], [ %41, %35 ]
  %44 = phi ptr [ %34, %32 ], [ %40, %35 ]
  %45 = sext i32 %43 to i64
  %46 = getelementptr inbounds i32, ptr %44, i64 %45
  store i32 %2, ptr %46, align 4, !tbaa !65
  %47 = load i32, ptr %7, align 8, !tbaa !59
  %48 = add nsw i32 %47, 1
  store i32 %48, ptr %7, align 8, !tbaa !59
  ret i32 %47
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @patchlistaux(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) unnamed_addr #1 {
  %6 = icmp eq i32 %1, -1
  br i1 %6, label %25, label %7

7:                                                ; preds = %7, %5
  %8 = phi i32 [ %19, %7 ], [ %1, %5 ]
  %9 = load ptr, ptr %0, align 8, !tbaa !63
  %10 = getelementptr inbounds %struct.Proto, ptr %9, i64 0, i32 4
  %11 = load ptr, ptr %10, align 8, !tbaa !64
  %12 = sext i32 %8 to i64
  %13 = getelementptr inbounds i32, ptr %11, i64 %12
  %14 = load i32, ptr %13, align 4, !tbaa !65
  %15 = lshr i32 %14, 14
  %16 = add nsw i32 %15, -131071
  %17 = icmp eq i32 %16, -1
  %18 = add nuw nsw i32 %8, 1
  %19 = add nsw i32 %18, %16
  %20 = tail call fastcc i32 @patchtestreg(ptr noundef nonnull %0, i32 noundef %8, i32 noundef %3) #47, !range !75
  %21 = icmp eq i32 %20, 0
  %22 = select i1 %21, i32 %4, i32 %2
  tail call fastcc void @fixjump(ptr noundef nonnull %0, i32 noundef %8, i32 noundef %22) #47
  %23 = icmp eq i32 %19, -1
  %24 = select i1 %17, i1 true, i1 %23
  br i1 %24, label %25, label %7, !llvm.loop !76

25:                                               ; preds = %7, %5
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable
define internal fastcc i32 @patchtestreg(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2) unnamed_addr #4 {
  %4 = load ptr, ptr %0, align 8, !tbaa !63
  %5 = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 4
  %6 = load ptr, ptr %5, align 8, !tbaa !64
  %7 = sext i32 %1 to i64
  %8 = getelementptr inbounds i32, ptr %6, i64 %7
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %10, label %18

10:                                               ; preds = %3
  %11 = getelementptr inbounds i32, ptr %8, i64 -1
  %12 = load i32, ptr %11, align 4, !tbaa !65
  %13 = and i32 %12, 63
  %14 = zext i32 %13 to i64
  %15 = getelementptr inbounds [38 x i8], ptr @luaP_opmodes, i64 0, i64 %14
  %16 = load i8, ptr %15, align 1, !tbaa !33
  %17 = icmp sgt i8 %16, -1
  br i1 %17, label %18, label %20

18:                                               ; preds = %10, %3
  %19 = load i32, ptr %8, align 4, !tbaa !65
  br label %20

20:                                               ; preds = %18, %10
  %21 = phi i32 [ %19, %18 ], [ %12, %10 ]
  %22 = phi ptr [ %8, %18 ], [ %11, %10 ]
  %23 = and i32 %21, 63
  %24 = icmp eq i32 %23, 27
  br i1 %24, label %25, label %43

25:                                               ; preds = %20
  %26 = icmp eq i32 %2, 255
  %27 = lshr i32 %21, 23
  %28 = icmp eq i32 %27, %2
  %29 = or i1 %26, %28
  br i1 %29, label %35, label %30

30:                                               ; preds = %25
  %31 = and i32 %21, -16321
  %32 = shl i32 %2, 6
  %33 = and i32 %32, 16320
  %34 = or i32 %31, %33
  br label %41

35:                                               ; preds = %25
  %36 = lshr i32 %21, 17
  %37 = and i32 %36, 32704
  %38 = and i32 %21, 8372224
  %39 = or i32 %38, %37
  %40 = or i32 %39, 26
  br label %41

41:                                               ; preds = %35, %30
  %42 = phi i32 [ %40, %35 ], [ %34, %30 ]
  store i32 %42, ptr %22, align 4, !tbaa !65
  br label %43

43:                                               ; preds = %41, %20
  %44 = phi i32 [ 1, %41 ], [ 0, %20 ]
  ret i32 %44
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @fixjump(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = load ptr, ptr %0, align 8, !tbaa !63
  %5 = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 4
  %6 = load ptr, ptr %5, align 8, !tbaa !64
  %7 = xor i32 %1, -1
  %8 = add i32 %7, %2
  %9 = tail call i32 @llvm.abs.i32(i32 %8, i1 true)
  %10 = icmp ugt i32 %9, 131071
  br i1 %10, label %11, label %14

11:                                               ; preds = %3
  %12 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %13 = load ptr, ptr %12, align 8, !tbaa !66
  tail call void @luaX_syntaxerror(ptr noundef %13, ptr noundef nonnull @.str.1.2) #46
  br label %14

14:                                               ; preds = %11, %3
  %15 = sext i32 %1 to i64
  %16 = getelementptr inbounds i32, ptr %6, i64 %15
  %17 = load i32, ptr %16, align 4, !tbaa !65
  %18 = and i32 %17, 16383
  %19 = shl i32 %8, 14
  %20 = add i32 %19, 2147467264
  %21 = or i32 %18, %20
  store i32 %21, ptr %16, align 4, !tbaa !65
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.abs.i32(i32, i1 immarg) #12

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaK_codeABC(ptr nocapture noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) #1 {
  %6 = shl i32 %2, 6
  %7 = or i32 %6, %1
  %8 = shl i32 %3, 23
  %9 = or i32 %7, %8
  %10 = shl i32 %4, 14
  %11 = or i32 %9, %10
  %12 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %13 = load ptr, ptr %12, align 8, !tbaa !66
  %14 = getelementptr inbounds %struct.LexState, ptr %13, i64 0, i32 2
  %15 = load i32, ptr %14, align 8, !tbaa !67
  %16 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %11, i32 noundef %15) #47
  ret i32 %16
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaK_jump(ptr nocapture noundef %0) #1 {
  %2 = alloca i32, align 4
  %3 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 8
  %4 = load i32, ptr %3, align 8, !tbaa !70
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #48
  store i32 -1, ptr %3, align 8, !tbaa !70
  %5 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %6 = load ptr, ptr %5, align 8, !tbaa !66
  %7 = getelementptr inbounds %struct.LexState, ptr %6, i64 0, i32 2
  %8 = load i32, ptr %7, align 8, !tbaa !67
  %9 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef 2147450902, i32 noundef %8) #47
  store i32 %9, ptr %2, align 4, !tbaa !65
  call void @luaK_concat(ptr noundef %0, ptr noundef nonnull %2, i32 noundef %4) #47
  %10 = load i32, ptr %2, align 4, !tbaa !65
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #48
  ret i32 %10
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_concat(ptr nocapture noundef readonly %0, ptr nocapture noundef %1, i32 noundef %2) #1 {
  %4 = icmp eq i32 %2, -1
  br i1 %4, label %26, label %5

5:                                                ; preds = %3
  %6 = load i32, ptr %1, align 4, !tbaa !65
  %7 = icmp eq i32 %6, -1
  br i1 %7, label %12, label %8

8:                                                ; preds = %5
  %9 = load ptr, ptr %0, align 8, !tbaa !63
  %10 = getelementptr inbounds %struct.Proto, ptr %9, i64 0, i32 4
  %11 = load ptr, ptr %10, align 8, !tbaa !64
  br label %13

12:                                               ; preds = %5
  store i32 %2, ptr %1, align 4, !tbaa !65
  br label %26

13:                                               ; preds = %13, %8
  %14 = phi i32 [ %22, %13 ], [ %6, %8 ]
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds i32, ptr %11, i64 %15
  %17 = load i32, ptr %16, align 4, !tbaa !65
  %18 = lshr i32 %17, 14
  %19 = add nsw i32 %18, -131071
  %20 = icmp eq i32 %19, -1
  %21 = add nuw nsw i32 %14, 1
  %22 = add nsw i32 %21, %19
  %23 = icmp eq i32 %22, -1
  %24 = select i1 %20, i1 true, i1 %23
  br i1 %24, label %25, label %13, !llvm.loop !77

25:                                               ; preds = %13
  %.lcssa = phi i32 [ %14, %13 ]
  tail call fastcc void @fixjump(ptr noundef nonnull %0, i32 noundef %.lcssa, i32 noundef %2) #47
  br label %26

26:                                               ; preds = %25, %12, %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaK_codeABx(ptr nocapture noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) #1 {
  %5 = shl i32 %2, 6
  %6 = or i32 %5, %1
  %7 = shl i32 %3, 14
  %8 = or i32 %6, %7
  %9 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %10 = load ptr, ptr %9, align 8, !tbaa !66
  %11 = getelementptr inbounds %struct.LexState, ptr %10, i64 0, i32 2
  %12 = load i32, ptr %11, align 8, !tbaa !67
  %13 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %8, i32 noundef %12) #47
  ret i32 %13
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_ret(ptr nocapture noundef %0, i32 noundef %1, i32 noundef %2) #1 {
  %4 = shl i32 %1, 6
  %5 = shl i32 %2, 23
  %6 = add i32 %5, 8388608
  %7 = or i32 %4, %6
  %8 = or i32 %7, 30
  %9 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %10 = load ptr, ptr %9, align 8, !tbaa !66
  %11 = getelementptr inbounds %struct.LexState, ptr %10, i64 0, i32 2
  %12 = load i32, ptr %11, align 8, !tbaa !67
  %13 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %8, i32 noundef %12) #47
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: readwrite) uwtable
define internal i32 @luaK_getlabel(ptr nocapture noundef %0) #3 {
  %2 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 6
  %3 = load i32, ptr %2, align 8, !tbaa !59
  %4 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 7
  store i32 %3, ptr %4, align 4, !tbaa !61
  ret i32 %3
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_patchlist(ptr nocapture noundef %0, i32 noundef %1, i32 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 6
  %5 = load i32, ptr %4, align 8, !tbaa !59
  %6 = icmp eq i32 %5, %2
  br i1 %6, label %7, label %10

7:                                                ; preds = %3
  %8 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 7
  store i32 %2, ptr %8, align 4, !tbaa !61
  %9 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 8
  tail call void @luaK_concat(ptr noundef nonnull %0, ptr noundef nonnull %9, i32 noundef %1) #47
  br label %11

10:                                               ; preds = %3
  tail call fastcc void @patchlistaux(ptr noundef nonnull %0, i32 noundef %1, i32 noundef %2, i32 noundef 255, i32 noundef %2) #47
  br label %11

11:                                               ; preds = %10, %7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_patchtohere(ptr nocapture noundef %0, i32 noundef %1) #1 {
  %3 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 6
  %4 = load i32, ptr %3, align 8, !tbaa !59
  %5 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 7
  store i32 %4, ptr %5, align 4, !tbaa !61
  %6 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 8
  tail call void @luaK_concat(ptr noundef %0, ptr noundef nonnull %6, i32 noundef %1) #47
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_checkstack(ptr nocapture noundef readonly %0, i32 noundef %1) #1 {
  %3 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %4 = load i32, ptr %3, align 4, !tbaa !78
  %5 = add nsw i32 %4, %1
  %6 = load ptr, ptr %0, align 8, !tbaa !63
  %7 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 22
  %8 = load i8, ptr %7, align 1, !tbaa !79
  %9 = zext i8 %8 to i32
  %10 = icmp sgt i32 %5, %9
  br i1 %10, label %11, label %21

11:                                               ; preds = %2
  %12 = icmp sgt i32 %5, 249
  br i1 %12, label %13, label %17

13:                                               ; preds = %11
  %14 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %15 = load ptr, ptr %14, align 8, !tbaa !66
  tail call void @luaX_syntaxerror(ptr noundef %15, ptr noundef nonnull @.str.4) #46
  %16 = load ptr, ptr %0, align 8, !tbaa !63
  br label %17

17:                                               ; preds = %13, %11
  %18 = phi ptr [ %16, %13 ], [ %6, %11 ]
  %19 = trunc i32 %5 to i8
  %20 = getelementptr inbounds %struct.Proto, ptr %18, i64 0, i32 22
  store i8 %19, ptr %20, align 1, !tbaa !79
  br label %21

21:                                               ; preds = %17, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_reserveregs(ptr nocapture noundef %0, i32 noundef %1) #1 {
  tail call void @luaK_checkstack(ptr noundef %0, i32 noundef %1) #47
  %3 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %4 = load i32, ptr %3, align 4, !tbaa !78
  %5 = add nsw i32 %4, %1
  store i32 %5, ptr %3, align 4, !tbaa !78
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaK_stringK(ptr nocapture noundef %0, ptr noundef %1) #1 {
  %3 = alloca %struct.lua_TValue, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %3) #48
  store ptr %1, ptr %3, align 8, !tbaa !33
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  store i32 4, ptr %4, align 8, !tbaa !16
  %5 = call fastcc i32 @addk(ptr noundef %0, ptr noundef nonnull %3, ptr noundef nonnull %3) #47
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %3) #48
  ret i32 %5
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @addk(ptr nocapture noundef %0, ptr noundef %1, ptr nocapture noundef readonly %2) unnamed_addr #1 {
  %4 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 4
  %5 = load ptr, ptr %4, align 8, !tbaa !72
  %6 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 1
  %7 = load ptr, ptr %6, align 8, !tbaa !80
  %8 = tail call ptr @luaH_set(ptr noundef %5, ptr noundef %7, ptr noundef %1) #46
  %9 = load ptr, ptr %0, align 8, !tbaa !63
  %10 = getelementptr inbounds %struct.Proto, ptr %9, i64 0, i32 11
  %11 = load i32, ptr %10, align 4, !tbaa !81
  %12 = getelementptr inbounds %struct.lua_TValue, ptr %8, i64 0, i32 1
  %13 = load i32, ptr %12, align 8, !tbaa !16
  %14 = icmp eq i32 %13, 3
  br i1 %14, label %15, label %18

15:                                               ; preds = %3
  %16 = load double, ptr %8, align 8, !tbaa !33
  %17 = fptosi double %16 to i32
  br label %68

18:                                               ; preds = %3
  %19 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 10
  %20 = load i32, ptr %19, align 8, !tbaa !82
  %21 = sitofp i32 %20 to double
  store double %21, ptr %8, align 8, !tbaa !33
  store i32 3, ptr %12, align 8, !tbaa !16
  %22 = load i32, ptr %19, align 8, !tbaa !82
  %23 = load i32, ptr %10, align 4, !tbaa !81
  %24 = icmp slt i32 %22, %23
  br i1 %24, label %30, label %25

25:                                               ; preds = %18
  %26 = getelementptr inbounds %struct.Proto, ptr %9, i64 0, i32 3
  %27 = load ptr, ptr %26, align 8, !tbaa !83
  %28 = tail call ptr @luaM_growaux_(ptr noundef %5, ptr noundef %27, ptr noundef nonnull %10, i64 noundef 16, i32 noundef 262143, ptr noundef nonnull @.str.2.5) #46
  store ptr %28, ptr %26, align 8, !tbaa !83
  %29 = load i32, ptr %10, align 4, !tbaa !81
  br label %30

30:                                               ; preds = %25, %18
  %31 = phi i32 [ %29, %25 ], [ %23, %18 ]
  %32 = icmp slt i32 %11, %31
  %33 = getelementptr inbounds %struct.Proto, ptr %9, i64 0, i32 3
  %34 = load ptr, ptr %33, align 8, !tbaa !83
  br i1 %32, label %35, label %43

35:                                               ; preds = %30
  %36 = sext i32 %11 to i64
  %37 = sext i32 %31 to i64
  br label %38

38:                                               ; preds = %38, %35
  %39 = phi i64 [ %36, %35 ], [ %40, %38 ]
  %40 = add nsw i64 %39, 1
  %41 = getelementptr inbounds %struct.lua_TValue, ptr %34, i64 %39, i32 1
  store i32 0, ptr %41, align 8, !tbaa !16
  %42 = icmp eq i64 %40, %37
  br i1 %42, label %43, label %38, !llvm.loop !84

43:                                               ; preds = %38, %30
  %44 = load i32, ptr %19, align 8, !tbaa !82
  %45 = sext i32 %44 to i64
  %46 = getelementptr inbounds %struct.lua_TValue, ptr %34, i64 %45
  %47 = load i64, ptr %2, align 8
  store i64 %47, ptr %46, align 8
  %48 = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  %49 = load i32, ptr %48, align 8, !tbaa !16
  %50 = getelementptr inbounds %struct.lua_TValue, ptr %34, i64 %45, i32 1
  store i32 %49, ptr %50, align 8, !tbaa !16
  %51 = load i32, ptr %48, align 8, !tbaa !16
  %52 = icmp sgt i32 %51, 3
  br i1 %52, label %53, label %65

53:                                               ; preds = %43
  %54 = load ptr, ptr %2, align 8, !tbaa !33
  %55 = getelementptr inbounds %struct.GCheader, ptr %54, i64 0, i32 2
  %56 = load i8, ptr %55, align 1, !tbaa !33
  %57 = and i8 %56, 3
  %58 = icmp eq i8 %57, 0
  br i1 %58, label %65, label %59

59:                                               ; preds = %53
  %60 = getelementptr inbounds %struct.GCheader, ptr %9, i64 0, i32 2
  %61 = load i8, ptr %60, align 1, !tbaa !33
  %62 = and i8 %61, 4
  %63 = icmp eq i8 %62, 0
  br i1 %63, label %65, label %64

64:                                               ; preds = %59
  tail call void @luaC_barrierf(ptr noundef %5, ptr noundef nonnull %9, ptr noundef nonnull %54) #46
  br label %65

65:                                               ; preds = %64, %59, %53, %43
  %66 = load i32, ptr %19, align 8, !tbaa !82
  %67 = add nsw i32 %66, 1
  store i32 %67, ptr %19, align 8, !tbaa !82
  br label %68

68:                                               ; preds = %65, %15
  %69 = phi i32 [ %17, %15 ], [ %66, %65 ]
  ret i32 %69
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaK_numberK(ptr nocapture noundef %0, double noundef %1) #1 {
  %3 = alloca %struct.lua_TValue, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %3) #48
  store double %1, ptr %3, align 8, !tbaa !33
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  store i32 3, ptr %4, align 8, !tbaa !16
  %5 = call fastcc i32 @addk(ptr noundef %0, ptr noundef nonnull %3, ptr noundef nonnull %3) #47
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %3) #48
  ret i32 %5
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_setreturns(ptr nocapture noundef %0, ptr nocapture noundef readonly %1, i32 noundef %2) #1 {
  %4 = load i32, ptr %1, align 8, !tbaa !85
  switch i32 %4, label %44 [
    i32 13, label %5
    i32 14, label %19
  ]

5:                                                ; preds = %3
  %6 = load ptr, ptr %0, align 8, !tbaa !63
  %7 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 4
  %8 = load ptr, ptr %7, align 8, !tbaa !64
  %9 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %10 = load i32, ptr %9, align 8, !tbaa !33
  %11 = sext i32 %10 to i64
  %12 = getelementptr inbounds i32, ptr %8, i64 %11
  %13 = load i32, ptr %12, align 4, !tbaa !65
  %14 = and i32 %13, -8372225
  %15 = shl i32 %2, 14
  %16 = add i32 %15, 16384
  %17 = and i32 %16, 8372224
  %18 = or i32 %14, %17
  store i32 %18, ptr %12, align 4, !tbaa !65
  br label %44

19:                                               ; preds = %3
  %20 = load ptr, ptr %0, align 8, !tbaa !63
  %21 = getelementptr inbounds %struct.Proto, ptr %20, i64 0, i32 4
  %22 = load ptr, ptr %21, align 8, !tbaa !64
  %23 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %24 = load i32, ptr %23, align 8, !tbaa !33
  %25 = sext i32 %24 to i64
  %26 = getelementptr inbounds i32, ptr %22, i64 %25
  %27 = load i32, ptr %26, align 4, !tbaa !65
  %28 = and i32 %27, 8388607
  %29 = shl i32 %2, 23
  %30 = add i32 %29, 8388608
  %31 = or i32 %28, %30
  store i32 %31, ptr %26, align 4, !tbaa !65
  %32 = load i32, ptr %23, align 8, !tbaa !33
  %33 = sext i32 %32 to i64
  %34 = getelementptr inbounds i32, ptr %22, i64 %33
  %35 = load i32, ptr %34, align 4, !tbaa !65
  %36 = and i32 %35, -16321
  %37 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %38 = load i32, ptr %37, align 4, !tbaa !78
  %39 = shl i32 %38, 6
  %40 = and i32 %39, 16320
  %41 = or i32 %40, %36
  store i32 %41, ptr %34, align 4, !tbaa !65
  tail call void @luaK_checkstack(ptr noundef nonnull %0, i32 noundef 1) #47
  %42 = load i32, ptr %37, align 4, !tbaa !78
  %43 = add nsw i32 %42, 1
  store i32 %43, ptr %37, align 4, !tbaa !78
  br label %44

44:                                               ; preds = %19, %5, %3
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable
define internal void @luaK_setoneret(ptr nocapture noundef readonly %0, ptr nocapture noundef %1) #4 {
  %3 = load i32, ptr %1, align 8, !tbaa !85
  switch i32 %3, label %26 [
    i32 13, label %4
    i32 14, label %15
  ]

4:                                                ; preds = %2
  store i32 12, ptr %1, align 8, !tbaa !85
  %5 = load ptr, ptr %0, align 8, !tbaa !63
  %6 = getelementptr inbounds %struct.Proto, ptr %5, i64 0, i32 4
  %7 = load ptr, ptr %6, align 8, !tbaa !64
  %8 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %9 = load i32, ptr %8, align 8, !tbaa !33
  %10 = sext i32 %9 to i64
  %11 = getelementptr inbounds i32, ptr %7, i64 %10
  %12 = load i32, ptr %11, align 4, !tbaa !65
  %13 = lshr i32 %12, 6
  %14 = and i32 %13, 255
  store i32 %14, ptr %8, align 8, !tbaa !33
  br label %26

15:                                               ; preds = %2
  %16 = load ptr, ptr %0, align 8, !tbaa !63
  %17 = getelementptr inbounds %struct.Proto, ptr %16, i64 0, i32 4
  %18 = load ptr, ptr %17, align 8, !tbaa !64
  %19 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %20 = load i32, ptr %19, align 8, !tbaa !33
  %21 = sext i32 %20 to i64
  %22 = getelementptr inbounds i32, ptr %18, i64 %21
  %23 = load i32, ptr %22, align 4, !tbaa !65
  %24 = and i32 %23, 8388607
  %25 = or i32 %24, 16777216
  store i32 %25, ptr %22, align 4, !tbaa !65
  store i32 11, ptr %1, align 8, !tbaa !85
  br label %26

26:                                               ; preds = %15, %4, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_dischargevars(ptr nocapture noundef %0, ptr nocapture noundef %1) #1 {
  %3 = load i32, ptr %1, align 8, !tbaa !85
  switch i32 %3, label %67 [
    i32 6, label %4
    i32 7, label %5
    i32 8, label %15
    i32 9, label %25
    i32 14, label %66
    i32 13, label %66
  ]

4:                                                ; preds = %2
  store i32 12, ptr %1, align 8, !tbaa !85
  br label %67

5:                                                ; preds = %2
  %6 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %7 = load i32, ptr %6, align 8, !tbaa !33
  %8 = shl i32 %7, 23
  %9 = or i32 %8, 4
  %10 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %11 = load ptr, ptr %10, align 8, !tbaa !66
  %12 = getelementptr inbounds %struct.LexState, ptr %11, i64 0, i32 2
  %13 = load i32, ptr %12, align 8, !tbaa !67
  %14 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %9, i32 noundef %13) #47
  store i32 %14, ptr %6, align 8, !tbaa !33
  store i32 11, ptr %1, align 8, !tbaa !85
  br label %67

15:                                               ; preds = %2
  %16 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %17 = load i32, ptr %16, align 8, !tbaa !33
  %18 = shl i32 %17, 14
  %19 = or i32 %18, 5
  %20 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %21 = load ptr, ptr %20, align 8, !tbaa !66
  %22 = getelementptr inbounds %struct.LexState, ptr %21, i64 0, i32 2
  %23 = load i32, ptr %22, align 8, !tbaa !67
  %24 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %19, i32 noundef %23) #47
  store i32 %24, ptr %16, align 8, !tbaa !33
  store i32 11, ptr %1, align 8, !tbaa !85
  br label %67

25:                                               ; preds = %2
  %26 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %27 = getelementptr inbounds i8, ptr %1, i64 12
  %28 = load i32, ptr %27, align 4, !tbaa !33
  %29 = and i32 %28, 256
  %30 = icmp eq i32 %29, 0
  br i1 %30, label %31, label %40

31:                                               ; preds = %25
  %32 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %33 = load i8, ptr %32, align 2, !tbaa !62
  %34 = zext i8 %33 to i32
  %35 = icmp slt i32 %28, %34
  br i1 %35, label %40, label %36

36:                                               ; preds = %31
  %37 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %38 = load i32, ptr %37, align 4, !tbaa !78
  %39 = add nsw i32 %38, -1
  store i32 %39, ptr %37, align 4, !tbaa !78
  br label %40

40:                                               ; preds = %36, %31, %25
  %41 = load i32, ptr %26, align 8, !tbaa !33
  %42 = and i32 %41, 256
  %43 = icmp eq i32 %42, 0
  br i1 %43, label %44, label %54

44:                                               ; preds = %40
  %45 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %46 = load i8, ptr %45, align 2, !tbaa !62
  %47 = zext i8 %46 to i32
  %48 = icmp slt i32 %41, %47
  br i1 %48, label %54, label %49

49:                                               ; preds = %44
  %50 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %51 = load i32, ptr %50, align 4, !tbaa !78
  %52 = add nsw i32 %51, -1
  store i32 %52, ptr %50, align 4, !tbaa !78
  %53 = load i32, ptr %26, align 8, !tbaa !33
  br label %54

54:                                               ; preds = %49, %44, %40
  %55 = phi i32 [ %41, %40 ], [ %41, %44 ], [ %53, %49 ]
  %56 = load i32, ptr %27, align 4, !tbaa !33
  %57 = shl i32 %55, 23
  %58 = shl i32 %56, 14
  %59 = or i32 %57, %58
  %60 = or i32 %59, 6
  %61 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %62 = load ptr, ptr %61, align 8, !tbaa !66
  %63 = getelementptr inbounds %struct.LexState, ptr %62, i64 0, i32 2
  %64 = load i32, ptr %63, align 8, !tbaa !67
  %65 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %60, i32 noundef %64) #47
  store i32 %65, ptr %26, align 8, !tbaa !33
  store i32 11, ptr %1, align 8, !tbaa !85
  br label %67

66:                                               ; preds = %2, %2
  tail call void @luaK_setoneret(ptr noundef %0, ptr noundef nonnull %1) #47
  br label %67

67:                                               ; preds = %66, %54, %15, %5, %4, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_exp2nextreg(ptr nocapture noundef %0, ptr nocapture noundef %1) #1 {
  tail call void @luaK_dischargevars(ptr noundef %0, ptr noundef %1) #47
  %3 = load i32, ptr %1, align 8, !tbaa !85
  %4 = icmp eq i32 %3, 12
  br i1 %4, label %5, label %19

5:                                                ; preds = %2
  %6 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %7 = load i32, ptr %6, align 8, !tbaa !33
  %8 = and i32 %7, 256
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %19

10:                                               ; preds = %5
  %11 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %12 = load i8, ptr %11, align 2, !tbaa !62
  %13 = zext i8 %12 to i32
  %14 = icmp slt i32 %7, %13
  br i1 %14, label %19, label %15

15:                                               ; preds = %10
  %16 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %17 = load i32, ptr %16, align 4, !tbaa !78
  %18 = add nsw i32 %17, -1
  store i32 %18, ptr %16, align 4, !tbaa !78
  br label %19

19:                                               ; preds = %15, %10, %5, %2
  tail call void @luaK_checkstack(ptr noundef %0, i32 noundef 1) #47
  %20 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %21 = load i32, ptr %20, align 4, !tbaa !78
  %22 = add nsw i32 %21, 1
  store i32 %22, ptr %20, align 4, !tbaa !78
  tail call fastcc void @exp2reg(ptr noundef %0, ptr noundef nonnull %1, i32 noundef %21) #47
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @exp2reg(ptr nocapture noundef %0, ptr nocapture noundef %1, i32 noundef %2) unnamed_addr #1 {
  tail call fastcc void @discharge2reg(ptr noundef %0, ptr noundef %1, i32 noundef %2) #47
  %4 = load i32, ptr %1, align 8, !tbaa !85
  %5 = icmp eq i32 %4, 10
  br i1 %5, label %6, label %10

6:                                                ; preds = %3
  %7 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 2
  %8 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %9 = load i32, ptr %8, align 8, !tbaa !33
  tail call void @luaK_concat(ptr noundef %0, ptr noundef nonnull %7, i32 noundef %9) #47
  br label %10

10:                                               ; preds = %6, %3
  %11 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 2
  %12 = load i32, ptr %11, align 8, !tbaa !87
  %13 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 3
  %14 = load i32, ptr %13, align 4, !tbaa !88
  %15 = icmp eq i32 %12, %14
  br i1 %15, label %56, label %16

16:                                               ; preds = %10
  %17 = tail call fastcc i32 @need_value(ptr noundef %0, i32 noundef %12) #47
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %19, label %22

19:                                               ; preds = %16
  %20 = tail call fastcc i32 @need_value(ptr noundef %0, i32 noundef %14) #47
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %48, label %22

22:                                               ; preds = %19, %16
  %23 = load i32, ptr %1, align 8, !tbaa !85
  %24 = icmp eq i32 %23, 10
  br i1 %24, label %27, label %25

25:                                               ; preds = %22
  %26 = tail call i32 @luaK_jump(ptr noundef %0) #47
  br label %27

27:                                               ; preds = %25, %22
  %28 = phi i32 [ %26, %25 ], [ -1, %22 ]
  %29 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 6
  %30 = load i32, ptr %29, align 8, !tbaa !59
  %31 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 7
  store i32 %30, ptr %31, align 4, !tbaa !61
  %32 = shl i32 %2, 6
  %33 = or i32 %32, 16386
  %34 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %35 = load ptr, ptr %34, align 8, !tbaa !66
  %36 = getelementptr inbounds %struct.LexState, ptr %35, i64 0, i32 2
  %37 = load i32, ptr %36, align 8, !tbaa !67
  %38 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %33, i32 noundef %37) #47
  %39 = load i32, ptr %29, align 8, !tbaa !59
  store i32 %39, ptr %31, align 4, !tbaa !61
  %40 = or i32 %32, 8388610
  %41 = load ptr, ptr %34, align 8, !tbaa !66
  %42 = getelementptr inbounds %struct.LexState, ptr %41, i64 0, i32 2
  %43 = load i32, ptr %42, align 8, !tbaa !67
  %44 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %40, i32 noundef %43) #47
  %45 = load i32, ptr %29, align 8, !tbaa !59
  store i32 %45, ptr %31, align 4, !tbaa !61
  %46 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 8
  tail call void @luaK_concat(ptr noundef %0, ptr noundef nonnull %46, i32 noundef %28) #47
  %47 = load i32, ptr %13, align 4, !tbaa !88
  br label %48

48:                                               ; preds = %27, %19
  %49 = phi i32 [ %47, %27 ], [ %14, %19 ]
  %50 = phi i32 [ %44, %27 ], [ -1, %19 ]
  %51 = phi i32 [ %38, %27 ], [ -1, %19 ]
  %52 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 6
  %53 = load i32, ptr %52, align 8, !tbaa !59
  %54 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 7
  store i32 %53, ptr %54, align 4, !tbaa !61
  tail call fastcc void @patchlistaux(ptr noundef %0, i32 noundef %49, i32 noundef %53, i32 noundef %2, i32 noundef %51) #47
  %55 = load i32, ptr %11, align 8, !tbaa !87
  tail call fastcc void @patchlistaux(ptr noundef %0, i32 noundef %55, i32 noundef %53, i32 noundef %2, i32 noundef %50) #47
  br label %56

56:                                               ; preds = %48, %10
  store i32 -1, ptr %11, align 8, !tbaa !87
  store i32 -1, ptr %13, align 4, !tbaa !88
  %57 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  store i32 %2, ptr %57, align 8, !tbaa !33
  store i32 12, ptr %1, align 8, !tbaa !85
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @discharge2reg(ptr nocapture noundef %0, ptr nocapture noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = alloca %struct.lua_TValue, align 8
  tail call void @luaK_dischargevars(ptr noundef %0, ptr noundef %1) #47
  %5 = load i32, ptr %1, align 8, !tbaa !85
  switch i32 %5, label %72 [
    i32 1, label %6
    i32 3, label %7
    i32 2, label %7
    i32 4, label %18
    i32 5, label %30
    i32 11, label %44
    i32 12, label %57
  ]

6:                                                ; preds = %3
  tail call void @luaK_nil(ptr noundef %0, i32 noundef %2, i32 noundef 1) #47
  br label %70

7:                                                ; preds = %3, %3
  %8 = icmp eq i32 %5, 2
  %9 = shl i32 %2, 6
  %10 = select i1 %8, i32 8388608, i32 2
  %11 = or i32 %9, %10
  %12 = or i32 %11, 2
  %13 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %14 = load ptr, ptr %13, align 8, !tbaa !66
  %15 = getelementptr inbounds %struct.LexState, ptr %14, i64 0, i32 2
  %16 = load i32, ptr %15, align 8, !tbaa !67
  %17 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %12, i32 noundef %16) #47
  br label %70

18:                                               ; preds = %3
  %19 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %20 = load i32, ptr %19, align 8, !tbaa !33
  %21 = shl i32 %2, 6
  %22 = shl i32 %20, 14
  %23 = or i32 %21, %22
  %24 = or i32 %23, 1
  %25 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %26 = load ptr, ptr %25, align 8, !tbaa !66
  %27 = getelementptr inbounds %struct.LexState, ptr %26, i64 0, i32 2
  %28 = load i32, ptr %27, align 8, !tbaa !67
  %29 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %24, i32 noundef %28) #47
  br label %70

30:                                               ; preds = %3
  %31 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %32 = load double, ptr %31, align 8, !tbaa !33
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %4) #48
  store double %32, ptr %4, align 8, !tbaa !33
  %33 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  store i32 3, ptr %33, align 8, !tbaa !16
  %34 = call fastcc i32 @addk(ptr noundef %0, ptr noundef nonnull %4, ptr noundef nonnull %4) #47
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %4) #48
  %35 = shl i32 %2, 6
  %36 = shl i32 %34, 14
  %37 = or i32 %35, %36
  %38 = or i32 %37, 1
  %39 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %40 = load ptr, ptr %39, align 8, !tbaa !66
  %41 = getelementptr inbounds %struct.LexState, ptr %40, i64 0, i32 2
  %42 = load i32, ptr %41, align 8, !tbaa !67
  %43 = call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %38, i32 noundef %42) #47
  br label %70

44:                                               ; preds = %3
  %45 = load ptr, ptr %0, align 8, !tbaa !63
  %46 = getelementptr inbounds %struct.Proto, ptr %45, i64 0, i32 4
  %47 = load ptr, ptr %46, align 8, !tbaa !64
  %48 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %49 = load i32, ptr %48, align 8, !tbaa !33
  %50 = sext i32 %49 to i64
  %51 = getelementptr inbounds i32, ptr %47, i64 %50
  %52 = load i32, ptr %51, align 4, !tbaa !65
  %53 = and i32 %52, -16321
  %54 = shl i32 %2, 6
  %55 = and i32 %54, 16320
  %56 = or i32 %53, %55
  store i32 %56, ptr %51, align 4, !tbaa !65
  br label %70

57:                                               ; preds = %3
  %58 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %59 = load i32, ptr %58, align 8, !tbaa !33
  %60 = icmp eq i32 %59, %2
  br i1 %60, label %70, label %61

61:                                               ; preds = %57
  %62 = shl i32 %2, 6
  %63 = shl i32 %59, 23
  %64 = or i32 %63, %62
  %65 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %66 = load ptr, ptr %65, align 8, !tbaa !66
  %67 = getelementptr inbounds %struct.LexState, ptr %66, i64 0, i32 2
  %68 = load i32, ptr %67, align 8, !tbaa !67
  %69 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %64, i32 noundef %68) #47
  br label %70

70:                                               ; preds = %61, %57, %44, %30, %18, %7, %6
  %71 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  store i32 %2, ptr %71, align 8, !tbaa !33
  store i32 12, ptr %1, align 8, !tbaa !85
  br label %72

72:                                               ; preds = %70, %3
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind optsize memory(read, inaccessiblemem: none) uwtable
define internal fastcc i32 @need_value(ptr nocapture noundef readonly %0, i32 noundef %1) unnamed_addr #14 {
  %3 = icmp eq i32 %1, -1
  br i1 %3, label %36, label %4

4:                                                ; preds = %2
  %5 = load ptr, ptr %0, align 8, !tbaa !63
  %6 = getelementptr inbounds %struct.Proto, ptr %5, i64 0, i32 4
  %7 = load ptr, ptr %6, align 8, !tbaa !64
  br label %8

8:                                                ; preds = %27, %4
  %9 = phi i32 [ %1, %4 ], [ %33, %27 ]
  %10 = sext i32 %9 to i64
  %11 = getelementptr inbounds i32, ptr %7, i64 %10
  %12 = icmp sgt i32 %9, 0
  br i1 %12, label %13, label %21

13:                                               ; preds = %8
  %14 = getelementptr inbounds i32, ptr %11, i64 -1
  %15 = load i32, ptr %14, align 4, !tbaa !65
  %16 = and i32 %15, 63
  %17 = zext i32 %16 to i64
  %18 = getelementptr inbounds [38 x i8], ptr @luaP_opmodes, i64 0, i64 %17
  %19 = load i8, ptr %18, align 1, !tbaa !33
  %20 = icmp sgt i8 %19, -1
  br i1 %20, label %21, label %23

21:                                               ; preds = %13, %8
  %22 = load i32, ptr %11, align 4, !tbaa !65
  br label %23

23:                                               ; preds = %21, %13
  %24 = phi i32 [ %22, %21 ], [ %15, %13 ]
  %25 = and i32 %24, 63
  %26 = icmp eq i32 %25, 27
  br i1 %26, label %27, label %36

27:                                               ; preds = %23
  %28 = load i32, ptr %11, align 4, !tbaa !65
  %29 = lshr i32 %28, 14
  %30 = add nsw i32 %29, -131071
  %31 = icmp eq i32 %30, -1
  %32 = add nuw nsw i32 %9, 1
  %33 = add nsw i32 %32, %30
  %34 = icmp eq i32 %33, -1
  %35 = select i1 %31, i1 true, i1 %34
  br i1 %35, label %36, label %8

36:                                               ; preds = %27, %23, %2
  %37 = phi i32 [ 0, %2 ], [ 1, %23 ], [ 0, %27 ]
  ret i32 %37
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaK_exp2anyreg(ptr nocapture noundef %0, ptr nocapture noundef %1) #1 {
  tail call void @luaK_dischargevars(ptr noundef %0, ptr noundef %1) #47
  %3 = load i32, ptr %1, align 8, !tbaa !85
  %4 = icmp eq i32 %3, 12
  br i1 %4, label %5, label %19

5:                                                ; preds = %2
  %6 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 2
  %7 = load i32, ptr %6, align 8, !tbaa !87
  %8 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 3
  %9 = load i32, ptr %8, align 4, !tbaa !88
  %10 = icmp eq i32 %7, %9
  %11 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  br i1 %10, label %21, label %12

12:                                               ; preds = %5
  %13 = load i32, ptr %11, align 8, !tbaa !33
  %14 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %15 = load i8, ptr %14, align 2, !tbaa !62
  %16 = zext i8 %15 to i32
  %17 = icmp slt i32 %13, %16
  br i1 %17, label %19, label %18

18:                                               ; preds = %12
  tail call fastcc void @exp2reg(ptr noundef nonnull %0, ptr noundef nonnull %1, i32 noundef %13) #47
  br label %21

19:                                               ; preds = %12, %2
  tail call void @luaK_exp2nextreg(ptr noundef %0, ptr noundef nonnull %1) #47
  %20 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  br label %21

21:                                               ; preds = %19, %18, %5
  %22 = phi ptr [ %11, %18 ], [ %20, %19 ], [ %11, %5 ]
  %23 = load i32, ptr %22, align 8, !tbaa !33
  ret i32 %23
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_exp2val(ptr nocapture noundef %0, ptr nocapture noundef %1) #1 {
  %3 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 2
  %4 = load i32, ptr %3, align 8, !tbaa !87
  %5 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 3
  %6 = load i32, ptr %5, align 4, !tbaa !88
  %7 = icmp eq i32 %4, %6
  br i1 %7, label %10, label %8

8:                                                ; preds = %2
  %9 = tail call i32 @luaK_exp2anyreg(ptr noundef %0, ptr noundef nonnull %1) #47
  br label %11

10:                                               ; preds = %2
  tail call void @luaK_dischargevars(ptr noundef %0, ptr noundef nonnull %1) #47
  br label %11

11:                                               ; preds = %10, %8
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaK_exp2RK(ptr nocapture noundef %0, ptr nocapture noundef %1) #1 {
  %3 = alloca %struct.lua_TValue, align 8
  %4 = alloca %struct.lua_TValue, align 8
  %5 = alloca %struct.lua_TValue, align 8
  %6 = alloca %struct.lua_TValue, align 8
  tail call void @luaK_exp2val(ptr noundef %0, ptr noundef %1) #47
  %7 = load i32, ptr %1, align 8, !tbaa !85
  switch i32 %7, label %39 [
    i32 5, label %8
    i32 2, label %8
    i32 3, label %8
    i32 1, label %8
    i32 4, label %33
  ]

8:                                                ; preds = %2, %2, %2, %2
  %9 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 10
  %10 = load i32, ptr %9, align 8, !tbaa !82
  %11 = icmp slt i32 %10, 256
  br i1 %11, label %12, label %39

12:                                               ; preds = %8
  switch i32 %7, label %24 [
    i32 1, label %13
    i32 5, label %19
  ]

13:                                               ; preds = %12
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %5) #48
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %6) #48
  %14 = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 0, i32 1
  store i32 0, ptr %14, align 8, !tbaa !16
  %15 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 1
  %16 = load ptr, ptr %15, align 8, !tbaa !80
  store ptr %16, ptr %5, align 8, !tbaa !33
  %17 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 0, i32 1
  store i32 5, ptr %17, align 8, !tbaa !16
  %18 = call fastcc i32 @addk(ptr noundef nonnull %0, ptr noundef nonnull %5, ptr noundef nonnull %6) #47
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %6) #48
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %5) #48
  br label %29

19:                                               ; preds = %12
  %20 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %21 = load double, ptr %20, align 8, !tbaa !33
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %4) #48
  store double %21, ptr %4, align 8, !tbaa !33
  %22 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  store i32 3, ptr %22, align 8, !tbaa !16
  %23 = call fastcc i32 @addk(ptr noundef nonnull %0, ptr noundef nonnull %4, ptr noundef nonnull %4) #47
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %4) #48
  br label %29

24:                                               ; preds = %12
  %25 = icmp eq i32 %7, 2
  %26 = zext i1 %25 to i32
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %3) #48
  store i32 %26, ptr %3, align 8, !tbaa !33
  %27 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  store i32 1, ptr %27, align 8, !tbaa !16
  %28 = call fastcc i32 @addk(ptr noundef nonnull %0, ptr noundef nonnull %3, ptr noundef nonnull %3) #47
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %3) #48
  br label %29

29:                                               ; preds = %24, %19, %13
  %30 = phi i32 [ %18, %13 ], [ %23, %19 ], [ %28, %24 ]
  %31 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  store i32 %30, ptr %31, align 8, !tbaa !33
  store i32 4, ptr %1, align 8, !tbaa !85
  %32 = or i32 %30, 256
  br label %41

33:                                               ; preds = %2
  %34 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %35 = load i32, ptr %34, align 8, !tbaa !33
  %36 = icmp slt i32 %35, 256
  br i1 %36, label %37, label %39

37:                                               ; preds = %33
  %38 = or i32 %35, 256
  br label %41

39:                                               ; preds = %33, %8, %2
  %40 = tail call i32 @luaK_exp2anyreg(ptr noundef %0, ptr noundef nonnull %1) #47
  br label %41

41:                                               ; preds = %39, %37, %29
  %42 = phi i32 [ %40, %39 ], [ %38, %37 ], [ %32, %29 ]
  ret i32 %42
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_storevar(ptr nocapture noundef %0, ptr nocapture noundef readonly %1, ptr nocapture noundef %2) #1 {
  %4 = load i32, ptr %1, align 8, !tbaa !85
  switch i32 %4, label %60 [
    i32 6, label %5
    i32 7, label %25
    i32 8, label %33
    i32 9, label %41
  ]

5:                                                ; preds = %3
  %6 = load i32, ptr %2, align 8, !tbaa !85
  %7 = icmp eq i32 %6, 12
  br i1 %7, label %8, label %22

8:                                                ; preds = %5
  %9 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  %10 = load i32, ptr %9, align 8, !tbaa !33
  %11 = and i32 %10, 256
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %13, label %22

13:                                               ; preds = %8
  %14 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %15 = load i8, ptr %14, align 2, !tbaa !62
  %16 = zext i8 %15 to i32
  %17 = icmp slt i32 %10, %16
  br i1 %17, label %22, label %18

18:                                               ; preds = %13
  %19 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %20 = load i32, ptr %19, align 4, !tbaa !78
  %21 = add nsw i32 %20, -1
  store i32 %21, ptr %19, align 4, !tbaa !78
  br label %22

22:                                               ; preds = %18, %13, %8, %5
  %23 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %24 = load i32, ptr %23, align 8, !tbaa !33
  tail call fastcc void @exp2reg(ptr noundef %0, ptr noundef nonnull %2, i32 noundef %24) #47
  br label %77

25:                                               ; preds = %3
  %26 = tail call i32 @luaK_exp2anyreg(ptr noundef %0, ptr noundef %2) #47
  %27 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %28 = load i32, ptr %27, align 8, !tbaa !33
  %29 = shl i32 %26, 6
  %30 = shl i32 %28, 23
  %31 = or i32 %29, %30
  %32 = or i32 %31, 8
  br label %53

33:                                               ; preds = %3
  %34 = tail call i32 @luaK_exp2anyreg(ptr noundef %0, ptr noundef %2) #47
  %35 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %36 = load i32, ptr %35, align 8, !tbaa !33
  %37 = shl i32 %34, 6
  %38 = shl i32 %36, 14
  %39 = or i32 %37, %38
  %40 = or i32 %39, 7
  br label %53

41:                                               ; preds = %3
  %42 = tail call i32 @luaK_exp2RK(ptr noundef %0, ptr noundef %2) #47
  %43 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %44 = load i32, ptr %43, align 8, !tbaa !33
  %45 = getelementptr inbounds i8, ptr %1, i64 12
  %46 = load i32, ptr %45, align 4, !tbaa !33
  %47 = shl i32 %44, 6
  %48 = shl i32 %46, 23
  %49 = shl i32 %42, 14
  %50 = or i32 %49, %47
  %51 = or i32 %50, %48
  %52 = or i32 %51, 9
  br label %53

53:                                               ; preds = %41, %33, %25
  %54 = phi i32 [ %52, %41 ], [ %40, %33 ], [ %32, %25 ]
  %55 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %56 = load ptr, ptr %55, align 8, !tbaa !66
  %57 = getelementptr inbounds %struct.LexState, ptr %56, i64 0, i32 2
  %58 = load i32, ptr %57, align 8, !tbaa !67
  %59 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %54, i32 noundef %58) #47
  br label %60

60:                                               ; preds = %53, %3
  %61 = load i32, ptr %2, align 8, !tbaa !85
  %62 = icmp eq i32 %61, 12
  br i1 %62, label %63, label %77

63:                                               ; preds = %60
  %64 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  %65 = load i32, ptr %64, align 8, !tbaa !33
  %66 = and i32 %65, 256
  %67 = icmp eq i32 %66, 0
  br i1 %67, label %68, label %77

68:                                               ; preds = %63
  %69 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %70 = load i8, ptr %69, align 2, !tbaa !62
  %71 = zext i8 %70 to i32
  %72 = icmp slt i32 %65, %71
  br i1 %72, label %77, label %73

73:                                               ; preds = %68
  %74 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %75 = load i32, ptr %74, align 4, !tbaa !78
  %76 = add nsw i32 %75, -1
  store i32 %76, ptr %74, align 4, !tbaa !78
  br label %77

77:                                               ; preds = %73, %68, %63, %60, %22
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_self(ptr nocapture noundef %0, ptr nocapture noundef %1, ptr nocapture noundef %2) #1 {
  %4 = tail call i32 @luaK_exp2anyreg(ptr noundef %0, ptr noundef %1) #47
  %5 = load i32, ptr %1, align 8, !tbaa !85
  %6 = icmp eq i32 %5, 12
  br i1 %6, label %7, label %21

7:                                                ; preds = %3
  %8 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %9 = load i32, ptr %8, align 8, !tbaa !33
  %10 = and i32 %9, 256
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %12, label %21

12:                                               ; preds = %7
  %13 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %14 = load i8, ptr %13, align 2, !tbaa !62
  %15 = zext i8 %14 to i32
  %16 = icmp slt i32 %9, %15
  br i1 %16, label %21, label %17

17:                                               ; preds = %12
  %18 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %19 = load i32, ptr %18, align 4, !tbaa !78
  %20 = add nsw i32 %19, -1
  store i32 %20, ptr %18, align 4, !tbaa !78
  br label %21

21:                                               ; preds = %17, %12, %7, %3
  %22 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %23 = load i32, ptr %22, align 4, !tbaa !78
  tail call void @luaK_checkstack(ptr noundef %0, i32 noundef 2) #47
  %24 = load i32, ptr %22, align 4, !tbaa !78
  %25 = add nsw i32 %24, 2
  store i32 %25, ptr %22, align 4, !tbaa !78
  %26 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %27 = load i32, ptr %26, align 8, !tbaa !33
  %28 = tail call i32 @luaK_exp2RK(ptr noundef %0, ptr noundef %2) #47
  %29 = shl i32 %23, 6
  %30 = shl i32 %27, 23
  %31 = shl i32 %28, 14
  %32 = or i32 %29, %30
  %33 = or i32 %32, %31
  %34 = or i32 %33, 11
  %35 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %36 = load ptr, ptr %35, align 8, !tbaa !66
  %37 = getelementptr inbounds %struct.LexState, ptr %36, i64 0, i32 2
  %38 = load i32, ptr %37, align 8, !tbaa !67
  %39 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %34, i32 noundef %38) #47
  %40 = load i32, ptr %2, align 8, !tbaa !85
  %41 = icmp eq i32 %40, 12
  br i1 %41, label %42, label %55

42:                                               ; preds = %21
  %43 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  %44 = load i32, ptr %43, align 8, !tbaa !33
  %45 = and i32 %44, 256
  %46 = icmp eq i32 %45, 0
  br i1 %46, label %47, label %55

47:                                               ; preds = %42
  %48 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %49 = load i8, ptr %48, align 2, !tbaa !62
  %50 = zext i8 %49 to i32
  %51 = icmp slt i32 %44, %50
  br i1 %51, label %55, label %52

52:                                               ; preds = %47
  %53 = load i32, ptr %22, align 4, !tbaa !78
  %54 = add nsw i32 %53, -1
  store i32 %54, ptr %22, align 4, !tbaa !78
  br label %55

55:                                               ; preds = %52, %47, %42, %21
  store i32 %23, ptr %26, align 8, !tbaa !33
  store i32 12, ptr %1, align 8, !tbaa !85
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_goiftrue(ptr nocapture noundef %0, ptr nocapture noundef %1) #1 {
  tail call void @luaK_dischargevars(ptr noundef %0, ptr noundef %1) #47
  %3 = load i32, ptr %1, align 8, !tbaa !85
  switch i32 %3, label %34 [
    i32 4, label %36
    i32 5, label %36
    i32 2, label %36
    i32 3, label %4
    i32 10, label %6
  ]

4:                                                ; preds = %2
  %5 = tail call i32 @luaK_jump(ptr noundef %0) #47
  br label %36

6:                                                ; preds = %2
  %7 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %8 = load i32, ptr %7, align 8, !tbaa !33
  %9 = load ptr, ptr %0, align 8, !tbaa !63
  %10 = getelementptr inbounds %struct.Proto, ptr %9, i64 0, i32 4
  %11 = load ptr, ptr %10, align 8, !tbaa !64
  %12 = sext i32 %8 to i64
  %13 = getelementptr inbounds i32, ptr %11, i64 %12
  %14 = icmp sgt i32 %8, 0
  br i1 %14, label %15, label %23

15:                                               ; preds = %6
  %16 = getelementptr inbounds i32, ptr %13, i64 -1
  %17 = load i32, ptr %16, align 4, !tbaa !65
  %18 = and i32 %17, 63
  %19 = zext i32 %18 to i64
  %20 = getelementptr inbounds [38 x i8], ptr @luaP_opmodes, i64 0, i64 %19
  %21 = load i8, ptr %20, align 1, !tbaa !33
  %22 = icmp sgt i8 %21, -1
  br i1 %22, label %23, label %25

23:                                               ; preds = %15, %6
  %24 = load i32, ptr %13, align 4, !tbaa !65
  br label %25

25:                                               ; preds = %23, %15
  %26 = phi i32 [ %24, %23 ], [ %17, %15 ]
  %27 = phi ptr [ %13, %23 ], [ %16, %15 ]
  %28 = and i32 %26, -16321
  %29 = and i32 %26, 16320
  %30 = icmp eq i32 %29, 0
  %31 = select i1 %30, i32 64, i32 0
  %32 = or i32 %31, %28
  store i32 %32, ptr %27, align 4, !tbaa !65
  %33 = load i32, ptr %7, align 8, !tbaa !33
  br label %36

34:                                               ; preds = %2
  %35 = tail call fastcc i32 @jumponcond(ptr noundef %0, ptr noundef nonnull %1, i32 noundef 0) #47
  br label %36

36:                                               ; preds = %34, %25, %4, %2, %2, %2
  %37 = phi i32 [ %35, %34 ], [ %33, %25 ], [ %5, %4 ], [ -1, %2 ], [ -1, %2 ], [ -1, %2 ]
  %38 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 3
  tail call void @luaK_concat(ptr noundef %0, ptr noundef nonnull %38, i32 noundef %37) #47
  %39 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 2
  %40 = load i32, ptr %39, align 8, !tbaa !87
  %41 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 6
  %42 = load i32, ptr %41, align 8, !tbaa !59
  %43 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 7
  store i32 %42, ptr %43, align 4, !tbaa !61
  %44 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 8
  tail call void @luaK_concat(ptr noundef %0, ptr noundef nonnull %44, i32 noundef %40) #47
  store i32 -1, ptr %39, align 8, !tbaa !87
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @jumponcond(ptr nocapture noundef %0, ptr nocapture noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = load i32, ptr %1, align 8, !tbaa !85
  %5 = icmp eq i32 %4, 11
  br i1 %5, label %6, label %32

6:                                                ; preds = %3
  %7 = load ptr, ptr %0, align 8, !tbaa !63
  %8 = getelementptr inbounds %struct.Proto, ptr %7, i64 0, i32 4
  %9 = load ptr, ptr %8, align 8, !tbaa !64
  %10 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %11 = load i32, ptr %10, align 8, !tbaa !33
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds i32, ptr %9, i64 %12
  %14 = load i32, ptr %13, align 4, !tbaa !65
  %15 = and i32 %14, 63
  %16 = icmp eq i32 %15, 19
  br i1 %16, label %17, label %32

17:                                               ; preds = %6
  %18 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 6
  %19 = load i32, ptr %18, align 8, !tbaa !59
  %20 = add nsw i32 %19, -1
  store i32 %20, ptr %18, align 8, !tbaa !59
  %21 = icmp eq i32 %2, 0
  %22 = lshr i32 %14, 17
  %23 = and i32 %22, 32704
  %24 = select i1 %21, i32 16410, i32 26
  %25 = or i32 %24, %23
  %26 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %27 = load ptr, ptr %26, align 8, !tbaa !66
  %28 = getelementptr inbounds %struct.LexState, ptr %27, i64 0, i32 2
  %29 = load i32, ptr %28, align 8, !tbaa !67
  %30 = tail call fastcc i32 @luaK_code(ptr noundef nonnull %0, i32 noundef %25, i32 noundef %29) #47
  %31 = tail call i32 @luaK_jump(ptr noundef nonnull %0) #47
  br label %62

32:                                               ; preds = %6, %3
  tail call fastcc void @discharge2anyreg(ptr noundef %0, ptr noundef nonnull %1) #47
  %33 = load i32, ptr %1, align 8, !tbaa !85
  %34 = icmp eq i32 %33, 12
  br i1 %34, label %35, label %49

35:                                               ; preds = %32
  %36 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %37 = load i32, ptr %36, align 8, !tbaa !33
  %38 = and i32 %37, 256
  %39 = icmp eq i32 %38, 0
  br i1 %39, label %40, label %49

40:                                               ; preds = %35
  %41 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %42 = load i8, ptr %41, align 2, !tbaa !62
  %43 = zext i8 %42 to i32
  %44 = icmp slt i32 %37, %43
  br i1 %44, label %49, label %45

45:                                               ; preds = %40
  %46 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %47 = load i32, ptr %46, align 4, !tbaa !78
  %48 = add nsw i32 %47, -1
  store i32 %48, ptr %46, align 4, !tbaa !78
  br label %49

49:                                               ; preds = %45, %40, %35, %32
  %50 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %51 = load i32, ptr %50, align 8, !tbaa !33
  %52 = shl i32 %51, 23
  %53 = shl i32 %2, 14
  %54 = or i32 %53, %52
  %55 = or i32 %54, 16347
  %56 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %57 = load ptr, ptr %56, align 8, !tbaa !66
  %58 = getelementptr inbounds %struct.LexState, ptr %57, i64 0, i32 2
  %59 = load i32, ptr %58, align 8, !tbaa !67
  %60 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %55, i32 noundef %59) #47
  %61 = tail call i32 @luaK_jump(ptr noundef %0) #47
  br label %62

62:                                               ; preds = %49, %17
  %63 = phi i32 [ %31, %17 ], [ %61, %49 ]
  ret i32 %63
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @discharge2anyreg(ptr nocapture noundef %0, ptr nocapture noundef %1) unnamed_addr #1 {
  %3 = load i32, ptr %1, align 8, !tbaa !85
  %4 = icmp eq i32 %3, 12
  br i1 %4, label %9, label %5

5:                                                ; preds = %2
  tail call void @luaK_checkstack(ptr noundef %0, i32 noundef 1) #47
  %6 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %7 = load i32, ptr %6, align 4, !tbaa !78
  %8 = add nsw i32 %7, 1
  store i32 %8, ptr %6, align 4, !tbaa !78
  tail call fastcc void @discharge2reg(ptr noundef %0, ptr noundef nonnull %1, i32 noundef %7) #47
  br label %9

9:                                                ; preds = %5, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_indexed(ptr nocapture noundef %0, ptr nocapture noundef writeonly %1, ptr nocapture noundef %2) #1 {
  %4 = tail call i32 @luaK_exp2RK(ptr noundef %0, ptr noundef %2) #47
  %5 = getelementptr inbounds i8, ptr %1, i64 12
  store i32 %4, ptr %5, align 4, !tbaa !33
  store i32 9, ptr %1, align 8, !tbaa !85
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_prefix(ptr nocapture noundef %0, i32 noundef %1, ptr nocapture noundef %2) #1 {
  %4 = alloca %struct.expdesc, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4) #48
  %5 = getelementptr inbounds %struct.expdesc, ptr %4, i64 0, i32 3
  store i32 -1, ptr %5, align 4, !tbaa !88
  %6 = getelementptr inbounds %struct.expdesc, ptr %4, i64 0, i32 2
  store i32 -1, ptr %6, align 8, !tbaa !87
  store i32 5, ptr %4, align 8, !tbaa !85
  %7 = getelementptr inbounds %struct.expdesc, ptr %4, i64 0, i32 1
  store double 0.000000e+00, ptr %7, align 8, !tbaa !33
  switch i32 %1, label %88 [
    i32 0, label %8
    i32 1, label %22
    i32 2, label %86
  ]

8:                                                ; preds = %3
  %9 = load i32, ptr %2, align 8, !tbaa !85
  %10 = icmp eq i32 %9, 5
  br i1 %10, label %11, label %19

11:                                               ; preds = %8
  %12 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 2
  %13 = load i32, ptr %12, align 8, !tbaa !87
  %14 = icmp eq i32 %13, -1
  br i1 %14, label %15, label %19

15:                                               ; preds = %11
  %16 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 3
  %17 = load i32, ptr %16, align 4, !tbaa !88
  %18 = icmp eq i32 %17, -1
  br i1 %18, label %21, label %19

19:                                               ; preds = %15, %11, %8
  %20 = tail call i32 @luaK_exp2anyreg(ptr noundef %0, ptr noundef nonnull %2) #47
  br label %21

21:                                               ; preds = %19, %15
  call fastcc void @codearith(ptr noundef %0, i32 noundef 18, ptr noundef nonnull %2, ptr noundef nonnull %4) #47
  br label %88

22:                                               ; preds = %3
  tail call void @luaK_dischargevars(ptr noundef %0, ptr noundef %2) #47
  %23 = load i32, ptr %2, align 8, !tbaa !85
  switch i32 %23, label %80 [
    i32 1, label %24
    i32 3, label %24
    i32 4, label %25
    i32 5, label %25
    i32 2, label %25
    i32 10, label %26
    i32 11, label %53
    i32 12, label %53
  ]

24:                                               ; preds = %22, %22
  store i32 2, ptr %2, align 8, !tbaa !85
  br label %80

25:                                               ; preds = %22, %22, %22
  store i32 3, ptr %2, align 8, !tbaa !85
  br label %80

26:                                               ; preds = %22
  %27 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  %28 = load i32, ptr %27, align 8, !tbaa !33
  %29 = load ptr, ptr %0, align 8, !tbaa !63
  %30 = getelementptr inbounds %struct.Proto, ptr %29, i64 0, i32 4
  %31 = load ptr, ptr %30, align 8, !tbaa !64
  %32 = sext i32 %28 to i64
  %33 = getelementptr inbounds i32, ptr %31, i64 %32
  %34 = icmp sgt i32 %28, 0
  br i1 %34, label %35, label %43

35:                                               ; preds = %26
  %36 = getelementptr inbounds i32, ptr %33, i64 -1
  %37 = load i32, ptr %36, align 4, !tbaa !65
  %38 = and i32 %37, 63
  %39 = zext i32 %38 to i64
  %40 = getelementptr inbounds [38 x i8], ptr @luaP_opmodes, i64 0, i64 %39
  %41 = load i8, ptr %40, align 1, !tbaa !33
  %42 = icmp sgt i8 %41, -1
  br i1 %42, label %43, label %45

43:                                               ; preds = %35, %26
  %44 = load i32, ptr %33, align 4, !tbaa !65
  br label %45

45:                                               ; preds = %43, %35
  %46 = phi i32 [ %44, %43 ], [ %37, %35 ]
  %47 = phi ptr [ %33, %43 ], [ %36, %35 ]
  %48 = and i32 %46, -16321
  %49 = and i32 %46, 16320
  %50 = icmp eq i32 %49, 0
  %51 = select i1 %50, i32 64, i32 0
  %52 = or i32 %51, %48
  store i32 %52, ptr %47, align 4, !tbaa !65
  br label %80

53:                                               ; preds = %22, %22
  tail call fastcc void @discharge2anyreg(ptr noundef %0, ptr noundef nonnull %2) #47
  %54 = load i32, ptr %2, align 8, !tbaa !85
  %55 = icmp eq i32 %54, 12
  br i1 %55, label %56, label %70

56:                                               ; preds = %53
  %57 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  %58 = load i32, ptr %57, align 8, !tbaa !33
  %59 = and i32 %58, 256
  %60 = icmp eq i32 %59, 0
  br i1 %60, label %61, label %70

61:                                               ; preds = %56
  %62 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %63 = load i8, ptr %62, align 2, !tbaa !62
  %64 = zext i8 %63 to i32
  %65 = icmp slt i32 %58, %64
  br i1 %65, label %70, label %66

66:                                               ; preds = %61
  %67 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %68 = load i32, ptr %67, align 4, !tbaa !78
  %69 = add nsw i32 %68, -1
  store i32 %69, ptr %67, align 4, !tbaa !78
  br label %70

70:                                               ; preds = %66, %61, %56, %53
  %71 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  %72 = load i32, ptr %71, align 8, !tbaa !33
  %73 = shl i32 %72, 23
  %74 = or i32 %73, 19
  %75 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %76 = load ptr, ptr %75, align 8, !tbaa !66
  %77 = getelementptr inbounds %struct.LexState, ptr %76, i64 0, i32 2
  %78 = load i32, ptr %77, align 8, !tbaa !67
  %79 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %74, i32 noundef %78) #47
  store i32 %79, ptr %71, align 8, !tbaa !33
  store i32 11, ptr %2, align 8, !tbaa !85
  br label %80

80:                                               ; preds = %70, %45, %25, %24, %22
  %81 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 3
  %82 = load i32, ptr %81, align 4, !tbaa !88
  %83 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 2
  %84 = load i32, ptr %83, align 8, !tbaa !87
  store i32 %84, ptr %81, align 4, !tbaa !88
  store i32 %82, ptr %83, align 8, !tbaa !87
  tail call fastcc void @removevalues(ptr noundef %0, i32 noundef %84) #47
  %85 = load i32, ptr %83, align 8, !tbaa !87
  tail call fastcc void @removevalues(ptr noundef %0, i32 noundef %85) #47
  br label %88

86:                                               ; preds = %3
  %87 = tail call i32 @luaK_exp2anyreg(ptr noundef %0, ptr noundef %2) #47
  call fastcc void @codearith(ptr noundef %0, i32 noundef 20, ptr noundef %2, ptr noundef nonnull %4) #47
  br label %88

88:                                               ; preds = %86, %80, %21, %3
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @codearith(ptr nocapture noundef %0, i32 noundef %1, ptr nocapture noundef %2, ptr nocapture noundef %3) unnamed_addr #1 {
  %5 = load i32, ptr %2, align 8, !tbaa !85
  %6 = icmp eq i32 %5, 5
  br i1 %6, label %7, label %57

7:                                                ; preds = %4
  %8 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 2
  %9 = load i32, ptr %8, align 8, !tbaa !87
  %10 = icmp eq i32 %9, -1
  br i1 %10, label %11, label %57

11:                                               ; preds = %7
  %12 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 3
  %13 = load i32, ptr %12, align 4, !tbaa !88
  %14 = icmp eq i32 %13, -1
  br i1 %14, label %15, label %57

15:                                               ; preds = %11
  %16 = load i32, ptr %3, align 8, !tbaa !85
  %17 = icmp eq i32 %16, 5
  br i1 %17, label %18, label %57

18:                                               ; preds = %15
  %19 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 2
  %20 = load i32, ptr %19, align 8, !tbaa !87
  %21 = icmp eq i32 %20, -1
  br i1 %21, label %22, label %57

22:                                               ; preds = %18
  %23 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 3
  %24 = load i32, ptr %23, align 4, !tbaa !88
  %25 = icmp eq i32 %24, -1
  br i1 %25, label %26, label %57

26:                                               ; preds = %22
  %27 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  %28 = load double, ptr %27, align 8, !tbaa !33
  %29 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 1
  %30 = load double, ptr %29, align 8, !tbaa !33
  switch i32 %1, label %55 [
    i32 12, label %31
    i32 13, label %33
    i32 14, label %35
    i32 15, label %37
    i32 16, label %41
    i32 17, label %48
    i32 18, label %50
    i32 20, label %60
  ]

31:                                               ; preds = %26
  %32 = fadd double %28, %30
  br label %52

33:                                               ; preds = %26
  %34 = fsub double %28, %30
  br label %52

35:                                               ; preds = %26
  %36 = fmul double %28, %30
  br label %52

37:                                               ; preds = %26
  %38 = fcmp oeq double %30, 0.000000e+00
  br i1 %38, label %58, label %39

39:                                               ; preds = %37
  %40 = fdiv double %28, %30
  br label %52

41:                                               ; preds = %26
  %42 = fcmp oeq double %30, 0.000000e+00
  br i1 %42, label %58, label %43

43:                                               ; preds = %41
  %44 = fdiv double %28, %30
  %45 = tail call double @llvm.floor.f64(double %44)
  %46 = fneg double %45
  %47 = tail call double @llvm.fmuladd.f64(double %46, double %30, double %28)
  br label %52

48:                                               ; preds = %26
  %49 = tail call double @pow(double noundef %28, double noundef %30) #46
  br label %52

50:                                               ; preds = %26
  %51 = fneg double %28
  br label %52

52:                                               ; preds = %50, %48, %43, %39, %35, %33, %31
  %53 = phi double [ %51, %50 ], [ %49, %48 ], [ %47, %43 ], [ %40, %39 ], [ %36, %35 ], [ %34, %33 ], [ %32, %31 ]
  %54 = fcmp ord double %53, 0.000000e+00
  br i1 %54, label %55, label %57

55:                                               ; preds = %52, %26
  %56 = phi double [ %53, %52 ], [ 0.000000e+00, %26 ]
  store double %56, ptr %27, align 8, !tbaa !33
  br label %139

57:                                               ; preds = %52, %22, %18, %15, %11, %7, %4
  switch i32 %1, label %58 [
    i32 20, label %60
    i32 18, label %60
  ]

58:                                               ; preds = %57, %41, %37
  %59 = tail call i32 @luaK_exp2RK(ptr noundef %0, ptr noundef %3) #47
  br label %60

60:                                               ; preds = %58, %57, %57, %26
  %61 = phi i32 [ %59, %58 ], [ 0, %57 ], [ 0, %57 ], [ 0, %26 ]
  %62 = tail call i32 @luaK_exp2RK(ptr noundef %0, ptr noundef nonnull %2) #47
  %63 = icmp sgt i32 %62, %61
  br i1 %63, label %64, label %94

64:                                               ; preds = %60
  %65 = load i32, ptr %2, align 8, !tbaa !85
  %66 = icmp eq i32 %65, 12
  br i1 %66, label %67, label %81

67:                                               ; preds = %64
  %68 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  %69 = load i32, ptr %68, align 8, !tbaa !33
  %70 = and i32 %69, 256
  %71 = icmp eq i32 %70, 0
  br i1 %71, label %72, label %81

72:                                               ; preds = %67
  %73 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %74 = load i8, ptr %73, align 2, !tbaa !62
  %75 = zext i8 %74 to i32
  %76 = icmp slt i32 %69, %75
  br i1 %76, label %81, label %77

77:                                               ; preds = %72
  %78 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %79 = load i32, ptr %78, align 4, !tbaa !78
  %80 = add nsw i32 %79, -1
  store i32 %80, ptr %78, align 4, !tbaa !78
  br label %81

81:                                               ; preds = %77, %72, %67, %64
  %82 = load i32, ptr %3, align 8, !tbaa !85
  %83 = icmp eq i32 %82, 12
  br i1 %83, label %84, label %128

84:                                               ; preds = %81
  %85 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 1
  %86 = load i32, ptr %85, align 8, !tbaa !33
  %87 = and i32 %86, 256
  %88 = icmp eq i32 %87, 0
  br i1 %88, label %89, label %128

89:                                               ; preds = %84
  %90 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %91 = load i8, ptr %90, align 2, !tbaa !62
  %92 = zext i8 %91 to i32
  %93 = icmp slt i32 %86, %92
  br i1 %93, label %128, label %124

94:                                               ; preds = %60
  %95 = load i32, ptr %3, align 8, !tbaa !85
  %96 = icmp eq i32 %95, 12
  br i1 %96, label %97, label %111

97:                                               ; preds = %94
  %98 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 1
  %99 = load i32, ptr %98, align 8, !tbaa !33
  %100 = and i32 %99, 256
  %101 = icmp eq i32 %100, 0
  br i1 %101, label %102, label %111

102:                                              ; preds = %97
  %103 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %104 = load i8, ptr %103, align 2, !tbaa !62
  %105 = zext i8 %104 to i32
  %106 = icmp slt i32 %99, %105
  br i1 %106, label %111, label %107

107:                                              ; preds = %102
  %108 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %109 = load i32, ptr %108, align 4, !tbaa !78
  %110 = add nsw i32 %109, -1
  store i32 %110, ptr %108, align 4, !tbaa !78
  br label %111

111:                                              ; preds = %107, %102, %97, %94
  %112 = load i32, ptr %2, align 8, !tbaa !85
  %113 = icmp eq i32 %112, 12
  br i1 %113, label %114, label %128

114:                                              ; preds = %111
  %115 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  %116 = load i32, ptr %115, align 8, !tbaa !33
  %117 = and i32 %116, 256
  %118 = icmp eq i32 %117, 0
  br i1 %118, label %119, label %128

119:                                              ; preds = %114
  %120 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %121 = load i8, ptr %120, align 2, !tbaa !62
  %122 = zext i8 %121 to i32
  %123 = icmp slt i32 %116, %122
  br i1 %123, label %128, label %124

124:                                              ; preds = %119, %89
  %125 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %126 = load i32, ptr %125, align 4, !tbaa !78
  %127 = add nsw i32 %126, -1
  store i32 %127, ptr %125, align 4, !tbaa !78
  br label %128

128:                                              ; preds = %124, %119, %114, %111, %89, %84, %81
  %129 = shl i32 %62, 23
  %130 = shl i32 %61, 14
  %131 = or i32 %130, %129
  %132 = or i32 %131, %1
  %133 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %134 = load ptr, ptr %133, align 8, !tbaa !66
  %135 = getelementptr inbounds %struct.LexState, ptr %134, i64 0, i32 2
  %136 = load i32, ptr %135, align 8, !tbaa !67
  %137 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %132, i32 noundef %136) #47
  %138 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  store i32 %137, ptr %138, align 8, !tbaa !33
  store i32 11, ptr %2, align 8, !tbaa !85
  br label %139

139:                                              ; preds = %128, %55
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind optsize memory(readwrite, inaccessiblemem: none) uwtable
define internal fastcc void @removevalues(ptr nocapture noundef readonly %0, i32 noundef %1) unnamed_addr #2 {
  %3 = icmp eq i32 %1, -1
  br i1 %3, label %20, label %4

4:                                                ; preds = %4, %2
  %5 = phi i32 [ %17, %4 ], [ %1, %2 ]
  %6 = tail call fastcc i32 @patchtestreg(ptr noundef %0, i32 noundef %5, i32 noundef 255) #47, !range !75
  %7 = load ptr, ptr %0, align 8, !tbaa !63
  %8 = getelementptr inbounds %struct.Proto, ptr %7, i64 0, i32 4
  %9 = load ptr, ptr %8, align 8, !tbaa !64
  %10 = sext i32 %5 to i64
  %11 = getelementptr inbounds i32, ptr %9, i64 %10
  %12 = load i32, ptr %11, align 4, !tbaa !65
  %13 = lshr i32 %12, 14
  %14 = add nsw i32 %13, -131071
  %15 = icmp eq i32 %14, -1
  %16 = add nuw nsw i32 %5, 1
  %17 = add nsw i32 %16, %14
  %18 = icmp eq i32 %17, -1
  %19 = select i1 %15, i1 true, i1 %18
  br i1 %19, label %20, label %4

20:                                               ; preds = %4, %2
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.floor.f64(double) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fmuladd.f64(double, double, double) #12

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @pow(double noundef, double noundef) local_unnamed_addr #15

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_infix(ptr nocapture noundef %0, i32 noundef %1, ptr nocapture noundef %2) #1 {
  switch i32 %1, label %37 [
    i32 13, label %4
    i32 14, label %5
    i32 6, label %23
    i32 0, label %24
    i32 1, label %24
    i32 2, label %24
    i32 3, label %24
    i32 4, label %24
    i32 5, label %24
  ]

4:                                                ; preds = %3
  tail call void @luaK_goiftrue(ptr noundef %0, ptr noundef %2) #47
  br label %39

5:                                                ; preds = %3
  tail call void @luaK_dischargevars(ptr noundef %0, ptr noundef %2) #47
  %6 = load i32, ptr %2, align 8, !tbaa !85
  switch i32 %6, label %12 [
    i32 1, label %14
    i32 3, label %14
    i32 2, label %7
    i32 10, label %9
  ]

7:                                                ; preds = %5
  %8 = tail call i32 @luaK_jump(ptr noundef %0) #47
  br label %14

9:                                                ; preds = %5
  %10 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  %11 = load i32, ptr %10, align 8, !tbaa !33
  br label %14

12:                                               ; preds = %5
  %13 = tail call fastcc i32 @jumponcond(ptr noundef %0, ptr noundef nonnull %2, i32 noundef 1) #47
  br label %14

14:                                               ; preds = %12, %9, %7, %5, %5
  %15 = phi i32 [ %13, %12 ], [ %11, %9 ], [ %8, %7 ], [ -1, %5 ], [ -1, %5 ]
  %16 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 2
  tail call void @luaK_concat(ptr noundef %0, ptr noundef nonnull %16, i32 noundef %15) #47
  %17 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 3
  %18 = load i32, ptr %17, align 4, !tbaa !88
  %19 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 6
  %20 = load i32, ptr %19, align 8, !tbaa !59
  %21 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 7
  store i32 %20, ptr %21, align 4, !tbaa !61
  %22 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 8
  tail call void @luaK_concat(ptr noundef %0, ptr noundef nonnull %22, i32 noundef %18) #47
  store i32 -1, ptr %17, align 4, !tbaa !88
  br label %39

23:                                               ; preds = %3
  tail call void @luaK_exp2nextreg(ptr noundef %0, ptr noundef %2) #47
  br label %39

24:                                               ; preds = %3, %3, %3, %3, %3, %3
  %25 = load i32, ptr %2, align 8, !tbaa !85
  %26 = icmp eq i32 %25, 5
  br i1 %26, label %27, label %35

27:                                               ; preds = %24
  %28 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 2
  %29 = load i32, ptr %28, align 8, !tbaa !87
  %30 = icmp eq i32 %29, -1
  br i1 %30, label %31, label %35

31:                                               ; preds = %27
  %32 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 3
  %33 = load i32, ptr %32, align 4, !tbaa !88
  %34 = icmp eq i32 %33, -1
  br i1 %34, label %39, label %35

35:                                               ; preds = %31, %27, %24
  %36 = tail call i32 @luaK_exp2RK(ptr noundef %0, ptr noundef nonnull %2) #47
  br label %39

37:                                               ; preds = %3
  %38 = tail call i32 @luaK_exp2RK(ptr noundef %0, ptr noundef %2) #47
  br label %39

39:                                               ; preds = %37, %35, %31, %23, %14, %4
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_posfix(ptr nocapture noundef %0, i32 noundef %1, ptr nocapture noundef %2, ptr nocapture noundef %3) #1 {
  switch i32 %1, label %71 [
    i32 13, label %5
    i32 14, label %9
    i32 6, label %13
    i32 0, label %59
    i32 1, label %60
    i32 2, label %61
    i32 3, label %62
    i32 4, label %63
    i32 5, label %64
    i32 8, label %65
    i32 7, label %66
    i32 9, label %67
    i32 10, label %68
    i32 11, label %69
    i32 12, label %70
  ]

5:                                                ; preds = %4
  tail call void @luaK_dischargevars(ptr noundef %0, ptr noundef %3) #47
  %6 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 3
  %7 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 3
  %8 = load i32, ptr %7, align 4, !tbaa !88
  tail call void @luaK_concat(ptr noundef %0, ptr noundef nonnull %6, i32 noundef %8) #47
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %2, ptr noundef nonnull align 8 dereferenceable(24) %3, i64 24, i1 false), !tbaa.struct !89
  br label %71

9:                                                ; preds = %4
  tail call void @luaK_dischargevars(ptr noundef %0, ptr noundef %3) #47
  %10 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 2
  %11 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 2
  %12 = load i32, ptr %11, align 8, !tbaa !87
  tail call void @luaK_concat(ptr noundef %0, ptr noundef nonnull %10, i32 noundef %12) #47
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %2, ptr noundef nonnull align 8 dereferenceable(24) %3, i64 24, i1 false), !tbaa.struct !89
  br label %71

13:                                               ; preds = %4
  tail call void @luaK_exp2val(ptr noundef %0, ptr noundef %3) #47
  %14 = load i32, ptr %3, align 8, !tbaa !85
  %15 = icmp eq i32 %14, 11
  br i1 %15, label %16, label %58

16:                                               ; preds = %13
  %17 = load ptr, ptr %0, align 8, !tbaa !63
  %18 = getelementptr inbounds %struct.Proto, ptr %17, i64 0, i32 4
  %19 = load ptr, ptr %18, align 8, !tbaa !64
  %20 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 1
  %21 = load i32, ptr %20, align 8, !tbaa !33
  %22 = sext i32 %21 to i64
  %23 = getelementptr inbounds i32, ptr %19, i64 %22
  %24 = load i32, ptr %23, align 4, !tbaa !65
  %25 = and i32 %24, 63
  %26 = icmp eq i32 %25, 21
  br i1 %26, label %27, label %58

27:                                               ; preds = %16
  %28 = load i32, ptr %2, align 8, !tbaa !85
  %29 = icmp eq i32 %28, 12
  br i1 %29, label %30, label %48

30:                                               ; preds = %27
  %31 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  %32 = load i32, ptr %31, align 8, !tbaa !33
  %33 = and i32 %32, 256
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %35, label %48

35:                                               ; preds = %30
  %36 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %37 = load i8, ptr %36, align 2, !tbaa !62
  %38 = zext i8 %37 to i32
  %39 = icmp slt i32 %32, %38
  br i1 %39, label %48, label %40

40:                                               ; preds = %35
  %41 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %42 = load i32, ptr %41, align 4, !tbaa !78
  %43 = add nsw i32 %42, -1
  store i32 %43, ptr %41, align 4, !tbaa !78
  %44 = load i32, ptr %20, align 8, !tbaa !33
  %45 = sext i32 %44 to i64
  %46 = getelementptr inbounds i32, ptr %19, i64 %45
  %47 = load i32, ptr %46, align 4, !tbaa !65
  br label %48

48:                                               ; preds = %40, %35, %30, %27
  %49 = phi i64 [ %22, %27 ], [ %22, %30 ], [ %22, %35 ], [ %45, %40 ]
  %50 = phi i32 [ %24, %27 ], [ %24, %30 ], [ %24, %35 ], [ %47, %40 ]
  %51 = getelementptr inbounds i32, ptr %19, i64 %49
  %52 = and i32 %50, 8388607
  %53 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  %54 = load i32, ptr %53, align 8, !tbaa !33
  %55 = shl i32 %54, 23
  %56 = or i32 %55, %52
  store i32 %56, ptr %51, align 4, !tbaa !65
  store i32 11, ptr %2, align 8, !tbaa !85
  %57 = load i32, ptr %20, align 8, !tbaa !33
  store i32 %57, ptr %53, align 8, !tbaa !33
  br label %71

58:                                               ; preds = %16, %13
  tail call void @luaK_exp2nextreg(ptr noundef %0, ptr noundef nonnull %3) #47
  tail call fastcc void @codearith(ptr noundef %0, i32 noundef 21, ptr noundef %2, ptr noundef nonnull %3) #47
  br label %71

59:                                               ; preds = %4
  tail call fastcc void @codearith(ptr noundef %0, i32 noundef 12, ptr noundef %2, ptr noundef %3) #47
  br label %71

60:                                               ; preds = %4
  tail call fastcc void @codearith(ptr noundef %0, i32 noundef 13, ptr noundef %2, ptr noundef %3) #47
  br label %71

61:                                               ; preds = %4
  tail call fastcc void @codearith(ptr noundef %0, i32 noundef 14, ptr noundef %2, ptr noundef %3) #47
  br label %71

62:                                               ; preds = %4
  tail call fastcc void @codearith(ptr noundef %0, i32 noundef 15, ptr noundef %2, ptr noundef %3) #47
  br label %71

63:                                               ; preds = %4
  tail call fastcc void @codearith(ptr noundef %0, i32 noundef 16, ptr noundef %2, ptr noundef %3) #47
  br label %71

64:                                               ; preds = %4
  tail call fastcc void @codearith(ptr noundef %0, i32 noundef 17, ptr noundef %2, ptr noundef %3) #47
  br label %71

65:                                               ; preds = %4
  tail call fastcc void @codecomp(ptr noundef %0, i32 noundef 23, i32 noundef 1, ptr noundef %2, ptr noundef %3) #47
  br label %71

66:                                               ; preds = %4
  tail call fastcc void @codecomp(ptr noundef %0, i32 noundef 23, i32 noundef 0, ptr noundef %2, ptr noundef %3) #47
  br label %71

67:                                               ; preds = %4
  tail call fastcc void @codecomp(ptr noundef %0, i32 noundef 24, i32 noundef 1, ptr noundef %2, ptr noundef %3) #47
  br label %71

68:                                               ; preds = %4
  tail call fastcc void @codecomp(ptr noundef %0, i32 noundef 25, i32 noundef 1, ptr noundef %2, ptr noundef %3) #47
  br label %71

69:                                               ; preds = %4
  tail call fastcc void @codecomp(ptr noundef %0, i32 noundef 24, i32 noundef 0, ptr noundef %2, ptr noundef %3) #47
  br label %71

70:                                               ; preds = %4
  tail call fastcc void @codecomp(ptr noundef %0, i32 noundef 25, i32 noundef 0, ptr noundef %2, ptr noundef %3) #47
  br label %71

71:                                               ; preds = %70, %69, %68, %67, %66, %65, %64, %63, %62, %61, %60, %59, %58, %48, %9, %5, %4
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #16

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @codecomp(ptr nocapture noundef %0, i32 noundef %1, i32 noundef %2, ptr nocapture noundef %3, ptr nocapture noundef %4) unnamed_addr #1 {
  %6 = tail call i32 @luaK_exp2RK(ptr noundef %0, ptr noundef %3) #47
  %7 = tail call i32 @luaK_exp2RK(ptr noundef %0, ptr noundef %4) #47
  %8 = load i32, ptr %4, align 8, !tbaa !85
  %9 = icmp eq i32 %8, 12
  br i1 %9, label %10, label %24

10:                                               ; preds = %5
  %11 = getelementptr inbounds %struct.expdesc, ptr %4, i64 0, i32 1
  %12 = load i32, ptr %11, align 8, !tbaa !33
  %13 = and i32 %12, 256
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %24

15:                                               ; preds = %10
  %16 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %17 = load i8, ptr %16, align 2, !tbaa !62
  %18 = zext i8 %17 to i32
  %19 = icmp slt i32 %12, %18
  br i1 %19, label %24, label %20

20:                                               ; preds = %15
  %21 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %22 = load i32, ptr %21, align 4, !tbaa !78
  %23 = add nsw i32 %22, -1
  store i32 %23, ptr %21, align 4, !tbaa !78
  br label %24

24:                                               ; preds = %20, %15, %10, %5
  %25 = load i32, ptr %3, align 8, !tbaa !85
  %26 = icmp eq i32 %25, 12
  br i1 %26, label %27, label %41

27:                                               ; preds = %24
  %28 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 1
  %29 = load i32, ptr %28, align 8, !tbaa !33
  %30 = and i32 %29, 256
  %31 = icmp eq i32 %30, 0
  br i1 %31, label %32, label %41

32:                                               ; preds = %27
  %33 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %34 = load i8, ptr %33, align 2, !tbaa !62
  %35 = zext i8 %34 to i32
  %36 = icmp slt i32 %29, %35
  br i1 %36, label %41, label %37

37:                                               ; preds = %32
  %38 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  %39 = load i32, ptr %38, align 4, !tbaa !78
  %40 = add nsw i32 %39, -1
  store i32 %40, ptr %38, align 4, !tbaa !78
  br label %41

41:                                               ; preds = %37, %32, %27, %24
  %42 = icmp eq i32 %2, 0
  %43 = icmp ne i32 %1, 23
  %44 = and i1 %43, %42
  %45 = select i1 %44, i32 %7, i32 %6
  %46 = select i1 %44, i32 %6, i32 %7
  %47 = shl i32 %2, 6
  %48 = select i1 %44, i32 64, i32 %47
  %49 = shl i32 %45, 23
  %50 = shl i32 %46, 14
  %51 = or i32 %48, %49
  %52 = or i32 %51, %50
  %53 = or i32 %52, %1
  %54 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %55 = load ptr, ptr %54, align 8, !tbaa !66
  %56 = getelementptr inbounds %struct.LexState, ptr %55, i64 0, i32 2
  %57 = load i32, ptr %56, align 8, !tbaa !67
  %58 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %53, i32 noundef %57) #47
  %59 = tail call i32 @luaK_jump(ptr noundef %0) #47
  %60 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 1
  store i32 %59, ptr %60, align 8, !tbaa !33
  store i32 10, ptr %3, align 8, !tbaa !85
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable
define internal void @luaK_fixline(ptr nocapture noundef readonly %0, i32 noundef %1) #4 {
  %3 = load ptr, ptr %0, align 8, !tbaa !63
  %4 = getelementptr inbounds %struct.Proto, ptr %3, i64 0, i32 6
  %5 = load ptr, ptr %4, align 8, !tbaa !74
  %6 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 6
  %7 = load i32, ptr %6, align 8, !tbaa !59
  %8 = add nsw i32 %7, -1
  %9 = sext i32 %8 to i64
  %10 = getelementptr inbounds i32, ptr %5, i64 %9
  store i32 %1, ptr %10, align 4, !tbaa !65
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaK_setlist(ptr nocapture noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) #1 {
  %5 = add nsw i32 %2, -1
  %6 = sdiv i32 %5, 50
  %7 = add nsw i32 %6, 1
  %8 = icmp eq i32 %3, -1
  %9 = shl i32 %3, 23
  %10 = icmp slt i32 %2, 25551
  %11 = shl i32 %1, 6
  %12 = select i1 %8, i32 0, i32 %9
  br i1 %10, label %13, label %19

13:                                               ; preds = %4
  %14 = shl i32 %7, 14
  %15 = or i32 %12, %14
  %16 = or i32 %15, %11
  %17 = or i32 %16, 34
  %18 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  br label %27

19:                                               ; preds = %4
  %20 = or i32 %11, %12
  %21 = or i32 %20, 34
  %22 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %23 = load ptr, ptr %22, align 8, !tbaa !66
  %24 = getelementptr inbounds %struct.LexState, ptr %23, i64 0, i32 2
  %25 = load i32, ptr %24, align 8, !tbaa !67
  %26 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %21, i32 noundef %25) #47
  br label %27

27:                                               ; preds = %19, %13
  %28 = phi ptr [ %22, %19 ], [ %18, %13 ]
  %29 = phi i32 [ %7, %19 ], [ %17, %13 ]
  %30 = load ptr, ptr %28, align 8, !tbaa !66
  %31 = getelementptr inbounds %struct.LexState, ptr %30, i64 0, i32 2
  %32 = load i32, ptr %31, align 8, !tbaa !67
  %33 = tail call fastcc i32 @luaK_code(ptr noundef %0, i32 noundef %29, i32 noundef %32) #47
  %34 = add nsw i32 %1, 1
  %35 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  store i32 %34, ptr %35, align 4, !tbaa !78
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: write) uwtable
define internal i32 @lua_sethook(ptr nocapture noundef writeonly %0, ptr noundef %1, i32 noundef %2, i32 noundef %3) #17 {
  %5 = icmp eq ptr %1, null
  %6 = icmp eq i32 %2, 0
  %7 = or i1 %5, %6
  %8 = trunc i32 %2 to i8
  %9 = select i1 %7, ptr null, ptr %1
  %10 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 21
  store ptr %9, ptr %10, align 8, !tbaa !92
  %11 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 19
  store i32 %3, ptr %11, align 8, !tbaa !93
  %12 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 20
  store i32 %3, ptr %12, align 4, !tbaa !94
  %13 = select i1 %7, i8 0, i8 %8
  %14 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 17
  store i8 %13, ptr %14, align 4, !tbaa !95
  ret i32 1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: read) uwtable
define internal ptr @lua_gethook(ptr nocapture noundef readonly %0) #5 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 21
  %3 = load ptr, ptr %2, align 8, !tbaa !92
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: read) uwtable
define internal i32 @lua_gethookmask(ptr nocapture noundef readonly %0) #5 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 17
  %3 = load i8, ptr %2, align 4, !tbaa !95
  %4 = zext i8 %3 to i32
  ret i32 %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: read) uwtable
define internal i32 @lua_gethookcount(ptr nocapture noundef readonly %0) #5 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 19
  %3 = load i32, ptr %2, align 8, !tbaa !93
  ret i32 %3
}

; Function Attrs: nofree norecurse nosync nounwind optsize memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define internal i32 @lua_getstack(ptr nocapture noundef readonly %0, i32 noundef %1, ptr nocapture noundef writeonly %2) #18 {
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %5 = load ptr, ptr %4, align 8, !tbaa !19
  %6 = icmp sgt i32 %1, 0
  br i1 %6, label %7, label %30

7:                                                ; preds = %3
  %8 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %9 = load ptr, ptr %8, align 8, !tbaa !38
  br label %10

10:                                               ; preds = %26, %7
  %11 = phi ptr [ %5, %7 ], [ %28, %26 ]
  %12 = phi i32 [ %1, %7 ], [ %27, %26 ]
  %13 = icmp ugt ptr %11, %9
  br i1 %13, label %14, label %47

14:                                               ; preds = %10
  %15 = add nsw i32 %12, -1
  %16 = getelementptr inbounds %struct.CallInfo, ptr %11, i64 0, i32 1
  %17 = load ptr, ptr %16, align 8, !tbaa !36
  %18 = load ptr, ptr %17, align 8, !tbaa !33
  %19 = getelementptr inbounds %struct.CClosure, ptr %18, i64 0, i32 3
  %20 = load i8, ptr %19, align 2, !tbaa !33
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %22, label %26

22:                                               ; preds = %14
  %23 = getelementptr inbounds %struct.CallInfo, ptr %11, i64 0, i32 5
  %24 = load i32, ptr %23, align 4, !tbaa !96
  %25 = sub nsw i32 %15, %24
  br label %26

26:                                               ; preds = %22, %14
  %27 = phi i32 [ %15, %14 ], [ %25, %22 ]
  %28 = getelementptr inbounds %struct.CallInfo, ptr %11, i64 -1
  %29 = icmp sgt i32 %27, 0
  br i1 %29, label %10, label %30, !llvm.loop !97

30:                                               ; preds = %26, %3
  %31 = phi i32 [ %1, %3 ], [ %27, %26 ]
  %32 = phi ptr [ %5, %3 ], [ %28, %26 ]
  %33 = icmp eq i32 %31, 0
  br i1 %33, label %34, label %44

34:                                               ; preds = %30
  %35 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %36 = load ptr, ptr %35, align 8, !tbaa !38
  %37 = icmp ugt ptr %32, %36
  br i1 %37, label %38, label %47

38:                                               ; preds = %34
  %39 = ptrtoint ptr %32 to i64
  %40 = ptrtoint ptr %36 to i64
  %41 = sub i64 %39, %40
  %42 = sdiv exact i64 %41, 40
  %43 = trunc i64 %42 to i32
  br label %44

44:                                               ; preds = %38, %30
  %45 = phi i32 [ %43, %38 ], [ 0, %30 ]
  %46 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 10
  store i32 %45, ptr %46, align 4, !tbaa !98
  br label %47

47:                                               ; preds = %44, %34, %10
  %48 = phi i32 [ 0, %34 ], [ 1, %44 ], [ 0, %10 ]
  ret i32 %48
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @lua_getlocal(ptr noundef %0, ptr nocapture noundef readonly %1, i32 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %5 = load ptr, ptr %4, align 8, !tbaa !38
  %6 = getelementptr inbounds %struct.lua_Debug, ptr %1, i64 0, i32 10
  %7 = load i32, ptr %6, align 4, !tbaa !98
  %8 = sext i32 %7 to i64
  %9 = getelementptr inbounds %struct.CallInfo, ptr %5, i64 %8
  %10 = tail call fastcc ptr @findlocal(ptr noundef %0, ptr noundef %9, i32 noundef %2) #47
  %11 = icmp eq ptr %10, null
  br i1 %11, label %17, label %12

12:                                               ; preds = %3
  %13 = load ptr, ptr %9, align 8, !tbaa !100
  %14 = add nsw i32 %2, -1
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds %struct.lua_TValue, ptr %13, i64 %15
  tail call void @luaA_pushobject(ptr noundef nonnull %0, ptr noundef %16) #46
  br label %17

17:                                               ; preds = %12, %3
  ret ptr %10
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @findlocal(ptr nocapture noundef readonly %0, ptr noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = getelementptr inbounds %struct.CallInfo, ptr %1, i64 0, i32 1
  %5 = load ptr, ptr %4, align 8, !tbaa !36
  %6 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 0, i32 1
  %7 = load i32, ptr %6, align 8, !tbaa !16
  %8 = icmp eq i32 %7, 6
  br i1 %8, label %9, label %22

9:                                                ; preds = %3
  %10 = load ptr, ptr %5, align 8, !tbaa !33
  %11 = getelementptr inbounds %struct.CClosure, ptr %10, i64 0, i32 3
  %12 = load i8, ptr %11, align 2, !tbaa !33
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %14, label %22

14:                                               ; preds = %9
  %15 = getelementptr inbounds %struct.LClosure, ptr %10, i64 0, i32 7
  %16 = load ptr, ptr %15, align 8, !tbaa !33
  %17 = icmp eq ptr %16, null
  br i1 %17, label %22, label %18

18:                                               ; preds = %14
  %19 = tail call fastcc i32 @currentpc(ptr noundef %0, ptr noundef nonnull %1) #47
  %20 = tail call ptr @luaF_getlocalname(ptr noundef nonnull %16, i32 noundef %2, i32 noundef %19) #46
  %21 = icmp eq ptr %20, null
  br i1 %21, label %22, label %40

22:                                               ; preds = %18, %14, %9, %3
  %23 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %24 = load ptr, ptr %23, align 8, !tbaa !19
  %25 = icmp eq ptr %24, %1
  %26 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %27 = getelementptr inbounds %struct.CallInfo, ptr %1, i64 1, i32 1
  %28 = select i1 %25, ptr %26, ptr %27
  %29 = load ptr, ptr %28, align 8, !tbaa !39
  %30 = load ptr, ptr %1, align 8, !tbaa !100
  %31 = ptrtoint ptr %29 to i64
  %32 = ptrtoint ptr %30 to i64
  %33 = sub i64 %31, %32
  %34 = ashr exact i64 %33, 4
  %35 = sext i32 %2 to i64
  %36 = icmp sge i64 %34, %35
  %37 = icmp sgt i32 %2, 0
  %38 = and i1 %37, %36
  %39 = select i1 %38, ptr @.str.6, ptr null
  br label %40

40:                                               ; preds = %22, %18
  %41 = phi ptr [ %39, %22 ], [ %20, %18 ]
  ret ptr %41
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define internal fastcc i32 @currentpc(ptr nocapture noundef readonly %0, ptr noundef %1) unnamed_addr #7 {
  %3 = getelementptr inbounds %struct.CallInfo, ptr %1, i64 0, i32 1
  %4 = load ptr, ptr %3, align 8, !tbaa !36
  %5 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  %6 = load i32, ptr %5, align 8, !tbaa !16
  %7 = icmp eq i32 %6, 6
  br i1 %7, label %8, label %38

8:                                                ; preds = %2
  %9 = load ptr, ptr %4, align 8, !tbaa !33
  %10 = getelementptr inbounds %struct.CClosure, ptr %9, i64 0, i32 3
  %11 = load i8, ptr %10, align 2, !tbaa !33
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %13, label %38

13:                                               ; preds = %8
  %14 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %15 = load ptr, ptr %14, align 8, !tbaa !19
  %16 = icmp eq ptr %15, %1
  br i1 %16, label %20, label %17

17:                                               ; preds = %13
  %18 = getelementptr inbounds %struct.CallInfo, ptr %1, i64 0, i32 3
  %19 = load ptr, ptr %18, align 8, !tbaa !101
  br label %25

20:                                               ; preds = %13
  %21 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 8
  %22 = load ptr, ptr %21, align 8, !tbaa !102
  %23 = getelementptr inbounds %struct.CallInfo, ptr %1, i64 0, i32 3
  store ptr %22, ptr %23, align 8, !tbaa !101
  %24 = load ptr, ptr %4, align 8, !tbaa !33
  br label %25

25:                                               ; preds = %20, %17
  %26 = phi ptr [ %9, %17 ], [ %24, %20 ]
  %27 = phi ptr [ %19, %17 ], [ %22, %20 ]
  %28 = getelementptr inbounds %struct.LClosure, ptr %26, i64 0, i32 7
  %29 = load ptr, ptr %28, align 8, !tbaa !33
  %30 = getelementptr inbounds %struct.Proto, ptr %29, i64 0, i32 4
  %31 = load ptr, ptr %30, align 8, !tbaa !64
  %32 = ptrtoint ptr %27 to i64
  %33 = ptrtoint ptr %31 to i64
  %34 = sub i64 %32, %33
  %35 = lshr exact i64 %34, 2
  %36 = trunc i64 %35 to i32
  %37 = add nsw i32 %36, -1
  br label %38

38:                                               ; preds = %25, %8, %2
  %39 = phi i32 [ %37, %25 ], [ -1, %8 ], [ -1, %2 ]
  ret i32 %39
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @lua_setlocal(ptr nocapture noundef %0, ptr nocapture noundef readonly %1, i32 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %5 = load ptr, ptr %4, align 8, !tbaa !38
  %6 = getelementptr inbounds %struct.lua_Debug, ptr %1, i64 0, i32 10
  %7 = load i32, ptr %6, align 4, !tbaa !98
  %8 = sext i32 %7 to i64
  %9 = getelementptr inbounds %struct.CallInfo, ptr %5, i64 %8
  %10 = tail call fastcc ptr @findlocal(ptr noundef %0, ptr noundef %9, i32 noundef %2) #47
  %11 = icmp eq ptr %10, null
  br i1 %11, label %24, label %12

12:                                               ; preds = %3
  %13 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %14 = load ptr, ptr %13, align 8, !tbaa !7
  %15 = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 -1
  %16 = load ptr, ptr %9, align 8, !tbaa !100
  %17 = add nsw i32 %2, -1
  %18 = sext i32 %17 to i64
  %19 = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 %18
  %20 = load i64, ptr %15, align 8
  store i64 %20, ptr %19, align 8
  %21 = getelementptr %struct.lua_TValue, ptr %14, i64 -1, i32 1
  %22 = load i32, ptr %21, align 8, !tbaa !16
  %23 = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 %18, i32 1
  store i32 %22, ptr %23, align 8, !tbaa !16
  br label %24

24:                                               ; preds = %12, %3
  %25 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %26 = load ptr, ptr %25, align 8, !tbaa !7
  %27 = getelementptr inbounds %struct.lua_TValue, ptr %26, i64 -1
  store ptr %27, ptr %25, align 8, !tbaa !7
  ret ptr %10
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_getinfo(ptr noundef %0, ptr noundef readonly %1, ptr noundef %2) #1 {
  %4 = load i8, ptr %1, align 1, !tbaa !33
  %5 = icmp eq i8 %4, 62
  br i1 %5, label %6, label %12

6:                                                ; preds = %3
  %7 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %8 = load ptr, ptr %7, align 8, !tbaa !7
  %9 = getelementptr inbounds %struct.lua_TValue, ptr %8, i64 -1
  %10 = getelementptr inbounds i8, ptr %1, i64 1
  %11 = load ptr, ptr %9, align 8, !tbaa !33
  store ptr %9, ptr %7, align 8, !tbaa !7
  br label %24

12:                                               ; preds = %3
  %13 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 10
  %14 = load i32, ptr %13, align 4, !tbaa !98
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %147, label %16

16:                                               ; preds = %12
  %17 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %18 = load ptr, ptr %17, align 8, !tbaa !38
  %19 = sext i32 %14 to i64
  %20 = getelementptr inbounds %struct.CallInfo, ptr %18, i64 %19
  %21 = getelementptr inbounds %struct.CallInfo, ptr %18, i64 %19, i32 1
  %22 = load ptr, ptr %21, align 8, !tbaa !36
  %23 = load ptr, ptr %22, align 8, !tbaa !33
  br label %24

24:                                               ; preds = %16, %6
  %25 = phi ptr [ null, %6 ], [ %20, %16 ]
  %26 = phi ptr [ %11, %6 ], [ %23, %16 ]
  %27 = phi ptr [ %10, %6 ], [ %1, %16 ]
  %28 = icmp eq ptr %26, null
  br i1 %28, label %147, label %29

29:                                               ; preds = %24
  %30 = load i8, ptr %27, align 1, !tbaa !33
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %143, label %32

32:                                               ; preds = %29
  %33 = icmp eq ptr %25, null
  %34 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 1
  %35 = getelementptr inbounds %struct.CallInfo, ptr %25, i64 0, i32 1
  %36 = getelementptr inbounds %struct.CallInfo, ptr %25, i64 0, i32 5
  %37 = getelementptr %struct.CallInfo, ptr %25, i64 -1, i32 1
  %38 = getelementptr inbounds %struct.CallInfo, ptr %25, i64 -1
  %39 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 2
  %40 = getelementptr inbounds %struct.CClosure, ptr %26, i64 0, i32 4
  %41 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 6
  %42 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 5
  %43 = getelementptr inbounds %struct.CClosure, ptr %26, i64 0, i32 3
  %44 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 4
  %45 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 7
  %46 = getelementptr inbounds %struct.LClosure, ptr %26, i64 0, i32 7
  %47 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 8
  %48 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 3
  %49 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 9
  br label %50

50:                                               ; preds = %138, %32
  %51 = phi i8 [ %30, %32 ], [ %141, %138 ]
  %52 = phi i32 [ 1, %32 ], [ %139, %138 ]
  %53 = phi ptr [ %27, %32 ], [ %140, %138 ]
  %54 = sext i8 %51 to i32
  switch i32 %54, label %137 [
    i32 83, label %55
    i32 108, label %76
    i32 117, label %94
    i32 110, label %97
    i32 76, label %138
    i32 102, label %138
  ]

55:                                               ; preds = %50
  %56 = load i8, ptr %43, align 2, !tbaa !33
  %57 = icmp eq i8 %56, 0
  br i1 %57, label %59, label %58

58:                                               ; preds = %55
  store ptr @.str.10, ptr %44, align 8, !tbaa !103
  store i32 -1, ptr %45, align 8, !tbaa !104
  br label %72

59:                                               ; preds = %55
  %60 = load ptr, ptr %46, align 8, !tbaa !33
  %61 = getelementptr inbounds %struct.Proto, ptr %60, i64 0, i32 9
  %62 = load ptr, ptr %61, align 8, !tbaa !105
  %63 = getelementptr inbounds %union.TString, ptr %62, i64 1
  store ptr %63, ptr %44, align 8, !tbaa !103
  %64 = load ptr, ptr %46, align 8, !tbaa !33
  %65 = getelementptr inbounds %struct.Proto, ptr %64, i64 0, i32 16
  %66 = load i32, ptr %65, align 8, !tbaa !106
  store i32 %66, ptr %45, align 8, !tbaa !104
  %67 = load ptr, ptr %46, align 8, !tbaa !33
  %68 = getelementptr inbounds %struct.Proto, ptr %67, i64 0, i32 17
  %69 = load i32, ptr %68, align 4, !tbaa !107
  %70 = icmp eq i32 %66, 0
  %71 = select i1 %70, ptr @.str.12, ptr @.str.13
  br label %72

72:                                               ; preds = %59, %58
  %73 = phi ptr [ %63, %59 ], [ @.str.10, %58 ]
  %74 = phi i32 [ %69, %59 ], [ -1, %58 ]
  %75 = phi ptr [ %71, %59 ], [ @.str.11, %58 ]
  store i32 %74, ptr %47, align 4
  store ptr %75, ptr %48, align 8
  tail call void @luaO_chunkid(ptr noundef nonnull %49, ptr noundef nonnull %73, i64 noundef 60) #46
  br label %138

76:                                               ; preds = %50
  br i1 %33, label %92, label %77

77:                                               ; preds = %76
  %78 = tail call fastcc i32 @currentpc(ptr noundef %0, ptr noundef nonnull %25) #47
  %79 = icmp slt i32 %78, 0
  br i1 %79, label %92, label %80

80:                                               ; preds = %77
  %81 = load ptr, ptr %35, align 8, !tbaa !36
  %82 = load ptr, ptr %81, align 8, !tbaa !33
  %83 = getelementptr inbounds %struct.LClosure, ptr %82, i64 0, i32 7
  %84 = load ptr, ptr %83, align 8, !tbaa !33
  %85 = getelementptr inbounds %struct.Proto, ptr %84, i64 0, i32 6
  %86 = load ptr, ptr %85, align 8, !tbaa !74
  %87 = icmp eq ptr %86, null
  br i1 %87, label %92, label %88

88:                                               ; preds = %80
  %89 = zext i32 %78 to i64
  %90 = getelementptr inbounds i32, ptr %86, i64 %89
  %91 = load i32, ptr %90, align 4, !tbaa !65
  br label %92

92:                                               ; preds = %88, %80, %77, %76
  %93 = phi i32 [ -1, %76 ], [ -1, %77 ], [ %91, %88 ], [ 0, %80 ]
  store i32 %93, ptr %42, align 8, !tbaa !108
  br label %138

94:                                               ; preds = %50
  %95 = load i8, ptr %40, align 1, !tbaa !33
  %96 = zext i8 %95 to i32
  store i32 %96, ptr %41, align 4, !tbaa !109
  br label %138

97:                                               ; preds = %50
  br i1 %33, label %136, label %98

98:                                               ; preds = %97
  %99 = load ptr, ptr %35, align 8, !tbaa !36
  %100 = getelementptr inbounds %struct.lua_TValue, ptr %99, i64 0, i32 1
  %101 = load i32, ptr %100, align 8, !tbaa !16
  %102 = icmp eq i32 %101, 6
  br i1 %102, label %103, label %111

103:                                              ; preds = %98
  %104 = load ptr, ptr %99, align 8, !tbaa !33
  %105 = getelementptr inbounds %struct.CClosure, ptr %104, i64 0, i32 3
  %106 = load i8, ptr %105, align 2, !tbaa !33
  %107 = icmp eq i8 %106, 0
  br i1 %107, label %108, label %111

108:                                              ; preds = %103
  %109 = load i32, ptr %36, align 4, !tbaa !96
  %110 = icmp sgt i32 %109, 0
  br i1 %110, label %136, label %111

111:                                              ; preds = %108, %103, %98
  %112 = load ptr, ptr %37, align 8, !tbaa !36
  %113 = getelementptr inbounds %struct.lua_TValue, ptr %112, i64 0, i32 1
  %114 = load i32, ptr %113, align 8, !tbaa !16
  %115 = icmp eq i32 %114, 6
  br i1 %115, label %116, label %136

116:                                              ; preds = %111
  %117 = load ptr, ptr %112, align 8, !tbaa !33
  %118 = getelementptr inbounds %struct.CClosure, ptr %117, i64 0, i32 3
  %119 = load i8, ptr %118, align 2, !tbaa !33
  %120 = icmp eq i8 %119, 0
  br i1 %120, label %121, label %136

121:                                              ; preds = %116
  %122 = getelementptr inbounds %struct.LClosure, ptr %117, i64 0, i32 7
  %123 = load ptr, ptr %122, align 8, !tbaa !33
  %124 = getelementptr inbounds %struct.Proto, ptr %123, i64 0, i32 4
  %125 = load ptr, ptr %124, align 8, !tbaa !64
  %126 = tail call fastcc i32 @currentpc(ptr noundef %0, ptr noundef nonnull %38) #47
  %127 = sext i32 %126 to i64
  %128 = getelementptr inbounds i32, ptr %125, i64 %127
  %129 = load i32, ptr %128, align 4, !tbaa !65
  %130 = and i32 %129, 63
  switch i32 %130, label %136 [
    i32 28, label %131
    i32 29, label %131
    i32 33, label %131
  ]

131:                                              ; preds = %121, %121, %121
  %132 = lshr i32 %129, 6
  %133 = and i32 %132, 255
  %134 = tail call fastcc ptr @getobjname(ptr noundef %0, ptr noundef nonnull %38, i32 noundef %133, ptr noundef nonnull %34) #47
  store ptr %134, ptr %39, align 8, !tbaa !110
  %135 = icmp eq ptr %134, null
  br i1 %135, label %136, label %138

136:                                              ; preds = %131, %121, %116, %111, %108, %97
  store ptr @.str.7, ptr %39, align 8, !tbaa !110
  store ptr null, ptr %34, align 8, !tbaa !111
  br label %138

137:                                              ; preds = %50
  br label %138

138:                                              ; preds = %137, %136, %131, %94, %92, %72, %50, %50
  %139 = phi i32 [ 0, %137 ], [ %52, %50 ], [ %52, %50 ], [ %52, %136 ], [ %52, %131 ], [ %52, %94 ], [ %52, %92 ], [ %52, %72 ]
  %140 = getelementptr inbounds i8, ptr %53, i64 1
  %141 = load i8, ptr %140, align 1, !tbaa !33
  %142 = icmp eq i8 %141, 0
  br i1 %142, label %143, label %50, !llvm.loop !112

143:                                              ; preds = %138, %29
  %144 = phi i32 [ 1, %29 ], [ %139, %138 ]
  %145 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %27, i32 noundef 102) #49
  %146 = icmp eq ptr %145, null
  br i1 %146, label %193, label %164

147:                                              ; preds = %24, %12
  %148 = phi ptr [ %27, %24 ], [ %1, %12 ]
  %149 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 2
  store ptr @.str.7, ptr %149, align 8, !tbaa !110
  %150 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 1
  store ptr @.str.7, ptr %150, align 8, !tbaa !111
  %151 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 3
  store ptr @.str.8, ptr %151, align 8, !tbaa !113
  %152 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 5
  store i32 -1, ptr %152, align 8, !tbaa !108
  %153 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 7
  store i32 -1, ptr %153, align 8, !tbaa !104
  %154 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 8
  store i32 -1, ptr %154, align 4, !tbaa !114
  %155 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 4
  store ptr @.str.9, ptr %155, align 8, !tbaa !103
  %156 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 9
  tail call void @luaO_chunkid(ptr noundef nonnull %156, ptr noundef nonnull @.str.9, i64 noundef 60) #46
  %157 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 6
  store i32 0, ptr %157, align 4, !tbaa !109
  %158 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %148, i32 noundef 102) #49
  %159 = icmp eq ptr %158, null
  br i1 %159, label %186, label %160

160:                                              ; preds = %147
  %161 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %162 = load ptr, ptr %161, align 8, !tbaa !7
  %163 = getelementptr inbounds %struct.lua_TValue, ptr %162, i64 0, i32 1
  store i32 0, ptr %163, align 8, !tbaa !16
  br label %169

164:                                              ; preds = %143
  %165 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %166 = load ptr, ptr %165, align 8, !tbaa !7
  store ptr %26, ptr %166, align 8, !tbaa !33
  %167 = getelementptr inbounds %struct.lua_TValue, ptr %166, i64 0, i32 1
  store i32 6, ptr %167, align 8, !tbaa !16
  %168 = load ptr, ptr %165, align 8, !tbaa !7
  br label %169

169:                                              ; preds = %164, %160
  %170 = phi i1 [ false, %164 ], [ true, %160 ]
  %171 = phi ptr [ %27, %164 ], [ %148, %160 ]
  %172 = phi ptr [ %26, %164 ], [ null, %160 ]
  %173 = phi i32 [ %144, %164 ], [ 1, %160 ]
  %174 = phi ptr [ %168, %164 ], [ %162, %160 ]
  %175 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %176 = load ptr, ptr %175, align 8, !tbaa !18
  %177 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %178 = ptrtoint ptr %176 to i64
  %179 = ptrtoint ptr %174 to i64
  %180 = sub i64 %178, %179
  %181 = icmp slt i64 %180, 17
  br i1 %181, label %182, label %183

182:                                              ; preds = %169
  tail call void @luaD_growstack(ptr noundef nonnull %0, i32 noundef 1) #46
  br label %183

183:                                              ; preds = %182, %169
  %184 = load ptr, ptr %177, align 8, !tbaa !7
  %185 = getelementptr inbounds %struct.lua_TValue, ptr %184, i64 1
  store ptr %185, ptr %177, align 8, !tbaa !7
  br label %186

186:                                              ; preds = %183, %147
  %187 = phi i32 [ 1, %147 ], [ %173, %183 ]
  %188 = phi ptr [ null, %147 ], [ %172, %183 ]
  %189 = phi ptr [ %148, %147 ], [ %171, %183 ]
  %190 = phi i1 [ true, %147 ], [ %170, %183 ]
  %191 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %189, i32 noundef 76) #49
  %192 = icmp eq ptr %191, null
  br i1 %192, label %250, label %196

193:                                              ; preds = %143
  %194 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %27, i32 noundef 76) #49
  %195 = icmp eq ptr %194, null
  br i1 %195, label %250, label %197

196:                                              ; preds = %186
  br i1 %190, label %203, label %197

197:                                              ; preds = %196, %193
  %198 = phi i32 [ %187, %196 ], [ %144, %193 ]
  %199 = phi ptr [ %188, %196 ], [ %26, %193 ]
  %200 = getelementptr inbounds %struct.CClosure, ptr %199, i64 0, i32 3
  %201 = load i8, ptr %200, align 2, !tbaa !33
  %202 = icmp eq i8 %201, 0
  br i1 %202, label %208, label %203

203:                                              ; preds = %197, %196
  %204 = phi i32 [ %198, %197 ], [ %187, %196 ]
  %205 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %206 = load ptr, ptr %205, align 8, !tbaa !7
  %207 = getelementptr inbounds %struct.lua_TValue, ptr %206, i64 0, i32 1
  store i32 0, ptr %207, align 8, !tbaa !16
  br label %234

208:                                              ; preds = %197
  %209 = tail call ptr @luaH_new(ptr noundef %0, i32 noundef 0, i32 noundef 0) #46
  %210 = getelementptr inbounds %struct.LClosure, ptr %199, i64 0, i32 7
  %211 = load ptr, ptr %210, align 8, !tbaa !33
  %212 = getelementptr inbounds %struct.Proto, ptr %211, i64 0, i32 6
  %213 = load ptr, ptr %212, align 8, !tbaa !74
  %214 = getelementptr inbounds %struct.Proto, ptr %211, i64 0, i32 13
  %215 = load i32, ptr %214, align 4, !tbaa !73
  %216 = icmp sgt i32 %215, 0
  br i1 %216, label %217, label %229

217:                                              ; preds = %217, %208
  %218 = phi i64 [ %223, %217 ], [ 0, %208 ]
  %219 = getelementptr inbounds i32, ptr %213, i64 %218
  %220 = load i32, ptr %219, align 4, !tbaa !65
  %221 = tail call ptr @luaH_setnum(ptr noundef %0, ptr noundef %209, i32 noundef %220) #46
  store i32 1, ptr %221, align 8, !tbaa !33
  %222 = getelementptr inbounds %struct.lua_TValue, ptr %221, i64 0, i32 1
  store i32 1, ptr %222, align 8, !tbaa !16
  %223 = add nuw nsw i64 %218, 1
  %224 = load ptr, ptr %210, align 8, !tbaa !33
  %225 = getelementptr inbounds %struct.Proto, ptr %224, i64 0, i32 13
  %226 = load i32, ptr %225, align 4, !tbaa !73
  %227 = sext i32 %226 to i64
  %228 = icmp slt i64 %223, %227
  br i1 %228, label %217, label %229, !llvm.loop !115

229:                                              ; preds = %217, %208
  %230 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %231 = load ptr, ptr %230, align 8, !tbaa !7
  store ptr %209, ptr %231, align 8, !tbaa !33
  %232 = getelementptr inbounds %struct.lua_TValue, ptr %231, i64 0, i32 1
  store i32 5, ptr %232, align 8, !tbaa !16
  %233 = load ptr, ptr %230, align 8, !tbaa !7
  br label %234

234:                                              ; preds = %229, %203
  %235 = phi i32 [ %198, %229 ], [ %204, %203 ]
  %236 = phi ptr [ %233, %229 ], [ %206, %203 ]
  %237 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %238 = load ptr, ptr %237, align 8, !tbaa !18
  %239 = ptrtoint ptr %238 to i64
  %240 = ptrtoint ptr %236 to i64
  %241 = sub i64 %239, %240
  %242 = icmp slt i64 %241, 17
  br i1 %242, label %243, label %246

243:                                              ; preds = %234
  tail call void @luaD_growstack(ptr noundef nonnull %0, i32 noundef 1) #46
  %244 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %245 = load ptr, ptr %244, align 8, !tbaa !7
  br label %246

246:                                              ; preds = %243, %234
  %247 = phi ptr [ %236, %234 ], [ %245, %243 ]
  %248 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %249 = getelementptr inbounds %struct.lua_TValue, ptr %247, i64 1
  store ptr %249, ptr %248, align 8, !tbaa !7
  br label %250

250:                                              ; preds = %246, %193, %186
  %251 = phi i32 [ %144, %193 ], [ %235, %246 ], [ %187, %186 ]
  ret i32 %251
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @getobjname(ptr nocapture noundef readonly %0, ptr noundef %1, i32 noundef %2, ptr nocapture noundef writeonly %3) unnamed_addr #1 {
  %5 = getelementptr inbounds %struct.CallInfo, ptr %1, i64 0, i32 1
  br label %6

6:                                                ; preds = %33, %4
  %7 = phi i32 [ %2, %4 ], [ %36, %33 ]
  %8 = load ptr, ptr %5, align 8, !tbaa !36
  %9 = getelementptr inbounds %struct.lua_TValue, ptr %8, i64 0, i32 1
  %10 = load i32, ptr %9, align 8, !tbaa !16
  %11 = icmp eq i32 %10, 6
  br i1 %11, label %12, label %82

12:                                               ; preds = %6
  %13 = load ptr, ptr %8, align 8, !tbaa !33
  %14 = getelementptr inbounds %struct.CClosure, ptr %13, i64 0, i32 3
  %15 = load i8, ptr %14, align 2, !tbaa !33
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %17, label %82

17:                                               ; preds = %12
  %18 = getelementptr inbounds %struct.LClosure, ptr %13, i64 0, i32 7
  %19 = load ptr, ptr %18, align 8, !tbaa !33
  %20 = tail call fastcc i32 @currentpc(ptr noundef %0, ptr noundef nonnull %1) #47
  %21 = add nsw i32 %7, 1
  %22 = tail call ptr @luaF_getlocalname(ptr noundef %19, i32 noundef %21, i32 noundef %20) #46
  store ptr %22, ptr %3, align 8, !tbaa !39
  %23 = icmp eq ptr %22, null
  br i1 %23, label %24, label %82

24:                                               ; preds = %17
  %25 = tail call fastcc i32 @symbexec(ptr noundef %19, i32 noundef %20, i32 noundef %7) #47
  %26 = and i32 %25, 63
  switch i32 %26, label %82 [
    i32 5, label %27
    i32 0, label %33
    i32 6, label %38
    i32 4, label %52
    i32 11, label %60
  ]

27:                                               ; preds = %24
  %.lcssa4 = phi i32 [ %25, %24 ]
  %.lcssa = phi ptr [ %19, %24 ]
  %28 = lshr i32 %.lcssa4, 14
  %29 = getelementptr inbounds %struct.Proto, ptr %.lcssa, i64 0, i32 3
  %30 = load ptr, ptr %29, align 8, !tbaa !83
  %31 = zext i32 %28 to i64
  %32 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %31
  br label %74

33:                                               ; preds = %24
  %34 = lshr i32 %25, 6
  %35 = and i32 %34, 255
  %36 = lshr i32 %25, 23
  %37 = icmp ult i32 %36, %35
  br i1 %37, label %6, label %82

38:                                               ; preds = %24
  %.lcssa5 = phi i32 [ %25, %24 ]
  %.lcssa1 = phi ptr [ %19, %24 ]
  %39 = and i32 %.lcssa5, 4194304
  %40 = icmp eq i32 %39, 0
  br i1 %40, label %79, label %41

41:                                               ; preds = %38
  %42 = lshr i32 %.lcssa5, 14
  %43 = getelementptr inbounds %struct.Proto, ptr %.lcssa1, i64 0, i32 3
  %44 = load ptr, ptr %43, align 8, !tbaa !83
  %45 = and i32 %42, 255
  %46 = zext i32 %45 to i64
  %47 = getelementptr inbounds %struct.lua_TValue, ptr %44, i64 %46, i32 1
  %48 = load i32, ptr %47, align 8, !tbaa !16
  %49 = icmp eq i32 %48, 4
  br i1 %49, label %50, label %79

50:                                               ; preds = %41
  %51 = getelementptr inbounds %struct.lua_TValue, ptr %44, i64 %46
  br label %74

52:                                               ; preds = %24
  %.lcssa6 = phi i32 [ %25, %24 ]
  %.lcssa2 = phi ptr [ %19, %24 ]
  %53 = getelementptr inbounds %struct.Proto, ptr %.lcssa2, i64 0, i32 8
  %54 = load ptr, ptr %53, align 8, !tbaa !58
  %55 = icmp eq ptr %54, null
  br i1 %55, label %79, label %56

56:                                               ; preds = %52
  %57 = lshr i32 %.lcssa6, 23
  %58 = zext i32 %57 to i64
  %59 = getelementptr inbounds ptr, ptr %54, i64 %58
  br label %74

60:                                               ; preds = %24
  %.lcssa7 = phi i32 [ %25, %24 ]
  %.lcssa3 = phi ptr [ %19, %24 ]
  %61 = and i32 %.lcssa7, 4194304
  %62 = icmp eq i32 %61, 0
  br i1 %62, label %79, label %63

63:                                               ; preds = %60
  %64 = lshr i32 %.lcssa7, 14
  %65 = getelementptr inbounds %struct.Proto, ptr %.lcssa3, i64 0, i32 3
  %66 = load ptr, ptr %65, align 8, !tbaa !83
  %67 = and i32 %64, 255
  %68 = zext i32 %67 to i64
  %69 = getelementptr inbounds %struct.lua_TValue, ptr %66, i64 %68, i32 1
  %70 = load i32, ptr %69, align 8, !tbaa !16
  %71 = icmp eq i32 %70, 4
  br i1 %71, label %72, label %79

72:                                               ; preds = %63
  %73 = getelementptr inbounds %struct.lua_TValue, ptr %66, i64 %68
  br label %74

74:                                               ; preds = %72, %56, %50, %27
  %75 = phi ptr [ %73, %72 ], [ %59, %56 ], [ %51, %50 ], [ %32, %27 ]
  %76 = phi ptr [ @.str.19, %72 ], [ @.str.18, %56 ], [ @.str.16, %50 ], [ @.str.15, %27 ]
  %77 = load ptr, ptr %75, align 8, !tbaa !33
  %78 = getelementptr inbounds %union.TString, ptr %77, i64 1
  br label %79

79:                                               ; preds = %74, %63, %60, %52, %41, %38
  %80 = phi ptr [ @.str.17, %41 ], [ @.str.17, %38 ], [ @.str.17, %52 ], [ @.str.17, %63 ], [ @.str.17, %60 ], [ %78, %74 ]
  %81 = phi ptr [ @.str.16, %41 ], [ @.str.16, %38 ], [ @.str.18, %52 ], [ @.str.19, %63 ], [ @.str.19, %60 ], [ %76, %74 ]
  store ptr %80, ptr %3, align 8, !tbaa !39
  br label %82

82:                                               ; preds = %79, %33, %24, %17, %12, %6
  %83 = phi ptr [ %81, %79 ], [ @.str.14, %17 ], [ null, %6 ], [ null, %12 ], [ null, %24 ], [ null, %33 ]
  ret ptr %83
}

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(argmem: read)
declare ptr @strchr(ptr noundef, i32 noundef) local_unnamed_addr #10

; Function Attrs: nofree norecurse nosync nounwind optsize memory(read, inaccessiblemem: none) uwtable
define internal fastcc i32 @symbexec(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2) unnamed_addr #14 {
  %4 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 12
  %5 = load i32, ptr %4, align 8, !tbaa !71
  %6 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 22
  %7 = load i8, ptr %6, align 1, !tbaa !79
  %8 = icmp ult i8 %7, -5
  br i1 %8, label %9, label %300

9:                                                ; preds = %3
  %10 = zext i8 %7 to i32
  %11 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 20
  %12 = load i8, ptr %11, align 1, !tbaa !116
  %13 = zext i8 %12 to i32
  %14 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 21
  %15 = load i8, ptr %14, align 2, !tbaa !117
  %16 = zext i8 %15 to i32
  %17 = and i32 %16, 1
  %18 = add nuw nsw i32 %17, %13
  %19 = icmp ugt i32 %18, %10
  %20 = and i32 %16, 5
  %21 = icmp eq i32 %20, 4
  %22 = or i1 %21, %19
  br i1 %22, label %300, label %23

23:                                               ; preds = %9
  %24 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 10
  %25 = load i32, ptr %24, align 8, !tbaa !55
  %26 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 19
  %27 = load i8, ptr %26, align 8, !tbaa !118
  %28 = zext i8 %27 to i32
  %29 = icmp sgt i32 %25, %28
  br i1 %29, label %300, label %30

30:                                               ; preds = %23
  %31 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 13
  %32 = load i32, ptr %31, align 4, !tbaa !73
  %33 = icmp eq i32 %32, %5
  %34 = icmp eq i32 %32, 0
  %35 = or i1 %34, %33
  %36 = icmp sgt i32 %5, 0
  %37 = and i1 %36, %35
  br i1 %37, label %38, label %300

38:                                               ; preds = %30
  %39 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 4
  %40 = load ptr, ptr %39, align 8, !tbaa !64
  %41 = add nsw i32 %5, -1
  %42 = zext i32 %41 to i64
  %43 = getelementptr inbounds i32, ptr %40, i64 %42
  %44 = load i32, ptr %43, align 4, !tbaa !65
  %45 = and i32 %44, 63
  %46 = icmp eq i32 %45, 30
  br i1 %46, label %47, label %300

47:                                               ; preds = %38
  %48 = icmp sgt i32 %1, 0
  br i1 %48, label %49, label %295

49:                                               ; preds = %47
  %50 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 11
  %51 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 14
  %52 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 5
  %53 = icmp eq i32 %2, 255
  %54 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 3
  %55 = and i8 %15, 6
  %56 = icmp eq i8 %55, 2
  br label %57

57:                                               ; preds = %290, %49
  %58 = phi i32 [ 0, %49 ], [ %293, %290 ]
  %59 = phi i32 [ %41, %49 ], [ %291, %290 ]
  %60 = sext i32 %58 to i64
  %61 = getelementptr inbounds i32, ptr %40, i64 %60
  %62 = load i32, ptr %61, align 4, !tbaa !65
  %63 = and i32 %62, 63
  %64 = lshr i32 %62, 6
  %65 = and i32 %64, 255
  %66 = icmp ult i32 %63, 38
  %67 = icmp ult i32 %65, %10
  %68 = and i1 %66, %67
  br i1 %68, label %69, label %300

69:                                               ; preds = %57
  %70 = zext i32 %63 to i64
  %71 = getelementptr inbounds [38 x i8], ptr @luaP_opmodes, i64 0, i64 %70
  %72 = load i8, ptr %71, align 1, !tbaa !33
  %73 = zext i8 %72 to i32
  %74 = and i32 %73, 3
  switch i32 %74, label %128 [
    i32 0, label %75
    i32 1, label %89
    i32 2, label %96
  ]

75:                                               ; preds = %69
  %76 = lshr i32 %62, 23
  %77 = lshr i32 %73, 4
  %78 = and i32 %77, 3
  %79 = tail call fastcc i32 @checkArgMode(ptr noundef nonnull %0, i32 noundef %76, i32 noundef %78) #47, !range !75
  %80 = icmp eq i32 %79, 0
  br i1 %80, label %300, label %81

81:                                               ; preds = %75
  %82 = lshr i32 %62, 14
  %83 = and i32 %82, 511
  %84 = lshr i8 %72, 2
  %85 = and i8 %84, 3
  %86 = zext i8 %85 to i32
  %87 = tail call fastcc i32 @checkArgMode(ptr noundef nonnull %0, i32 noundef %83, i32 noundef %86) #47, !range !75
  %88 = icmp eq i32 %87, 0
  br i1 %88, label %300, label %128

89:                                               ; preds = %69
  %90 = lshr i32 %62, 14
  %91 = and i32 %73, 48
  %92 = icmp eq i32 %91, 48
  br i1 %92, label %93, label %128

93:                                               ; preds = %89
  %94 = load i32, ptr %50, align 4, !tbaa !81
  %95 = icmp slt i32 %90, %94
  br i1 %95, label %128, label %300

96:                                               ; preds = %69
  %97 = lshr i32 %62, 14
  %98 = add nsw i32 %97, -131071
  %99 = and i32 %73, 48
  %100 = icmp eq i32 %99, 32
  br i1 %100, label %101, label %128

101:                                              ; preds = %96
  %102 = add nsw i32 %58, 1
  %103 = add nsw i32 %102, %98
  %104 = icmp sgt i32 %103, -1
  %105 = icmp slt i32 %103, %5
  %106 = select i1 %104, i1 %105, i1 false
  br i1 %106, label %107, label %300

107:                                              ; preds = %101
  %108 = icmp eq i32 %103, 0
  br i1 %108, label %128, label %109

109:                                              ; preds = %107
  %110 = add i32 %98, %58
  %111 = zext i32 %103 to i64
  br label %112

112:                                              ; preds = %121, %109
  %113 = phi i64 [ 0, %109 ], [ %122, %121 ]
  %114 = trunc i64 %113 to i32
  %115 = sub i32 %110, %114
  %116 = sext i32 %115 to i64
  %117 = getelementptr inbounds i32, ptr %40, i64 %116
  %118 = load i32, ptr %117, align 4, !tbaa !65
  %119 = and i32 %118, 8372287
  %120 = icmp eq i32 %119, 34
  br i1 %120, label %121, label %124

121:                                              ; preds = %112
  %122 = add nuw nsw i64 %113, 1
  %123 = icmp eq i64 %122, %111
  br i1 %123, label %124, label %112, !llvm.loop !119

124:                                              ; preds = %121, %112
  %125 = phi i32 [ %103, %121 ], [ %114, %112 ]
  %126 = and i32 %125, 1
  %127 = icmp eq i32 %126, 0
  br i1 %127, label %128, label %300

128:                                              ; preds = %124, %107, %96, %93, %89, %81, %69
  %129 = phi i32 [ 0, %69 ], [ 0, %96 ], [ 0, %93 ], [ 0, %89 ], [ %83, %81 ], [ 0, %124 ], [ 0, %107 ]
  %130 = phi i32 [ 0, %69 ], [ %98, %96 ], [ %90, %93 ], [ %90, %89 ], [ %76, %81 ], [ %98, %124 ], [ %98, %107 ]
  %131 = and i8 %72, 64
  %132 = icmp ne i8 %131, 0
  %133 = icmp eq i32 %65, %2
  %134 = and i1 %133, %132
  %135 = select i1 %134, i32 %58, i32 %59
  %136 = icmp sgt i8 %72, -1
  br i1 %136, label %147, label %137

137:                                              ; preds = %128
  %138 = add nsw i32 %58, 2
  %139 = icmp slt i32 %138, %5
  br i1 %139, label %140, label %300

140:                                              ; preds = %137
  %141 = add nsw i32 %58, 1
  %142 = sext i32 %141 to i64
  %143 = getelementptr inbounds i32, ptr %40, i64 %142
  %144 = load i32, ptr %143, align 4, !tbaa !65
  %145 = and i32 %144, 63
  %146 = icmp eq i32 %145, 22
  br i1 %146, label %147, label %300

147:                                              ; preds = %140, %128
  switch i32 %63, label %290 [
    i32 2, label %148
    i32 3, label %160
    i32 4, label %165
    i32 8, label %165
    i32 5, label %167
    i32 7, label %167
    i32 11, label %173
    i32 21, label %179
    i32 33, label %181
    i32 31, label %190
    i32 32, label %190
    i32 22, label %193
    i32 28, label %202
    i32 29, label %202
    i32 30, label %226
    i32 34, label %232
    i32 36, label %242
    i32 37, label %272
  ]

148:                                              ; preds = %147
  %149 = icmp eq i32 %129, 1
  br i1 %149, label %150, label %290

150:                                              ; preds = %148
  %151 = add nsw i32 %58, 2
  %152 = icmp slt i32 %151, %5
  br i1 %152, label %153, label %300

153:                                              ; preds = %150
  %154 = add nsw i32 %58, 1
  %155 = sext i32 %154 to i64
  %156 = getelementptr inbounds i32, ptr %40, i64 %155
  %157 = load i32, ptr %156, align 4, !tbaa !65
  %158 = and i32 %157, 8372287
  %159 = icmp eq i32 %158, 34
  br i1 %159, label %300, label %290

160:                                              ; preds = %147
  %161 = icmp sgt i32 %65, %2
  %162 = icmp slt i32 %130, %2
  %163 = select i1 %161, i1 true, i1 %162
  %164 = select i1 %163, i32 %135, i32 %58
  br label %290

165:                                              ; preds = %147, %147
  %166 = icmp slt i32 %130, %28
  br i1 %166, label %290, label %300

167:                                              ; preds = %147, %147
  %168 = load ptr, ptr %54, align 8, !tbaa !83
  %169 = sext i32 %130 to i64
  %170 = getelementptr inbounds %struct.lua_TValue, ptr %168, i64 %169, i32 1
  %171 = load i32, ptr %170, align 8, !tbaa !16
  %172 = icmp eq i32 %171, 4
  br i1 %172, label %290, label %300

173:                                              ; preds = %147
  %174 = add nuw nsw i32 %65, 1
  %175 = icmp ult i32 %174, %10
  br i1 %175, label %176, label %300

176:                                              ; preds = %173
  %177 = icmp eq i32 %174, %2
  %178 = select i1 %177, i32 %58, i32 %135
  br label %290

179:                                              ; preds = %147
  %180 = icmp slt i32 %130, %129
  br i1 %180, label %290, label %300

181:                                              ; preds = %147
  %182 = icmp eq i32 %129, 0
  br i1 %182, label %300, label %183

183:                                              ; preds = %181
  %184 = add nuw nsw i32 %65, 2
  %185 = add nuw nsw i32 %129, %184
  %186 = icmp ult i32 %185, %10
  br i1 %186, label %187, label %300

187:                                              ; preds = %183
  %188 = icmp sgt i32 %184, %2
  %189 = select i1 %188, i32 %135, i32 %58
  br label %290

190:                                              ; preds = %147, %147
  %191 = add nuw nsw i32 %65, 3
  %192 = icmp ult i32 %191, %10
  br i1 %192, label %193, label %300

193:                                              ; preds = %190, %147
  %194 = add nsw i32 %58, 1
  %195 = add nsw i32 %194, %130
  %196 = icmp sge i32 %58, %195
  %197 = select i1 %53, i1 true, i1 %196
  %198 = icmp sgt i32 %195, %1
  %199 = select i1 %197, i1 true, i1 %198
  %200 = select i1 %199, i32 0, i32 %130
  %201 = add nsw i32 %200, %58
  br label %290

202:                                              ; preds = %147, %147
  %203 = icmp ne i32 %130, 0
  %204 = add nsw i32 %130, %65
  %205 = icmp sgt i32 %204, %10
  %206 = select i1 %203, i1 %205, i1 false
  br i1 %206, label %300, label %207

207:                                              ; preds = %202
  %208 = icmp eq i32 %129, 0
  br i1 %208, label %209, label %217

209:                                              ; preds = %207
  %210 = add nsw i32 %58, 1
  %211 = sext i32 %210 to i64
  %212 = getelementptr inbounds i32, ptr %40, i64 %211
  %213 = load i32, ptr %212, align 4, !tbaa !65
  %214 = and i32 %213, 63
  switch i32 %214, label %300 [
    i32 28, label %215
    i32 29, label %215
    i32 30, label %215
    i32 34, label %215
  ]

215:                                              ; preds = %209, %209, %209, %209
  %216 = icmp ugt i32 %213, 8388607
  br i1 %216, label %300, label %223

217:                                              ; preds = %207
  %218 = add nsw i32 %129, -1
  %219 = icmp ne i32 %218, 0
  %220 = add nuw nsw i32 %218, %65
  %221 = icmp sgt i32 %220, %10
  %222 = select i1 %219, i1 %221, i1 false
  br i1 %222, label %300, label %223

223:                                              ; preds = %217, %215
  %224 = icmp sgt i32 %65, %2
  %225 = select i1 %224, i32 %135, i32 %58
  br label %290

226:                                              ; preds = %147
  %227 = icmp sgt i32 %130, 1
  br i1 %227, label %228, label %290

228:                                              ; preds = %226
  %229 = add nsw i32 %65, -1
  %230 = add nsw i32 %229, %130
  %231 = icmp sgt i32 %230, %10
  br i1 %231, label %300, label %290

232:                                              ; preds = %147
  %233 = icmp slt i32 %130, 1
  %234 = add nuw nsw i32 %130, %65
  %235 = icmp slt i32 %234, %10
  %236 = select i1 %233, i1 true, i1 %235
  br i1 %236, label %237, label %300

237:                                              ; preds = %232
  %238 = icmp eq i32 %129, 0
  br i1 %238, label %239, label %290

239:                                              ; preds = %237
  %240 = add nsw i32 %58, 1
  %241 = icmp slt i32 %240, %41
  br i1 %241, label %290, label %300

242:                                              ; preds = %147
  %243 = load i32, ptr %51, align 8, !tbaa !120
  %244 = icmp slt i32 %130, %243
  br i1 %244, label %245, label %300

245:                                              ; preds = %242
  %246 = load ptr, ptr %52, align 8, !tbaa !121
  %247 = sext i32 %130 to i64
  %248 = getelementptr inbounds ptr, ptr %246, i64 %247
  %249 = load ptr, ptr %248, align 8, !tbaa !39
  %250 = getelementptr inbounds %struct.Proto, ptr %249, i64 0, i32 19
  %251 = load i8, ptr %250, align 8, !tbaa !118
  %252 = zext i8 %251 to i32
  %253 = add nsw i32 %58, %252
  %254 = icmp slt i32 %253, %5
  br i1 %254, label %255, label %300

255:                                              ; preds = %245
  %256 = icmp eq i8 %251, 0
  br i1 %256, label %270, label %257

257:                                              ; preds = %255
  %258 = add nuw nsw i32 %252, 1
  %259 = zext i32 %258 to i64
  br label %263

260:                                              ; preds = %263
  %261 = add nuw nsw i64 %264, 1
  %262 = icmp eq i64 %261, %259
  br i1 %262, label %270, label %263, !llvm.loop !122

263:                                              ; preds = %260, %257
  %264 = phi i64 [ 1, %257 ], [ %261, %260 ]
  %265 = add nsw i64 %264, %60
  %266 = getelementptr inbounds i32, ptr %40, i64 %265
  %267 = load i32, ptr %266, align 4, !tbaa !65
  %268 = and i32 %267, 59
  %269 = icmp eq i32 %268, 0
  br i1 %269, label %260, label %300

270:                                              ; preds = %260, %255
  %271 = select i1 %53, i32 %58, i32 %253
  br label %290

272:                                              ; preds = %147
  br i1 %56, label %273, label %300

273:                                              ; preds = %272
  %274 = add nsw i32 %130, -1
  %275 = icmp eq i32 %130, 0
  br i1 %275, label %276, label %287

276:                                              ; preds = %273
  %277 = add nsw i32 %58, 1
  %278 = sext i32 %277 to i64
  %279 = getelementptr inbounds i32, ptr %40, i64 %278
  %280 = load i32, ptr %279, align 4, !tbaa !65
  %281 = and i32 %280, 63
  switch i32 %281, label %300 [
    i32 28, label %282
    i32 29, label %282
    i32 30, label %282
    i32 34, label %282
  ]

282:                                              ; preds = %276, %276, %276, %276
  %283 = icmp ugt i32 %280, 8388607
  %284 = add nsw i32 %274, %65
  %285 = icmp sgt i32 %284, %10
  %286 = select i1 %283, i1 true, i1 %285
  br i1 %286, label %300, label %290

287:                                              ; preds = %273
  %288 = add nsw i32 %274, %65
  %289 = icmp sgt i32 %288, %10
  br i1 %289, label %300, label %290

290:                                              ; preds = %287, %282, %270, %239, %237, %228, %226, %223, %193, %187, %179, %176, %167, %165, %160, %153, %148, %147
  %291 = phi i32 [ %135, %147 ], [ %135, %287 ], [ %135, %270 ], [ %135, %239 ], [ %135, %237 ], [ %135, %228 ], [ %135, %226 ], [ %135, %193 ], [ %135, %179 ], [ %135, %167 ], [ %135, %165 ], [ %135, %153 ], [ %135, %148 ], [ %178, %176 ], [ %189, %187 ], [ %225, %223 ], [ %164, %160 ], [ %135, %282 ]
  %292 = phi i32 [ %58, %147 ], [ %58, %287 ], [ %271, %270 ], [ %240, %239 ], [ %58, %237 ], [ %58, %228 ], [ %58, %226 ], [ %201, %193 ], [ %58, %179 ], [ %58, %167 ], [ %58, %165 ], [ %58, %153 ], [ %58, %148 ], [ %58, %176 ], [ %58, %187 ], [ %58, %223 ], [ %58, %160 ], [ %58, %282 ]
  %293 = add nsw i32 %292, 1
  %294 = icmp slt i32 %293, %1
  br i1 %294, label %57, label %295, !llvm.loop !123

295:                                              ; preds = %290, %47
  %296 = phi i32 [ %41, %47 ], [ %291, %290 ]
  %297 = sext i32 %296 to i64
  %298 = getelementptr inbounds i32, ptr %40, i64 %297
  %299 = load i32, ptr %298, align 4, !tbaa !65
  br label %300

300:                                              ; preds = %295, %287, %282, %276, %272, %263, %245, %242, %239, %232, %228, %217, %215, %209, %202, %190, %183, %181, %179, %173, %167, %165, %153, %150, %140, %137, %124, %101, %93, %81, %75, %57, %38, %30, %23, %9, %3
  %301 = phi i32 [ %299, %295 ], [ 0, %38 ], [ 0, %3 ], [ 0, %9 ], [ 0, %23 ], [ 0, %30 ], [ 0, %263 ], [ 0, %57 ], [ 0, %75 ], [ 0, %81 ], [ 0, %93 ], [ 0, %101 ], [ 0, %124 ], [ 0, %137 ], [ 0, %140 ], [ 0, %150 ], [ 0, %153 ], [ 0, %165 ], [ 0, %167 ], [ 0, %173 ], [ 0, %179 ], [ 0, %181 ], [ 0, %183 ], [ 0, %190 ], [ 0, %215 ], [ 0, %228 ], [ 0, %239 ], [ 0, %272 ], [ 0, %282 ], [ 0, %287 ], [ 0, %209 ], [ 0, %242 ], [ 0, %245 ], [ 0, %276 ], [ 0, %202 ], [ 0, %217 ], [ 0, %232 ]
  ret i32 %301
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: read) uwtable
define internal fastcc i32 @checkArgMode(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2) unnamed_addr #5 {
  switch i32 %2, label %24 [
    i32 0, label %4
    i32 3, label %11
    i32 2, label %6
  ]

4:                                                ; preds = %3
  %5 = icmp eq i32 %1, 0
  br i1 %5, label %24, label %25

6:                                                ; preds = %3
  %7 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 22
  %8 = load i8, ptr %7, align 1, !tbaa !79
  %9 = zext i8 %8 to i32
  %10 = icmp sgt i32 %9, %1
  br i1 %10, label %24, label %25

11:                                               ; preds = %3
  %12 = and i32 %1, 256
  %13 = icmp eq i32 %12, 0
  br i1 %13, label %19, label %14

14:                                               ; preds = %11
  %15 = and i32 %1, -257
  %16 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 11
  %17 = load i32, ptr %16, align 4, !tbaa !81
  %18 = icmp slt i32 %15, %17
  br i1 %18, label %24, label %25

19:                                               ; preds = %11
  %20 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 22
  %21 = load i8, ptr %20, align 1, !tbaa !79
  %22 = zext i8 %21 to i32
  %23 = icmp sgt i32 %22, %1
  br i1 %23, label %24, label %25

24:                                               ; preds = %19, %14, %6, %4, %3
  br label %25

25:                                               ; preds = %24, %19, %14, %6, %4
  %26 = phi i32 [ 1, %24 ], [ 0, %4 ], [ 0, %6 ], [ 0, %19 ], [ 0, %14 ]
  ret i32 %26
}

; Function Attrs: nofree norecurse nosync nounwind optsize memory(read, inaccessiblemem: none) uwtable
define internal i32 @luaG_checkcode(ptr nocapture noundef readonly %0) #14 {
  %2 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 12
  %3 = load i32, ptr %2, align 8, !tbaa !71
  %4 = tail call fastcc i32 @symbexec(ptr noundef %0, i32 noundef %3, i32 noundef 255) #47
  %5 = icmp ne i32 %4, 0
  %6 = zext i1 %5 to i32
  ret i32 %6
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaG_typeerror(ptr noundef %0, ptr noundef %1, ptr noundef %2) #1 {
  %4 = alloca ptr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #48
  store ptr null, ptr %4, align 8, !tbaa !39
  %5 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  %6 = load i32, ptr %5, align 8, !tbaa !16
  %7 = sext i32 %6 to i64
  %8 = getelementptr inbounds [0 x ptr], ptr @luaT_typenames, i64 0, i64 %7
  %9 = load ptr, ptr %8, align 8, !tbaa !39
  %10 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %11 = load ptr, ptr %10, align 8, !tbaa !19
  %12 = load ptr, ptr %11, align 8, !tbaa !100
  %13 = getelementptr inbounds %struct.CallInfo, ptr %11, i64 0, i32 2
  %14 = load ptr, ptr %13, align 8, !tbaa !20
  %15 = icmp ult ptr %12, %14
  br i1 %15, label %19, label %34

16:                                               ; preds = %19
  %17 = getelementptr inbounds %struct.lua_TValue, ptr %20, i64 1
  %18 = icmp ult ptr %17, %14
  br i1 %18, label %19, label %34, !llvm.loop !124

19:                                               ; preds = %16, %3
  %20 = phi ptr [ %17, %16 ], [ %12, %3 ]
  %21 = icmp eq ptr %20, %1
  br i1 %21, label %22, label %16

22:                                               ; preds = %19
  %23 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  %24 = load ptr, ptr %23, align 8, !tbaa !17
  %25 = ptrtoint ptr %1 to i64
  %26 = ptrtoint ptr %24 to i64
  %27 = sub i64 %25, %26
  %28 = lshr exact i64 %27, 4
  %29 = trunc i64 %28 to i32
  %30 = call fastcc ptr @getobjname(ptr noundef %0, ptr noundef nonnull %11, i32 noundef %29, ptr noundef nonnull %4) #47
  %31 = icmp eq ptr %30, null
  br i1 %31, label %34, label %32

32:                                               ; preds = %22
  %33 = load ptr, ptr %4, align 8, !tbaa !39
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.20, ptr noundef %2, ptr noundef nonnull %30, ptr noundef %33, ptr noundef %9) #47
  br label %35

34:                                               ; preds = %22, %16, %3
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %0, ptr noundef nonnull @.str.1.23, ptr noundef %2, ptr noundef %9) #47
  br label %35

35:                                               ; preds = %34, %32
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaG_runerror(ptr noundef %0, ptr noundef %1, ...) #1 {
  %3 = alloca [60 x i8], align 16
  %4 = alloca [1 x %struct.__va_list_tag], align 16
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4) #48
  call void @llvm.va_start(ptr nonnull %4)
  %5 = call ptr @luaO_pushvfstring(ptr noundef %0, ptr noundef %1, ptr noundef nonnull %4) #46
  %6 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %7 = load ptr, ptr %6, align 8, !tbaa !19
  %8 = getelementptr inbounds %struct.CallInfo, ptr %7, i64 0, i32 1
  %9 = load ptr, ptr %8, align 8, !tbaa !36
  %10 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 0, i32 1
  %11 = load i32, ptr %10, align 8, !tbaa !16
  %12 = icmp eq i32 %11, 6
  br i1 %12, label %13, label %45

13:                                               ; preds = %2
  %14 = load ptr, ptr %9, align 8, !tbaa !33
  %15 = getelementptr inbounds %struct.CClosure, ptr %14, i64 0, i32 3
  %16 = load i8, ptr %15, align 2, !tbaa !33
  %17 = icmp eq i8 %16, 0
  br i1 %17, label %18, label %45

18:                                               ; preds = %13
  call void @llvm.lifetime.start.p0(i64 60, ptr nonnull %3) #48
  %19 = call fastcc i32 @currentpc(ptr noundef nonnull %0, ptr noundef nonnull %7) #47
  %20 = icmp slt i32 %19, 0
  %21 = load ptr, ptr %8, align 8, !tbaa !36
  %22 = load ptr, ptr %21, align 8, !tbaa !33
  %23 = getelementptr inbounds %struct.LClosure, ptr %22, i64 0, i32 7
  %24 = load ptr, ptr %23, align 8, !tbaa !33
  br i1 %20, label %33, label %25

25:                                               ; preds = %18
  %26 = getelementptr inbounds %struct.Proto, ptr %24, i64 0, i32 6
  %27 = load ptr, ptr %26, align 8, !tbaa !74
  %28 = icmp eq ptr %27, null
  br i1 %28, label %33, label %29

29:                                               ; preds = %25
  %30 = zext i32 %19 to i64
  %31 = getelementptr inbounds i32, ptr %27, i64 %30
  %32 = load i32, ptr %31, align 4, !tbaa !65
  br label %33

33:                                               ; preds = %29, %25, %18
  %34 = phi i32 [ %32, %29 ], [ 0, %25 ], [ -1, %18 ]
  %35 = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 0, i32 1
  %36 = load i32, ptr %35, align 8, !tbaa !16
  %37 = icmp eq i32 %36, 6
  call void @llvm.assume(i1 %37)
  %38 = getelementptr inbounds %struct.CClosure, ptr %22, i64 0, i32 3
  %39 = load i8, ptr %38, align 2, !tbaa !33
  %40 = icmp eq i8 %39, 0
  call void @llvm.assume(i1 %40)
  %41 = getelementptr inbounds %struct.Proto, ptr %24, i64 0, i32 9
  %42 = load ptr, ptr %41, align 8, !tbaa !105
  %43 = getelementptr inbounds %union.TString, ptr %42, i64 1
  call void @luaO_chunkid(ptr noundef nonnull %3, ptr noundef nonnull %43, i64 noundef 60) #46
  %44 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef nonnull %0, ptr noundef nonnull @.str.20.24, ptr noundef nonnull %3, i32 noundef %34, ptr noundef %5) #46
  call void @llvm.lifetime.end.p0(i64 60, ptr nonnull %3) #48
  br label %45

45:                                               ; preds = %33, %13, %2
  call void @llvm.va_end(ptr nonnull %4)
  call void @luaG_errormsg(ptr noundef nonnull %0) #47
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4) #48
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite)
declare void @llvm.assume(i1 noundef) #19

; Function Attrs: nounwind optsize uwtable
define internal void @luaG_errormsg(ptr noundef %0) #1 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 27
  %3 = load i64, ptr %2, align 8, !tbaa !125
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %39, label %5

5:                                                ; preds = %1
  %6 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 10
  %7 = load ptr, ptr %6, align 8, !tbaa !43
  %8 = getelementptr inbounds i8, ptr %7, i64 %3
  %9 = getelementptr inbounds %struct.lua_TValue, ptr %8, i64 0, i32 1
  %10 = load i32, ptr %9, align 8, !tbaa !16
  %11 = icmp eq i32 %10, 6
  br i1 %11, label %13, label %12

12:                                               ; preds = %5
  tail call void @luaD_throw(ptr noundef nonnull %0, i32 noundef 5) #46
  br label %13

13:                                               ; preds = %12, %5
  %14 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %15 = load ptr, ptr %14, align 8, !tbaa !7
  %16 = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 -1
  %17 = load i64, ptr %16, align 8
  store i64 %17, ptr %15, align 8
  %18 = getelementptr %struct.lua_TValue, ptr %15, i64 -1, i32 1
  %19 = load i32, ptr %18, align 8, !tbaa !16
  %20 = getelementptr inbounds %struct.lua_TValue, ptr %15, i64 0, i32 1
  store i32 %19, ptr %20, align 8, !tbaa !16
  %21 = load ptr, ptr %14, align 8, !tbaa !7
  %22 = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 -1
  %23 = load i64, ptr %8, align 8
  store i64 %23, ptr %22, align 8
  %24 = load i32, ptr %9, align 8, !tbaa !16
  %25 = getelementptr %struct.lua_TValue, ptr %21, i64 -1, i32 1
  store i32 %24, ptr %25, align 8, !tbaa !16
  %26 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %27 = load ptr, ptr %26, align 8, !tbaa !18
  %28 = load ptr, ptr %14, align 8, !tbaa !7
  %29 = ptrtoint ptr %27 to i64
  %30 = ptrtoint ptr %28 to i64
  %31 = sub i64 %29, %30
  %32 = icmp slt i64 %31, 17
  br i1 %32, label %33, label %35

33:                                               ; preds = %13
  tail call void @luaD_growstack(ptr noundef nonnull %0, i32 noundef 1) #46
  %34 = load ptr, ptr %14, align 8, !tbaa !7
  br label %35

35:                                               ; preds = %33, %13
  %36 = phi ptr [ %28, %13 ], [ %34, %33 ]
  %37 = getelementptr inbounds %struct.lua_TValue, ptr %36, i64 1
  store ptr %37, ptr %14, align 8, !tbaa !7
  %38 = getelementptr inbounds %struct.lua_TValue, ptr %36, i64 -1
  tail call void @luaD_call(ptr noundef nonnull %0, ptr noundef nonnull %38, i32 noundef 1) #46
  br label %39

39:                                               ; preds = %35, %1
  tail call void @luaD_throw(ptr noundef nonnull %0, i32 noundef 2) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaG_concaterror(ptr noundef %0, ptr noundef %1, ptr noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  %6 = add i32 %5, -3
  %7 = icmp ult i32 %6, 2
  %8 = select i1 %7, ptr %2, ptr %1
  tail call void @luaG_typeerror(ptr noundef %0, ptr noundef %8, ptr noundef nonnull @.str.2.27) #47
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaG_aritherror(ptr noundef %0, ptr noundef %1, ptr noundef %2) #1 {
  %4 = alloca %struct.lua_TValue, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %4) #48
  %5 = call ptr @luaV_tonumber(ptr noundef %1, ptr noundef nonnull %4) #46
  %6 = icmp eq ptr %5, null
  %7 = select i1 %6, ptr %1, ptr %2
  call void @luaG_typeerror(ptr noundef %0, ptr noundef %7, ptr noundef nonnull @.str.3.28) #47
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %4) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaG_ordererror(ptr noundef %0, ptr nocapture noundef readonly %1, ptr nocapture noundef readonly %2) #1 {
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  %6 = sext i32 %5 to i64
  %7 = getelementptr inbounds [0 x ptr], ptr @luaT_typenames, i64 0, i64 %6
  %8 = load ptr, ptr %7, align 8, !tbaa !39
  %9 = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  %10 = load i32, ptr %9, align 8, !tbaa !16
  %11 = sext i32 %10 to i64
  %12 = getelementptr inbounds [0 x ptr], ptr @luaT_typenames, i64 0, i64 %11
  %13 = load ptr, ptr %12, align 8, !tbaa !39
  %14 = getelementptr inbounds i8, ptr %8, i64 2
  %15 = load i8, ptr %14, align 1, !tbaa !33
  %16 = getelementptr inbounds i8, ptr %13, i64 2
  %17 = load i8, ptr %16, align 1, !tbaa !33
  %18 = icmp eq i8 %15, %17
  br i1 %18, label %19, label %20

19:                                               ; preds = %3
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %0, ptr noundef nonnull @.str.4.29, ptr noundef nonnull %8) #47
  br label %21

20:                                               ; preds = %3
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %0, ptr noundef nonnull @.str.5, ptr noundef nonnull %8, ptr noundef nonnull %13) #47
  br label %21

21:                                               ; preds = %20, %19
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaD_seterrorobj(ptr noundef %0, i32 noundef %1, ptr noundef %2) #1 {
  switch i32 %1, label %18 [
    i32 4, label %4
    i32 5, label %6
    i32 3, label %8
    i32 2, label %8
  ]

4:                                                ; preds = %3
  %5 = tail call ptr @luaS_newlstr(ptr noundef %0, ptr noundef nonnull @.str.30, i64 noundef 17) #46
  store ptr %5, ptr %2, align 8, !tbaa !33
  br label %15

6:                                                ; preds = %3
  %7 = tail call ptr @luaS_newlstr(ptr noundef %0, ptr noundef nonnull @.str.1.31, i64 noundef 23) #46
  store ptr %7, ptr %2, align 8, !tbaa !33
  br label %15

8:                                                ; preds = %3, %3
  %9 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %10 = load ptr, ptr %9, align 8, !tbaa !7
  %11 = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 -1
  %12 = load i64, ptr %11, align 8
  store i64 %12, ptr %2, align 8
  %13 = getelementptr %struct.lua_TValue, ptr %10, i64 -1, i32 1
  %14 = load i32, ptr %13, align 8, !tbaa !16
  br label %15

15:                                               ; preds = %8, %6, %4
  %16 = phi i32 [ %14, %8 ], [ 4, %6 ], [ 4, %4 ]
  %17 = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  store i32 %16, ptr %17, align 8, !tbaa !16
  br label %18

18:                                               ; preds = %15, %3
  %19 = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 1
  %20 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  store ptr %19, ptr %20, align 8, !tbaa !7
  ret void
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal void @luaD_throw(ptr noundef %0, i32 noundef %1) #20 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 26
  %4 = load ptr, ptr %3, align 8, !tbaa !126
  %5 = icmp eq ptr %4, null
  br i1 %5, label %9, label %6

6:                                                ; preds = %2
  %7 = getelementptr inbounds %struct.lua_longjmp, ptr %4, i64 0, i32 2
  store volatile i32 %1, ptr %7, align 8, !tbaa !127
  %8 = getelementptr inbounds %struct.lua_longjmp, ptr %4, i64 0, i32 1
  tail call void @_longjmp(ptr noundef nonnull %8, i32 noundef 1) #50
  unreachable

9:                                                ; preds = %2
  %10 = trunc i32 %1 to i8
  %11 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 3
  store i8 %10, ptr %11, align 2, !tbaa !50
  %12 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %13 = load ptr, ptr %12, align 8, !tbaa !25
  %14 = getelementptr inbounds %struct.global_State, ptr %13, i64 0, i32 19
  %15 = load ptr, ptr %14, align 8, !tbaa !26
  %16 = icmp eq ptr %15, null
  br i1 %16, label %32, label %17

17:                                               ; preds = %9
  %18 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %19 = load ptr, ptr %18, align 8, !tbaa !38
  %20 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  store ptr %19, ptr %20, align 8, !tbaa !19
  %21 = load ptr, ptr %19, align 8, !tbaa !100
  %22 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  store ptr %21, ptr %22, align 8, !tbaa !17
  tail call void @luaF_close(ptr noundef nonnull %0, ptr noundef %21) #46
  %23 = load ptr, ptr %22, align 8, !tbaa !17
  tail call void @luaD_seterrorobj(ptr noundef nonnull %0, i32 noundef %1, ptr noundef %23) #47
  %24 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 16
  %25 = load i16, ptr %24, align 2, !tbaa !129
  %26 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 15
  store i16 %25, ptr %26, align 8, !tbaa !24
  %27 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 18
  store i8 1, ptr %27, align 1, !tbaa !130
  tail call fastcc void @restore_stack_limit(ptr noundef nonnull %0) #47
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %3, i8 0, i64 16, i1 false)
  %28 = load ptr, ptr %12, align 8, !tbaa !25
  %29 = getelementptr inbounds %struct.global_State, ptr %28, i64 0, i32 19
  %30 = load ptr, ptr %29, align 8, !tbaa !26
  %31 = tail call i32 %30(ptr noundef nonnull %0) #46
  br label %32

32:                                               ; preds = %17, %9
  tail call void @exit(i32 noundef 1) #50
  unreachable
}

; Function Attrs: noreturn nounwind optsize
declare void @_longjmp(ptr noundef, i32 noundef) local_unnamed_addr #21

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @restore_stack_limit(ptr noundef %0) unnamed_addr #1 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 14
  %3 = load i32, ptr %2, align 4, !tbaa !131
  %4 = icmp sgt i32 %3, 20000
  br i1 %4, label %5, label %27

5:                                                ; preds = %1
  %6 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %7 = load ptr, ptr %6, align 8, !tbaa !19
  %8 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %9 = load ptr, ptr %8, align 8, !tbaa !38
  %10 = ptrtoint ptr %7 to i64
  %11 = ptrtoint ptr %9 to i64
  %12 = sub i64 %10, %11
  %13 = sdiv exact i64 %12, 40
  %14 = trunc i64 %13 to i32
  %15 = icmp slt i32 %14, 19999
  br i1 %15, label %16, label %27

16:                                               ; preds = %5
  %17 = zext i32 %3 to i64
  %18 = mul nuw nsw i64 %17, 40
  %19 = tail call ptr @luaM_realloc_(ptr noundef nonnull %0, ptr noundef %9, i64 noundef %18, i64 noundef 800000) #46
  store ptr %19, ptr %8, align 8, !tbaa !38
  store i32 20000, ptr %2, align 4, !tbaa !131
  %20 = load ptr, ptr %6, align 8, !tbaa !19
  %21 = ptrtoint ptr %20 to i64
  %22 = sub i64 %21, %11
  %23 = sdiv exact i64 %22, 40
  %24 = getelementptr inbounds %struct.CallInfo, ptr %19, i64 %23
  store ptr %24, ptr %6, align 8, !tbaa !19
  %25 = getelementptr inbounds %struct.CallInfo, ptr %19, i64 19999
  %26 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 11
  store ptr %25, ptr %26, align 8, !tbaa !132
  br label %27

27:                                               ; preds = %16, %5, %1
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #22

; Function Attrs: noreturn nounwind optsize
declare void @exit(i32 noundef) local_unnamed_addr #21

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaD_rawrunprotected(ptr noundef %0, ptr nocapture noundef readonly %1, ptr noundef %2) #1 {
  %4 = alloca %struct.lua_longjmp, align 8
  call void @llvm.lifetime.start.p0(i64 216, ptr nonnull %4) #48
  %5 = getelementptr inbounds %struct.lua_longjmp, ptr %4, i64 0, i32 2
  store volatile i32 0, ptr %5, align 8, !tbaa !127
  %6 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 26
  %7 = load ptr, ptr %6, align 8, !tbaa !126
  store ptr %7, ptr %4, align 8, !tbaa !133
  store ptr %4, ptr %6, align 8, !tbaa !126
  %8 = getelementptr inbounds %struct.lua_longjmp, ptr %4, i64 0, i32 1
  %9 = call i32 @_setjmp(ptr noundef nonnull %8) #51
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %11, label %12

11:                                               ; preds = %3
  call void %1(ptr noundef nonnull %0, ptr noundef %2) #46
  br label %12

12:                                               ; preds = %11, %3
  %13 = load ptr, ptr %4, align 8, !tbaa !133
  store ptr %13, ptr %6, align 8, !tbaa !126
  %14 = load volatile i32, ptr %5, align 8, !tbaa !127
  call void @llvm.lifetime.end.p0(i64 216, ptr nonnull %4) #48
  ret i32 %14
}

; Function Attrs: nounwind optsize returns_twice
declare i32 @_setjmp(ptr noundef) local_unnamed_addr #23

; Function Attrs: nounwind optsize uwtable
define internal void @luaD_reallocstack(ptr noundef %0, i32 noundef %1) #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 10
  %4 = load ptr, ptr %3, align 8, !tbaa !43
  %5 = add nsw i32 %1, 6
  %6 = icmp sgt i32 %1, -8
  br i1 %6, label %7, label %15

7:                                                ; preds = %2
  %8 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 13
  %9 = load i32, ptr %8, align 8, !tbaa !134
  %10 = sext i32 %9 to i64
  %11 = shl nsw i64 %10, 4
  %12 = sext i32 %5 to i64
  %13 = shl nsw i64 %12, 4
  %14 = tail call ptr @luaM_realloc_(ptr noundef nonnull %0, ptr noundef %4, i64 noundef %11, i64 noundef %13) #46
  br label %17

15:                                               ; preds = %2
  %16 = tail call ptr @luaM_toobig(ptr noundef nonnull %0) #46
  br label %17

17:                                               ; preds = %15, %7
  %18 = phi ptr [ %14, %7 ], [ %16, %15 ]
  store ptr %18, ptr %3, align 8, !tbaa !43
  %19 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 13
  store i32 %5, ptr %19, align 8, !tbaa !134
  %20 = sext i32 %1 to i64
  %21 = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 %20
  %22 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  store ptr %21, ptr %22, align 8, !tbaa !18
  %23 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %24 = load ptr, ptr %23, align 8, !tbaa !7
  %25 = ptrtoint ptr %24 to i64
  %26 = ptrtoint ptr %4 to i64
  %27 = sub i64 %25, %26
  %28 = ashr exact i64 %27, 4
  %29 = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 %28
  store ptr %29, ptr %23, align 8, !tbaa !7
  %30 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 24
  %31 = load ptr, ptr %30, align 8, !tbaa !33
  %32 = icmp eq ptr %31, null
  br i1 %32, label %46, label %33

33:                                               ; preds = %33, %17
  %34 = phi ptr [ %42, %33 ], [ %31, %17 ]
  %35 = getelementptr inbounds %struct.UpVal, ptr %34, i64 0, i32 3
  %36 = load ptr, ptr %35, align 8, !tbaa !33
  %37 = ptrtoint ptr %36 to i64
  %38 = sub i64 %37, %26
  %39 = ashr exact i64 %38, 4
  %40 = load ptr, ptr %3, align 8, !tbaa !43
  %41 = getelementptr inbounds %struct.lua_TValue, ptr %40, i64 %39
  store ptr %41, ptr %35, align 8, !tbaa !33
  %42 = load ptr, ptr %34, align 8, !tbaa !33
  %43 = icmp eq ptr %42, null
  br i1 %43, label %44, label %33, !llvm.loop !135

44:                                               ; preds = %33
  %45 = load ptr, ptr %3, align 8, !tbaa !43
  br label %46

46:                                               ; preds = %44, %17
  %47 = phi ptr [ %45, %44 ], [ %18, %17 ]
  %48 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %49 = load ptr, ptr %48, align 8, !tbaa !38
  %50 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %51 = load ptr, ptr %50, align 8, !tbaa !19
  %52 = icmp ugt ptr %49, %51
  br i1 %52, label %74, label %53

53:                                               ; preds = %53, %46
  %54 = phi ptr [ %72, %53 ], [ %49, %46 ]
  %55 = getelementptr inbounds %struct.CallInfo, ptr %54, i64 0, i32 2
  %56 = load ptr, ptr %55, align 8, !tbaa !20
  %57 = ptrtoint ptr %56 to i64
  %58 = sub i64 %57, %26
  %59 = ashr exact i64 %58, 4
  %60 = getelementptr inbounds %struct.lua_TValue, ptr %47, i64 %59
  store ptr %60, ptr %55, align 8, !tbaa !20
  %61 = load ptr, ptr %54, align 8, !tbaa !100
  %62 = ptrtoint ptr %61 to i64
  %63 = sub i64 %62, %26
  %64 = ashr exact i64 %63, 4
  %65 = getelementptr inbounds %struct.lua_TValue, ptr %47, i64 %64
  store ptr %65, ptr %54, align 8, !tbaa !100
  %66 = getelementptr inbounds %struct.CallInfo, ptr %54, i64 0, i32 1
  %67 = load ptr, ptr %66, align 8, !tbaa !36
  %68 = ptrtoint ptr %67 to i64
  %69 = sub i64 %68, %26
  %70 = ashr exact i64 %69, 4
  %71 = getelementptr inbounds %struct.lua_TValue, ptr %47, i64 %70
  store ptr %71, ptr %66, align 8, !tbaa !36
  %72 = getelementptr inbounds %struct.CallInfo, ptr %54, i64 1
  %73 = icmp ugt ptr %72, %51
  br i1 %73, label %74, label %53, !llvm.loop !136

74:                                               ; preds = %53, %46
  %75 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  %76 = load ptr, ptr %75, align 8, !tbaa !17
  %77 = ptrtoint ptr %76 to i64
  %78 = sub i64 %77, %26
  %79 = ashr exact i64 %78, 4
  %80 = getelementptr inbounds %struct.lua_TValue, ptr %47, i64 %79
  store ptr %80, ptr %75, align 8, !tbaa !17
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaD_reallocCI(ptr noundef %0, i32 noundef %1) #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %4 = load ptr, ptr %3, align 8, !tbaa !38
  %5 = icmp sgt i32 %1, -2
  br i1 %5, label %6, label %14

6:                                                ; preds = %2
  %7 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 14
  %8 = load i32, ptr %7, align 4, !tbaa !131
  %9 = sext i32 %8 to i64
  %10 = mul nsw i64 %9, 40
  %11 = sext i32 %1 to i64
  %12 = mul nsw i64 %11, 40
  %13 = tail call ptr @luaM_realloc_(ptr noundef nonnull %0, ptr noundef %4, i64 noundef %10, i64 noundef %12) #46
  br label %17

14:                                               ; preds = %2
  %15 = tail call ptr @luaM_toobig(ptr noundef nonnull %0) #46
  %16 = sext i32 %1 to i64
  br label %17

17:                                               ; preds = %14, %6
  %18 = phi i64 [ %16, %14 ], [ %11, %6 ]
  %19 = phi ptr [ %15, %14 ], [ %13, %6 ]
  store ptr %19, ptr %3, align 8, !tbaa !38
  %20 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 14
  store i32 %1, ptr %20, align 4, !tbaa !131
  %21 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %22 = load ptr, ptr %21, align 8, !tbaa !19
  %23 = ptrtoint ptr %22 to i64
  %24 = ptrtoint ptr %4 to i64
  %25 = sub i64 %23, %24
  %26 = sdiv exact i64 %25, 40
  %27 = getelementptr inbounds %struct.CallInfo, ptr %19, i64 %26
  store ptr %27, ptr %21, align 8, !tbaa !19
  %28 = getelementptr inbounds %struct.CallInfo, ptr %19, i64 %18
  %29 = getelementptr inbounds %struct.CallInfo, ptr %28, i64 -1
  %30 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 11
  store ptr %29, ptr %30, align 8, !tbaa !132
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaD_growstack(ptr noundef %0, i32 noundef %1) #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 13
  %4 = load i32, ptr %3, align 8, !tbaa !134
  %5 = icmp slt i32 %4, %1
  %6 = add nsw i32 %4, %1
  %7 = shl nsw i32 %4, 1
  %8 = select i1 %5, i32 %6, i32 %7
  tail call void @luaD_reallocstack(ptr noundef nonnull %0, i32 noundef %8) #47
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaD_callhook(ptr noundef %0, i32 noundef %1, i32 noundef %2) #1 {
  %4 = alloca %struct.lua_Debug, align 8
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 21
  %6 = load ptr, ptr %5, align 8, !tbaa !92
  %7 = icmp eq ptr %6, null
  br i1 %7, label %63, label %8

8:                                                ; preds = %3
  %9 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 18
  %10 = load i8, ptr %9, align 1, !tbaa !130
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %63, label %12

12:                                               ; preds = %8
  %13 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %14 = load ptr, ptr %13, align 8, !tbaa !7
  %15 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 10
  %16 = load ptr, ptr %15, align 8, !tbaa !43
  %17 = ptrtoint ptr %14 to i64
  %18 = ptrtoint ptr %16 to i64
  %19 = sub i64 %17, %18
  %20 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %21 = load ptr, ptr %20, align 8, !tbaa !19
  %22 = getelementptr inbounds %struct.CallInfo, ptr %21, i64 0, i32 2
  %23 = load ptr, ptr %22, align 8, !tbaa !20
  %24 = ptrtoint ptr %23 to i64
  %25 = sub i64 %24, %18
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %4) #48
  store i32 %1, ptr %4, align 8, !tbaa !137
  %26 = getelementptr inbounds %struct.lua_Debug, ptr %4, i64 0, i32 5
  store i32 %2, ptr %26, align 8, !tbaa !108
  %27 = icmp eq i32 %1, 4
  br i1 %27, label %36, label %28

28:                                               ; preds = %12
  %29 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %30 = load ptr, ptr %29, align 8, !tbaa !38
  %31 = ptrtoint ptr %21 to i64
  %32 = ptrtoint ptr %30 to i64
  %33 = sub i64 %31, %32
  %34 = sdiv exact i64 %33, 40
  %35 = trunc i64 %34 to i32
  br label %36

36:                                               ; preds = %28, %12
  %37 = phi i32 [ %35, %28 ], [ 0, %12 ]
  %38 = getelementptr inbounds %struct.lua_Debug, ptr %4, i64 0, i32 10
  store i32 %37, ptr %38, align 4
  %39 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %40 = load ptr, ptr %39, align 8, !tbaa !18
  %41 = ptrtoint ptr %40 to i64
  %42 = sub i64 %41, %17
  %43 = icmp slt i64 %42, 321
  br i1 %43, label %44, label %53

44:                                               ; preds = %36
  %45 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 13
  %46 = load i32, ptr %45, align 8, !tbaa !134
  %47 = icmp slt i32 %46, 20
  %48 = add nsw i32 %46, 20
  %49 = shl nsw i32 %46, 1
  %50 = select i1 %47, i32 %48, i32 %49
  tail call void @luaD_reallocstack(ptr noundef nonnull %0, i32 noundef %50) #47
  %51 = load ptr, ptr %13, align 8, !tbaa !7
  %52 = load ptr, ptr %20, align 8, !tbaa !19
  br label %53

53:                                               ; preds = %44, %36
  %54 = phi ptr [ %21, %36 ], [ %52, %44 ]
  %55 = phi ptr [ %14, %36 ], [ %51, %44 ]
  %56 = getelementptr inbounds %struct.lua_TValue, ptr %55, i64 20
  %57 = getelementptr inbounds %struct.CallInfo, ptr %54, i64 0, i32 2
  store ptr %56, ptr %57, align 8, !tbaa !20
  store i8 0, ptr %9, align 1, !tbaa !130
  call void %6(ptr noundef nonnull %0, ptr noundef nonnull %4) #46
  store i8 1, ptr %9, align 1, !tbaa !130
  %58 = load ptr, ptr %15, align 8, !tbaa !43
  %59 = getelementptr inbounds i8, ptr %58, i64 %25
  %60 = load ptr, ptr %20, align 8, !tbaa !19
  %61 = getelementptr inbounds %struct.CallInfo, ptr %60, i64 0, i32 2
  store ptr %59, ptr %61, align 8, !tbaa !20
  %62 = getelementptr inbounds i8, ptr %58, i64 %19
  store ptr %62, ptr %13, align 8, !tbaa !7
  call void @llvm.lifetime.end.p0(i64 120, ptr nonnull %4) #48
  br label %63

63:                                               ; preds = %53, %8, %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaD_precall(ptr noundef %0, ptr noundef %1, i32 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  %6 = icmp eq i32 %5, 6
  br i1 %6, label %7, label %9

7:                                                ; preds = %3
  %8 = load ptr, ptr %1, align 8, !tbaa !33
  br label %59

9:                                                ; preds = %3
  %10 = tail call ptr @luaT_gettmbyobj(ptr noundef %0, ptr noundef nonnull %1, i32 noundef 16) #46
  %11 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 10
  %12 = load ptr, ptr %11, align 8, !tbaa !43
  %13 = getelementptr inbounds %struct.lua_TValue, ptr %10, i64 0, i32 1
  %14 = load i32, ptr %13, align 8, !tbaa !16
  %15 = icmp eq i32 %14, 6
  br i1 %15, label %17, label %16

16:                                               ; preds = %9
  tail call void @luaG_typeerror(ptr noundef nonnull %0, ptr noundef nonnull %1, ptr noundef nonnull @.str.5.36) #46
  br label %17

17:                                               ; preds = %16, %9
  %18 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %19 = load ptr, ptr %18, align 8, !tbaa !7
  %20 = icmp ugt ptr %19, %1
  br i1 %20, label %21, label %31

21:                                               ; preds = %21, %17
  %22 = phi ptr [ %23, %21 ], [ %19, %17 ]
  %23 = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 -1
  %24 = load i64, ptr %23, align 8
  store i64 %24, ptr %22, align 8
  %25 = getelementptr %struct.lua_TValue, ptr %22, i64 -1, i32 1
  %26 = load i32, ptr %25, align 8, !tbaa !16
  %27 = getelementptr inbounds %struct.lua_TValue, ptr %22, i64 0, i32 1
  store i32 %26, ptr %27, align 8, !tbaa !16
  %28 = icmp ugt ptr %23, %1
  br i1 %28, label %21, label %29, !llvm.loop !138

29:                                               ; preds = %21
  %30 = load ptr, ptr %18, align 8, !tbaa !7
  br label %31

31:                                               ; preds = %29, %17
  %32 = phi ptr [ %30, %29 ], [ %19, %17 ]
  %33 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %34 = load ptr, ptr %33, align 8, !tbaa !18
  %35 = ptrtoint ptr %34 to i64
  %36 = ptrtoint ptr %32 to i64
  %37 = sub i64 %35, %36
  %38 = icmp slt i64 %37, 17
  br i1 %38, label %39, label %47

39:                                               ; preds = %31
  %40 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 13
  %41 = load i32, ptr %40, align 8, !tbaa !134
  %42 = icmp slt i32 %41, 1
  %43 = add nsw i32 %41, 1
  %44 = shl nsw i32 %41, 1
  %45 = select i1 %42, i32 %43, i32 %44
  tail call void @luaD_reallocstack(ptr noundef nonnull %0, i32 noundef %45) #47
  %46 = load ptr, ptr %18, align 8, !tbaa !7
  br label %47

47:                                               ; preds = %39, %31
  %48 = phi ptr [ %32, %31 ], [ %46, %39 ]
  %49 = ptrtoint ptr %1 to i64
  %50 = ptrtoint ptr %12 to i64
  %51 = sub i64 %49, %50
  %52 = getelementptr inbounds %struct.lua_TValue, ptr %48, i64 1
  store ptr %52, ptr %18, align 8, !tbaa !7
  %53 = load ptr, ptr %11, align 8, !tbaa !43
  %54 = getelementptr inbounds i8, ptr %53, i64 %51
  %55 = load i64, ptr %10, align 8
  store i64 %55, ptr %54, align 8
  %56 = load i32, ptr %13, align 8, !tbaa !16
  %57 = getelementptr inbounds %struct.lua_TValue, ptr %54, i64 0, i32 1
  store i32 %56, ptr %57, align 8, !tbaa !16
  %58 = inttoptr i64 %55 to ptr
  br label %59

59:                                               ; preds = %47, %7
  %60 = phi ptr [ %8, %7 ], [ %58, %47 ]
  %61 = phi ptr [ %1, %7 ], [ %54, %47 ]
  %62 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 10
  %63 = load ptr, ptr %62, align 8, !tbaa !43
  %64 = ptrtoint ptr %61 to i64
  %65 = ptrtoint ptr %63 to i64
  %66 = sub i64 %64, %65
  %67 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 8
  %68 = load ptr, ptr %67, align 8, !tbaa !102
  %69 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %70 = load ptr, ptr %69, align 8, !tbaa !19
  %71 = getelementptr inbounds %struct.CallInfo, ptr %70, i64 0, i32 3
  store ptr %68, ptr %71, align 8, !tbaa !101
  %72 = getelementptr inbounds %struct.LClosure, ptr %60, i64 0, i32 3
  %73 = load i8, ptr %72, align 2, !tbaa !139
  %74 = icmp eq i8 %73, 0
  br i1 %74, label %75, label %242

75:                                               ; preds = %59
  %76 = getelementptr inbounds %struct.LClosure, ptr %60, i64 0, i32 7
  %77 = load ptr, ptr %76, align 8, !tbaa !141
  %78 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %79 = load ptr, ptr %78, align 8, !tbaa !18
  %80 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %81 = load ptr, ptr %80, align 8, !tbaa !7
  %82 = ptrtoint ptr %79 to i64
  %83 = ptrtoint ptr %81 to i64
  %84 = sub i64 %82, %83
  %85 = getelementptr inbounds %struct.Proto, ptr %77, i64 0, i32 22
  %86 = load i8, ptr %85, align 1, !tbaa !79
  %87 = zext i8 %86 to i32
  %88 = shl nuw nsw i32 %87, 4
  %89 = zext i32 %88 to i64
  %90 = icmp sgt i64 %84, %89
  br i1 %90, label %99, label %91

91:                                               ; preds = %75
  %92 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 13
  %93 = load i32, ptr %92, align 8, !tbaa !134
  %94 = icmp slt i32 %93, %87
  %95 = add nsw i32 %93, %87
  %96 = shl nsw i32 %93, 1
  %97 = select i1 %94, i32 %95, i32 %96
  tail call void @luaD_reallocstack(ptr noundef nonnull %0, i32 noundef %97) #47
  %98 = load ptr, ptr %62, align 8, !tbaa !43
  br label %99

99:                                               ; preds = %91, %75
  %100 = phi ptr [ %63, %75 ], [ %98, %91 ]
  %101 = getelementptr inbounds i8, ptr %100, i64 %66
  %102 = getelementptr inbounds %struct.Proto, ptr %77, i64 0, i32 21
  %103 = load i8, ptr %102, align 2, !tbaa !117
  %104 = icmp eq i8 %103, 0
  br i1 %104, label %105, label %114

105:                                              ; preds = %99
  %106 = getelementptr inbounds %struct.lua_TValue, ptr %101, i64 1
  %107 = load ptr, ptr %80, align 8, !tbaa !7
  %108 = getelementptr inbounds %struct.Proto, ptr %77, i64 0, i32 20
  %109 = load i8, ptr %108, align 1, !tbaa !116
  %110 = zext i8 %109 to i64
  %111 = getelementptr inbounds %struct.lua_TValue, ptr %106, i64 %110
  %112 = icmp ugt ptr %107, %111
  br i1 %112, label %113, label %203

113:                                              ; preds = %105
  store ptr %111, ptr %80, align 8, !tbaa !7
  br label %203

114:                                              ; preds = %99
  %115 = load ptr, ptr %80, align 8, !tbaa !7
  %116 = ptrtoint ptr %115 to i64
  %117 = ptrtoint ptr %101 to i64
  %118 = sub i64 %116, %117
  %119 = lshr exact i64 %118, 4
  %120 = trunc i64 %119 to i32
  %121 = add nsw i32 %120, -1
  %122 = getelementptr inbounds %struct.Proto, ptr %77, i64 0, i32 20
  %123 = load i8, ptr %122, align 1, !tbaa !116
  %124 = zext i8 %123 to i32
  %125 = icmp sgt i32 %120, %124
  br i1 %125, label %134, label %126

126:                                              ; preds = %126, %114
  %127 = phi ptr [ %129, %126 ], [ %115, %114 ]
  %128 = phi i32 [ %131, %126 ], [ %121, %114 ]
  %129 = getelementptr inbounds %struct.lua_TValue, ptr %127, i64 1
  %130 = getelementptr inbounds %struct.lua_TValue, ptr %127, i64 0, i32 1
  store i32 0, ptr %130, align 8, !tbaa !16
  %131 = add nsw i32 %128, 1
  %132 = icmp eq i32 %131, %124
  br i1 %132, label %133, label %126, !llvm.loop !142

133:                                              ; preds = %126
  %.lcssa = phi ptr [ %129, %126 ]
  store ptr %.lcssa, ptr %80, align 8, !tbaa !7
  br label %134

134:                                              ; preds = %133, %114
  %135 = phi ptr [ %.lcssa, %133 ], [ %115, %114 ]
  %136 = phi i32 [ %124, %133 ], [ %121, %114 ]
  %137 = and i8 %103, 4
  %138 = icmp eq i8 %137, 0
  br i1 %138, label %174, label %139

139:                                              ; preds = %134
  %140 = sub i32 %136, %124
  %141 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %142 = load ptr, ptr %141, align 8, !tbaa !25
  %143 = getelementptr inbounds %struct.global_State, ptr %142, i64 0, i32 14
  %144 = load i64, ptr %143, align 8, !tbaa !31
  %145 = getelementptr inbounds %struct.global_State, ptr %142, i64 0, i32 13
  %146 = load i64, ptr %145, align 8, !tbaa !32
  %147 = icmp ult i64 %144, %146
  br i1 %147, label %149, label %148

148:                                              ; preds = %139
  tail call void @luaC_step(ptr noundef nonnull %0) #46
  br label %149

149:                                              ; preds = %148, %139
  %150 = tail call ptr @luaH_new(ptr noundef nonnull %0, i32 noundef %140, i32 noundef 1) #46
  %151 = icmp sgt i32 %140, 0
  br i1 %151, label %152, label %168

152:                                              ; preds = %149
  %153 = zext i32 %140 to i64
  %154 = sub nsw i64 0, %153
  br label %155

155:                                              ; preds = %155, %152
  %156 = phi i64 [ 0, %152 ], [ %160, %155 ]
  %157 = load ptr, ptr %80, align 8, !tbaa !7
  %158 = getelementptr inbounds %struct.lua_TValue, ptr %157, i64 %154
  %159 = getelementptr inbounds %struct.lua_TValue, ptr %158, i64 %156
  %160 = add nuw nsw i64 %156, 1
  %161 = trunc i64 %160 to i32
  %162 = tail call ptr @luaH_setnum(ptr noundef nonnull %0, ptr noundef %150, i32 noundef %161) #46
  %163 = load i64, ptr %159, align 8
  store i64 %163, ptr %162, align 8
  %164 = getelementptr inbounds %struct.lua_TValue, ptr %158, i64 %156, i32 1
  %165 = load i32, ptr %164, align 8, !tbaa !16
  %166 = getelementptr inbounds %struct.lua_TValue, ptr %162, i64 0, i32 1
  store i32 %165, ptr %166, align 8, !tbaa !16
  %167 = icmp eq i64 %160, %153
  br i1 %167, label %168, label %155, !llvm.loop !143

168:                                              ; preds = %155, %149
  %169 = tail call ptr @luaS_newlstr(ptr noundef nonnull %0, ptr noundef nonnull @.str.6.37, i64 noundef 1) #46
  %170 = tail call ptr @luaH_setstr(ptr noundef nonnull %0, ptr noundef %150, ptr noundef %169) #46
  %171 = sitofp i32 %140 to double
  store double %171, ptr %170, align 8, !tbaa !33
  %172 = getelementptr inbounds %struct.lua_TValue, ptr %170, i64 0, i32 1
  store i32 3, ptr %172, align 8, !tbaa !16
  %173 = load ptr, ptr %80, align 8, !tbaa !7
  br label %174

174:                                              ; preds = %168, %134
  %175 = phi ptr [ %173, %168 ], [ %135, %134 ]
  %176 = phi ptr [ %150, %168 ], [ null, %134 ]
  %177 = zext i32 %136 to i64
  %178 = sub nsw i64 0, %177
  %179 = getelementptr inbounds %struct.lua_TValue, ptr %175, i64 %178
  %180 = icmp eq i8 %123, 0
  br i1 %180, label %194, label %181

181:                                              ; preds = %174
  %182 = zext i8 %123 to i64
  br label %183

183:                                              ; preds = %183, %181
  %184 = phi i64 [ 0, %181 ], [ %192, %183 ]
  %185 = getelementptr inbounds %struct.lua_TValue, ptr %179, i64 %184
  %186 = load ptr, ptr %80, align 8, !tbaa !7
  %187 = getelementptr inbounds %struct.lua_TValue, ptr %186, i64 1
  store ptr %187, ptr %80, align 8, !tbaa !7
  %188 = load i64, ptr %185, align 8
  store i64 %188, ptr %186, align 8
  %189 = getelementptr inbounds %struct.lua_TValue, ptr %179, i64 %184, i32 1
  %190 = load i32, ptr %189, align 8, !tbaa !16
  %191 = getelementptr inbounds %struct.lua_TValue, ptr %186, i64 0, i32 1
  store i32 %190, ptr %191, align 8, !tbaa !16
  store i32 0, ptr %189, align 8, !tbaa !16
  %192 = add nuw nsw i64 %184, 1
  %193 = icmp eq i64 %192, %182
  br i1 %193, label %194, label %183, !llvm.loop !144

194:                                              ; preds = %183, %174
  %195 = icmp eq ptr %176, null
  br i1 %195, label %200, label %196

196:                                              ; preds = %194
  %197 = load ptr, ptr %80, align 8, !tbaa !7
  %198 = getelementptr inbounds %struct.lua_TValue, ptr %197, i64 1
  store ptr %198, ptr %80, align 8, !tbaa !7
  store ptr %176, ptr %197, align 8, !tbaa !33
  %199 = getelementptr inbounds %struct.lua_TValue, ptr %197, i64 0, i32 1
  store i32 5, ptr %199, align 8, !tbaa !16
  br label %200

200:                                              ; preds = %196, %194
  %201 = load ptr, ptr %62, align 8, !tbaa !43
  %202 = getelementptr inbounds i8, ptr %201, i64 %66
  br label %203

203:                                              ; preds = %200, %113, %105
  %204 = phi ptr [ %175, %200 ], [ %106, %113 ], [ %106, %105 ]
  %205 = phi ptr [ %202, %200 ], [ %101, %113 ], [ %101, %105 ]
  %206 = load ptr, ptr %69, align 8, !tbaa !19
  %207 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 11
  %208 = load ptr, ptr %207, align 8, !tbaa !132
  %209 = icmp eq ptr %206, %208
  br i1 %209, label %210, label %212

210:                                              ; preds = %203
  %211 = tail call fastcc ptr @growCI(ptr noundef nonnull %0) #47
  br label %214

212:                                              ; preds = %203
  %213 = getelementptr inbounds %struct.CallInfo, ptr %206, i64 1
  store ptr %213, ptr %69, align 8, !tbaa !19
  br label %214

214:                                              ; preds = %212, %210
  %215 = phi ptr [ %211, %210 ], [ %213, %212 ]
  %216 = getelementptr inbounds %struct.CallInfo, ptr %215, i64 0, i32 1
  store ptr %205, ptr %216, align 8, !tbaa !36
  store ptr %204, ptr %215, align 8, !tbaa !100
  %217 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  store ptr %204, ptr %217, align 8, !tbaa !17
  %218 = load i8, ptr %85, align 1, !tbaa !79
  %219 = zext i8 %218 to i64
  %220 = getelementptr inbounds %struct.lua_TValue, ptr %204, i64 %219
  %221 = getelementptr inbounds %struct.CallInfo, ptr %215, i64 0, i32 2
  store ptr %220, ptr %221, align 8, !tbaa !20
  %222 = getelementptr inbounds %struct.Proto, ptr %77, i64 0, i32 4
  %223 = load ptr, ptr %222, align 8, !tbaa !64
  store ptr %223, ptr %67, align 8, !tbaa !102
  %224 = getelementptr inbounds %struct.CallInfo, ptr %215, i64 0, i32 5
  store i32 0, ptr %224, align 4, !tbaa !96
  %225 = getelementptr inbounds %struct.CallInfo, ptr %215, i64 0, i32 4
  store i32 %2, ptr %225, align 8, !tbaa !145
  %226 = load ptr, ptr %80, align 8, !tbaa !7
  %227 = icmp ult ptr %226, %220
  br i1 %227, label %228, label %233

228:                                              ; preds = %228, %214
  %229 = phi ptr [ %231, %228 ], [ %226, %214 ]
  %230 = getelementptr inbounds %struct.lua_TValue, ptr %229, i64 0, i32 1
  store i32 0, ptr %230, align 8, !tbaa !16
  %231 = getelementptr inbounds %struct.lua_TValue, ptr %229, i64 1
  %232 = icmp ult ptr %231, %220
  br i1 %232, label %228, label %233, !llvm.loop !146

233:                                              ; preds = %228, %214
  store ptr %220, ptr %80, align 8, !tbaa !7
  %234 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 17
  %235 = load i8, ptr %234, align 4, !tbaa !95
  %236 = and i8 %235, 1
  %237 = icmp eq i8 %236, 0
  br i1 %237, label %299, label %238

238:                                              ; preds = %233
  %239 = getelementptr inbounds i32, ptr %223, i64 1
  store ptr %239, ptr %67, align 8, !tbaa !102
  tail call void @luaD_callhook(ptr noundef nonnull %0, i32 noundef 0, i32 noundef -1) #47
  %240 = load ptr, ptr %67, align 8, !tbaa !102
  %241 = getelementptr inbounds i32, ptr %240, i64 -1
  store ptr %241, ptr %67, align 8, !tbaa !102
  br label %299

242:                                              ; preds = %59
  %243 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %244 = load ptr, ptr %243, align 8, !tbaa !18
  %245 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %246 = load ptr, ptr %245, align 8, !tbaa !7
  %247 = ptrtoint ptr %244 to i64
  %248 = ptrtoint ptr %246 to i64
  %249 = sub i64 %247, %248
  %250 = icmp slt i64 %249, 321
  br i1 %250, label %251, label %259

251:                                              ; preds = %242
  %252 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 13
  %253 = load i32, ptr %252, align 8, !tbaa !134
  %254 = icmp slt i32 %253, 20
  %255 = add nsw i32 %253, 20
  %256 = shl nsw i32 %253, 1
  %257 = select i1 %254, i32 %255, i32 %256
  tail call void @luaD_reallocstack(ptr noundef nonnull %0, i32 noundef %257) #47
  %258 = load ptr, ptr %69, align 8, !tbaa !19
  br label %259

259:                                              ; preds = %251, %242
  %260 = phi ptr [ %70, %242 ], [ %258, %251 ]
  %261 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 11
  %262 = load ptr, ptr %261, align 8, !tbaa !132
  %263 = icmp eq ptr %260, %262
  br i1 %263, label %264, label %266

264:                                              ; preds = %259
  %265 = tail call fastcc ptr @growCI(ptr noundef nonnull %0) #47
  br label %268

266:                                              ; preds = %259
  %267 = getelementptr inbounds %struct.CallInfo, ptr %260, i64 1
  store ptr %267, ptr %69, align 8, !tbaa !19
  br label %268

268:                                              ; preds = %266, %264
  %269 = phi ptr [ %265, %264 ], [ %267, %266 ]
  %270 = load ptr, ptr %62, align 8, !tbaa !43
  %271 = getelementptr inbounds i8, ptr %270, i64 %66
  %272 = getelementptr inbounds %struct.CallInfo, ptr %269, i64 0, i32 1
  store ptr %271, ptr %272, align 8, !tbaa !36
  %273 = getelementptr inbounds %struct.lua_TValue, ptr %271, i64 1
  store ptr %273, ptr %269, align 8, !tbaa !100
  %274 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  store ptr %273, ptr %274, align 8, !tbaa !17
  %275 = load ptr, ptr %245, align 8, !tbaa !7
  %276 = getelementptr inbounds %struct.lua_TValue, ptr %275, i64 20
  %277 = getelementptr inbounds %struct.CallInfo, ptr %269, i64 0, i32 2
  store ptr %276, ptr %277, align 8, !tbaa !20
  %278 = getelementptr inbounds %struct.CallInfo, ptr %269, i64 0, i32 4
  store i32 %2, ptr %278, align 8, !tbaa !145
  %279 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 17
  %280 = load i8, ptr %279, align 4, !tbaa !95
  %281 = and i8 %280, 1
  %282 = icmp eq i8 %281, 0
  br i1 %282, label %284, label %283

283:                                              ; preds = %268
  tail call void @luaD_callhook(ptr noundef nonnull %0, i32 noundef 0, i32 noundef -1) #47
  br label %284

284:                                              ; preds = %283, %268
  %285 = load ptr, ptr %69, align 8, !tbaa !19
  %286 = getelementptr inbounds %struct.CallInfo, ptr %285, i64 0, i32 1
  %287 = load ptr, ptr %286, align 8, !tbaa !36
  %288 = load ptr, ptr %287, align 8, !tbaa !33
  %289 = getelementptr inbounds %struct.CClosure, ptr %288, i64 0, i32 7
  %290 = load ptr, ptr %289, align 8, !tbaa !33
  %291 = tail call i32 %290(ptr noundef nonnull %0) #46
  %292 = icmp slt i32 %291, 0
  br i1 %292, label %299, label %293

293:                                              ; preds = %284
  %294 = load ptr, ptr %245, align 8, !tbaa !7
  %295 = zext i32 %291 to i64
  %296 = sub nsw i64 0, %295
  %297 = getelementptr inbounds %struct.lua_TValue, ptr %294, i64 %296
  %298 = tail call i32 @luaD_poscall(ptr noundef nonnull %0, ptr noundef %297) #47
  br label %299

299:                                              ; preds = %293, %284, %238, %233
  %300 = phi i32 [ 0, %238 ], [ 0, %233 ], [ 1, %293 ], [ 2, %284 ]
  ret i32 %300
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc nonnull ptr @growCI(ptr noundef %0) unnamed_addr #1 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 14
  %3 = load i32, ptr %2, align 4, !tbaa !131
  %4 = icmp sgt i32 %3, 20000
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  tail call void @luaD_throw(ptr noundef nonnull %0, i32 noundef 5) #47
  unreachable

6:                                                ; preds = %1
  %7 = shl nsw i32 %3, 1
  tail call void @luaD_reallocCI(ptr noundef nonnull %0, i32 noundef %7) #47
  %8 = load i32, ptr %2, align 4, !tbaa !131
  %9 = icmp sgt i32 %8, 20000
  br i1 %9, label %10, label %11

10:                                               ; preds = %6
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.7.38) #46
  br label %11

11:                                               ; preds = %10, %6
  %12 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %13 = load ptr, ptr %12, align 8, !tbaa !19
  %14 = getelementptr inbounds %struct.CallInfo, ptr %13, i64 1
  store ptr %14, ptr %12, align 8, !tbaa !19
  ret ptr %14
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaD_poscall(ptr noundef %0, ptr noundef %1) #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 17
  %4 = load i8, ptr %3, align 4, !tbaa !95
  %5 = and i8 %4, 2
  %6 = icmp eq i8 %5, 0
  br i1 %6, label %38, label %7

7:                                                ; preds = %2
  %8 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 10
  %9 = load ptr, ptr %8, align 8, !tbaa !43
  tail call void @luaD_callhook(ptr noundef nonnull %0, i32 noundef 1, i32 noundef -1) #47
  %10 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %11 = load ptr, ptr %10, align 8, !tbaa !19
  %12 = getelementptr inbounds %struct.CallInfo, ptr %11, i64 0, i32 1
  %13 = load ptr, ptr %12, align 8, !tbaa !36
  %14 = load ptr, ptr %13, align 8, !tbaa !33
  %15 = getelementptr inbounds %struct.CClosure, ptr %14, i64 0, i32 3
  %16 = load i8, ptr %15, align 2, !tbaa !33
  %17 = icmp eq i8 %16, 0
  br i1 %17, label %18, label %32

18:                                               ; preds = %7
  %19 = load i8, ptr %3, align 4, !tbaa !95
  %20 = and i8 %19, 2
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %32, label %22

22:                                               ; preds = %28, %18
  %23 = load ptr, ptr %10, align 8, !tbaa !19
  %24 = getelementptr inbounds %struct.CallInfo, ptr %23, i64 0, i32 5
  %25 = load i32, ptr %24, align 4, !tbaa !96
  %26 = add nsw i32 %25, -1
  store i32 %26, ptr %24, align 4, !tbaa !96
  %27 = icmp eq i32 %25, 0
  br i1 %27, label %32, label %28

28:                                               ; preds = %22
  tail call void @luaD_callhook(ptr noundef nonnull %0, i32 noundef 4, i32 noundef -1) #47
  %29 = load i8, ptr %3, align 4, !tbaa !95
  %30 = and i8 %29, 2
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %32, label %22, !llvm.loop !147

32:                                               ; preds = %28, %22, %18, %7
  %33 = ptrtoint ptr %1 to i64
  %34 = ptrtoint ptr %9 to i64
  %35 = sub i64 %33, %34
  %36 = load ptr, ptr %8, align 8, !tbaa !43
  %37 = getelementptr inbounds i8, ptr %36, i64 %35
  br label %38

38:                                               ; preds = %32, %2
  %39 = phi ptr [ %37, %32 ], [ %1, %2 ]
  %40 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %41 = load ptr, ptr %40, align 8, !tbaa !19
  %42 = getelementptr inbounds %struct.CallInfo, ptr %41, i64 -1
  store ptr %42, ptr %40, align 8, !tbaa !19
  %43 = getelementptr inbounds %struct.CallInfo, ptr %41, i64 0, i32 1
  %44 = load ptr, ptr %43, align 8, !tbaa !36
  %45 = getelementptr inbounds %struct.CallInfo, ptr %41, i64 0, i32 4
  %46 = load i32, ptr %45, align 8, !tbaa !145
  %47 = load ptr, ptr %42, align 8, !tbaa !100
  %48 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  store ptr %47, ptr %48, align 8, !tbaa !17
  %49 = getelementptr %struct.CallInfo, ptr %41, i64 -1, i32 3
  %50 = load ptr, ptr %49, align 8, !tbaa !101
  %51 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 8
  store ptr %50, ptr %51, align 8, !tbaa !102
  %52 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %53 = icmp eq i32 %46, 0
  br i1 %53, label %78, label %54

54:                                               ; preds = %60, %38
  %55 = phi ptr [ %61, %60 ], [ %39, %38 ]
  %56 = phi ptr [ %62, %60 ], [ %44, %38 ]
  %57 = phi i32 [ %67, %60 ], [ %46, %38 ]
  %58 = load ptr, ptr %52, align 8, !tbaa !7
  %59 = icmp ult ptr %55, %58
  br i1 %59, label %60, label %69

60:                                               ; preds = %54
  %61 = getelementptr inbounds %struct.lua_TValue, ptr %55, i64 1
  %62 = getelementptr inbounds %struct.lua_TValue, ptr %56, i64 1
  %63 = load i64, ptr %55, align 8
  store i64 %63, ptr %56, align 8
  %64 = getelementptr inbounds %struct.lua_TValue, ptr %55, i64 0, i32 1
  %65 = load i32, ptr %64, align 8, !tbaa !16
  %66 = getelementptr inbounds %struct.lua_TValue, ptr %56, i64 0, i32 1
  store i32 %65, ptr %66, align 8, !tbaa !16
  %67 = add nsw i32 %57, -1
  %68 = icmp eq i32 %67, 0
  br i1 %68, label %78, label %54, !llvm.loop !148

69:                                               ; preds = %54
  %.lcssa1 = phi ptr [ %56, %54 ]
  %.lcssa = phi i32 [ %57, %54 ]
  %70 = icmp sgt i32 %.lcssa, 0
  br i1 %70, label %71, label %78

71:                                               ; preds = %71, %69
  %72 = phi ptr [ %75, %71 ], [ %.lcssa1, %69 ]
  %73 = phi i32 [ %74, %71 ], [ %.lcssa, %69 ]
  %74 = add nsw i32 %73, -1
  %75 = getelementptr inbounds %struct.lua_TValue, ptr %72, i64 1
  %76 = getelementptr inbounds %struct.lua_TValue, ptr %72, i64 0, i32 1
  store i32 0, ptr %76, align 8, !tbaa !16
  %77 = icmp ugt i32 %73, 1
  br i1 %77, label %71, label %78, !llvm.loop !149

78:                                               ; preds = %71, %69, %60, %38
  %79 = phi ptr [ %.lcssa1, %69 ], [ %44, %38 ], [ %75, %71 ], [ %62, %60 ]
  store ptr %79, ptr %52, align 8, !tbaa !7
  %80 = add nsw i32 %46, 1
  ret i32 %80
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaD_call(ptr noundef %0, ptr noundef %1, i32 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 15
  %5 = load i16, ptr %4, align 8, !tbaa !24
  %6 = add i16 %5, 1
  store i16 %6, ptr %4, align 8, !tbaa !24
  %7 = icmp ugt i16 %6, 199
  br i1 %7, label %8, label %14

8:                                                ; preds = %3
  %9 = icmp eq i16 %6, 200
  br i1 %9, label %10, label %11

10:                                               ; preds = %8
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.2.41) #46
  br label %14

11:                                               ; preds = %8
  %12 = icmp ugt i16 %6, 224
  br i1 %12, label %13, label %14

13:                                               ; preds = %11
  tail call void @luaD_throw(ptr noundef nonnull %0, i32 noundef 5) #47
  unreachable

14:                                               ; preds = %11, %10, %3
  %15 = tail call i32 @luaD_precall(ptr noundef nonnull %0, ptr noundef %1, i32 noundef %2) #47, !range !150
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %17, label %18

17:                                               ; preds = %14
  tail call void @luaV_execute(ptr noundef nonnull %0, i32 noundef 1) #46
  br label %18

18:                                               ; preds = %17, %14
  %19 = load i16, ptr %4, align 8, !tbaa !24
  %20 = add i16 %19, -1
  store i16 %20, ptr %4, align 8, !tbaa !24
  %21 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %22 = load ptr, ptr %21, align 8, !tbaa !25
  %23 = getelementptr inbounds %struct.global_State, ptr %22, i64 0, i32 14
  %24 = load i64, ptr %23, align 8, !tbaa !31
  %25 = getelementptr inbounds %struct.global_State, ptr %22, i64 0, i32 13
  %26 = load i64, ptr %25, align 8, !tbaa !32
  %27 = icmp ult i64 %24, %26
  br i1 %27, label %29, label %28

28:                                               ; preds = %18
  tail call void @luaC_step(ptr noundef nonnull %0) #46
  br label %29

29:                                               ; preds = %28, %18
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_resume(ptr noundef %0, i32 noundef %1) #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 3
  %4 = load i8, ptr %3, align 2, !tbaa !50
  switch i8 %4, label %11 [
    i8 1, label %12
    i8 0, label %5
  ]

5:                                                ; preds = %2
  %6 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %7 = load ptr, ptr %6, align 8, !tbaa !19
  %8 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %9 = load ptr, ptr %8, align 8, !tbaa !38
  %10 = icmp eq ptr %7, %9
  br i1 %10, label %12, label %11

11:                                               ; preds = %5, %2
  tail call fastcc void @resume_error(ptr noundef nonnull %0, ptr noundef nonnull @.str.3.42) #47
  br label %41

12:                                               ; preds = %5, %2
  %13 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 15
  %14 = load i16, ptr %13, align 8, !tbaa !24
  %15 = icmp ugt i16 %14, 199
  br i1 %15, label %16, label %17

16:                                               ; preds = %12
  tail call fastcc void @resume_error(ptr noundef nonnull %0, ptr noundef nonnull @.str.2.41) #47
  br label %41

17:                                               ; preds = %12
  %18 = add nuw nsw i16 %14, 1
  store i16 %18, ptr %13, align 8, !tbaa !24
  %19 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 16
  store i16 %18, ptr %19, align 2, !tbaa !129
  %20 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %21 = load ptr, ptr %20, align 8, !tbaa !7
  %22 = sext i32 %1 to i64
  %23 = sub nsw i64 0, %22
  %24 = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 %23
  %25 = tail call i32 @luaD_rawrunprotected(ptr noundef nonnull %0, ptr noundef nonnull @resume, ptr noundef %24) #47
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %34, label %27

27:                                               ; preds = %17
  %28 = trunc i32 %25 to i8
  store i8 %28, ptr %3, align 2, !tbaa !50
  %29 = load ptr, ptr %20, align 8, !tbaa !7
  tail call void @luaD_seterrorobj(ptr noundef nonnull %0, i32 noundef %25, ptr noundef %29) #47
  %30 = load ptr, ptr %20, align 8, !tbaa !7
  %31 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %32 = load ptr, ptr %31, align 8, !tbaa !19
  %33 = getelementptr inbounds %struct.CallInfo, ptr %32, i64 0, i32 2
  store ptr %30, ptr %33, align 8, !tbaa !20
  br label %37

34:                                               ; preds = %17
  %35 = load i8, ptr %3, align 2, !tbaa !50
  %36 = zext i8 %35 to i32
  br label %37

37:                                               ; preds = %34, %27
  %38 = phi i32 [ %25, %27 ], [ %36, %34 ]
  %39 = load i16, ptr %13, align 8, !tbaa !24
  %40 = add i16 %39, -1
  store i16 %40, ptr %13, align 8, !tbaa !24
  br label %41

41:                                               ; preds = %37, %16, %11
  %42 = phi i32 [ 2, %11 ], [ 2, %16 ], [ %38, %37 ]
  ret i32 %42
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @resume_error(ptr noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %4 = load ptr, ptr %3, align 8, !tbaa !19
  %5 = load ptr, ptr %4, align 8, !tbaa !100
  %6 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  store ptr %5, ptr %6, align 8, !tbaa !7
  %7 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %1) #49
  %8 = tail call ptr @luaS_newlstr(ptr noundef %0, ptr noundef %1, i64 noundef %7) #46
  store ptr %8, ptr %5, align 8, !tbaa !33
  %9 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 0, i32 1
  store i32 4, ptr %9, align 8, !tbaa !16
  %10 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %11 = load ptr, ptr %10, align 8, !tbaa !18
  %12 = load ptr, ptr %6, align 8, !tbaa !7
  %13 = ptrtoint ptr %11 to i64
  %14 = ptrtoint ptr %12 to i64
  %15 = sub i64 %13, %14
  %16 = icmp slt i64 %15, 17
  br i1 %16, label %17, label %25

17:                                               ; preds = %2
  %18 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 13
  %19 = load i32, ptr %18, align 8, !tbaa !134
  %20 = icmp slt i32 %19, 1
  %21 = add nsw i32 %19, 1
  %22 = shl nsw i32 %19, 1
  %23 = select i1 %20, i32 %21, i32 %22
  tail call void @luaD_reallocstack(ptr noundef nonnull %0, i32 noundef %23) #47
  %24 = load ptr, ptr %6, align 8, !tbaa !7
  br label %25

25:                                               ; preds = %17, %2
  %26 = phi ptr [ %12, %2 ], [ %24, %17 ]
  %27 = getelementptr inbounds %struct.lua_TValue, ptr %26, i64 1
  store ptr %27, ptr %6, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @resume(ptr noundef %0, ptr noundef %1) #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 3
  %5 = load i8, ptr %4, align 2, !tbaa !50
  %6 = icmp eq i8 %5, 0
  br i1 %6, label %7, label %13

7:                                                ; preds = %2
  %8 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 -1
  %9 = tail call i32 @luaD_precall(ptr noundef nonnull %0, ptr noundef nonnull %8, i32 noundef -1) #47, !range !150
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %11, label %41

11:                                               ; preds = %7
  %12 = load ptr, ptr %3, align 8, !tbaa !19
  br label %32

13:                                               ; preds = %2
  %14 = load ptr, ptr %3, align 8, !tbaa !19
  store i8 0, ptr %4, align 2, !tbaa !50
  %15 = getelementptr inbounds %struct.CallInfo, ptr %14, i64 0, i32 1
  %16 = load ptr, ptr %15, align 8, !tbaa !36
  %17 = load ptr, ptr %16, align 8, !tbaa !33
  %18 = getelementptr inbounds %struct.CClosure, ptr %17, i64 0, i32 3
  %19 = load i8, ptr %18, align 2, !tbaa !33
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %29, label %21

21:                                               ; preds = %13
  %22 = tail call i32 @luaD_poscall(ptr noundef nonnull %0, ptr noundef %1) #47
  %23 = icmp eq i32 %22, 0
  %24 = load ptr, ptr %3, align 8, !tbaa !19
  br i1 %23, label %32, label %25

25:                                               ; preds = %21
  %26 = getelementptr inbounds %struct.CallInfo, ptr %24, i64 0, i32 2
  %27 = load ptr, ptr %26, align 8, !tbaa !20
  %28 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  store ptr %27, ptr %28, align 8, !tbaa !7
  br label %32

29:                                               ; preds = %13
  %30 = load ptr, ptr %14, align 8, !tbaa !100
  %31 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  store ptr %30, ptr %31, align 8, !tbaa !17
  br label %32

32:                                               ; preds = %29, %25, %21, %11
  %33 = phi ptr [ %12, %11 ], [ %14, %29 ], [ %24, %25 ], [ %24, %21 ]
  %34 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %35 = load ptr, ptr %34, align 8, !tbaa !38
  %36 = ptrtoint ptr %33 to i64
  %37 = ptrtoint ptr %35 to i64
  %38 = sub i64 %36, %37
  %39 = sdiv exact i64 %38, 40
  %40 = trunc i64 %39 to i32
  tail call void @luaV_execute(ptr noundef nonnull %0, i32 noundef %40) #46
  br label %41

41:                                               ; preds = %32, %7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @lua_yield(ptr noundef %0, i32 noundef %1) #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 15
  %4 = load i16, ptr %3, align 8, !tbaa !24
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 16
  %6 = load i16, ptr %5, align 2, !tbaa !129
  %7 = icmp ugt i16 %4, %6
  br i1 %7, label %8, label %9

8:                                                ; preds = %2
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.4.43) #46
  br label %9

9:                                                ; preds = %8, %2
  %10 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %11 = load ptr, ptr %10, align 8, !tbaa !7
  %12 = sext i32 %1 to i64
  %13 = sub nsw i64 0, %12
  %14 = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 %13
  %15 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  store ptr %14, ptr %15, align 8, !tbaa !17
  %16 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 3
  store i8 1, ptr %16, align 2, !tbaa !50
  ret i32 -1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaD_pcall(ptr noundef %0, ptr nocapture noundef readonly %1, ptr noundef %2, i64 noundef %3, i64 noundef %4) #1 {
  %6 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 15
  %7 = load i16, ptr %6, align 8, !tbaa !24
  %8 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %9 = load ptr, ptr %8, align 8, !tbaa !19
  %10 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  %11 = load ptr, ptr %10, align 8, !tbaa !38
  %12 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 18
  %13 = load i8, ptr %12, align 1, !tbaa !130
  %14 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 27
  %15 = load i64, ptr %14, align 8, !tbaa !125
  store i64 %4, ptr %14, align 8, !tbaa !125
  %16 = tail call i32 @luaD_rawrunprotected(ptr noundef %0, ptr noundef %1, ptr noundef %2) #47
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %32, label %18

18:                                               ; preds = %5
  %19 = ptrtoint ptr %9 to i64
  %20 = ptrtoint ptr %11 to i64
  %21 = sub i64 %19, %20
  %22 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 10
  %23 = load ptr, ptr %22, align 8, !tbaa !43
  %24 = getelementptr inbounds i8, ptr %23, i64 %3
  tail call void @luaF_close(ptr noundef nonnull %0, ptr noundef %24) #46
  tail call void @luaD_seterrorobj(ptr noundef nonnull %0, i32 noundef %16, ptr noundef %24) #47
  store i16 %7, ptr %6, align 8, !tbaa !24
  %25 = load ptr, ptr %10, align 8, !tbaa !38
  %26 = getelementptr inbounds i8, ptr %25, i64 %21
  store ptr %26, ptr %8, align 8, !tbaa !19
  %27 = load ptr, ptr %26, align 8, !tbaa !100
  %28 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  store ptr %27, ptr %28, align 8, !tbaa !17
  %29 = getelementptr inbounds %struct.CallInfo, ptr %26, i64 0, i32 3
  %30 = load ptr, ptr %29, align 8, !tbaa !101
  %31 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 8
  store ptr %30, ptr %31, align 8, !tbaa !102
  store i8 %13, ptr %12, align 1, !tbaa !130
  tail call fastcc void @restore_stack_limit(ptr noundef nonnull %0) #47
  br label %32

32:                                               ; preds = %18, %5
  store i64 %15, ptr %14, align 8, !tbaa !125
  ret i32 %16
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaD_protectedparser(ptr noundef %0, ptr noundef %1, ptr noundef %2) #1 {
  %4 = alloca %struct.SParser, align 8
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %4) #48
  store ptr %1, ptr %4, align 8, !tbaa !151
  %5 = getelementptr inbounds %struct.SParser, ptr %4, i64 0, i32 2
  store ptr %2, ptr %5, align 8, !tbaa !153
  %6 = getelementptr inbounds %struct.SParser, ptr %4, i64 0, i32 1
  store ptr null, ptr %6, align 8, !tbaa !154
  %7 = getelementptr inbounds %struct.SParser, ptr %4, i64 0, i32 1, i32 2
  store i64 0, ptr %7, align 8, !tbaa !155
  %8 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %9 = load ptr, ptr %8, align 8, !tbaa !7
  %10 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 10
  %11 = load ptr, ptr %10, align 8, !tbaa !43
  %12 = ptrtoint ptr %9 to i64
  %13 = ptrtoint ptr %11 to i64
  %14 = sub i64 %12, %13
  %15 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 27
  %16 = load i64, ptr %15, align 8, !tbaa !125
  %17 = call i32 @luaD_pcall(ptr noundef %0, ptr noundef nonnull @f_parser, ptr noundef nonnull %4, i64 noundef %14, i64 noundef %16) #47
  %18 = load ptr, ptr %6, align 8, !tbaa !154
  %19 = load i64, ptr %7, align 8, !tbaa !155
  %20 = call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %18, i64 noundef %19, i64 noundef 0) #46
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %4) #48
  ret i32 %17
}

; Function Attrs: nounwind optsize uwtable
define internal void @f_parser(ptr noundef %0, ptr noundef %1) #1 {
  %3 = load ptr, ptr %1, align 8, !tbaa !151
  %4 = tail call i32 @luaZ_lookahead(ptr noundef %3) #46
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %6 = load ptr, ptr %5, align 8, !tbaa !25
  %7 = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 14
  %8 = load i64, ptr %7, align 8, !tbaa !31
  %9 = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 13
  %10 = load i64, ptr %9, align 8, !tbaa !32
  %11 = icmp ult i64 %8, %10
  br i1 %11, label %13, label %12

12:                                               ; preds = %2
  tail call void @luaC_step(ptr noundef nonnull %0) #46
  br label %13

13:                                               ; preds = %12, %2
  %14 = icmp eq i32 %4, 27
  %15 = select i1 %14, ptr @luaU_undump, ptr @luaY_parser
  %16 = load ptr, ptr %1, align 8, !tbaa !151
  %17 = getelementptr inbounds %struct.SParser, ptr %1, i64 0, i32 1
  %18 = getelementptr inbounds %struct.SParser, ptr %1, i64 0, i32 2
  %19 = load ptr, ptr %18, align 8, !tbaa !153
  %20 = tail call ptr %15(ptr noundef nonnull %0, ptr noundef %16, ptr noundef nonnull %17, ptr noundef %19) #46, !callees !156
  %21 = getelementptr inbounds %struct.Proto, ptr %20, i64 0, i32 19
  %22 = load i8, ptr %21, align 8, !tbaa !118
  %23 = zext i8 %22 to i32
  %24 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 22
  %25 = load ptr, ptr %24, align 8, !tbaa !33
  %26 = tail call ptr @luaF_newLclosure(ptr noundef nonnull %0, i32 noundef %23, ptr noundef %25) #46
  %27 = getelementptr inbounds %struct.LClosure, ptr %26, i64 0, i32 7
  store ptr %20, ptr %27, align 8, !tbaa !33
  %28 = load i8, ptr %21, align 8, !tbaa !118
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %38, label %30

30:                                               ; preds = %30, %13
  %31 = phi i64 [ %34, %30 ], [ 0, %13 ]
  %32 = tail call ptr @luaF_newupval(ptr noundef %0) #46
  %33 = getelementptr inbounds %struct.LClosure, ptr %26, i64 0, i32 8, i64 %31
  store ptr %32, ptr %33, align 8, !tbaa !33
  %34 = add nuw nsw i64 %31, 1
  %35 = load i8, ptr %21, align 8, !tbaa !118
  %36 = zext i8 %35 to i64
  %37 = icmp ult i64 %34, %36
  br i1 %37, label %30, label %38, !llvm.loop !157

38:                                               ; preds = %30, %13
  %39 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %40 = load ptr, ptr %39, align 8, !tbaa !7
  store ptr %26, ptr %40, align 8, !tbaa !33
  %41 = getelementptr inbounds %struct.lua_TValue, ptr %40, i64 0, i32 1
  store i32 6, ptr %41, align 8, !tbaa !16
  %42 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %43 = load ptr, ptr %42, align 8, !tbaa !18
  %44 = load ptr, ptr %39, align 8, !tbaa !7
  %45 = ptrtoint ptr %43 to i64
  %46 = ptrtoint ptr %44 to i64
  %47 = sub i64 %45, %46
  %48 = icmp slt i64 %47, 17
  br i1 %48, label %49, label %57

49:                                               ; preds = %38
  %50 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 13
  %51 = load i32, ptr %50, align 8, !tbaa !134
  %52 = icmp slt i32 %51, 1
  %53 = add nsw i32 %51, 1
  %54 = shl nsw i32 %51, 1
  %55 = select i1 %52, i32 %53, i32 %54
  tail call void @luaD_reallocstack(ptr noundef nonnull %0, i32 noundef %55) #47
  %56 = load ptr, ptr %39, align 8, !tbaa !7
  br label %57

57:                                               ; preds = %49, %38
  %58 = phi ptr [ %44, %38 ], [ %56, %49 ]
  %59 = getelementptr inbounds %struct.lua_TValue, ptr %58, i64 1
  store ptr %59, ptr %39, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaU_dump(ptr noundef %0, ptr nocapture noundef readonly %1, ptr noundef %2, ptr noundef %3, i32 noundef %4) #1 {
  %6 = alloca [12 x i8], align 1
  %7 = alloca %struct.DumpState, align 8
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %7) #48
  store ptr %0, ptr %7, align 8, !tbaa !158
  %8 = getelementptr inbounds %struct.DumpState, ptr %7, i64 0, i32 1
  store ptr %2, ptr %8, align 8, !tbaa !160
  %9 = getelementptr inbounds %struct.DumpState, ptr %7, i64 0, i32 2
  store ptr %3, ptr %9, align 8, !tbaa !161
  %10 = getelementptr inbounds %struct.DumpState, ptr %7, i64 0, i32 3
  store i32 %4, ptr %10, align 8, !tbaa !162
  %11 = getelementptr inbounds %struct.DumpState, ptr %7, i64 0, i32 4
  call void @llvm.lifetime.start.p0(i64 12, ptr nonnull %6) #48
  call void @luaU_header(ptr noundef nonnull %6) #46
  %12 = call i32 %2(ptr noundef %0, ptr noundef nonnull %6, i64 noundef 12, ptr noundef %3) #46
  store i32 %12, ptr %11, align 4, !tbaa !163
  call void @llvm.lifetime.end.p0(i64 12, ptr nonnull %6) #48
  call fastcc void @DumpFunction(ptr noundef %1, ptr noundef null, ptr noundef nonnull %7) #47
  %13 = load i32, ptr %11, align 4, !tbaa !163
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %7) #48
  ret i32 %13
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @DumpFunction(ptr nocapture noundef readonly %0, ptr noundef readnone %1, ptr noundef %2) unnamed_addr #1 {
  %4 = alloca i32, align 4
  %5 = alloca i8, align 1
  %6 = alloca i8, align 1
  %7 = alloca double, align 8
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i8, align 1
  %14 = alloca i8, align 1
  %15 = alloca i8, align 1
  %16 = alloca i8, align 1
  %17 = alloca i32, align 4
  %18 = alloca i32, align 4
  %19 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 9
  %20 = load ptr, ptr %19, align 8, !tbaa !105
  %21 = icmp eq ptr %20, %1
  br i1 %21, label %27, label %22

22:                                               ; preds = %3
  %23 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 3
  %24 = load i32, ptr %23, align 8, !tbaa !162
  %25 = icmp eq i32 %24, 0
  %26 = select i1 %25, ptr %20, ptr null
  br label %27

27:                                               ; preds = %22, %3
  %28 = phi ptr [ null, %3 ], [ %26, %22 ]
  tail call fastcc void @DumpString(ptr noundef %28, ptr noundef %2) #47
  %29 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 16
  %30 = load i32, ptr %29, align 8, !tbaa !106
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %18)
  store i32 %30, ptr %18, align 4, !tbaa !65
  %31 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 4
  %32 = load i32, ptr %31, align 4, !tbaa !163
  %33 = icmp eq i32 %32, 0
  br i1 %33, label %35, label %34

34:                                               ; preds = %27
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %18)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %17)
  br label %45

35:                                               ; preds = %27
  %36 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 1
  %37 = load ptr, ptr %36, align 8, !tbaa !160
  %38 = load ptr, ptr %2, align 8, !tbaa !158
  %39 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 2
  %40 = load ptr, ptr %39, align 8, !tbaa !161
  %41 = call i32 %37(ptr noundef %38, ptr noundef nonnull %18, i64 noundef 4, ptr noundef %40) #46
  store i32 %41, ptr %31, align 4, !tbaa !163
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %18)
  %42 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 17
  %43 = load i32, ptr %42, align 4, !tbaa !107
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %17)
  store i32 %43, ptr %17, align 4, !tbaa !65
  %44 = icmp eq i32 %41, 0
  br i1 %44, label %46, label %45

45:                                               ; preds = %35, %34
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %17)
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %16) #48
  br label %54

46:                                               ; preds = %35
  %47 = load ptr, ptr %36, align 8, !tbaa !160
  %48 = load ptr, ptr %2, align 8, !tbaa !158
  %49 = load ptr, ptr %39, align 8, !tbaa !161
  %50 = call i32 %47(ptr noundef %48, ptr noundef nonnull %17, i64 noundef 4, ptr noundef %49) #46
  store i32 %50, ptr %31, align 4, !tbaa !163
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %17)
  %51 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 19
  %52 = load i8, ptr %51, align 8, !tbaa !118
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %16) #48
  store i8 %52, ptr %16, align 1, !tbaa !33
  %53 = icmp eq i32 %50, 0
  br i1 %53, label %55, label %54

54:                                               ; preds = %46, %45
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %16) #48
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %15) #48
  br label %65

55:                                               ; preds = %46
  %56 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 1
  %57 = load ptr, ptr %56, align 8, !tbaa !160
  %58 = load ptr, ptr %2, align 8, !tbaa !158
  %59 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 2
  %60 = load ptr, ptr %59, align 8, !tbaa !161
  %61 = call i32 %57(ptr noundef %58, ptr noundef nonnull %16, i64 noundef 1, ptr noundef %60) #46
  store i32 %61, ptr %31, align 4, !tbaa !163
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %16) #48
  %62 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 20
  %63 = load i8, ptr %62, align 1, !tbaa !116
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %15) #48
  store i8 %63, ptr %15, align 1, !tbaa !33
  %64 = icmp eq i32 %61, 0
  br i1 %64, label %66, label %65

65:                                               ; preds = %55, %54
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %15) #48
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %14) #48
  br label %76

66:                                               ; preds = %55
  %67 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 1
  %68 = load ptr, ptr %67, align 8, !tbaa !160
  %69 = load ptr, ptr %2, align 8, !tbaa !158
  %70 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 2
  %71 = load ptr, ptr %70, align 8, !tbaa !161
  %72 = call i32 %68(ptr noundef %69, ptr noundef nonnull %15, i64 noundef 1, ptr noundef %71) #46
  store i32 %72, ptr %31, align 4, !tbaa !163
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %15) #48
  %73 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 21
  %74 = load i8, ptr %73, align 2, !tbaa !117
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %14) #48
  store i8 %74, ptr %14, align 1, !tbaa !33
  %75 = icmp eq i32 %72, 0
  br i1 %75, label %77, label %76

76:                                               ; preds = %66, %65
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %14) #48
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %13) #48
  br label %94

77:                                               ; preds = %66
  %78 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 1
  %79 = load ptr, ptr %78, align 8, !tbaa !160
  %80 = load ptr, ptr %2, align 8, !tbaa !158
  %81 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 2
  %82 = load ptr, ptr %81, align 8, !tbaa !161
  %83 = call i32 %79(ptr noundef %80, ptr noundef nonnull %14, i64 noundef 1, ptr noundef %82) #46
  store i32 %83, ptr %31, align 4, !tbaa !163
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %14) #48
  %84 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 22
  %85 = load i8, ptr %84, align 1, !tbaa !79
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %13) #48
  store i8 %85, ptr %13, align 1, !tbaa !33
  %86 = icmp eq i32 %83, 0
  br i1 %86, label %87, label %94

87:                                               ; preds = %77
  %88 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 1
  %89 = load ptr, ptr %88, align 8, !tbaa !160
  %90 = load ptr, ptr %2, align 8, !tbaa !158
  %91 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 2
  %92 = load ptr, ptr %91, align 8, !tbaa !161
  %93 = call i32 %89(ptr noundef %90, ptr noundef nonnull %13, i64 noundef 1, ptr noundef %92) #46
  store i32 %93, ptr %31, align 4, !tbaa !163
  br label %94

94:                                               ; preds = %87, %77, %76
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %13) #48
  %95 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 4
  %96 = load ptr, ptr %95, align 8, !tbaa !64
  %97 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 12
  %98 = load i32, ptr %97, align 8, !tbaa !71
  call fastcc void @DumpVector(ptr noundef %96, i32 noundef %98, ptr noundef nonnull %2) #47
  %99 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 11
  %100 = load i32, ptr %99, align 4, !tbaa !81
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  store i32 %100, ptr %4, align 4, !tbaa !65
  %101 = load i32, ptr %31, align 4, !tbaa !163
  %102 = icmp eq i32 %101, 0
  br i1 %102, label %103, label %110

103:                                              ; preds = %94
  %104 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 1
  %105 = load ptr, ptr %104, align 8, !tbaa !160
  %106 = load ptr, ptr %2, align 8, !tbaa !158
  %107 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 2
  %108 = load ptr, ptr %107, align 8, !tbaa !161
  %109 = call i32 %105(ptr noundef %106, ptr noundef nonnull %4, i64 noundef 4, ptr noundef %108) #46
  store i32 %109, ptr %31, align 4, !tbaa !163
  br label %110

110:                                              ; preds = %103, %94
  %111 = phi i32 [ %101, %94 ], [ %109, %103 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  %112 = icmp sgt i32 %100, 0
  br i1 %112, label %113, label %162

113:                                              ; preds = %110
  %114 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 3
  %115 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 1
  %116 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 2
  %117 = zext i32 %100 to i64
  br label %118

118:                                              ; preds = %157, %113
  %119 = phi i64 [ 0, %113 ], [ %158, %157 ]
  %120 = load ptr, ptr %114, align 8, !tbaa !83
  %121 = getelementptr inbounds %struct.lua_TValue, ptr %120, i64 %119
  %122 = getelementptr inbounds %struct.lua_TValue, ptr %120, i64 %119, i32 1
  %123 = load i32, ptr %122, align 8, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %5) #48
  %124 = trunc i32 %123 to i8
  store i8 %124, ptr %5, align 1, !tbaa !33
  %125 = load i32, ptr %31, align 4, !tbaa !163
  %126 = icmp eq i32 %125, 0
  br i1 %126, label %127, label %133

127:                                              ; preds = %118
  %128 = load ptr, ptr %115, align 8, !tbaa !160
  %129 = load ptr, ptr %2, align 8, !tbaa !158
  %130 = load ptr, ptr %116, align 8, !tbaa !161
  %131 = call i32 %128(ptr noundef %129, ptr noundef nonnull %5, i64 noundef 1, ptr noundef %130) #46
  store i32 %131, ptr %31, align 4, !tbaa !163
  %132 = load i32, ptr %122, align 8, !tbaa !16
  br label %133

133:                                              ; preds = %127, %118
  %134 = phi i32 [ %125, %118 ], [ %131, %127 ]
  %135 = phi i32 [ %123, %118 ], [ %132, %127 ]
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %5) #48
  switch i32 %135, label %157 [
    i32 4, label %155
    i32 1, label %136
    i32 3, label %146
  ]

136:                                              ; preds = %133
  %137 = load i32, ptr %121, align 8, !tbaa !33
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %6) #48
  %138 = trunc i32 %137 to i8
  store i8 %138, ptr %6, align 1, !tbaa !33
  %139 = icmp eq i32 %134, 0
  br i1 %139, label %140, label %145

140:                                              ; preds = %136
  %141 = load ptr, ptr %115, align 8, !tbaa !160
  %142 = load ptr, ptr %2, align 8, !tbaa !158
  %143 = load ptr, ptr %116, align 8, !tbaa !161
  %144 = call i32 %141(ptr noundef %142, ptr noundef nonnull %6, i64 noundef 1, ptr noundef %143) #46
  store i32 %144, ptr %31, align 4, !tbaa !163
  br label %145

145:                                              ; preds = %140, %136
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %6) #48
  br label %157

146:                                              ; preds = %133
  %147 = load double, ptr %121, align 8, !tbaa !33
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %7)
  store double %147, ptr %7, align 8, !tbaa !90
  %148 = icmp eq i32 %134, 0
  br i1 %148, label %149, label %154

149:                                              ; preds = %146
  %150 = load ptr, ptr %115, align 8, !tbaa !160
  %151 = load ptr, ptr %2, align 8, !tbaa !158
  %152 = load ptr, ptr %116, align 8, !tbaa !161
  %153 = call i32 %150(ptr noundef %151, ptr noundef nonnull %7, i64 noundef 8, ptr noundef %152) #46
  store i32 %153, ptr %31, align 4, !tbaa !163
  br label %154

154:                                              ; preds = %149, %146
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %7)
  br label %157

155:                                              ; preds = %133
  %156 = load ptr, ptr %121, align 8, !tbaa !33
  call fastcc void @DumpString(ptr noundef %156, ptr noundef %2) #47
  br label %157

157:                                              ; preds = %155, %154, %145, %133
  %158 = add nuw nsw i64 %119, 1
  %159 = icmp eq i64 %158, %117
  br i1 %159, label %160, label %118, !llvm.loop !164

160:                                              ; preds = %157
  %161 = load i32, ptr %31, align 4, !tbaa !163
  br label %162

162:                                              ; preds = %160, %110
  %163 = phi i32 [ %161, %160 ], [ %111, %110 ]
  %164 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 14
  %165 = load i32, ptr %164, align 8, !tbaa !120
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8)
  store i32 %165, ptr %8, align 4, !tbaa !65
  %166 = icmp eq i32 %163, 0
  br i1 %166, label %167, label %174

167:                                              ; preds = %162
  %168 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 1
  %169 = load ptr, ptr %168, align 8, !tbaa !160
  %170 = load ptr, ptr %2, align 8, !tbaa !158
  %171 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 2
  %172 = load ptr, ptr %171, align 8, !tbaa !161
  %173 = call i32 %169(ptr noundef %170, ptr noundef nonnull %8, i64 noundef 4, ptr noundef %172) #46
  store i32 %173, ptr %31, align 4, !tbaa !163
  br label %174

174:                                              ; preds = %167, %162
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8)
  %175 = icmp sgt i32 %165, 0
  br i1 %175, label %176, label %187

176:                                              ; preds = %174
  %177 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 5
  %178 = zext i32 %165 to i64
  br label %179

179:                                              ; preds = %179, %176
  %180 = phi i64 [ 0, %176 ], [ %185, %179 ]
  %181 = load ptr, ptr %177, align 8, !tbaa !121
  %182 = getelementptr inbounds ptr, ptr %181, i64 %180
  %183 = load ptr, ptr %182, align 8, !tbaa !39
  %184 = load ptr, ptr %19, align 8, !tbaa !105
  call fastcc void @DumpFunction(ptr noundef %183, ptr noundef %184, ptr noundef %2) #47
  %185 = add nuw nsw i64 %180, 1
  %186 = icmp eq i64 %185, %178
  br i1 %186, label %187, label %179, !llvm.loop !165

187:                                              ; preds = %179, %174
  %188 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 3
  %189 = load i32, ptr %188, align 8, !tbaa !162
  %190 = icmp eq i32 %189, 0
  br i1 %190, label %191, label %194

191:                                              ; preds = %187
  %192 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 13
  %193 = load i32, ptr %192, align 4, !tbaa !73
  br label %194

194:                                              ; preds = %191, %187
  %195 = phi i32 [ %193, %191 ], [ 0, %187 ]
  %196 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 6
  %197 = load ptr, ptr %196, align 8, !tbaa !74
  call fastcc void @DumpVector(ptr noundef %197, i32 noundef %195, ptr noundef nonnull %2) #47
  %198 = load i32, ptr %188, align 8, !tbaa !162
  %199 = icmp eq i32 %198, 0
  br i1 %199, label %200, label %203

200:                                              ; preds = %194
  %201 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 15
  %202 = load i32, ptr %201, align 4, !tbaa !166
  br label %203

203:                                              ; preds = %200, %194
  %204 = phi i32 [ %202, %200 ], [ 0, %194 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %12)
  store i32 %204, ptr %12, align 4, !tbaa !65
  %205 = load i32, ptr %31, align 4, !tbaa !163
  %206 = icmp eq i32 %205, 0
  br i1 %206, label %207, label %214

207:                                              ; preds = %203
  %208 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 1
  %209 = load ptr, ptr %208, align 8, !tbaa !160
  %210 = load ptr, ptr %2, align 8, !tbaa !158
  %211 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 2
  %212 = load ptr, ptr %211, align 8, !tbaa !161
  %213 = call i32 %209(ptr noundef %210, ptr noundef nonnull %12, i64 noundef 4, ptr noundef %212) #46
  store i32 %213, ptr %31, align 4, !tbaa !163
  br label %214

214:                                              ; preds = %207, %203
  %215 = phi i32 [ %205, %203 ], [ %213, %207 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %12)
  %216 = icmp sgt i32 %204, 0
  br i1 %216, label %217, label %251

217:                                              ; preds = %214
  %218 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 7
  %219 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 1
  %220 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 2
  %221 = zext i32 %204 to i64
  br label %222

222:                                              ; preds = %247, %217
  %223 = phi i64 [ 0, %217 ], [ %249, %247 ]
  %224 = load ptr, ptr %218, align 8, !tbaa !167
  %225 = getelementptr inbounds %struct.stringtable, ptr %224, i64 %223
  %226 = load ptr, ptr %225, align 8, !tbaa !168
  call fastcc void @DumpString(ptr noundef %226, ptr noundef nonnull %2) #47
  %227 = load ptr, ptr %218, align 8, !tbaa !167
  %228 = getelementptr inbounds %struct.stringtable, ptr %227, i64 %223, i32 1
  %229 = load i32, ptr %228, align 8, !tbaa !170
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %11)
  store i32 %229, ptr %11, align 4, !tbaa !65
  %230 = load i32, ptr %31, align 4, !tbaa !163
  %231 = icmp eq i32 %230, 0
  br i1 %231, label %233, label %232

232:                                              ; preds = %222
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  br label %247

233:                                              ; preds = %222
  %234 = load ptr, ptr %219, align 8, !tbaa !160
  %235 = load ptr, ptr %2, align 8, !tbaa !158
  %236 = load ptr, ptr %220, align 8, !tbaa !161
  %237 = call i32 %234(ptr noundef %235, ptr noundef nonnull %11, i64 noundef 4, ptr noundef %236) #46
  store i32 %237, ptr %31, align 4, !tbaa !163
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %11)
  %238 = load ptr, ptr %218, align 8, !tbaa !167
  %239 = getelementptr inbounds %struct.stringtable, ptr %238, i64 %223, i32 2
  %240 = load i32, ptr %239, align 4, !tbaa !171
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %10)
  store i32 %240, ptr %10, align 4, !tbaa !65
  %241 = icmp eq i32 %237, 0
  br i1 %241, label %242, label %247

242:                                              ; preds = %233
  %243 = load ptr, ptr %219, align 8, !tbaa !160
  %244 = load ptr, ptr %2, align 8, !tbaa !158
  %245 = load ptr, ptr %220, align 8, !tbaa !161
  %246 = call i32 %243(ptr noundef %244, ptr noundef nonnull %10, i64 noundef 4, ptr noundef %245) #46
  store i32 %246, ptr %31, align 4, !tbaa !163
  br label %247

247:                                              ; preds = %242, %233, %232
  %248 = phi i32 [ %230, %232 ], [ %237, %233 ], [ %246, %242 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %10)
  %249 = add nuw nsw i64 %223, 1
  %250 = icmp eq i64 %249, %221
  br i1 %250, label %251, label %222, !llvm.loop !172

251:                                              ; preds = %247, %214
  %252 = phi i32 [ %215, %214 ], [ %248, %247 ]
  %253 = load i32, ptr %188, align 8, !tbaa !162
  %254 = icmp eq i32 %253, 0
  br i1 %254, label %255, label %258

255:                                              ; preds = %251
  %256 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 10
  %257 = load i32, ptr %256, align 8, !tbaa !55
  br label %258

258:                                              ; preds = %255, %251
  %259 = phi i32 [ %257, %255 ], [ 0, %251 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %9)
  store i32 %259, ptr %9, align 4, !tbaa !65
  %260 = icmp eq i32 %252, 0
  br i1 %260, label %261, label %268

261:                                              ; preds = %258
  %262 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 1
  %263 = load ptr, ptr %262, align 8, !tbaa !160
  %264 = load ptr, ptr %2, align 8, !tbaa !158
  %265 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 2
  %266 = load ptr, ptr %265, align 8, !tbaa !161
  %267 = call i32 %263(ptr noundef %264, ptr noundef nonnull %9, i64 noundef 4, ptr noundef %266) #46
  store i32 %267, ptr %31, align 4, !tbaa !163
  br label %268

268:                                              ; preds = %261, %258
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %9)
  %269 = icmp sgt i32 %259, 0
  br i1 %269, label %270, label %280

270:                                              ; preds = %268
  %271 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 8
  %272 = zext i32 %259 to i64
  br label %273

273:                                              ; preds = %273, %270
  %274 = phi i64 [ 0, %270 ], [ %278, %273 ]
  %275 = load ptr, ptr %271, align 8, !tbaa !58
  %276 = getelementptr inbounds ptr, ptr %275, i64 %274
  %277 = load ptr, ptr %276, align 8, !tbaa !39
  call fastcc void @DumpString(ptr noundef %277, ptr noundef %2) #47
  %278 = add nuw nsw i64 %274, 1
  %279 = icmp eq i64 %278, %272
  br i1 %279, label %280, label %273, !llvm.loop !173

280:                                              ; preds = %273, %268
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @DumpString(ptr noundef %0, ptr nocapture noundef %1) unnamed_addr #1 {
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = icmp eq ptr %0, null
  br i1 %5, label %6, label %18

6:                                                ; preds = %2
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #48
  store i64 0, ptr %3, align 8, !tbaa !40
  %7 = getelementptr inbounds %struct.DumpState, ptr %1, i64 0, i32 4
  %8 = load i32, ptr %7, align 4, !tbaa !163
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %17

10:                                               ; preds = %6
  %11 = getelementptr inbounds %struct.DumpState, ptr %1, i64 0, i32 1
  %12 = load ptr, ptr %11, align 8, !tbaa !160
  %13 = load ptr, ptr %1, align 8, !tbaa !158
  %14 = getelementptr inbounds %struct.DumpState, ptr %1, i64 0, i32 2
  %15 = load ptr, ptr %14, align 8, !tbaa !161
  %16 = call i32 %12(ptr noundef %13, ptr noundef nonnull %3, i64 noundef 8, ptr noundef %15) #46
  store i32 %16, ptr %7, align 4, !tbaa !163
  br label %17

17:                                               ; preds = %10, %6
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #48
  br label %41

18:                                               ; preds = %2
  %19 = getelementptr inbounds %union.TString, ptr %0, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #48
  %20 = getelementptr inbounds %struct.anon.0, ptr %0, i64 0, i32 5
  %21 = load i64, ptr %20, align 8, !tbaa !33
  %22 = add i64 %21, 1
  store i64 %22, ptr %4, align 8, !tbaa !40
  %23 = getelementptr inbounds %struct.DumpState, ptr %1, i64 0, i32 4
  %24 = load i32, ptr %23, align 4, !tbaa !163
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %26, label %40

26:                                               ; preds = %18
  %27 = getelementptr inbounds %struct.DumpState, ptr %1, i64 0, i32 1
  %28 = load ptr, ptr %27, align 8, !tbaa !160
  %29 = load ptr, ptr %1, align 8, !tbaa !158
  %30 = getelementptr inbounds %struct.DumpState, ptr %1, i64 0, i32 2
  %31 = load ptr, ptr %30, align 8, !tbaa !161
  %32 = call i32 %28(ptr noundef %29, ptr noundef nonnull %4, i64 noundef 8, ptr noundef %31) #46
  store i32 %32, ptr %23, align 4, !tbaa !163
  %33 = icmp eq i32 %32, 0
  br i1 %33, label %34, label %40

34:                                               ; preds = %26
  %35 = load i64, ptr %4, align 8, !tbaa !40
  %36 = load ptr, ptr %27, align 8, !tbaa !160
  %37 = load ptr, ptr %1, align 8, !tbaa !158
  %38 = load ptr, ptr %30, align 8, !tbaa !161
  %39 = call i32 %36(ptr noundef %37, ptr noundef nonnull %19, i64 noundef %35, ptr noundef %38) #46
  store i32 %39, ptr %23, align 4, !tbaa !163
  br label %40

40:                                               ; preds = %34, %26, %18
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #48
  br label %41

41:                                               ; preds = %40, %17
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @DumpVector(ptr noundef %0, i32 noundef %1, ptr nocapture noundef %2) unnamed_addr #1 {
  %4 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  store i32 %1, ptr %4, align 4, !tbaa !65
  %5 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 4
  %6 = load i32, ptr %5, align 4, !tbaa !163
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %9, label %8

8:                                                ; preds = %3
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %24

9:                                                ; preds = %3
  %10 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 1
  %11 = load ptr, ptr %10, align 8, !tbaa !160
  %12 = load ptr, ptr %2, align 8, !tbaa !158
  %13 = getelementptr inbounds %struct.DumpState, ptr %2, i64 0, i32 2
  %14 = load ptr, ptr %13, align 8, !tbaa !161
  %15 = call i32 %11(ptr noundef %12, ptr noundef nonnull %4, i64 noundef 4, ptr noundef %14) #46
  store i32 %15, ptr %5, align 4, !tbaa !163
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %17, label %24

17:                                               ; preds = %9
  %18 = sext i32 %1 to i64
  %19 = shl nsw i64 %18, 2
  %20 = load ptr, ptr %10, align 8, !tbaa !160
  %21 = load ptr, ptr %2, align 8, !tbaa !158
  %22 = load ptr, ptr %13, align 8, !tbaa !161
  %23 = call i32 %20(ptr noundef %21, ptr noundef %0, i64 noundef %19, ptr noundef %22) #46
  store i32 %23, ptr %5, align 4, !tbaa !163
  br label %24

24:                                               ; preds = %17, %9, %8
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaF_newCclosure(ptr noundef %0, i32 noundef %1, ptr noundef %2) #1 {
  %4 = shl i32 %1, 4
  %5 = add i32 %4, 40
  %6 = sext i32 %5 to i64
  %7 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef null, i64 noundef 0, i64 noundef %6) #46
  tail call void @luaC_link(ptr noundef %0, ptr noundef %7, i8 noundef zeroext 6) #46
  %8 = getelementptr inbounds %struct.CClosure, ptr %7, i64 0, i32 3
  store i8 1, ptr %8, align 2, !tbaa !33
  %9 = getelementptr inbounds %struct.CClosure, ptr %7, i64 0, i32 6
  store ptr %2, ptr %9, align 8, !tbaa !33
  %10 = trunc i32 %1 to i8
  %11 = getelementptr inbounds %struct.CClosure, ptr %7, i64 0, i32 4
  store i8 %10, ptr %11, align 1, !tbaa !33
  ret ptr %7
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaF_newLclosure(ptr noundef %0, i32 noundef %1, ptr noundef %2) #1 {
  %4 = shl i32 %1, 3
  %5 = add i32 %4, 40
  %6 = sext i32 %5 to i64
  %7 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef null, i64 noundef 0, i64 noundef %6) #46
  tail call void @luaC_link(ptr noundef %0, ptr noundef %7, i8 noundef zeroext 6) #46
  %8 = getelementptr inbounds %struct.LClosure, ptr %7, i64 0, i32 3
  store i8 0, ptr %8, align 2, !tbaa !33
  %9 = getelementptr inbounds %struct.LClosure, ptr %7, i64 0, i32 6
  store ptr %2, ptr %9, align 8, !tbaa !33
  %10 = trunc i32 %1 to i8
  %11 = getelementptr inbounds %struct.LClosure, ptr %7, i64 0, i32 4
  store i8 %10, ptr %11, align 1, !tbaa !33
  %12 = icmp eq i32 %1, 0
  br i1 %12, label %24, label %13

13:                                               ; preds = %3
  %14 = add i32 %1, -1
  %15 = sext i32 %14 to i64
  %16 = shl nsw i64 %15, 3
  %17 = add nsw i64 %16, 40
  %18 = zext i32 %14 to i64
  %19 = shl nuw nsw i64 %18, 3
  %20 = sub nsw i64 %17, %19
  %21 = getelementptr i8, ptr %7, i64 %20
  %22 = zext i32 %1 to i64
  %23 = shl nuw nsw i64 %22, 3
  tail call void @llvm.memset.p0.i64(ptr align 8 %21, i8 0, i64 %23, i1 false), !tbaa !33
  br label %24

24:                                               ; preds = %13, %3
  ret ptr %7
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaF_newupval(ptr noundef %0) #1 {
  %2 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef null, i64 noundef 0, i64 noundef 40) #46
  tail call void @luaC_link(ptr noundef %0, ptr noundef %2, i8 noundef zeroext 10) #46
  %3 = getelementptr inbounds %struct.UpVal, ptr %2, i64 0, i32 4
  %4 = getelementptr inbounds %struct.UpVal, ptr %2, i64 0, i32 3
  store ptr %3, ptr %4, align 8, !tbaa !57
  %5 = getelementptr inbounds %struct.UpVal, ptr %2, i64 0, i32 4, i32 0, i32 1
  store i32 0, ptr %5, align 8, !tbaa !16
  ret ptr %2
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaF_findupval(ptr noundef %0, ptr noundef %1) #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %4 = load ptr, ptr %3, align 8, !tbaa !25
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 24
  br label %6

6:                                                ; preds = %14, %2
  %7 = phi ptr [ %5, %2 ], [ %8, %14 ]
  %8 = load ptr, ptr %7, align 8, !tbaa !39
  %9 = icmp eq ptr %8, null
  br i1 %9, label %27, label %10

10:                                               ; preds = %6
  %11 = getelementptr inbounds %struct.UpVal, ptr %8, i64 0, i32 3
  %12 = load ptr, ptr %11, align 8, !tbaa !57
  %13 = icmp ult ptr %12, %1
  br i1 %13, label %27, label %14

14:                                               ; preds = %10
  %15 = icmp eq ptr %12, %1
  br i1 %15, label %16, label %6, !llvm.loop !174

16:                                               ; preds = %14
  %.lcssa1 = phi ptr [ %8, %14 ]
  %17 = getelementptr inbounds %struct.GCheader, ptr %.lcssa1, i64 0, i32 2
  %18 = load i8, ptr %17, align 1, !tbaa !33
  %19 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 3
  %20 = load i8, ptr %19, align 8, !tbaa !175
  %21 = xor i8 %20, -1
  %22 = and i8 %18, 3
  %23 = and i8 %22, %21
  %24 = icmp eq i8 %23, 0
  br i1 %24, label %42, label %25

25:                                               ; preds = %16
  %26 = xor i8 %18, 3
  store i8 %26, ptr %17, align 1, !tbaa !33
  br label %42

27:                                               ; preds = %10, %6
  %.lcssa2 = phi ptr [ %7, %10 ], [ %7, %6 ]
  %28 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef null, i64 noundef 0, i64 noundef 40) #46
  %29 = getelementptr inbounds %struct.UpVal, ptr %28, i64 0, i32 1
  store i8 10, ptr %29, align 8, !tbaa !176
  %30 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 3
  %31 = load i8, ptr %30, align 8, !tbaa !175
  %32 = and i8 %31, 3
  %33 = getelementptr inbounds %struct.UpVal, ptr %28, i64 0, i32 2
  store i8 %32, ptr %33, align 1, !tbaa !177
  %34 = getelementptr inbounds %struct.UpVal, ptr %28, i64 0, i32 3
  store ptr %1, ptr %34, align 8, !tbaa !57
  %35 = load ptr, ptr %.lcssa2, align 8, !tbaa !39
  store ptr %35, ptr %28, align 8, !tbaa !178
  store ptr %28, ptr %.lcssa2, align 8, !tbaa !39
  %36 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 22
  %37 = getelementptr inbounds %struct.UpVal, ptr %28, i64 0, i32 4
  store ptr %36, ptr %37, align 8, !tbaa !33
  %38 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 22, i32 4, i32 0, i32 1
  %39 = load ptr, ptr %38, align 8, !tbaa !33
  %40 = getelementptr inbounds %struct.UpVal, ptr %28, i64 0, i32 4, i32 0, i32 1
  store ptr %39, ptr %40, align 8, !tbaa !33
  %41 = getelementptr inbounds %struct.UpVal, ptr %39, i64 0, i32 4
  store ptr %28, ptr %41, align 8, !tbaa !33
  store ptr %28, ptr %38, align 8, !tbaa !33
  br label %42

42:                                               ; preds = %27, %25, %16
  %43 = phi ptr [ %28, %27 ], [ %.lcssa1, %25 ], [ %.lcssa1, %16 ]
  ret ptr %43
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaF_freeupval(ptr noundef %0, ptr noundef %1) #1 {
  %3 = getelementptr inbounds %struct.UpVal, ptr %1, i64 0, i32 3
  %4 = load ptr, ptr %3, align 8, !tbaa !57
  %5 = getelementptr inbounds %struct.UpVal, ptr %1, i64 0, i32 4
  %6 = icmp eq ptr %4, %5
  br i1 %6, label %15, label %7

7:                                                ; preds = %2
  %8 = load ptr, ptr %5, align 8, !tbaa !33
  %9 = getelementptr inbounds %struct.UpVal, ptr %1, i64 0, i32 4, i32 0, i32 1
  %10 = load ptr, ptr %9, align 8, !tbaa !33
  %11 = getelementptr inbounds %struct.UpVal, ptr %10, i64 0, i32 4
  store ptr %8, ptr %11, align 8, !tbaa !33
  %12 = load ptr, ptr %9, align 8, !tbaa !33
  %13 = load ptr, ptr %5, align 8, !tbaa !33
  %14 = getelementptr inbounds %struct.UpVal, ptr %13, i64 0, i32 4, i32 0, i32 1
  store ptr %12, ptr %14, align 8, !tbaa !33
  br label %15

15:                                               ; preds = %7, %2
  %16 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef nonnull %1, i64 noundef 40, i64 noundef 0) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaF_close(ptr noundef %0, ptr noundef readnone %1) #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 24
  %4 = load ptr, ptr %3, align 8, !tbaa !179
  %5 = icmp eq ptr %4, null
  br i1 %5, label %41, label %6

6:                                                ; preds = %2
  %7 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %8 = load ptr, ptr %7, align 8, !tbaa !25
  %9 = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 3
  br label %10

10:                                               ; preds = %38, %6
  %11 = phi ptr [ %4, %6 ], [ %39, %38 ]
  %12 = getelementptr inbounds %struct.UpVal, ptr %11, i64 0, i32 3
  %13 = load ptr, ptr %12, align 8, !tbaa !57
  %14 = icmp ult ptr %13, %1
  br i1 %14, label %41, label %15

15:                                               ; preds = %10
  %16 = load ptr, ptr %11, align 8, !tbaa !178
  store ptr %16, ptr %3, align 8, !tbaa !179
  %17 = getelementptr inbounds %struct.GCheader, ptr %11, i64 0, i32 2
  %18 = load i8, ptr %17, align 1, !tbaa !33
  %19 = load i8, ptr %9, align 8, !tbaa !175
  %20 = xor i8 %19, -1
  %21 = and i8 %18, 3
  %22 = and i8 %21, %20
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %25, label %24

24:                                               ; preds = %15
  tail call void @luaF_freeupval(ptr noundef nonnull %0, ptr noundef nonnull %11) #47
  br label %38

25:                                               ; preds = %15
  %26 = getelementptr inbounds %struct.UpVal, ptr %11, i64 0, i32 4
  %27 = load ptr, ptr %26, align 8, !tbaa !33
  %28 = getelementptr inbounds %struct.UpVal, ptr %11, i64 0, i32 4, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8, !tbaa !33
  %30 = getelementptr inbounds %struct.UpVal, ptr %29, i64 0, i32 4
  store ptr %27, ptr %30, align 8, !tbaa !33
  %31 = load ptr, ptr %28, align 8, !tbaa !33
  %32 = load ptr, ptr %26, align 8, !tbaa !33
  %33 = getelementptr inbounds %struct.UpVal, ptr %32, i64 0, i32 4, i32 0, i32 1
  store ptr %31, ptr %33, align 8, !tbaa !33
  %34 = load ptr, ptr %12, align 8, !tbaa !57
  %35 = load i64, ptr %34, align 8
  store i64 %35, ptr %26, align 8
  %36 = getelementptr inbounds %struct.lua_TValue, ptr %34, i64 0, i32 1
  %37 = load i32, ptr %36, align 8, !tbaa !16
  store i32 %37, ptr %28, align 8, !tbaa !16
  store ptr %26, ptr %12, align 8, !tbaa !57
  tail call void @luaC_linkupval(ptr noundef nonnull %0, ptr noundef nonnull %11) #46
  br label %38

38:                                               ; preds = %25, %24
  %39 = load ptr, ptr %3, align 8, !tbaa !179
  %40 = icmp eq ptr %39, null
  br i1 %40, label %41, label %10, !llvm.loop !180

41:                                               ; preds = %38, %10, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaF_newproto(ptr noundef %0) #1 {
  %2 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef null, i64 noundef 0, i64 noundef 120) #46
  tail call void @luaC_link(ptr noundef %0, ptr noundef %2, i8 noundef zeroext 9) #46
  %3 = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 3
  %4 = getelementptr inbounds %struct.Proto, ptr %2, i64 0, i32 19
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(88) %3, i8 0, i64 88, i1 false)
  store i32 0, ptr %4, align 8
  ret ptr %2
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaF_freeproto(ptr noundef %0, ptr noundef %1) #1 {
  %3 = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 4
  %4 = load ptr, ptr %3, align 8, !tbaa !64
  %5 = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 12
  %6 = load i32, ptr %5, align 8, !tbaa !71
  %7 = sext i32 %6 to i64
  %8 = shl nsw i64 %7, 2
  %9 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %4, i64 noundef %8, i64 noundef 0) #46
  %10 = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 5
  %11 = load ptr, ptr %10, align 8, !tbaa !121
  %12 = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 14
  %13 = load i32, ptr %12, align 8, !tbaa !120
  %14 = sext i32 %13 to i64
  %15 = shl nsw i64 %14, 3
  %16 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %11, i64 noundef %15, i64 noundef 0) #46
  %17 = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 3
  %18 = load ptr, ptr %17, align 8, !tbaa !83
  %19 = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 11
  %20 = load i32, ptr %19, align 4, !tbaa !81
  %21 = sext i32 %20 to i64
  %22 = shl nsw i64 %21, 4
  %23 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %18, i64 noundef %22, i64 noundef 0) #46
  %24 = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 6
  %25 = load ptr, ptr %24, align 8, !tbaa !74
  %26 = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 13
  %27 = load i32, ptr %26, align 4, !tbaa !73
  %28 = sext i32 %27 to i64
  %29 = shl nsw i64 %28, 2
  %30 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %25, i64 noundef %29, i64 noundef 0) #46
  %31 = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 7
  %32 = load ptr, ptr %31, align 8, !tbaa !167
  %33 = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 15
  %34 = load i32, ptr %33, align 4, !tbaa !166
  %35 = sext i32 %34 to i64
  %36 = shl nsw i64 %35, 4
  %37 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %32, i64 noundef %36, i64 noundef 0) #46
  %38 = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 8
  %39 = load ptr, ptr %38, align 8, !tbaa !58
  %40 = getelementptr inbounds %struct.Proto, ptr %1, i64 0, i32 10
  %41 = load i32, ptr %40, align 8, !tbaa !55
  %42 = sext i32 %41 to i64
  %43 = shl nsw i64 %42, 3
  %44 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %39, i64 noundef %43, i64 noundef 0) #46
  %45 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %1, i64 noundef 120, i64 noundef 0) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaF_freeclosure(ptr noundef %0, ptr noundef %1) #1 {
  %3 = getelementptr inbounds %struct.CClosure, ptr %1, i64 0, i32 3
  %4 = load i8, ptr %3, align 2, !tbaa !33
  %5 = icmp eq i8 %4, 0
  %6 = getelementptr inbounds %struct.LClosure, ptr %1, i64 0, i32 4
  %7 = getelementptr inbounds %struct.CClosure, ptr %1, i64 0, i32 4
  %8 = select i1 %5, ptr %6, ptr %7
  %9 = select i1 %5, i64 3, i64 4
  %10 = load i8, ptr %8, align 1, !tbaa !33
  %11 = zext i8 %10 to i64
  %12 = shl nuw nsw i64 %11, %9
  %13 = add nuw nsw i64 %12, 40
  %14 = and i64 %13, 65528
  %15 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef nonnull %1, i64 noundef %14, i64 noundef 0) #46
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind optsize memory(read, inaccessiblemem: none) uwtable
define internal ptr @luaF_getlocalname(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2) #14 {
  %4 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 15
  %5 = load i32, ptr %4, align 4, !tbaa !166
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %32

7:                                                ; preds = %3
  %8 = getelementptr inbounds %struct.Proto, ptr %0, i64 0, i32 7
  %9 = load ptr, ptr %8, align 8, !tbaa !167
  %10 = zext i32 %5 to i64
  br label %11

11:                                               ; preds = %28, %7
  %12 = phi i64 [ 0, %7 ], [ %30, %28 ]
  %13 = phi i32 [ %1, %7 ], [ %29, %28 ]
  %14 = getelementptr inbounds %struct.stringtable, ptr %9, i64 %12, i32 1
  %15 = load i32, ptr %14, align 8, !tbaa !170
  %16 = icmp sgt i32 %15, %2
  br i1 %16, label %32, label %17

17:                                               ; preds = %11
  %18 = getelementptr inbounds %struct.stringtable, ptr %9, i64 %12, i32 2
  %19 = load i32, ptr %18, align 4, !tbaa !171
  %20 = icmp sgt i32 %19, %2
  br i1 %20, label %21, label %28

21:                                               ; preds = %17
  %22 = add nsw i32 %13, -1
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %24, label %28

24:                                               ; preds = %21
  %.lcssa = phi i64 [ %12, %21 ]
  %25 = getelementptr inbounds %struct.stringtable, ptr %9, i64 %.lcssa
  %26 = load ptr, ptr %25, align 8, !tbaa !168
  %27 = getelementptr inbounds %union.TString, ptr %26, i64 1
  br label %32

28:                                               ; preds = %21, %17
  %29 = phi i32 [ %22, %21 ], [ %13, %17 ]
  %30 = add nuw nsw i64 %12, 1
  %31 = icmp eq i64 %30, %10
  br i1 %31, label %32, label %11, !llvm.loop !181

32:                                               ; preds = %28, %24, %11, %3
  %33 = phi ptr [ %27, %24 ], [ null, %3 ], [ null, %11 ], [ null, %28 ]
  ret ptr %33
}

; Function Attrs: nounwind optsize uwtable
define internal i64 @luaC_separateudata(ptr nocapture noundef readonly %0, i32 noundef %1) #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %4 = load ptr, ptr %3, align 8, !tbaa !25
  %5 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 21
  %6 = load ptr, ptr %5, align 8, !tbaa !42
  %7 = load ptr, ptr %6, align 8, !tbaa !39
  %8 = icmp eq ptr %7, null
  br i1 %8, label %61, label %9

9:                                                ; preds = %2
  %10 = icmp ne i32 %1, 0
  %11 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 11
  br label %12

12:                                               ; preds = %56, %9
  %13 = phi ptr [ %7, %9 ], [ %59, %56 ]
  %14 = phi i64 [ 0, %9 ], [ %58, %56 ]
  %15 = phi ptr [ %6, %9 ], [ %57, %56 ]
  %16 = getelementptr inbounds %struct.GCheader, ptr %13, i64 0, i32 2
  %17 = load i8, ptr %16, align 1, !tbaa !33
  %18 = and i8 %17, 3
  %19 = icmp ne i8 %18, 0
  %20 = or i1 %10, %19
  %21 = and i8 %17, 8
  %22 = icmp eq i8 %21, 0
  %23 = and i1 %20, %22
  br i1 %23, label %24, label %56

24:                                               ; preds = %12
  %25 = getelementptr inbounds %struct.anon.1, ptr %13, i64 0, i32 3
  %26 = load ptr, ptr %25, align 8, !tbaa !33
  %27 = icmp eq ptr %26, null
  br i1 %27, label %40, label %28

28:                                               ; preds = %24
  %29 = getelementptr inbounds %struct.Table, ptr %26, i64 0, i32 3
  %30 = load i8, ptr %29, align 2, !tbaa !182
  %31 = and i8 %30, 4
  %32 = icmp eq i8 %31, 0
  br i1 %32, label %33, label %40

33:                                               ; preds = %28
  %34 = load ptr, ptr %3, align 8, !tbaa !25
  %35 = getelementptr inbounds %struct.global_State, ptr %34, i64 0, i32 24, i64 2
  %36 = load ptr, ptr %35, align 8, !tbaa !39
  %37 = tail call ptr @luaT_gettm(ptr noundef nonnull %26, i32 noundef 2, ptr noundef %36) #46
  %38 = icmp eq ptr %37, null
  %39 = load i8, ptr %16, align 1, !tbaa !33
  br i1 %38, label %40, label %43

40:                                               ; preds = %33, %28, %24
  %41 = phi i8 [ %17, %28 ], [ %17, %24 ], [ %39, %33 ]
  %42 = or i8 %41, 8
  store i8 %42, ptr %16, align 1, !tbaa !33
  br label %56

43:                                               ; preds = %33
  %44 = getelementptr inbounds %struct.anon.1, ptr %13, i64 0, i32 5
  %45 = load i64, ptr %44, align 8, !tbaa !33
  %46 = add i64 %14, 40
  %47 = add i64 %46, %45
  %48 = or i8 %39, 8
  store i8 %48, ptr %16, align 1, !tbaa !33
  %49 = load ptr, ptr %13, align 8, !tbaa !33
  store ptr %49, ptr %15, align 8, !tbaa !39
  %50 = load ptr, ptr %11, align 8, !tbaa !184
  %51 = icmp eq ptr %50, null
  br i1 %51, label %52, label %53

52:                                               ; preds = %43
  store ptr %13, ptr %13, align 8, !tbaa !33
  store ptr %13, ptr %11, align 8, !tbaa !184
  br label %56

53:                                               ; preds = %43
  %54 = load ptr, ptr %50, align 8, !tbaa !33
  store ptr %54, ptr %13, align 8, !tbaa !33
  %55 = load ptr, ptr %11, align 8, !tbaa !184
  store ptr %13, ptr %55, align 8, !tbaa !33
  store ptr %13, ptr %11, align 8, !tbaa !184
  br label %56

56:                                               ; preds = %53, %52, %40, %12
  %57 = phi ptr [ %13, %40 ], [ %15, %52 ], [ %15, %53 ], [ %13, %12 ]
  %58 = phi i64 [ %14, %40 ], [ %47, %52 ], [ %47, %53 ], [ %14, %12 ]
  %59 = load ptr, ptr %57, align 8, !tbaa !39
  %60 = icmp eq ptr %59, null
  br i1 %60, label %61, label %12, !llvm.loop !185

61:                                               ; preds = %56, %2
  %62 = phi i64 [ 0, %2 ], [ %58, %56 ]
  ret i64 %62
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaC_callGCTM(ptr noundef %0) #1 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %3 = load ptr, ptr %2, align 8, !tbaa !25
  %4 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 11
  %5 = load ptr, ptr %4, align 8, !tbaa !184
  %6 = icmp eq ptr %5, null
  br i1 %6, label %12, label %7

7:                                                ; preds = %7, %1
  tail call fastcc void @GCTM(ptr noundef nonnull %0) #47
  %8 = load ptr, ptr %2, align 8, !tbaa !25
  %9 = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 11
  %10 = load ptr, ptr %9, align 8, !tbaa !184
  %11 = icmp eq ptr %10, null
  br i1 %11, label %12, label %7, !llvm.loop !186

12:                                               ; preds = %7, %1
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @GCTM(ptr noundef %0) unnamed_addr #1 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %3 = load ptr, ptr %2, align 8, !tbaa !25
  %4 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 11
  %5 = load ptr, ptr %4, align 8, !tbaa !184
  %6 = load ptr, ptr %5, align 8, !tbaa !33
  %7 = icmp eq ptr %6, %5
  br i1 %7, label %8, label %9

8:                                                ; preds = %1
  store ptr null, ptr %4, align 8, !tbaa !184
  br label %11

9:                                                ; preds = %1
  %10 = load ptr, ptr %6, align 8, !tbaa !33
  store ptr %10, ptr %5, align 8, !tbaa !33
  br label %11

11:                                               ; preds = %9, %8
  %12 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 21
  %13 = load ptr, ptr %12, align 8, !tbaa !42
  %14 = load ptr, ptr %13, align 8, !tbaa !187
  store ptr %14, ptr %6, align 8, !tbaa !33
  %15 = load ptr, ptr %12, align 8, !tbaa !42
  store ptr %6, ptr %15, align 8, !tbaa !187
  %16 = getelementptr inbounds %struct.GCheader, ptr %6, i64 0, i32 2
  %17 = load i8, ptr %16, align 1, !tbaa !33
  %18 = and i8 %17, -8
  %19 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 3
  %20 = load i8, ptr %19, align 8, !tbaa !175
  %21 = and i8 %20, 3
  %22 = or i8 %21, %18
  store i8 %22, ptr %16, align 1, !tbaa !33
  %23 = getelementptr inbounds %struct.anon.1, ptr %6, i64 0, i32 3
  %24 = load ptr, ptr %23, align 8, !tbaa !33
  %25 = icmp eq ptr %24, null
  br i1 %25, label %56, label %26

26:                                               ; preds = %11
  %27 = getelementptr inbounds %struct.Table, ptr %24, i64 0, i32 3
  %28 = load i8, ptr %27, align 2, !tbaa !182
  %29 = and i8 %28, 4
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %31, label %56

31:                                               ; preds = %26
  %32 = load ptr, ptr %2, align 8, !tbaa !25
  %33 = getelementptr inbounds %struct.global_State, ptr %32, i64 0, i32 24, i64 2
  %34 = load ptr, ptr %33, align 8, !tbaa !39
  %35 = tail call ptr @luaT_gettm(ptr noundef nonnull %24, i32 noundef 2, ptr noundef %34) #46
  %36 = icmp eq ptr %35, null
  br i1 %36, label %56, label %37

37:                                               ; preds = %31
  %38 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 18
  %39 = load i8, ptr %38, align 1, !tbaa !130
  %40 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 13
  %41 = load i64, ptr %40, align 8, !tbaa !32
  store i8 0, ptr %38, align 1, !tbaa !130
  %42 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 14
  %43 = load i64, ptr %42, align 8, !tbaa !31
  %44 = shl i64 %43, 1
  store i64 %44, ptr %40, align 8, !tbaa !32
  %45 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %46 = load ptr, ptr %45, align 8, !tbaa !7
  %47 = load i64, ptr %35, align 8
  store i64 %47, ptr %46, align 8
  %48 = getelementptr inbounds %struct.lua_TValue, ptr %35, i64 0, i32 1
  %49 = load i32, ptr %48, align 8, !tbaa !16
  %50 = getelementptr inbounds %struct.lua_TValue, ptr %46, i64 0, i32 1
  store i32 %49, ptr %50, align 8, !tbaa !16
  %51 = load ptr, ptr %45, align 8, !tbaa !7
  %52 = getelementptr inbounds %struct.lua_TValue, ptr %51, i64 1
  store ptr %6, ptr %52, align 8, !tbaa !33
  %53 = getelementptr inbounds %struct.lua_TValue, ptr %51, i64 1, i32 1
  store i32 7, ptr %53, align 8, !tbaa !16
  %54 = load ptr, ptr %45, align 8, !tbaa !7
  %55 = getelementptr inbounds %struct.lua_TValue, ptr %54, i64 2
  store ptr %55, ptr %45, align 8, !tbaa !7
  tail call void @luaD_call(ptr noundef nonnull %0, ptr noundef %54, i32 noundef 0) #46
  store i8 %39, ptr %38, align 1, !tbaa !130
  store i64 %41, ptr %40, align 8, !tbaa !32
  br label %56

56:                                               ; preds = %37, %31, %26, %11
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaC_freeall(ptr noundef %0) #1 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %3 = load ptr, ptr %2, align 8, !tbaa !25
  %4 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 3
  store i8 67, ptr %4, align 8, !tbaa !175
  %5 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 6
  %6 = tail call fastcc ptr @sweeplist(ptr noundef %0, ptr noundef nonnull %5, i64 noundef -3) #47
  %7 = getelementptr inbounds %struct.stringtable, ptr %3, i64 0, i32 2
  %8 = load i32, ptr %7, align 4, !tbaa !188
  %9 = icmp sgt i32 %8, 0
  br i1 %9, label %10, label %19

10:                                               ; preds = %10, %1
  %11 = phi i64 [ %15, %10 ], [ 0, %1 ]
  %12 = load ptr, ptr %3, align 8, !tbaa !189
  %13 = getelementptr inbounds ptr, ptr %12, i64 %11
  %14 = tail call fastcc ptr @sweeplist(ptr noundef %0, ptr noundef %13, i64 noundef -3) #47
  %15 = add nuw nsw i64 %11, 1
  %16 = load i32, ptr %7, align 4, !tbaa !188
  %17 = sext i32 %16 to i64
  %18 = icmp slt i64 %15, %17
  br i1 %18, label %10, label %19, !llvm.loop !190

19:                                               ; preds = %10, %1
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @sweeplist(ptr noundef %0, ptr noundef %1, i64 noundef %2) unnamed_addr #1 {
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %5 = load ptr, ptr %4, align 8, !tbaa !25
  %6 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 3
  %7 = load i8, ptr %6, align 8, !tbaa !175
  %8 = xor i8 %7, 3
  %9 = load ptr, ptr %1, align 8, !tbaa !39
  %10 = icmp eq ptr %9, null
  br i1 %10, label %68, label %11

11:                                               ; preds = %3
  %12 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 6
  br label %13

13:                                               ; preds = %64, %11
  %14 = phi ptr [ %9, %11 ], [ %66, %64 ]
  %15 = phi ptr [ %1, %11 ], [ %65, %64 ]
  %16 = phi i64 [ %2, %11 ], [ %17, %64 ]
  %17 = add i64 %16, -1
  %18 = icmp eq i64 %16, 0
  br i1 %18, label %68, label %19

19:                                               ; preds = %13
  %20 = getelementptr inbounds %struct.GCheader, ptr %14, i64 0, i32 1
  %21 = load i8, ptr %20, align 8, !tbaa !33
  %22 = icmp eq i8 %21, 8
  br i1 %22, label %23, label %26

23:                                               ; preds = %19
  %24 = getelementptr inbounds %struct.lua_State, ptr %14, i64 0, i32 24
  %25 = tail call fastcc ptr @sweeplist(ptr noundef %0, ptr noundef nonnull %24, i64 noundef -3) #47
  br label %26

26:                                               ; preds = %23, %19
  %27 = getelementptr inbounds %struct.GCheader, ptr %14, i64 0, i32 2
  %28 = load i8, ptr %27, align 1, !tbaa !33
  %29 = xor i8 %28, 3
  %30 = and i8 %29, %8
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %37, label %32

32:                                               ; preds = %26
  %33 = and i8 %28, -8
  %34 = load i8, ptr %6, align 8, !tbaa !175
  %35 = and i8 %34, 3
  %36 = or i8 %35, %33
  store i8 %36, ptr %27, align 1, !tbaa !33
  br label %64

37:                                               ; preds = %26
  %38 = load ptr, ptr %14, align 8, !tbaa !33
  store ptr %38, ptr %15, align 8, !tbaa !39
  %39 = load ptr, ptr %12, align 8, !tbaa !191
  %40 = icmp eq ptr %14, %39
  br i1 %40, label %41, label %43

41:                                               ; preds = %37
  %42 = load ptr, ptr %14, align 8, !tbaa !33
  store ptr %42, ptr %12, align 8, !tbaa !191
  br label %43

43:                                               ; preds = %41, %37
  %44 = load i8, ptr %20, align 8, !tbaa !33
  switch i8 %44, label %64 [
    i8 9, label %45
    i8 6, label %46
    i8 10, label %47
    i8 5, label %48
    i8 8, label %49
    i8 4, label %50
    i8 7, label %59
  ]

45:                                               ; preds = %43
  tail call void @luaF_freeproto(ptr noundef %0, ptr noundef nonnull %14) #46
  br label %64

46:                                               ; preds = %43
  tail call void @luaF_freeclosure(ptr noundef %0, ptr noundef nonnull %14) #46
  br label %64

47:                                               ; preds = %43
  tail call void @luaF_freeupval(ptr noundef %0, ptr noundef nonnull %14) #46
  br label %64

48:                                               ; preds = %43
  tail call void @luaH_free(ptr noundef %0, ptr noundef nonnull %14) #46
  br label %64

49:                                               ; preds = %43
  tail call void @luaE_freethread(ptr noundef %0, ptr noundef nonnull %14) #46
  br label %64

50:                                               ; preds = %43
  %51 = load ptr, ptr %4, align 8, !tbaa !25
  %52 = getelementptr inbounds %struct.stringtable, ptr %51, i64 0, i32 1
  %53 = load i32, ptr %52, align 8, !tbaa !192
  %54 = add i32 %53, -1
  store i32 %54, ptr %52, align 8, !tbaa !192
  %55 = getelementptr inbounds %struct.anon.0, ptr %14, i64 0, i32 5
  %56 = load i64, ptr %55, align 8, !tbaa !33
  %57 = add i64 %56, 25
  %58 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef nonnull %14, i64 noundef %57, i64 noundef 0) #46
  br label %64

59:                                               ; preds = %43
  %60 = getelementptr inbounds %struct.anon.1, ptr %14, i64 0, i32 5
  %61 = load i64, ptr %60, align 8, !tbaa !33
  %62 = add i64 %61, 40
  %63 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef nonnull %14, i64 noundef %62, i64 noundef 0) #46
  br label %64

64:                                               ; preds = %59, %50, %49, %48, %47, %46, %45, %43, %32
  %65 = phi ptr [ %14, %32 ], [ %15, %43 ], [ %15, %45 ], [ %15, %46 ], [ %15, %47 ], [ %15, %48 ], [ %15, %49 ], [ %15, %50 ], [ %15, %59 ]
  %66 = load ptr, ptr %65, align 8, !tbaa !39
  %67 = icmp eq ptr %66, null
  br i1 %67, label %68, label %13, !llvm.loop !193

68:                                               ; preds = %64, %13, %3
  %69 = phi ptr [ %1, %3 ], [ %65, %64 ], [ %15, %13 ]
  ret ptr %69
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaC_step(ptr noundef %0) #1 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %3 = load ptr, ptr %2, align 8, !tbaa !25
  %4 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 18
  %5 = load i32, ptr %4, align 4, !tbaa !54
  %6 = mul i32 %5, 10
  %7 = zext i32 %6 to i64
  %8 = icmp eq i32 %6, 0
  %9 = select i1 %8, i64 9223372036854775806, i64 %7
  %10 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 14
  %11 = load i64, ptr %10, align 8, !tbaa !31
  %12 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 13
  %13 = load i64, ptr %12, align 8, !tbaa !32
  %14 = sub i64 %11, %13
  %15 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 16
  %16 = load i64, ptr %15, align 8, !tbaa !194
  %17 = add i64 %14, %16
  store i64 %17, ptr %15, align 8, !tbaa !194
  %18 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 4
  br label %19

19:                                               ; preds = %19, %1
  %20 = phi i64 [ %9, %1 ], [ %22, %19 ]
  %21 = tail call fastcc i64 @singlestep(ptr noundef %0) #47
  %22 = sub nsw i64 %20, %21
  %23 = load i8, ptr %18, align 1, !tbaa !51
  %24 = icmp ne i8 %23, 0
  %25 = icmp sgt i64 %22, 0
  %26 = select i1 %24, i1 %25, i1 false
  br i1 %26, label %19, label %27, !llvm.loop !195

27:                                               ; preds = %19
  %.lcssa = phi i1 [ %24, %19 ]
  br i1 %.lcssa, label %28, label %37

28:                                               ; preds = %27
  %29 = load i64, ptr %15, align 8, !tbaa !194
  %30 = icmp ult i64 %29, 1024
  br i1 %30, label %31, label %34

31:                                               ; preds = %28
  %32 = load i64, ptr %10, align 8, !tbaa !31
  %33 = add i64 %32, 1024
  br label %45

34:                                               ; preds = %28
  %35 = add i64 %29, -1024
  store i64 %35, ptr %15, align 8, !tbaa !194
  %36 = load i64, ptr %10, align 8, !tbaa !31
  br label %45

37:                                               ; preds = %27
  %38 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 15
  %39 = load i64, ptr %38, align 8, !tbaa !196
  %40 = udiv i64 %39, 100
  %41 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 17
  %42 = load i32, ptr %41, align 8, !tbaa !53
  %43 = sext i32 %42 to i64
  %44 = mul i64 %40, %43
  br label %45

45:                                               ; preds = %37, %34, %31
  %46 = phi i64 [ %33, %31 ], [ %36, %34 ], [ %44, %37 ]
  store i64 %46, ptr %12, align 8, !tbaa !32
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @singlestep(ptr noundef %0) unnamed_addr #1 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %3 = load ptr, ptr %2, align 8, !tbaa !25
  %4 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 4
  %5 = load i8, ptr %4, align 1, !tbaa !51
  switch i8 %5, label %257 [
    i8 0, label %6
    i8 1, label %7
    i8 2, label %188
    i8 3, label %209
    i8 4, label %245
  ]

6:                                                ; preds = %1
  tail call fastcc void @markroot(ptr noundef nonnull %0) #47
  br label %257

7:                                                ; preds = %1
  %8 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 8
  %9 = load ptr, ptr %8, align 8, !tbaa !197
  %10 = icmp eq ptr %9, null
  br i1 %10, label %13, label %11

11:                                               ; preds = %7
  %12 = tail call fastcc i64 @propagatemark(ptr noundef nonnull %3) #47, !range !198
  br label %257

13:                                               ; preds = %7
  %14 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 22
  %15 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 22, i32 4, i32 0, i32 1
  %16 = load ptr, ptr %15, align 8, !tbaa !33
  %17 = icmp eq ptr %16, %14
  br i1 %17, label %48, label %18

18:                                               ; preds = %37, %13
  %19 = phi ptr [ %39, %37 ], [ %16, %13 ]
  %20 = getelementptr inbounds %struct.GCheader, ptr %19, i64 0, i32 2
  %21 = load i8, ptr %20, align 1, !tbaa !33
  %22 = and i8 %21, 7
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %37

24:                                               ; preds = %18
  %25 = getelementptr inbounds %struct.UpVal, ptr %19, i64 0, i32 3
  %26 = load ptr, ptr %25, align 8, !tbaa !57
  %27 = getelementptr inbounds %struct.lua_TValue, ptr %26, i64 0, i32 1
  %28 = load i32, ptr %27, align 8, !tbaa !16
  %29 = icmp sgt i32 %28, 3
  br i1 %29, label %30, label %37

30:                                               ; preds = %24
  %31 = load ptr, ptr %26, align 8, !tbaa !33
  %32 = getelementptr inbounds %struct.GCheader, ptr %31, i64 0, i32 2
  %33 = load i8, ptr %32, align 1, !tbaa !33
  %34 = and i8 %33, 3
  %35 = icmp eq i8 %34, 0
  br i1 %35, label %37, label %36

36:                                               ; preds = %30
  tail call fastcc void @reallymarkobject(ptr noundef %3, ptr noundef nonnull %31) #47
  br label %37

37:                                               ; preds = %36, %30, %24, %18
  %38 = getelementptr inbounds %struct.UpVal, ptr %19, i64 0, i32 4, i32 0, i32 1
  %39 = load ptr, ptr %38, align 8, !tbaa !33
  %40 = icmp eq ptr %39, %14
  br i1 %40, label %41, label %18, !llvm.loop !199

41:                                               ; preds = %37
  %42 = load ptr, ptr %8, align 8, !tbaa !197
  %43 = icmp eq ptr %42, null
  br i1 %43, label %48, label %44

44:                                               ; preds = %44, %41
  %45 = tail call fastcc i64 @propagatemark(ptr noundef nonnull %3) #47, !range !198
  %46 = load ptr, ptr %8, align 8, !tbaa !197
  %47 = icmp eq ptr %46, null
  br i1 %47, label %48, label %44, !llvm.loop !200

48:                                               ; preds = %44, %41, %13
  %49 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 10
  %50 = load ptr, ptr %49, align 8, !tbaa !201
  store ptr %50, ptr %8, align 8, !tbaa !197
  store ptr null, ptr %49, align 8, !tbaa !201
  %51 = getelementptr inbounds %struct.GCheader, ptr %0, i64 0, i32 2
  %52 = load i8, ptr %51, align 1, !tbaa !33
  %53 = and i8 %52, 3
  %54 = icmp eq i8 %53, 0
  br i1 %54, label %56, label %55

55:                                               ; preds = %48
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %3, ptr noundef nonnull %0) #47
  br label %56

56:                                               ; preds = %55, %48
  tail call fastcc void @markmt(ptr noundef nonnull %3) #47
  %57 = load ptr, ptr %8, align 8, !tbaa !197
  %58 = icmp eq ptr %57, null
  br i1 %58, label %63, label %59

59:                                               ; preds = %59, %56
  %60 = tail call fastcc i64 @propagatemark(ptr noundef nonnull %3) #47, !range !198
  %61 = load ptr, ptr %8, align 8, !tbaa !197
  %62 = icmp eq ptr %61, null
  br i1 %62, label %63, label %59, !llvm.loop !200

63:                                               ; preds = %59, %56
  %64 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 9
  %65 = load ptr, ptr %64, align 8, !tbaa !202
  store ptr %65, ptr %8, align 8, !tbaa !197
  store ptr null, ptr %64, align 8, !tbaa !202
  %66 = icmp eq ptr %65, null
  br i1 %66, label %71, label %67

67:                                               ; preds = %67, %63
  %68 = tail call fastcc i64 @propagatemark(ptr noundef nonnull %3) #47, !range !198
  %69 = load ptr, ptr %8, align 8, !tbaa !197
  %70 = icmp eq ptr %69, null
  br i1 %70, label %71, label %67, !llvm.loop !200

71:                                               ; preds = %67, %63
  %72 = tail call i64 @luaC_separateudata(ptr noundef %0, i32 noundef 0) #47
  %73 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 11
  %74 = load ptr, ptr %73, align 8, !tbaa !184
  %75 = icmp eq ptr %74, null
  br i1 %75, label %89, label %76

76:                                               ; preds = %71
  %77 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 3
  br label %78

78:                                               ; preds = %78, %76
  %79 = phi ptr [ %80, %78 ], [ %74, %76 ]
  %80 = load ptr, ptr %79, align 8, !tbaa !33
  %81 = getelementptr inbounds %struct.GCheader, ptr %80, i64 0, i32 2
  %82 = load i8, ptr %81, align 1, !tbaa !33
  %83 = and i8 %82, -8
  %84 = load i8, ptr %77, align 8, !tbaa !175
  %85 = and i8 %84, 3
  %86 = or i8 %85, %83
  store i8 %86, ptr %81, align 1, !tbaa !33
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %3, ptr noundef %80) #47
  %87 = load ptr, ptr %73, align 8, !tbaa !184
  %88 = icmp eq ptr %80, %87
  br i1 %88, label %89, label %78, !llvm.loop !203

89:                                               ; preds = %78, %71
  %90 = load ptr, ptr %8, align 8, !tbaa !197
  %91 = icmp eq ptr %90, null
  br i1 %91, label %98, label %92

92:                                               ; preds = %92, %89
  %93 = phi i64 [ %95, %92 ], [ 0, %89 ]
  %94 = tail call fastcc i64 @propagatemark(ptr noundef nonnull %3) #47, !range !198
  %95 = add i64 %94, %93
  %96 = load ptr, ptr %8, align 8, !tbaa !197
  %97 = icmp eq ptr %96, null
  br i1 %97, label %98, label %92, !llvm.loop !200

98:                                               ; preds = %92, %89
  %99 = phi i64 [ 0, %89 ], [ %95, %92 ]
  %100 = load ptr, ptr %49, align 8, !tbaa !201
  %101 = icmp eq ptr %100, null
  br i1 %101, label %176, label %102

102:                                              ; preds = %172, %98
  %103 = phi ptr [ %174, %172 ], [ %100, %98 ]
  %104 = getelementptr inbounds %struct.Table, ptr %103, i64 0, i32 2
  %105 = load i8, ptr %104, align 1, !tbaa !204
  %106 = and i8 %105, 16
  %107 = icmp eq i8 %106, 0
  br i1 %107, label %127, label %108

108:                                              ; preds = %102
  %109 = getelementptr inbounds %struct.Table, ptr %103, i64 0, i32 10
  %110 = load i32, ptr %109, align 8, !tbaa !205
  %111 = icmp eq i32 %110, 0
  br i1 %111, label %127, label %112

112:                                              ; preds = %108
  %113 = getelementptr inbounds %struct.Table, ptr %103, i64 0, i32 6
  %114 = sext i32 %110 to i64
  br label %115

115:                                              ; preds = %124, %112
  %116 = phi i64 [ %114, %112 ], [ %117, %124 ]
  %117 = add nsw i64 %116, -1
  %118 = load ptr, ptr %113, align 8, !tbaa !206
  %119 = getelementptr inbounds %struct.lua_TValue, ptr %118, i64 %117
  %120 = tail call fastcc i32 @iscleared(ptr noundef %119, i32 noundef 0) #47, !range !75
  %121 = icmp eq i32 %120, 0
  br i1 %121, label %124, label %122

122:                                              ; preds = %115
  %123 = getelementptr inbounds %struct.lua_TValue, ptr %118, i64 %117, i32 1
  store i32 0, ptr %123, align 8, !tbaa !16
  br label %124

124:                                              ; preds = %122, %115
  %125 = and i64 %117, 4294967295
  %126 = icmp eq i64 %125, 0
  br i1 %126, label %127, label %115, !llvm.loop !207

127:                                              ; preds = %124, %108, %102
  %128 = getelementptr inbounds %struct.Table, ptr %103, i64 0, i32 4
  %129 = load i8, ptr %128, align 1, !tbaa !208
  %130 = zext i8 %129 to i32
  %131 = getelementptr inbounds %struct.Table, ptr %103, i64 0, i32 7
  %132 = shl nsw i32 -1, %130
  %133 = xor i32 %132, -1
  %134 = zext i32 %133 to i64
  br label %135

135:                                              ; preds = %169, %127
  %136 = phi i64 [ %134, %127 ], [ %170, %169 ]
  %137 = load ptr, ptr %131, align 8, !tbaa !209
  %138 = getelementptr inbounds %struct.Node, ptr %137, i64 %136
  %139 = getelementptr inbounds %struct.lua_TValue, ptr %138, i64 0, i32 1
  %140 = load i32, ptr %139, align 8, !tbaa !210
  %141 = icmp eq i32 %140, 0
  br i1 %141, label %169, label %142

142:                                              ; preds = %135
  %143 = getelementptr inbounds %struct.Node, ptr %137, i64 %136, i32 1
  %144 = getelementptr inbounds %struct.lua_TValue, ptr %143, i64 0, i32 1
  %145 = load i32, ptr %144, align 8, !tbaa !33
  %146 = icmp sgt i32 %145, 3
  br i1 %146, label %147, label %160

147:                                              ; preds = %142
  %148 = icmp eq i32 %145, 4
  %149 = load ptr, ptr %143, align 8, !tbaa !33
  br i1 %148, label %150, label %154

150:                                              ; preds = %147
  %151 = getelementptr inbounds %struct.anon.0, ptr %149, i64 0, i32 2
  %152 = load i8, ptr %151, align 1, !tbaa !33
  %153 = and i8 %152, -4
  store i8 %153, ptr %151, align 1, !tbaa !33
  br label %160

154:                                              ; preds = %147
  %155 = getelementptr inbounds %struct.GCheader, ptr %149, i64 0, i32 2
  %156 = load i8, ptr %155, align 1, !tbaa !33
  %157 = and i8 %156, 3
  %158 = icmp eq i8 %157, 0
  br i1 %158, label %160, label %159

159:                                              ; preds = %154
  store i32 0, ptr %139, align 8, !tbaa !210
  br label %167

160:                                              ; preds = %154, %150, %142
  %161 = tail call fastcc i32 @iscleared(ptr noundef nonnull %138, i32 noundef 0) #47, !range !75
  %162 = icmp eq i32 %161, 0
  br i1 %162, label %169, label %163

163:                                              ; preds = %160
  %164 = getelementptr inbounds %struct.Node, ptr %137, i64 %136, i32 1, i32 0, i32 1
  %165 = load i32, ptr %164, align 8, !tbaa !33
  store i32 0, ptr %139, align 8, !tbaa !210
  %166 = icmp sgt i32 %165, 3
  br i1 %166, label %167, label %169

167:                                              ; preds = %163, %159
  %168 = getelementptr inbounds %struct.Node, ptr %137, i64 %136, i32 1, i32 0, i32 1
  store i32 11, ptr %168, align 8, !tbaa !33
  br label %169

169:                                              ; preds = %167, %163, %160, %135
  %170 = add nsw i64 %136, -1
  %171 = icmp eq i64 %136, 0
  br i1 %171, label %172, label %135, !llvm.loop !212

172:                                              ; preds = %169
  %173 = getelementptr inbounds %struct.Table, ptr %103, i64 0, i32 9
  %174 = load ptr, ptr %173, align 8, !tbaa !213
  %175 = icmp eq ptr %174, null
  br i1 %175, label %176, label %102, !llvm.loop !214

176:                                              ; preds = %172, %98
  %177 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 3
  %178 = load i8, ptr %177, align 8, !tbaa !175
  %179 = xor i8 %178, 3
  store i8 %179, ptr %177, align 8, !tbaa !175
  %180 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 5
  store i32 0, ptr %180, align 4, !tbaa !215
  %181 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 6
  %182 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 7
  store ptr %181, ptr %182, align 8, !tbaa !216
  store i8 2, ptr %4, align 1, !tbaa !51
  %183 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 14
  %184 = load i64, ptr %183, align 8, !tbaa !31
  %185 = add i64 %99, %72
  %186 = sub i64 %184, %185
  %187 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 15
  store i64 %186, ptr %187, align 8, !tbaa !196
  br label %257

188:                                              ; preds = %1
  %189 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 14
  %190 = load i64, ptr %189, align 8, !tbaa !31
  %191 = load ptr, ptr %3, align 8, !tbaa !189
  %192 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 5
  %193 = load i32, ptr %192, align 4, !tbaa !215
  %194 = add nsw i32 %193, 1
  store i32 %194, ptr %192, align 4, !tbaa !215
  %195 = sext i32 %193 to i64
  %196 = getelementptr inbounds ptr, ptr %191, i64 %195
  %197 = tail call fastcc ptr @sweeplist(ptr noundef nonnull %0, ptr noundef %196, i64 noundef -3) #47
  %198 = load i32, ptr %192, align 4, !tbaa !215
  %199 = getelementptr inbounds %struct.stringtable, ptr %3, i64 0, i32 2
  %200 = load i32, ptr %199, align 4, !tbaa !188
  %201 = icmp slt i32 %198, %200
  br i1 %201, label %203, label %202

202:                                              ; preds = %188
  store i8 3, ptr %4, align 1, !tbaa !51
  br label %203

203:                                              ; preds = %202, %188
  %204 = load i64, ptr %189, align 8, !tbaa !31
  %205 = sub i64 %204, %190
  %206 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 15
  %207 = load i64, ptr %206, align 8, !tbaa !196
  %208 = add i64 %205, %207
  store i64 %208, ptr %206, align 8, !tbaa !196
  br label %257

209:                                              ; preds = %1
  %210 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 14
  %211 = load i64, ptr %210, align 8, !tbaa !31
  %212 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 7
  %213 = load ptr, ptr %212, align 8, !tbaa !216
  %214 = tail call fastcc ptr @sweeplist(ptr noundef nonnull %0, ptr noundef %213, i64 noundef 40) #47
  store ptr %214, ptr %212, align 8, !tbaa !216
  %215 = load ptr, ptr %214, align 8, !tbaa !39
  %216 = icmp eq ptr %215, null
  br i1 %216, label %217, label %239

217:                                              ; preds = %209
  %218 = load ptr, ptr %2, align 8, !tbaa !25
  %219 = getelementptr inbounds %struct.stringtable, ptr %218, i64 0, i32 1
  %220 = load i32, ptr %219, align 8, !tbaa !192
  %221 = getelementptr inbounds %struct.stringtable, ptr %218, i64 0, i32 2
  %222 = load i32, ptr %221, align 4, !tbaa !188
  %223 = sdiv i32 %222, 4
  %224 = icmp ult i32 %220, %223
  %225 = icmp sgt i32 %222, 64
  %226 = and i1 %225, %224
  br i1 %226, label %227, label %229

227:                                              ; preds = %217
  %228 = lshr i32 %222, 1
  tail call void @luaS_resize(ptr noundef nonnull %0, i32 noundef %228) #46
  br label %229

229:                                              ; preds = %227, %217
  %230 = getelementptr inbounds %struct.global_State, ptr %218, i64 0, i32 12, i32 2
  %231 = load i64, ptr %230, align 8, !tbaa !217
  %232 = icmp ugt i64 %231, 64
  br i1 %232, label %233, label %238

233:                                              ; preds = %229
  %234 = getelementptr inbounds %struct.global_State, ptr %218, i64 0, i32 12
  %235 = lshr i64 %231, 1
  %236 = load ptr, ptr %234, align 8, !tbaa !218
  %237 = tail call ptr @luaM_realloc_(ptr noundef nonnull %0, ptr noundef %236, i64 noundef %231, i64 noundef %235) #46
  store ptr %237, ptr %234, align 8, !tbaa !218
  store i64 %235, ptr %230, align 8, !tbaa !217
  br label %238

238:                                              ; preds = %233, %229
  store i8 4, ptr %4, align 1, !tbaa !51
  br label %239

239:                                              ; preds = %238, %209
  %240 = load i64, ptr %210, align 8, !tbaa !31
  %241 = sub i64 %240, %211
  %242 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 15
  %243 = load i64, ptr %242, align 8, !tbaa !196
  %244 = add i64 %241, %243
  store i64 %244, ptr %242, align 8, !tbaa !196
  br label %257

245:                                              ; preds = %1
  %246 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 11
  %247 = load ptr, ptr %246, align 8, !tbaa !184
  %248 = icmp eq ptr %247, null
  br i1 %248, label %255, label %249

249:                                              ; preds = %245
  tail call fastcc void @GCTM(ptr noundef nonnull %0) #47
  %250 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 15
  %251 = load i64, ptr %250, align 8, !tbaa !196
  %252 = icmp ugt i64 %251, 100
  br i1 %252, label %253, label %257

253:                                              ; preds = %249
  %254 = add i64 %251, -100
  store i64 %254, ptr %250, align 8, !tbaa !196
  br label %257

255:                                              ; preds = %245
  store i8 0, ptr %4, align 1, !tbaa !51
  %256 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 16
  store i64 0, ptr %256, align 8, !tbaa !194
  br label %257

257:                                              ; preds = %255, %253, %249, %239, %203, %176, %11, %6, %1
  %258 = phi i64 [ 0, %255 ], [ 400, %239 ], [ 10, %203 ], [ %12, %11 ], [ 0, %176 ], [ 0, %6 ], [ 100, %253 ], [ 100, %249 ], [ 0, %1 ]
  ret i64 %258
}

; Function Attrs: nofree nosync nounwind optsize memory(readwrite, inaccessiblemem: none) uwtable
define internal fastcc void @markroot(ptr nocapture noundef readonly %0) unnamed_addr #24 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %3 = load ptr, ptr %2, align 8, !tbaa !25
  %4 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 8
  %5 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 21
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %4, i8 0, i64 24, i1 false)
  %6 = load ptr, ptr %5, align 8, !tbaa !42
  %7 = getelementptr inbounds %struct.GCheader, ptr %6, i64 0, i32 2
  %8 = load i8, ptr %7, align 1, !tbaa !33
  %9 = and i8 %8, 3
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %13, label %11

11:                                               ; preds = %1
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %3, ptr noundef nonnull %6) #47
  %12 = load ptr, ptr %5, align 8, !tbaa !42
  br label %13

13:                                               ; preds = %11, %1
  %14 = phi ptr [ %12, %11 ], [ %6, %1 ]
  %15 = getelementptr inbounds %struct.lua_State, ptr %14, i64 0, i32 22, i32 1
  %16 = load i32, ptr %15, align 8, !tbaa !219
  %17 = icmp sgt i32 %16, 3
  br i1 %17, label %18, label %26

18:                                               ; preds = %13
  %19 = getelementptr inbounds %struct.lua_State, ptr %14, i64 0, i32 22
  %20 = load ptr, ptr %19, align 8, !tbaa !33
  %21 = getelementptr inbounds %struct.GCheader, ptr %20, i64 0, i32 2
  %22 = load i8, ptr %21, align 1, !tbaa !33
  %23 = and i8 %22, 3
  %24 = icmp eq i8 %23, 0
  br i1 %24, label %26, label %25

25:                                               ; preds = %18
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %3, ptr noundef nonnull %20) #47
  br label %26

26:                                               ; preds = %25, %18, %13
  %27 = load ptr, ptr %2, align 8, !tbaa !25
  %28 = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 20, i32 1
  %29 = load i32, ptr %28, align 8, !tbaa !220
  %30 = icmp sgt i32 %29, 3
  br i1 %30, label %31, label %39

31:                                               ; preds = %26
  %32 = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 20
  %33 = load ptr, ptr %32, align 8, !tbaa !33
  %34 = getelementptr inbounds %struct.GCheader, ptr %33, i64 0, i32 2
  %35 = load i8, ptr %34, align 1, !tbaa !33
  %36 = and i8 %35, 3
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %39, label %38

38:                                               ; preds = %31
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %3, ptr noundef nonnull %33) #47
  br label %39

39:                                               ; preds = %38, %31, %26
  tail call fastcc void @markmt(ptr noundef nonnull %3) #47
  %40 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 4
  store i8 1, ptr %40, align 1, !tbaa !51
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @propagatemark(ptr noundef %0) unnamed_addr #1 {
  %2 = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 8
  %3 = load ptr, ptr %2, align 8, !tbaa !197
  %4 = getelementptr inbounds %struct.GCheader, ptr %3, i64 0, i32 2
  %5 = load i8, ptr %4, align 1, !tbaa !33
  %6 = or i8 %5, 4
  store i8 %6, ptr %4, align 1, !tbaa !33
  %7 = getelementptr inbounds %struct.GCheader, ptr %3, i64 0, i32 1
  %8 = load i8, ptr %7, align 8, !tbaa !33
  switch i8 %8, label %470 [
    i8 5, label %9
    i8 6, label %150
    i8 8, label %225
    i8 9, label %334
  ]

9:                                                ; preds = %1
  %10 = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 9
  %11 = load ptr, ptr %10, align 8, !tbaa !213
  store ptr %11, ptr %2, align 8, !tbaa !197
  %12 = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 5
  %13 = load ptr, ptr %12, align 8, !tbaa !221
  %14 = icmp eq ptr %13, null
  br i1 %14, label %57, label %15

15:                                               ; preds = %9
  %16 = getelementptr inbounds %struct.GCheader, ptr %13, i64 0, i32 2
  %17 = load i8, ptr %16, align 1, !tbaa !33
  %18 = and i8 %17, 3
  %19 = icmp eq i8 %18, 0
  br i1 %19, label %23, label %20

20:                                               ; preds = %15
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %0, ptr noundef nonnull %13) #47
  %21 = load ptr, ptr %12, align 8, !tbaa !221
  %22 = icmp eq ptr %21, null
  br i1 %22, label %57, label %23

23:                                               ; preds = %20, %15
  %24 = phi ptr [ %21, %20 ], [ %13, %15 ]
  %25 = getelementptr inbounds %struct.Table, ptr %24, i64 0, i32 3
  %26 = load i8, ptr %25, align 2, !tbaa !182
  %27 = and i8 %26, 8
  %28 = icmp eq i8 %27, 0
  br i1 %28, label %29, label %57

29:                                               ; preds = %23
  %30 = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 24, i64 3
  %31 = load ptr, ptr %30, align 8, !tbaa !39
  %32 = tail call ptr @luaT_gettm(ptr noundef nonnull %24, i32 noundef 3, ptr noundef %31) #46
  %33 = icmp eq ptr %32, null
  br i1 %33, label %57, label %34

34:                                               ; preds = %29
  %35 = getelementptr inbounds %struct.lua_TValue, ptr %32, i64 0, i32 1
  %36 = load i32, ptr %35, align 8, !tbaa !16
  %37 = icmp eq i32 %36, 4
  br i1 %37, label %38, label %57

38:                                               ; preds = %34
  %39 = load ptr, ptr %32, align 8, !tbaa !33
  %40 = getelementptr inbounds %union.TString, ptr %39, i64 1
  %41 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %40, i32 noundef 107) #49
  %42 = icmp ne ptr %41, null
  %43 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %40, i32 noundef 118) #49
  %44 = icmp ne ptr %43, null
  %45 = select i1 %42, i1 true, i1 %44
  br i1 %45, label %46, label %57

46:                                               ; preds = %38
  %47 = load i8, ptr %4, align 1, !tbaa !204
  %48 = and i8 %47, -25
  %49 = select i1 %42, i8 8, i8 0
  %50 = select i1 %44, i8 16, i8 0
  %51 = or i8 %50, %49
  %52 = or i8 %51, %48
  store i8 %52, ptr %4, align 1, !tbaa !204
  %53 = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 10
  %54 = load ptr, ptr %53, align 8, !tbaa !201
  store ptr %54, ptr %10, align 8, !tbaa !213
  store ptr %3, ptr %53, align 8, !tbaa !201
  %55 = select i1 %42, i1 %44, i1 false
  br i1 %55, label %134, label %56

56:                                               ; preds = %46
  br i1 %44, label %83, label %57

57:                                               ; preds = %56, %38, %34, %29, %23, %20, %9
  %58 = phi i1 [ %42, %56 ], [ false, %9 ], [ false, %23 ], [ false, %20 ], [ false, %29 ], [ false, %34 ], [ false, %38 ]
  %59 = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 10
  %60 = load i32, ptr %59, align 8, !tbaa !205
  %61 = icmp eq i32 %60, 0
  br i1 %61, label %83, label %62

62:                                               ; preds = %57
  %63 = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 6
  %64 = sext i32 %60 to i64
  br label %65

65:                                               ; preds = %80, %62
  %66 = phi i64 [ %64, %62 ], [ %67, %80 ]
  %67 = add nsw i64 %66, -1
  %68 = load ptr, ptr %63, align 8, !tbaa !206
  %69 = getelementptr inbounds %struct.lua_TValue, ptr %68, i64 %67, i32 1
  %70 = load i32, ptr %69, align 8, !tbaa !16
  %71 = icmp sgt i32 %70, 3
  br i1 %71, label %72, label %80

72:                                               ; preds = %65
  %73 = getelementptr inbounds %struct.lua_TValue, ptr %68, i64 %67
  %74 = load ptr, ptr %73, align 8, !tbaa !33
  %75 = getelementptr inbounds %struct.GCheader, ptr %74, i64 0, i32 2
  %76 = load i8, ptr %75, align 1, !tbaa !33
  %77 = and i8 %76, 3
  %78 = icmp eq i8 %77, 0
  br i1 %78, label %80, label %79

79:                                               ; preds = %72
  tail call fastcc void @reallymarkobject(ptr noundef %0, ptr noundef nonnull %74) #47
  br label %80

80:                                               ; preds = %79, %72, %65
  %81 = and i64 %67, 4294967295
  %82 = icmp eq i64 %81, 0
  br i1 %82, label %83, label %65, !llvm.loop !222

83:                                               ; preds = %80, %57, %56
  %84 = phi i1 [ %42, %56 ], [ %58, %57 ], [ %58, %80 ]
  %85 = phi i1 [ true, %56 ], [ false, %57 ], [ false, %80 ]
  %86 = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 4
  %87 = load i8, ptr %86, align 1, !tbaa !208
  %88 = zext i8 %87 to i32
  %89 = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 7
  %90 = shl nsw i32 -1, %88
  %91 = xor i32 %90, -1
  %92 = zext i32 %91 to i64
  br label %93

93:                                               ; preds = %129, %83
  %94 = phi i64 [ %92, %83 ], [ %130, %129 ]
  %95 = load ptr, ptr %89, align 8, !tbaa !209
  %96 = getelementptr inbounds %struct.Node, ptr %95, i64 %94
  %97 = getelementptr inbounds %struct.lua_TValue, ptr %96, i64 0, i32 1
  %98 = load i32, ptr %97, align 8, !tbaa !210
  %99 = icmp eq i32 %98, 0
  br i1 %99, label %100, label %105

100:                                              ; preds = %93
  %101 = getelementptr inbounds %struct.Node, ptr %95, i64 %94, i32 1, i32 0, i32 1
  %102 = load i32, ptr %101, align 8, !tbaa !33
  %103 = icmp sgt i32 %102, 3
  br i1 %103, label %104, label %129

104:                                              ; preds = %100
  store i32 11, ptr %101, align 8, !tbaa !33
  br label %129

105:                                              ; preds = %93
  br i1 %84, label %118, label %106

106:                                              ; preds = %105
  %107 = getelementptr inbounds %struct.Node, ptr %95, i64 %94, i32 1
  %108 = getelementptr inbounds %struct.anon.2, ptr %107, i64 0, i32 1
  %109 = load i32, ptr %108, align 8, !tbaa !33
  %110 = icmp sgt i32 %109, 3
  br i1 %110, label %111, label %118

111:                                              ; preds = %106
  %112 = load ptr, ptr %107, align 8, !tbaa !33
  %113 = getelementptr inbounds %struct.GCheader, ptr %112, i64 0, i32 2
  %114 = load i8, ptr %113, align 1, !tbaa !33
  %115 = and i8 %114, 3
  %116 = icmp eq i8 %115, 0
  br i1 %116, label %118, label %117

117:                                              ; preds = %111
  tail call fastcc void @reallymarkobject(ptr noundef %0, ptr noundef nonnull %112) #47
  br label %118

118:                                              ; preds = %117, %111, %106, %105
  br i1 %85, label %129, label %119

119:                                              ; preds = %118
  %120 = load i32, ptr %97, align 8, !tbaa !210
  %121 = icmp sgt i32 %120, 3
  br i1 %121, label %122, label %129

122:                                              ; preds = %119
  %123 = load ptr, ptr %96, align 8, !tbaa !33
  %124 = getelementptr inbounds %struct.GCheader, ptr %123, i64 0, i32 2
  %125 = load i8, ptr %124, align 1, !tbaa !33
  %126 = and i8 %125, 3
  %127 = icmp eq i8 %126, 0
  br i1 %127, label %129, label %128

128:                                              ; preds = %122
  tail call fastcc void @reallymarkobject(ptr noundef %0, ptr noundef nonnull %123) #47
  br label %129

129:                                              ; preds = %128, %122, %119, %118, %104, %100
  %130 = add nsw i64 %94, -1
  %131 = icmp eq i64 %94, 0
  br i1 %131, label %132, label %93, !llvm.loop !223

132:                                              ; preds = %129
  %133 = or i1 %84, %85
  br i1 %133, label %134, label %137

134:                                              ; preds = %132, %46
  %135 = load i8, ptr %4, align 1, !tbaa !33
  %136 = and i8 %135, -5
  store i8 %136, ptr %4, align 1, !tbaa !33
  br label %137

137:                                              ; preds = %134, %132
  %138 = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 10
  %139 = load i32, ptr %138, align 8, !tbaa !205
  %140 = sext i32 %139 to i64
  %141 = shl nsw i64 %140, 4
  %142 = add nsw i64 %141, 64
  %143 = getelementptr inbounds %struct.Table, ptr %3, i64 0, i32 4
  %144 = load i8, ptr %143, align 1, !tbaa !208
  %145 = zext i8 %144 to i32
  %146 = shl nuw i32 1, %145
  %147 = sext i32 %146 to i64
  %148 = mul nsw i64 %147, 40
  %149 = add nsw i64 %142, %148
  br label %470

150:                                              ; preds = %1
  %151 = getelementptr inbounds %struct.CClosure, ptr %3, i64 0, i32 5
  %152 = load ptr, ptr %151, align 8, !tbaa !33
  store ptr %152, ptr %2, align 8, !tbaa !197
  %153 = getelementptr inbounds %struct.CClosure, ptr %3, i64 0, i32 6
  %154 = load ptr, ptr %153, align 8, !tbaa !33
  %155 = getelementptr inbounds %struct.GCheader, ptr %154, i64 0, i32 2
  %156 = load i8, ptr %155, align 1, !tbaa !33
  %157 = and i8 %156, 3
  %158 = icmp eq i8 %157, 0
  br i1 %158, label %160, label %159

159:                                              ; preds = %150
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %0, ptr noundef nonnull %154) #47
  br label %160

160:                                              ; preds = %159, %150
  %161 = getelementptr inbounds %struct.CClosure, ptr %3, i64 0, i32 3
  %162 = load i8, ptr %161, align 2, !tbaa !33
  %163 = icmp eq i8 %162, 0
  br i1 %163, label %188, label %164

164:                                              ; preds = %160
  %165 = getelementptr inbounds %struct.CClosure, ptr %3, i64 0, i32 4
  %166 = load i8, ptr %165, align 1, !tbaa !33
  %167 = icmp eq i8 %166, 0
  br i1 %167, label %216, label %168

168:                                              ; preds = %183, %164
  %169 = phi i8 [ %184, %183 ], [ %166, %164 ]
  %170 = phi i64 [ %185, %183 ], [ 0, %164 ]
  %171 = getelementptr inbounds %struct.CClosure, ptr %3, i64 0, i32 8, i64 %170, i32 1
  %172 = load i32, ptr %171, align 8, !tbaa !33
  %173 = icmp sgt i32 %172, 3
  br i1 %173, label %174, label %183

174:                                              ; preds = %168
  %175 = getelementptr inbounds %struct.CClosure, ptr %3, i64 0, i32 8, i64 %170
  %176 = load ptr, ptr %175, align 8, !tbaa !33
  %177 = getelementptr inbounds %struct.GCheader, ptr %176, i64 0, i32 2
  %178 = load i8, ptr %177, align 1, !tbaa !33
  %179 = and i8 %178, 3
  %180 = icmp eq i8 %179, 0
  br i1 %180, label %183, label %181

181:                                              ; preds = %174
  tail call fastcc void @reallymarkobject(ptr noundef %0, ptr noundef nonnull %176) #47
  %182 = load i8, ptr %165, align 1, !tbaa !33
  br label %183

183:                                              ; preds = %181, %174, %168
  %184 = phi i8 [ %169, %168 ], [ %169, %174 ], [ %182, %181 ]
  %185 = add nuw nsw i64 %170, 1
  %186 = zext i8 %184 to i64
  %187 = icmp ult i64 %185, %186
  br i1 %187, label %168, label %216, !llvm.loop !224

188:                                              ; preds = %160
  %189 = getelementptr inbounds %struct.LClosure, ptr %3, i64 0, i32 7
  %190 = load ptr, ptr %189, align 8, !tbaa !33
  %191 = getelementptr inbounds %struct.GCheader, ptr %190, i64 0, i32 2
  %192 = load i8, ptr %191, align 1, !tbaa !33
  %193 = and i8 %192, 3
  %194 = icmp eq i8 %193, 0
  br i1 %194, label %196, label %195

195:                                              ; preds = %188
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %0, ptr noundef nonnull %190) #47
  br label %196

196:                                              ; preds = %195, %188
  %197 = getelementptr inbounds %struct.LClosure, ptr %3, i64 0, i32 4
  %198 = load i8, ptr %197, align 1, !tbaa !33
  %199 = icmp eq i8 %198, 0
  br i1 %199, label %216, label %200

200:                                              ; preds = %211, %196
  %201 = phi i8 [ %212, %211 ], [ %198, %196 ]
  %202 = phi i64 [ %213, %211 ], [ 0, %196 ]
  %203 = getelementptr inbounds %struct.LClosure, ptr %3, i64 0, i32 8, i64 %202
  %204 = load ptr, ptr %203, align 8, !tbaa !33
  %205 = getelementptr inbounds %struct.GCheader, ptr %204, i64 0, i32 2
  %206 = load i8, ptr %205, align 1, !tbaa !33
  %207 = and i8 %206, 3
  %208 = icmp eq i8 %207, 0
  br i1 %208, label %211, label %209

209:                                              ; preds = %200
  tail call fastcc void @reallymarkobject(ptr noundef %0, ptr noundef nonnull %204) #47
  %210 = load i8, ptr %197, align 1, !tbaa !33
  br label %211

211:                                              ; preds = %209, %200
  %212 = phi i8 [ %201, %200 ], [ %210, %209 ]
  %213 = add nuw nsw i64 %202, 1
  %214 = zext i8 %212 to i64
  %215 = icmp ult i64 %213, %214
  br i1 %215, label %200, label %216, !llvm.loop !225

216:                                              ; preds = %211, %196, %183, %164
  %217 = phi i8 [ 0, %164 ], [ 0, %196 ], [ %212, %211 ], [ %184, %183 ]
  %218 = load i8, ptr %161, align 2, !tbaa !33
  %219 = icmp eq i8 %218, 0
  %220 = zext i8 %217 to i64
  %221 = select i1 %219, i64 3, i64 4
  %222 = shl nuw nsw i64 %220, %221
  %223 = add nuw nsw i64 %222, 40
  %224 = and i64 %223, 65528
  br label %470

225:                                              ; preds = %1
  %226 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 25
  %227 = load ptr, ptr %226, align 8, !tbaa !226
  store ptr %227, ptr %2, align 8, !tbaa !197
  %228 = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 9
  %229 = load ptr, ptr %228, align 8, !tbaa !202
  store ptr %229, ptr %226, align 8, !tbaa !226
  store ptr %3, ptr %228, align 8, !tbaa !202
  %230 = load i8, ptr %4, align 1, !tbaa !33
  %231 = and i8 %230, -5
  store i8 %231, ptr %4, align 1, !tbaa !33
  %232 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 22, i32 1
  %233 = load i32, ptr %232, align 8, !tbaa !219
  %234 = icmp sgt i32 %233, 3
  br i1 %234, label %235, label %243

235:                                              ; preds = %225
  %236 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 22
  %237 = load ptr, ptr %236, align 8, !tbaa !33
  %238 = getelementptr inbounds %struct.GCheader, ptr %237, i64 0, i32 2
  %239 = load i8, ptr %238, align 1, !tbaa !33
  %240 = and i8 %239, 3
  %241 = icmp eq i8 %240, 0
  br i1 %241, label %243, label %242

242:                                              ; preds = %235
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %0, ptr noundef nonnull %237) #47
  br label %243

243:                                              ; preds = %242, %235, %225
  %244 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 4
  %245 = load ptr, ptr %244, align 8, !tbaa !7
  %246 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 12
  %247 = load ptr, ptr %246, align 8, !tbaa !38
  %248 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 7
  %249 = load ptr, ptr %248, align 8, !tbaa !19
  %250 = icmp ugt ptr %247, %249
  br i1 %250, label %260, label %251

251:                                              ; preds = %251, %243
  %252 = phi ptr [ %258, %251 ], [ %247, %243 ]
  %253 = phi ptr [ %257, %251 ], [ %245, %243 ]
  %254 = getelementptr inbounds %struct.CallInfo, ptr %252, i64 0, i32 2
  %255 = load ptr, ptr %254, align 8, !tbaa !20
  %256 = icmp ult ptr %253, %255
  %257 = select i1 %256, ptr %255, ptr %253
  %258 = getelementptr inbounds %struct.CallInfo, ptr %252, i64 1
  %259 = icmp ugt ptr %258, %249
  br i1 %259, label %260, label %251, !llvm.loop !227

260:                                              ; preds = %251, %243
  %261 = phi ptr [ %245, %243 ], [ %257, %251 ]
  %262 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 10
  %263 = load ptr, ptr %262, align 8, !tbaa !43
  %264 = icmp ult ptr %263, %245
  br i1 %264, label %268, label %265

265:                                              ; preds = %282, %260
  %266 = phi ptr [ %263, %260 ], [ %284, %282 ]
  %267 = icmp ugt ptr %266, %261
  br i1 %267, label %291, label %286

268:                                              ; preds = %282, %260
  %269 = phi ptr [ %283, %282 ], [ %245, %260 ]
  %270 = phi ptr [ %284, %282 ], [ %263, %260 ]
  %271 = getelementptr inbounds %struct.lua_TValue, ptr %270, i64 0, i32 1
  %272 = load i32, ptr %271, align 8, !tbaa !16
  %273 = icmp sgt i32 %272, 3
  br i1 %273, label %274, label %282

274:                                              ; preds = %268
  %275 = load ptr, ptr %270, align 8, !tbaa !33
  %276 = getelementptr inbounds %struct.GCheader, ptr %275, i64 0, i32 2
  %277 = load i8, ptr %276, align 1, !tbaa !33
  %278 = and i8 %277, 3
  %279 = icmp eq i8 %278, 0
  br i1 %279, label %282, label %280

280:                                              ; preds = %274
  tail call fastcc void @reallymarkobject(ptr noundef %0, ptr noundef nonnull %275) #47
  %281 = load ptr, ptr %244, align 8, !tbaa !7
  br label %282

282:                                              ; preds = %280, %274, %268
  %283 = phi ptr [ %269, %268 ], [ %269, %274 ], [ %281, %280 ]
  %284 = getelementptr inbounds %struct.lua_TValue, ptr %270, i64 1
  %285 = icmp ult ptr %284, %283
  br i1 %285, label %268, label %265, !llvm.loop !228

286:                                              ; preds = %286, %265
  %287 = phi ptr [ %289, %286 ], [ %266, %265 ]
  %288 = getelementptr inbounds %struct.lua_TValue, ptr %287, i64 0, i32 1
  store i32 0, ptr %288, align 8, !tbaa !16
  %289 = getelementptr inbounds %struct.lua_TValue, ptr %287, i64 1
  %290 = icmp ugt ptr %289, %261
  br i1 %290, label %291, label %286, !llvm.loop !229

291:                                              ; preds = %286, %265
  %292 = load ptr, ptr %262, align 8, !tbaa !43
  %293 = ptrtoint ptr %261 to i64
  %294 = ptrtoint ptr %292 to i64
  %295 = sub i64 %293, %294
  %296 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 14
  %297 = load i32, ptr %296, align 4, !tbaa !131
  %298 = icmp sgt i32 %297, 20000
  br i1 %298, label %324, label %299

299:                                              ; preds = %291
  %300 = load ptr, ptr %248, align 8, !tbaa !19
  %301 = ptrtoint ptr %300 to i64
  %302 = load ptr, ptr %246, align 8, !tbaa !38
  %303 = ptrtoint ptr %302 to i64
  %304 = sub i64 %301, %303
  %305 = sdiv exact i64 %304, 40
  %306 = trunc i64 %305 to i32
  %307 = shl nsw i32 %306, 2
  %308 = icmp slt i32 %307, %297
  %309 = icmp sgt i32 %297, 16
  %310 = and i1 %309, %308
  br i1 %310, label %311, label %313

311:                                              ; preds = %299
  %312 = lshr i32 %297, 1
  tail call void @luaD_reallocCI(ptr noundef nonnull %3, i32 noundef %312) #46
  br label %313

313:                                              ; preds = %311, %299
  %314 = lshr i64 %295, 2
  %315 = trunc i64 %314 to i32
  %316 = and i32 %315, -4
  %317 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 13
  %318 = load i32, ptr %317, align 8, !tbaa !134
  %319 = icmp slt i32 %316, %318
  %320 = icmp sgt i32 %318, 90
  %321 = and i1 %319, %320
  br i1 %321, label %322, label %324

322:                                              ; preds = %313
  %323 = lshr i32 %318, 1
  tail call void @luaD_reallocstack(ptr noundef nonnull %3, i32 noundef %323) #46
  br label %324

324:                                              ; preds = %322, %313, %291
  %325 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 13
  %326 = load i32, ptr %325, align 8, !tbaa !134
  %327 = sext i32 %326 to i64
  %328 = shl nsw i64 %327, 4
  %329 = add nsw i64 %328, 184
  %330 = load i32, ptr %296, align 4, !tbaa !131
  %331 = sext i32 %330 to i64
  %332 = mul nsw i64 %331, 40
  %333 = add nsw i64 %329, %332
  br label %470

334:                                              ; preds = %1
  %335 = getelementptr inbounds %struct.Proto, ptr %3, i64 0, i32 18
  %336 = load ptr, ptr %335, align 8, !tbaa !230
  store ptr %336, ptr %2, align 8, !tbaa !197
  %337 = getelementptr inbounds %struct.Proto, ptr %3, i64 0, i32 9
  %338 = load ptr, ptr %337, align 8, !tbaa !105
  %339 = icmp eq ptr %338, null
  br i1 %339, label %344, label %340

340:                                              ; preds = %334
  %341 = getelementptr inbounds %struct.anon.0, ptr %338, i64 0, i32 2
  %342 = load i8, ptr %341, align 1, !tbaa !33
  %343 = and i8 %342, -4
  store i8 %343, ptr %341, align 1, !tbaa !33
  br label %344

344:                                              ; preds = %340, %334
  %345 = getelementptr inbounds %struct.Proto, ptr %3, i64 0, i32 11
  %346 = load i32, ptr %345, align 4, !tbaa !81
  %347 = icmp sgt i32 %346, 0
  br i1 %347, label %348, label %350

348:                                              ; preds = %344
  %349 = getelementptr inbounds %struct.Proto, ptr %3, i64 0, i32 3
  br label %356

350:                                              ; preds = %372, %344
  %351 = getelementptr inbounds %struct.Proto, ptr %3, i64 0, i32 10
  %352 = load i32, ptr %351, align 8, !tbaa !55
  %353 = icmp sgt i32 %352, 0
  br i1 %353, label %354, label %377

354:                                              ; preds = %350
  %355 = getelementptr inbounds %struct.Proto, ptr %3, i64 0, i32 8
  br label %383

356:                                              ; preds = %372, %348
  %357 = phi i32 [ %346, %348 ], [ %373, %372 ]
  %358 = phi i64 [ 0, %348 ], [ %374, %372 ]
  %359 = load ptr, ptr %349, align 8, !tbaa !83
  %360 = getelementptr inbounds %struct.lua_TValue, ptr %359, i64 %358, i32 1
  %361 = load i32, ptr %360, align 8, !tbaa !16
  %362 = icmp sgt i32 %361, 3
  br i1 %362, label %363, label %372

363:                                              ; preds = %356
  %364 = getelementptr inbounds %struct.lua_TValue, ptr %359, i64 %358
  %365 = load ptr, ptr %364, align 8, !tbaa !33
  %366 = getelementptr inbounds %struct.GCheader, ptr %365, i64 0, i32 2
  %367 = load i8, ptr %366, align 1, !tbaa !33
  %368 = and i8 %367, 3
  %369 = icmp eq i8 %368, 0
  br i1 %369, label %372, label %370

370:                                              ; preds = %363
  tail call fastcc void @reallymarkobject(ptr noundef %0, ptr noundef nonnull %365) #47
  %371 = load i32, ptr %345, align 4, !tbaa !81
  br label %372

372:                                              ; preds = %370, %363, %356
  %373 = phi i32 [ %357, %356 ], [ %357, %363 ], [ %371, %370 ]
  %374 = add nuw nsw i64 %358, 1
  %375 = sext i32 %373 to i64
  %376 = icmp slt i64 %374, %375
  br i1 %376, label %356, label %350, !llvm.loop !231

377:                                              ; preds = %395, %350
  %378 = getelementptr inbounds %struct.Proto, ptr %3, i64 0, i32 14
  %379 = load i32, ptr %378, align 8, !tbaa !120
  %380 = icmp sgt i32 %379, 0
  br i1 %380, label %381, label %400

381:                                              ; preds = %377
  %382 = getelementptr inbounds %struct.Proto, ptr %3, i64 0, i32 5
  br label %409

383:                                              ; preds = %395, %354
  %384 = phi i32 [ %352, %354 ], [ %396, %395 ]
  %385 = phi i64 [ 0, %354 ], [ %397, %395 ]
  %386 = load ptr, ptr %355, align 8, !tbaa !58
  %387 = getelementptr inbounds ptr, ptr %386, i64 %385
  %388 = load ptr, ptr %387, align 8, !tbaa !39
  %389 = icmp eq ptr %388, null
  br i1 %389, label %395, label %390

390:                                              ; preds = %383
  %391 = getelementptr inbounds %struct.anon.0, ptr %388, i64 0, i32 2
  %392 = load i8, ptr %391, align 1, !tbaa !33
  %393 = and i8 %392, -4
  store i8 %393, ptr %391, align 1, !tbaa !33
  %394 = load i32, ptr %351, align 8, !tbaa !55
  br label %395

395:                                              ; preds = %390, %383
  %396 = phi i32 [ %384, %383 ], [ %394, %390 ]
  %397 = add nuw nsw i64 %385, 1
  %398 = sext i32 %396 to i64
  %399 = icmp slt i64 %397, %398
  br i1 %399, label %383, label %377, !llvm.loop !232

400:                                              ; preds = %423, %377
  %401 = phi i32 [ %379, %377 ], [ %424, %423 ]
  %402 = getelementptr inbounds %struct.Proto, ptr %3, i64 0, i32 15
  %403 = load i32, ptr %402, align 4, !tbaa !166
  %404 = icmp sgt i32 %403, 0
  br i1 %404, label %407, label %405

405:                                              ; preds = %400
  %406 = sext i32 %403 to i64
  br label %447

407:                                              ; preds = %400
  %408 = getelementptr inbounds %struct.Proto, ptr %3, i64 0, i32 7
  br label %428

409:                                              ; preds = %423, %381
  %410 = phi i32 [ %379, %381 ], [ %424, %423 ]
  %411 = phi i64 [ 0, %381 ], [ %425, %423 ]
  %412 = load ptr, ptr %382, align 8, !tbaa !121
  %413 = getelementptr inbounds ptr, ptr %412, i64 %411
  %414 = load ptr, ptr %413, align 8, !tbaa !39
  %415 = icmp eq ptr %414, null
  br i1 %415, label %423, label %416

416:                                              ; preds = %409
  %417 = getelementptr inbounds %struct.GCheader, ptr %414, i64 0, i32 2
  %418 = load i8, ptr %417, align 1, !tbaa !33
  %419 = and i8 %418, 3
  %420 = icmp eq i8 %419, 0
  br i1 %420, label %423, label %421

421:                                              ; preds = %416
  tail call fastcc void @reallymarkobject(ptr noundef %0, ptr noundef nonnull %414) #47
  %422 = load i32, ptr %378, align 8, !tbaa !120
  br label %423

423:                                              ; preds = %421, %416, %409
  %424 = phi i32 [ %410, %409 ], [ %422, %421 ], [ %410, %416 ]
  %425 = add nuw nsw i64 %411, 1
  %426 = sext i32 %424 to i64
  %427 = icmp slt i64 %425, %426
  br i1 %427, label %409, label %400, !llvm.loop !233

428:                                              ; preds = %440, %407
  %429 = phi i32 [ %403, %407 ], [ %441, %440 ]
  %430 = phi i64 [ 0, %407 ], [ %442, %440 ]
  %431 = load ptr, ptr %408, align 8, !tbaa !167
  %432 = getelementptr inbounds %struct.stringtable, ptr %431, i64 %430
  %433 = load ptr, ptr %432, align 8, !tbaa !168
  %434 = icmp eq ptr %433, null
  br i1 %434, label %440, label %435

435:                                              ; preds = %428
  %436 = getelementptr inbounds %struct.anon.0, ptr %433, i64 0, i32 2
  %437 = load i8, ptr %436, align 1, !tbaa !33
  %438 = and i8 %437, -4
  store i8 %438, ptr %436, align 1, !tbaa !33
  %439 = load i32, ptr %402, align 4, !tbaa !166
  br label %440

440:                                              ; preds = %435, %428
  %441 = phi i32 [ %429, %428 ], [ %439, %435 ]
  %442 = add nuw nsw i64 %430, 1
  %443 = sext i32 %441 to i64
  %444 = icmp slt i64 %442, %443
  br i1 %444, label %428, label %445, !llvm.loop !234

445:                                              ; preds = %440
  %.lcssa = phi i64 [ %443, %440 ]
  %446 = load i32, ptr %378, align 8, !tbaa !120
  br label %447

447:                                              ; preds = %445, %405
  %448 = phi i64 [ %406, %405 ], [ %.lcssa, %445 ]
  %449 = phi i32 [ %401, %405 ], [ %446, %445 ]
  %450 = getelementptr inbounds %struct.Proto, ptr %3, i64 0, i32 12
  %451 = load i32, ptr %450, align 8, !tbaa !71
  %452 = sext i32 %451 to i64
  %453 = sext i32 %449 to i64
  %454 = load i32, ptr %345, align 4, !tbaa !81
  %455 = sext i32 %454 to i64
  %456 = getelementptr inbounds %struct.Proto, ptr %3, i64 0, i32 13
  %457 = load i32, ptr %456, align 4, !tbaa !73
  %458 = sext i32 %457 to i64
  %459 = load i32, ptr %351, align 8, !tbaa !55
  %460 = sext i32 %459 to i64
  %461 = add nsw i64 %448, %455
  %462 = shl nsw i64 %461, 4
  %463 = add nsw i64 %460, %453
  %464 = shl nsw i64 %463, 3
  %465 = add nsw i64 %458, %452
  %466 = shl nsw i64 %465, 2
  %467 = add nsw i64 %466, 120
  %468 = add nsw i64 %467, %462
  %469 = add nsw i64 %468, %464
  br label %470

470:                                              ; preds = %447, %324, %216, %137, %1
  %471 = phi i64 [ %469, %447 ], [ %333, %324 ], [ %224, %216 ], [ %149, %137 ], [ 0, %1 ]
  ret i64 %471
}

; Function Attrs: nofree nosync nounwind optsize memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define internal fastcc void @reallymarkobject(ptr noundef %0, ptr noundef %1) unnamed_addr #25 {
  %3 = getelementptr inbounds %struct.GCheader, ptr %1, i64 0, i32 2
  %4 = load i8, ptr %3, align 1, !tbaa !33
  br label %5

5:                                                ; preds = %23, %2
  %6 = phi i8 [ %4, %2 ], [ %27, %23 ]
  %7 = phi ptr [ %1, %2 ], [ %25, %23 ]
  %8 = getelementptr inbounds %struct.GCheader, ptr %7, i64 0, i32 2
  %9 = and i8 %6, -4
  store i8 %9, ptr %8, align 1, !tbaa !33
  %10 = getelementptr inbounds %struct.GCheader, ptr %7, i64 0, i32 1
  %11 = load i8, ptr %10, align 8, !tbaa !33
  switch i8 %11, label %67 [
    i8 9, label %63
    i8 7, label %12
    i8 10, label %30
    i8 6, label %51
    i8 5, label %55
    i8 8, label %59
  ]

12:                                               ; preds = %5
  %13 = getelementptr inbounds %struct.anon.1, ptr %7, i64 0, i32 3
  %14 = load ptr, ptr %13, align 8, !tbaa !33
  %15 = or i8 %9, 4
  store i8 %15, ptr %8, align 1, !tbaa !33
  %16 = icmp eq ptr %14, null
  br i1 %16, label %23, label %17

17:                                               ; preds = %12
  %18 = getelementptr inbounds %struct.GCheader, ptr %14, i64 0, i32 2
  %19 = load i8, ptr %18, align 1, !tbaa !33
  %20 = and i8 %19, 3
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %23, label %22

22:                                               ; preds = %17
  tail call fastcc void @reallymarkobject(ptr noundef %0, ptr noundef nonnull %14) #47
  br label %23

23:                                               ; preds = %22, %17, %12
  %24 = getelementptr inbounds %struct.anon.1, ptr %7, i64 0, i32 4
  %25 = load ptr, ptr %24, align 8, !tbaa !33
  %26 = getelementptr inbounds %struct.GCheader, ptr %25, i64 0, i32 2
  %27 = load i8, ptr %26, align 1, !tbaa !33
  %28 = and i8 %27, 3
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %67, label %5

30:                                               ; preds = %5
  %.lcssa8 = phi ptr [ %7, %5 ]
  %.lcssa2 = phi ptr [ %8, %5 ]
  %31 = getelementptr inbounds %struct.UpVal, ptr %.lcssa8, i64 0, i32 3
  %32 = load ptr, ptr %31, align 8, !tbaa !57
  %33 = getelementptr inbounds %struct.lua_TValue, ptr %32, i64 0, i32 1
  %34 = load i32, ptr %33, align 8, !tbaa !16
  %35 = icmp sgt i32 %34, 3
  br i1 %35, label %36, label %44

36:                                               ; preds = %30
  %37 = load ptr, ptr %32, align 8, !tbaa !33
  %38 = getelementptr inbounds %struct.GCheader, ptr %37, i64 0, i32 2
  %39 = load i8, ptr %38, align 1, !tbaa !33
  %40 = and i8 %39, 3
  %41 = icmp eq i8 %40, 0
  br i1 %41, label %44, label %42

42:                                               ; preds = %36
  tail call fastcc void @reallymarkobject(ptr noundef %0, ptr noundef nonnull %37) #47
  %43 = load ptr, ptr %31, align 8, !tbaa !57
  br label %44

44:                                               ; preds = %42, %36, %30
  %45 = phi ptr [ %43, %42 ], [ %32, %36 ], [ %32, %30 ]
  %46 = getelementptr inbounds %struct.UpVal, ptr %.lcssa8, i64 0, i32 4
  %47 = icmp eq ptr %45, %46
  br i1 %47, label %48, label %67

48:                                               ; preds = %44
  %49 = load i8, ptr %.lcssa2, align 1, !tbaa !33
  %50 = or i8 %49, 4
  store i8 %50, ptr %.lcssa2, align 1, !tbaa !33
  br label %67

51:                                               ; preds = %5
  %.lcssa9 = phi ptr [ %7, %5 ]
  %.lcssa3 = phi ptr [ %8, %5 ]
  %52 = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 8
  %53 = load ptr, ptr %52, align 8, !tbaa !197
  %54 = getelementptr inbounds %struct.CClosure, ptr %.lcssa9, i64 0, i32 5
  store ptr %53, ptr %54, align 8, !tbaa !33
  store ptr %.lcssa9, ptr %52, align 8, !tbaa !197
  br label %67

55:                                               ; preds = %5
  %.lcssa10 = phi ptr [ %7, %5 ]
  %.lcssa4 = phi ptr [ %8, %5 ]
  %56 = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 8
  %57 = load ptr, ptr %56, align 8, !tbaa !197
  %58 = getelementptr inbounds %struct.Table, ptr %.lcssa10, i64 0, i32 9
  store ptr %57, ptr %58, align 8, !tbaa !33
  store ptr %.lcssa10, ptr %56, align 8, !tbaa !197
  br label %67

59:                                               ; preds = %5
  %.lcssa11 = phi ptr [ %7, %5 ]
  %.lcssa5 = phi ptr [ %8, %5 ]
  %60 = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 8
  %61 = load ptr, ptr %60, align 8, !tbaa !197
  %62 = getelementptr inbounds %struct.lua_State, ptr %.lcssa11, i64 0, i32 25
  store ptr %61, ptr %62, align 8, !tbaa !33
  store ptr %.lcssa11, ptr %60, align 8, !tbaa !197
  br label %67

63:                                               ; preds = %5
  %.lcssa7 = phi ptr [ %7, %5 ]
  %.lcssa1 = phi ptr [ %8, %5 ]
  %64 = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 8
  %65 = load ptr, ptr %64, align 8, !tbaa !197
  %66 = getelementptr inbounds %struct.Proto, ptr %.lcssa7, i64 0, i32 18
  store ptr %65, ptr %66, align 8, !tbaa !33
  store ptr %.lcssa7, ptr %64, align 8, !tbaa !197
  br label %67

67:                                               ; preds = %63, %59, %55, %51, %48, %44, %23, %5
  ret void
}

; Function Attrs: nofree nosync nounwind optsize memory(readwrite, inaccessiblemem: none) uwtable
define internal fastcc void @markmt(ptr noundef %0) unnamed_addr #24 {
  br label %2

2:                                                ; preds = %13, %1
  %3 = phi i64 [ 0, %1 ], [ %14, %13 ]
  %4 = getelementptr inbounds %struct.global_State, ptr %0, i64 0, i32 23, i64 %3
  %5 = load ptr, ptr %4, align 8, !tbaa !39
  %6 = icmp eq ptr %5, null
  br i1 %6, label %13, label %7

7:                                                ; preds = %2
  %8 = getelementptr inbounds %struct.GCheader, ptr %5, i64 0, i32 2
  %9 = load i8, ptr %8, align 1, !tbaa !33
  %10 = and i8 %9, 3
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %13, label %12

12:                                               ; preds = %7
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %0, ptr noundef nonnull %5) #47
  br label %13

13:                                               ; preds = %12, %7, %2
  %14 = add nuw nsw i64 %3, 1
  %15 = icmp eq i64 %14, 9
  br i1 %15, label %16, label %2, !llvm.loop !235

16:                                               ; preds = %13
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable
define internal fastcc i32 @iscleared(ptr nocapture noundef readonly %0, i32 noundef %1) unnamed_addr #4 {
  %3 = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %4 = load i32, ptr %3, align 8, !tbaa !16
  %5 = icmp sgt i32 %4, 3
  br i1 %5, label %6, label %26

6:                                                ; preds = %2
  %7 = icmp eq i32 %4, 4
  %8 = load ptr, ptr %0, align 8, !tbaa !33
  br i1 %7, label %9, label %13

9:                                                ; preds = %6
  %10 = getelementptr inbounds %struct.anon.0, ptr %8, i64 0, i32 2
  %11 = load i8, ptr %10, align 1, !tbaa !33
  %12 = and i8 %11, -4
  store i8 %12, ptr %10, align 1, !tbaa !33
  br label %26

13:                                               ; preds = %6
  %14 = getelementptr inbounds %struct.GCheader, ptr %8, i64 0, i32 2
  %15 = load i8, ptr %14, align 1, !tbaa !33
  %16 = and i8 %15, 3
  %17 = icmp eq i8 %16, 0
  br i1 %17, label %18, label %26

18:                                               ; preds = %13
  %19 = icmp ne i32 %4, 7
  %20 = icmp ne i32 %1, 0
  %21 = or i1 %20, %19
  br i1 %21, label %26, label %22

22:                                               ; preds = %18
  %23 = lshr i8 %15, 3
  %24 = and i8 %23, 1
  %25 = zext i8 %24 to i32
  br label %26

26:                                               ; preds = %22, %18, %13, %9, %2
  %27 = phi i32 [ 0, %9 ], [ 0, %2 ], [ 1, %13 ], [ 0, %18 ], [ %25, %22 ]
  ret i32 %27
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaC_fullgc(ptr noundef %0) #1 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %3 = load ptr, ptr %2, align 8, !tbaa !25
  %4 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 4
  %5 = load i8, ptr %4, align 1, !tbaa !51
  %6 = icmp ult i8 %5, 2
  br i1 %6, label %7, label %12

7:                                                ; preds = %1
  %8 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 5
  store i32 0, ptr %8, align 4, !tbaa !215
  %9 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 6
  %10 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 7
  store ptr %9, ptr %10, align 8, !tbaa !216
  %11 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %11, i8 0, i64 24, i1 false)
  store i8 2, ptr %4, align 1, !tbaa !51
  br label %14

12:                                               ; preds = %1
  %13 = icmp eq i8 %5, 4
  br i1 %13, label %19, label %14

14:                                               ; preds = %12, %7
  br label %15

15:                                               ; preds = %15, %14
  %16 = tail call fastcc i64 @singlestep(ptr noundef %0) #47
  %17 = load i8, ptr %4, align 1, !tbaa !51
  %18 = icmp eq i8 %17, 4
  br i1 %18, label %19, label %15, !llvm.loop !236

19:                                               ; preds = %15, %12
  tail call fastcc void @markroot(ptr noundef %0) #47
  %20 = load i8, ptr %4, align 1, !tbaa !51
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %26, label %22

22:                                               ; preds = %22, %19
  %23 = tail call fastcc i64 @singlestep(ptr noundef %0) #47
  %24 = load i8, ptr %4, align 1, !tbaa !51
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %26, label %22, !llvm.loop !237

26:                                               ; preds = %22, %19
  %27 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 15
  %28 = load i64, ptr %27, align 8, !tbaa !196
  %29 = udiv i64 %28, 100
  %30 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 17
  %31 = load i32, ptr %30, align 8, !tbaa !53
  %32 = sext i32 %31 to i64
  %33 = mul i64 %29, %32
  %34 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 13
  store i64 %33, ptr %34, align 8, !tbaa !32
  ret void
}

; Function Attrs: nofree nosync nounwind optsize memory(readwrite, inaccessiblemem: none) uwtable
define internal void @luaC_barrierf(ptr nocapture noundef readonly %0, ptr nocapture noundef %1, ptr noundef %2) #24 {
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %5 = load ptr, ptr %4, align 8, !tbaa !25
  %6 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 4
  %7 = load i8, ptr %6, align 1, !tbaa !51
  %8 = icmp eq i8 %7, 1
  br i1 %8, label %9, label %10

9:                                                ; preds = %3
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %5, ptr noundef %2) #47
  br label %18

10:                                               ; preds = %3
  %11 = getelementptr inbounds %struct.GCheader, ptr %1, i64 0, i32 2
  %12 = load i8, ptr %11, align 1, !tbaa !33
  %13 = and i8 %12, -8
  %14 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 3
  %15 = load i8, ptr %14, align 8, !tbaa !175
  %16 = and i8 %15, 3
  %17 = or i8 %16, %13
  store i8 %17, ptr %11, align 1, !tbaa !33
  br label %18

18:                                               ; preds = %10, %9
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable
define internal void @luaC_barrierback(ptr nocapture noundef readonly %0, ptr noundef %1) #4 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %4 = load ptr, ptr %3, align 8, !tbaa !25
  %5 = getelementptr inbounds %struct.GCheader, ptr %1, i64 0, i32 2
  %6 = load i8, ptr %5, align 1, !tbaa !33
  %7 = and i8 %6, -5
  store i8 %7, ptr %5, align 1, !tbaa !33
  %8 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 9
  %9 = load ptr, ptr %8, align 8, !tbaa !202
  %10 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 9
  store ptr %9, ptr %10, align 8, !tbaa !213
  store ptr %1, ptr %8, align 8, !tbaa !202
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable
define internal void @luaC_link(ptr nocapture noundef readonly %0, ptr noundef %1, i8 noundef zeroext %2) #4 {
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %5 = load ptr, ptr %4, align 8, !tbaa !25
  %6 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 6
  %7 = load ptr, ptr %6, align 8, !tbaa !191
  store ptr %7, ptr %1, align 8, !tbaa !33
  store ptr %1, ptr %6, align 8, !tbaa !191
  %8 = getelementptr inbounds %struct.global_State, ptr %5, i64 0, i32 3
  %9 = load i8, ptr %8, align 8, !tbaa !175
  %10 = and i8 %9, 3
  %11 = getelementptr inbounds %struct.GCheader, ptr %1, i64 0, i32 2
  store i8 %10, ptr %11, align 1, !tbaa !33
  %12 = getelementptr inbounds %struct.GCheader, ptr %1, i64 0, i32 1
  store i8 %2, ptr %12, align 8, !tbaa !33
  ret void
}

; Function Attrs: nofree nosync nounwind optsize memory(readwrite, inaccessiblemem: none) uwtable
define internal void @luaC_linkupval(ptr nocapture noundef readonly %0, ptr noundef %1) #24 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %4 = load ptr, ptr %3, align 8, !tbaa !25
  %5 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 6
  %6 = load ptr, ptr %5, align 8, !tbaa !191
  store ptr %6, ptr %1, align 8, !tbaa !33
  store ptr %1, ptr %5, align 8, !tbaa !191
  %7 = getelementptr inbounds %struct.GCheader, ptr %1, i64 0, i32 2
  %8 = load i8, ptr %7, align 1, !tbaa !33
  %9 = and i8 %8, 7
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %46

11:                                               ; preds = %2
  %12 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 4
  %13 = load i8, ptr %12, align 1, !tbaa !51
  %14 = icmp eq i8 %13, 1
  br i1 %14, label %15, label %40

15:                                               ; preds = %11
  %16 = or i8 %8, 4
  store i8 %16, ptr %7, align 1, !tbaa !33
  %17 = getelementptr inbounds %struct.UpVal, ptr %1, i64 0, i32 3
  %18 = load ptr, ptr %17, align 8, !tbaa !57
  %19 = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 0, i32 1
  %20 = load i32, ptr %19, align 8, !tbaa !16
  %21 = icmp sgt i32 %20, 3
  br i1 %21, label %22, label %46

22:                                               ; preds = %15
  %23 = load ptr, ptr %18, align 8, !tbaa !33
  %24 = getelementptr inbounds %struct.GCheader, ptr %23, i64 0, i32 2
  %25 = load i8, ptr %24, align 1, !tbaa !33
  %26 = and i8 %25, 3
  %27 = icmp eq i8 %26, 0
  br i1 %27, label %46, label %28

28:                                               ; preds = %22
  %29 = load ptr, ptr %3, align 8, !tbaa !25
  %30 = getelementptr inbounds %struct.global_State, ptr %29, i64 0, i32 4
  %31 = load i8, ptr %30, align 1, !tbaa !51
  %32 = icmp eq i8 %31, 1
  br i1 %32, label %33, label %34

33:                                               ; preds = %28
  tail call fastcc void @reallymarkobject(ptr noundef nonnull %29, ptr noundef nonnull %23) #47
  br label %46

34:                                               ; preds = %28
  %35 = and i8 %8, -8
  %36 = getelementptr inbounds %struct.global_State, ptr %29, i64 0, i32 3
  %37 = load i8, ptr %36, align 8, !tbaa !175
  %38 = and i8 %37, 3
  %39 = or i8 %38, %35
  store i8 %39, ptr %7, align 1, !tbaa !33
  br label %46

40:                                               ; preds = %11
  %41 = and i8 %8, -8
  %42 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 3
  %43 = load i8, ptr %42, align 8, !tbaa !175
  %44 = and i8 %43, 3
  %45 = or i8 %44, %41
  store i8 %45, ptr %7, align 1, !tbaa !33
  br label %46

46:                                               ; preds = %40, %34, %33, %22, %15, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaX_init(ptr noundef %0) #1 {
  br label %2

2:                                                ; preds = %2, %1
  %3 = phi i64 [ 0, %1 ], [ %11, %2 ]
  %4 = getelementptr inbounds [32 x ptr], ptr @luaX_tokens, i64 0, i64 %3
  %5 = load ptr, ptr %4, align 8, !tbaa !39
  %6 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %5) #49
  %7 = tail call ptr @luaS_newlstr(ptr noundef %0, ptr noundef %5, i64 noundef %6) #46
  %8 = getelementptr inbounds %struct.anon.0, ptr %7, i64 0, i32 2
  %9 = load i8, ptr %8, align 1, !tbaa !33
  %10 = or i8 %9, 32
  store i8 %10, ptr %8, align 1, !tbaa !33
  %11 = add nuw nsw i64 %3, 1
  %12 = getelementptr inbounds %struct.anon.0, ptr %7, i64 0, i32 3
  %13 = trunc i64 %11 to i8
  store i8 %13, ptr %12, align 2, !tbaa !33
  %14 = icmp eq i64 %11, 21
  br i1 %14, label %15, label %2, !llvm.loop !238

15:                                               ; preds = %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaX_token2str(ptr nocapture noundef readonly %0, i32 noundef %1) #1 {
  %3 = icmp slt i32 %1, 257
  br i1 %3, label %4, label %18

4:                                                ; preds = %2
  %5 = tail call ptr @__ctype_b_loc() #52
  %6 = load ptr, ptr %5, align 8, !tbaa !39
  %7 = sext i32 %1 to i64
  %8 = getelementptr inbounds i16, ptr %6, i64 %7
  %9 = load i16, ptr %8, align 2, !tbaa !239
  %10 = and i16 %9, 2
  %11 = icmp eq i16 %10, 0
  %12 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 6
  %13 = load ptr, ptr %12, align 8, !tbaa !240
  br i1 %11, label %16, label %14

14:                                               ; preds = %4
  %15 = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %13, ptr noundef nonnull @.str.31, i32 noundef %1) #46
  br label %23

16:                                               ; preds = %4
  %17 = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %13, ptr noundef nonnull @.str.32, i32 noundef %1) #46
  br label %23

18:                                               ; preds = %2
  %19 = add nsw i32 %1, -257
  %20 = zext i32 %19 to i64
  %21 = getelementptr inbounds [32 x ptr], ptr @luaX_tokens, i64 0, i64 %20
  %22 = load ptr, ptr %21, align 8, !tbaa !39
  br label %23

23:                                               ; preds = %18, %16, %14
  %24 = phi ptr [ %22, %18 ], [ %15, %14 ], [ %17, %16 ]
  ret ptr %24
}

; Function Attrs: mustprogress nofree nosync nounwind optsize willreturn memory(none)
declare ptr @__ctype_b_loc() local_unnamed_addr #26

; Function Attrs: nounwind optsize uwtable
define internal void @luaX_lexerror(ptr nocapture noundef readonly %0, ptr noundef %1, i32 noundef %2) #1 {
  %4 = alloca [80 x i8], align 16
  call void @llvm.lifetime.start.p0(i64 80, ptr nonnull %4) #48
  %5 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 9
  %6 = load ptr, ptr %5, align 8, !tbaa !241
  %7 = getelementptr inbounds %union.TString, ptr %6, i64 1
  call void @luaO_chunkid(ptr noundef nonnull %4, ptr noundef nonnull %7, i64 noundef 80) #46
  %8 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 6
  %9 = load ptr, ptr %8, align 8, !tbaa !240
  %10 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 1
  %11 = load i32, ptr %10, align 4, !tbaa !242
  %12 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %9, ptr noundef nonnull @.str.33, ptr noundef nonnull %4, i32 noundef %11, ptr noundef %1) #46
  %13 = icmp eq i32 %2, 0
  br i1 %13, label %27, label %14

14:                                               ; preds = %3
  %15 = load ptr, ptr %8, align 8, !tbaa !240
  %16 = add i32 %2, -284
  %17 = icmp ult i32 %16, 3
  br i1 %17, label %18, label %22

18:                                               ; preds = %14
  call fastcc void @save(ptr noundef nonnull %0, i32 noundef 0) #47
  %19 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 8
  %20 = load ptr, ptr %19, align 8, !tbaa !243
  %21 = load ptr, ptr %20, align 8, !tbaa !244
  br label %24

22:                                               ; preds = %14
  %23 = call ptr @luaX_token2str(ptr noundef nonnull %0, i32 noundef %2) #47
  br label %24

24:                                               ; preds = %22, %18
  %25 = phi ptr [ %23, %22 ], [ %21, %18 ]
  %26 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %15, ptr noundef nonnull @.str.34, ptr noundef %12, ptr noundef %25) #46
  br label %27

27:                                               ; preds = %24, %3
  %28 = load ptr, ptr %8, align 8, !tbaa !240
  call void @luaD_throw(ptr noundef %28, i32 noundef 3) #46
  call void @llvm.lifetime.end.p0(i64 80, ptr nonnull %4) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @save(ptr nocapture noundef readonly %0, i32 noundef %1) unnamed_addr #1 {
  %3 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 8
  %4 = load ptr, ptr %3, align 8, !tbaa !243
  %5 = getelementptr inbounds %struct.Mbuffer, ptr %4, i64 0, i32 1
  %6 = load i64, ptr %5, align 8, !tbaa !245
  %7 = add i64 %6, 1
  %8 = getelementptr inbounds %struct.Mbuffer, ptr %4, i64 0, i32 2
  %9 = load i64, ptr %8, align 8, !tbaa !246
  %10 = icmp ugt i64 %7, %9
  br i1 %10, label %13, label %11

11:                                               ; preds = %2
  %12 = load ptr, ptr %4, align 8, !tbaa !244
  br label %32

13:                                               ; preds = %2
  %14 = icmp ugt i64 %9, 9223372036854775805
  br i1 %14, label %15, label %17

15:                                               ; preds = %13
  tail call void @luaX_lexerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.35, i32 noundef 0) #47
  %16 = load i64, ptr %8, align 8, !tbaa !246
  br label %17

17:                                               ; preds = %15, %13
  %18 = phi i64 [ %16, %15 ], [ %9, %13 ]
  %19 = shl i64 %18, 1
  %20 = icmp eq i64 %19, -2
  %21 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 6
  %22 = load ptr, ptr %21, align 8, !tbaa !240
  br i1 %20, label %26, label %23

23:                                               ; preds = %17
  %24 = load ptr, ptr %4, align 8, !tbaa !244
  %25 = tail call ptr @luaM_realloc_(ptr noundef %22, ptr noundef %24, i64 noundef %18, i64 noundef %19) #46
  br label %28

26:                                               ; preds = %17
  %27 = tail call ptr @luaM_toobig(ptr noundef %22) #46
  br label %28

28:                                               ; preds = %26, %23
  %29 = phi ptr [ %25, %23 ], [ %27, %26 ]
  store ptr %29, ptr %4, align 8, !tbaa !244
  store i64 %19, ptr %8, align 8, !tbaa !246
  %30 = load i64, ptr %5, align 8, !tbaa !245
  %31 = add i64 %30, 1
  br label %32

32:                                               ; preds = %28, %11
  %33 = phi i64 [ %7, %11 ], [ %31, %28 ]
  %34 = phi i64 [ %6, %11 ], [ %30, %28 ]
  %35 = phi ptr [ %12, %11 ], [ %29, %28 ]
  %36 = trunc i32 %1 to i8
  store i64 %33, ptr %5, align 8, !tbaa !245
  %37 = getelementptr inbounds i8, ptr %35, i64 %34
  store i8 %36, ptr %37, align 1, !tbaa !33
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaX_syntaxerror(ptr nocapture noundef readonly %0, ptr noundef %1) #1 {
  %3 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  %4 = load i32, ptr %3, align 8, !tbaa !247
  tail call void @luaX_lexerror(ptr noundef %0, ptr noundef %1, i32 noundef %4) #47
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaX_newstring(ptr nocapture noundef readonly %0, ptr noundef %1, i64 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 6
  %5 = load ptr, ptr %4, align 8, !tbaa !240
  %6 = tail call ptr @luaS_newlstr(ptr noundef %5, ptr noundef %1, i64 noundef %2) #46
  %7 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %8 = load ptr, ptr %7, align 8, !tbaa !248
  %9 = getelementptr inbounds %struct.FuncState, ptr %8, i64 0, i32 1
  %10 = load ptr, ptr %9, align 8, !tbaa !80
  %11 = tail call ptr @luaH_setstr(ptr noundef %5, ptr noundef %10, ptr noundef %6) #46
  %12 = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 0, i32 1
  %13 = load i32, ptr %12, align 8, !tbaa !16
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %16

15:                                               ; preds = %3
  store i32 1, ptr %11, align 8, !tbaa !33
  store i32 1, ptr %12, align 8, !tbaa !16
  br label %16

16:                                               ; preds = %15, %3
  ret ptr %6
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaX_setinput(ptr noundef %0, ptr nocapture noundef %1, ptr noundef %2, ptr noundef %3) #1 {
  %5 = getelementptr inbounds %struct.LexState, ptr %1, i64 0, i32 10
  store i8 46, ptr %5, align 8, !tbaa !249
  %6 = getelementptr inbounds %struct.LexState, ptr %1, i64 0, i32 6
  store ptr %0, ptr %6, align 8, !tbaa !240
  %7 = getelementptr inbounds %struct.LexState, ptr %1, i64 0, i32 4
  store i32 287, ptr %7, align 8, !tbaa !250
  %8 = getelementptr inbounds %struct.LexState, ptr %1, i64 0, i32 7
  store ptr %2, ptr %8, align 8, !tbaa !251
  %9 = getelementptr inbounds %struct.LexState, ptr %1, i64 0, i32 5
  store ptr null, ptr %9, align 8, !tbaa !248
  %10 = getelementptr inbounds %struct.LexState, ptr %1, i64 0, i32 1
  store i32 1, ptr %10, align 4, !tbaa !242
  %11 = getelementptr inbounds %struct.LexState, ptr %1, i64 0, i32 2
  store i32 1, ptr %11, align 8, !tbaa !67
  %12 = getelementptr inbounds %struct.LexState, ptr %1, i64 0, i32 9
  store ptr %3, ptr %12, align 8, !tbaa !241
  %13 = getelementptr inbounds %struct.LexState, ptr %1, i64 0, i32 8
  %14 = load ptr, ptr %13, align 8, !tbaa !243
  %15 = load ptr, ptr %14, align 8, !tbaa !244
  %16 = getelementptr inbounds %struct.Mbuffer, ptr %14, i64 0, i32 2
  %17 = load i64, ptr %16, align 8, !tbaa !246
  %18 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %15, i64 noundef %17, i64 noundef 32) #46
  %19 = load ptr, ptr %13, align 8, !tbaa !243
  store ptr %18, ptr %19, align 8, !tbaa !244
  %20 = getelementptr inbounds %struct.Mbuffer, ptr %19, i64 0, i32 2
  store i64 32, ptr %20, align 8, !tbaa !246
  %21 = load ptr, ptr %8, align 8, !tbaa !251
  %22 = load i64, ptr %21, align 8, !tbaa !252
  %23 = add i64 %22, -1
  store i64 %23, ptr %21, align 8, !tbaa !252
  %24 = icmp eq i64 %22, 0
  br i1 %24, label %31, label %25

25:                                               ; preds = %4
  %26 = getelementptr inbounds %struct.Zio, ptr %21, i64 0, i32 1
  %27 = load ptr, ptr %26, align 8, !tbaa !254
  %28 = getelementptr inbounds i8, ptr %27, i64 1
  store ptr %28, ptr %26, align 8, !tbaa !254
  %29 = load i8, ptr %27, align 1, !tbaa !33
  %30 = zext i8 %29 to i32
  br label %33

31:                                               ; preds = %4
  %32 = tail call i32 @luaZ_fill(ptr noundef nonnull %21) #46
  br label %33

33:                                               ; preds = %31, %25
  %34 = phi i32 [ %30, %25 ], [ %32, %31 ]
  store i32 %34, ptr %1, align 8, !tbaa !255
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaX_next(ptr noundef %0) #1 {
  %2 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 1
  %3 = load i32, ptr %2, align 4, !tbaa !242
  %4 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 2
  store i32 %3, ptr %4, align 8, !tbaa !67
  %5 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 4
  %6 = load i32, ptr %5, align 8, !tbaa !250
  %7 = icmp eq i32 %6, 287
  %8 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  br i1 %7, label %10, label %9

9:                                                ; preds = %1
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %8, ptr noundef nonnull align 8 dereferenceable(16) %5, i64 16, i1 false), !tbaa.struct !256
  store i32 287, ptr %5, align 8, !tbaa !250
  br label %13

10:                                               ; preds = %1
  %11 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3, i32 1
  %12 = tail call fastcc i32 @llex(ptr noundef nonnull %0, ptr noundef nonnull %11) #47
  store i32 %12, ptr %8, align 8, !tbaa !247
  br label %13

13:                                               ; preds = %10, %9
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @llex(ptr nocapture noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 8
  %4 = load ptr, ptr %3, align 8, !tbaa !243
  %5 = getelementptr inbounds %struct.Mbuffer, ptr %4, i64 0, i32 1
  store i64 0, ptr %5, align 8, !tbaa !245
  %6 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 7
  br label %7

7:                                                ; preds = %12, %2
  %8 = load i32, ptr %0, align 8, !tbaa !255
  br label %9

9:                                                ; preds = %415, %7
  %10 = phi i32 [ %8, %7 ], [ %416, %415 ]
  switch i32 %10, label %393 [
    i32 10, label %11
    i32 13, label %11
    i32 45, label %13
    i32 91, label %74
    i32 61, label %81
    i32 60, label %112
    i32 62, label %143
    i32 126, label %174
    i32 34, label %205
    i32 39, label %205
    i32 46, label %362
    i32 -1, label %478
  ]

11:                                               ; preds = %9, %9
  tail call fastcc void @inclinenumber(ptr noundef nonnull %0) #47
  br label %12

12:                                               ; preds = %57, %57, %57, %54, %11
  br label %7

13:                                               ; preds = %9
  %.lcssa2 = phi i32 [ %10, %9 ]
  %14 = load ptr, ptr %6, align 8, !tbaa !251
  %15 = load i64, ptr %14, align 8, !tbaa !252
  %16 = add i64 %15, -1
  store i64 %16, ptr %14, align 8, !tbaa !252
  %17 = icmp eq i64 %15, 0
  br i1 %17, label %24, label %18

18:                                               ; preds = %13
  %19 = getelementptr inbounds %struct.Zio, ptr %14, i64 0, i32 1
  %20 = load ptr, ptr %19, align 8, !tbaa !254
  %21 = getelementptr inbounds i8, ptr %20, i64 1
  store ptr %21, ptr %19, align 8, !tbaa !254
  %22 = load i8, ptr %20, align 1, !tbaa !33
  %23 = zext i8 %22 to i32
  br label %26

24:                                               ; preds = %13
  %25 = tail call i32 @luaZ_fill(ptr noundef nonnull %14) #46
  br label %26

26:                                               ; preds = %24, %18
  %27 = phi i32 [ %23, %18 ], [ %25, %24 ]
  store i32 %27, ptr %0, align 8, !tbaa !255
  %28 = icmp eq i32 %27, 45
  br i1 %28, label %29, label %478

29:                                               ; preds = %26
  %30 = load ptr, ptr %6, align 8, !tbaa !251
  %31 = load i64, ptr %30, align 8, !tbaa !252
  %32 = add i64 %31, -1
  store i64 %32, ptr %30, align 8, !tbaa !252
  %33 = icmp eq i64 %31, 0
  br i1 %33, label %40, label %34

34:                                               ; preds = %29
  %35 = getelementptr inbounds %struct.Zio, ptr %30, i64 0, i32 1
  %36 = load ptr, ptr %35, align 8, !tbaa !254
  %37 = getelementptr inbounds i8, ptr %36, i64 1
  store ptr %37, ptr %35, align 8, !tbaa !254
  %38 = load i8, ptr %36, align 1, !tbaa !33
  %39 = zext i8 %38 to i32
  br label %42

40:                                               ; preds = %29
  %41 = tail call i32 @luaZ_fill(ptr noundef nonnull %30) #46
  br label %42

42:                                               ; preds = %40, %34
  %43 = phi i32 [ %39, %34 ], [ %41, %40 ]
  store i32 %43, ptr %0, align 8, !tbaa !255
  %44 = icmp eq i32 %43, 91
  br i1 %44, label %47, label %45

45:                                               ; preds = %52, %42
  %46 = phi i32 [ %43, %42 ], [ %53, %52 ]
  br label %57

47:                                               ; preds = %42
  %48 = tail call fastcc i32 @skip_sep(ptr noundef nonnull %0) #47
  %49 = load ptr, ptr %3, align 8, !tbaa !243
  %50 = getelementptr inbounds %struct.Mbuffer, ptr %49, i64 0, i32 1
  store i64 0, ptr %50, align 8, !tbaa !245
  %51 = icmp sgt i32 %48, -1
  br i1 %51, label %54, label %52

52:                                               ; preds = %47
  %53 = load i32, ptr %0, align 8, !tbaa !255
  br label %45

54:                                               ; preds = %47
  tail call fastcc void @read_long_string(ptr noundef nonnull %0, ptr noundef null, i32 noundef %48) #47
  %55 = load ptr, ptr %3, align 8, !tbaa !243
  %56 = getelementptr inbounds %struct.Mbuffer, ptr %55, i64 0, i32 1
  store i64 0, ptr %56, align 8, !tbaa !245
  br label %12

57:                                               ; preds = %72, %45
  %58 = phi i32 [ %73, %72 ], [ %46, %45 ]
  switch i32 %58, label %59 [
    i32 10, label %12
    i32 13, label %12
    i32 -1, label %12
  ]

59:                                               ; preds = %57
  %60 = load ptr, ptr %6, align 8, !tbaa !251
  %61 = load i64, ptr %60, align 8, !tbaa !252
  %62 = add i64 %61, -1
  store i64 %62, ptr %60, align 8, !tbaa !252
  %63 = icmp eq i64 %61, 0
  br i1 %63, label %70, label %64

64:                                               ; preds = %59
  %65 = getelementptr inbounds %struct.Zio, ptr %60, i64 0, i32 1
  %66 = load ptr, ptr %65, align 8, !tbaa !254
  %67 = getelementptr inbounds i8, ptr %66, i64 1
  store ptr %67, ptr %65, align 8, !tbaa !254
  %68 = load i8, ptr %66, align 1, !tbaa !33
  %69 = zext i8 %68 to i32
  br label %72

70:                                               ; preds = %59
  %71 = tail call i32 @luaZ_fill(ptr noundef nonnull %60) #46
  br label %72

72:                                               ; preds = %70, %64
  %73 = phi i32 [ %69, %64 ], [ %71, %70 ]
  store i32 %73, ptr %0, align 8, !tbaa !255
  br label %57, !llvm.loop !257

74:                                               ; preds = %9
  %.lcssa3 = phi i32 [ %10, %9 ]
  %75 = tail call fastcc i32 @skip_sep(ptr noundef nonnull %0) #47
  %76 = icmp sgt i32 %75, -1
  br i1 %76, label %77, label %78

77:                                               ; preds = %74
  tail call fastcc void @read_long_string(ptr noundef nonnull %0, ptr noundef %1, i32 noundef %75) #47
  br label %478

78:                                               ; preds = %74
  %79 = icmp eq i32 %75, -1
  br i1 %79, label %478, label %80

80:                                               ; preds = %78
  tail call void @luaX_lexerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.36, i32 noundef 286) #47
  br label %81

81:                                               ; preds = %80, %9
  %.lcssa4 = phi i32 [ %.lcssa3, %80 ], [ %10, %9 ]
  %82 = load ptr, ptr %6, align 8, !tbaa !251
  %83 = load i64, ptr %82, align 8, !tbaa !252
  %84 = add i64 %83, -1
  store i64 %84, ptr %82, align 8, !tbaa !252
  %85 = icmp eq i64 %83, 0
  br i1 %85, label %92, label %86

86:                                               ; preds = %81
  %87 = getelementptr inbounds %struct.Zio, ptr %82, i64 0, i32 1
  %88 = load ptr, ptr %87, align 8, !tbaa !254
  %89 = getelementptr inbounds i8, ptr %88, i64 1
  store ptr %89, ptr %87, align 8, !tbaa !254
  %90 = load i8, ptr %88, align 1, !tbaa !33
  %91 = zext i8 %90 to i32
  br label %94

92:                                               ; preds = %81
  %93 = tail call i32 @luaZ_fill(ptr noundef nonnull %82) #46
  br label %94

94:                                               ; preds = %92, %86
  %95 = phi i32 [ %91, %86 ], [ %93, %92 ]
  store i32 %95, ptr %0, align 8, !tbaa !255
  %96 = icmp eq i32 %95, 61
  br i1 %96, label %97, label %478

97:                                               ; preds = %94
  %98 = load ptr, ptr %6, align 8, !tbaa !251
  %99 = load i64, ptr %98, align 8, !tbaa !252
  %100 = add i64 %99, -1
  store i64 %100, ptr %98, align 8, !tbaa !252
  %101 = icmp eq i64 %99, 0
  br i1 %101, label %108, label %102

102:                                              ; preds = %97
  %103 = getelementptr inbounds %struct.Zio, ptr %98, i64 0, i32 1
  %104 = load ptr, ptr %103, align 8, !tbaa !254
  %105 = getelementptr inbounds i8, ptr %104, i64 1
  store ptr %105, ptr %103, align 8, !tbaa !254
  %106 = load i8, ptr %104, align 1, !tbaa !33
  %107 = zext i8 %106 to i32
  br label %110

108:                                              ; preds = %97
  %109 = tail call i32 @luaZ_fill(ptr noundef nonnull %98) #46
  br label %110

110:                                              ; preds = %108, %102
  %111 = phi i32 [ %107, %102 ], [ %109, %108 ]
  store i32 %111, ptr %0, align 8, !tbaa !255
  br label %478

112:                                              ; preds = %9
  %.lcssa5 = phi i32 [ %10, %9 ]
  %113 = load ptr, ptr %6, align 8, !tbaa !251
  %114 = load i64, ptr %113, align 8, !tbaa !252
  %115 = add i64 %114, -1
  store i64 %115, ptr %113, align 8, !tbaa !252
  %116 = icmp eq i64 %114, 0
  br i1 %116, label %123, label %117

117:                                              ; preds = %112
  %118 = getelementptr inbounds %struct.Zio, ptr %113, i64 0, i32 1
  %119 = load ptr, ptr %118, align 8, !tbaa !254
  %120 = getelementptr inbounds i8, ptr %119, i64 1
  store ptr %120, ptr %118, align 8, !tbaa !254
  %121 = load i8, ptr %119, align 1, !tbaa !33
  %122 = zext i8 %121 to i32
  br label %125

123:                                              ; preds = %112
  %124 = tail call i32 @luaZ_fill(ptr noundef nonnull %113) #46
  br label %125

125:                                              ; preds = %123, %117
  %126 = phi i32 [ %122, %117 ], [ %124, %123 ]
  store i32 %126, ptr %0, align 8, !tbaa !255
  %127 = icmp eq i32 %126, 61
  br i1 %127, label %128, label %478

128:                                              ; preds = %125
  %129 = load ptr, ptr %6, align 8, !tbaa !251
  %130 = load i64, ptr %129, align 8, !tbaa !252
  %131 = add i64 %130, -1
  store i64 %131, ptr %129, align 8, !tbaa !252
  %132 = icmp eq i64 %130, 0
  br i1 %132, label %139, label %133

133:                                              ; preds = %128
  %134 = getelementptr inbounds %struct.Zio, ptr %129, i64 0, i32 1
  %135 = load ptr, ptr %134, align 8, !tbaa !254
  %136 = getelementptr inbounds i8, ptr %135, i64 1
  store ptr %136, ptr %134, align 8, !tbaa !254
  %137 = load i8, ptr %135, align 1, !tbaa !33
  %138 = zext i8 %137 to i32
  br label %141

139:                                              ; preds = %128
  %140 = tail call i32 @luaZ_fill(ptr noundef nonnull %129) #46
  br label %141

141:                                              ; preds = %139, %133
  %142 = phi i32 [ %138, %133 ], [ %140, %139 ]
  store i32 %142, ptr %0, align 8, !tbaa !255
  br label %478

143:                                              ; preds = %9
  %.lcssa6 = phi i32 [ %10, %9 ]
  %144 = load ptr, ptr %6, align 8, !tbaa !251
  %145 = load i64, ptr %144, align 8, !tbaa !252
  %146 = add i64 %145, -1
  store i64 %146, ptr %144, align 8, !tbaa !252
  %147 = icmp eq i64 %145, 0
  br i1 %147, label %154, label %148

148:                                              ; preds = %143
  %149 = getelementptr inbounds %struct.Zio, ptr %144, i64 0, i32 1
  %150 = load ptr, ptr %149, align 8, !tbaa !254
  %151 = getelementptr inbounds i8, ptr %150, i64 1
  store ptr %151, ptr %149, align 8, !tbaa !254
  %152 = load i8, ptr %150, align 1, !tbaa !33
  %153 = zext i8 %152 to i32
  br label %156

154:                                              ; preds = %143
  %155 = tail call i32 @luaZ_fill(ptr noundef nonnull %144) #46
  br label %156

156:                                              ; preds = %154, %148
  %157 = phi i32 [ %153, %148 ], [ %155, %154 ]
  store i32 %157, ptr %0, align 8, !tbaa !255
  %158 = icmp eq i32 %157, 61
  br i1 %158, label %159, label %478

159:                                              ; preds = %156
  %160 = load ptr, ptr %6, align 8, !tbaa !251
  %161 = load i64, ptr %160, align 8, !tbaa !252
  %162 = add i64 %161, -1
  store i64 %162, ptr %160, align 8, !tbaa !252
  %163 = icmp eq i64 %161, 0
  br i1 %163, label %170, label %164

164:                                              ; preds = %159
  %165 = getelementptr inbounds %struct.Zio, ptr %160, i64 0, i32 1
  %166 = load ptr, ptr %165, align 8, !tbaa !254
  %167 = getelementptr inbounds i8, ptr %166, i64 1
  store ptr %167, ptr %165, align 8, !tbaa !254
  %168 = load i8, ptr %166, align 1, !tbaa !33
  %169 = zext i8 %168 to i32
  br label %172

170:                                              ; preds = %159
  %171 = tail call i32 @luaZ_fill(ptr noundef nonnull %160) #46
  br label %172

172:                                              ; preds = %170, %164
  %173 = phi i32 [ %169, %164 ], [ %171, %170 ]
  store i32 %173, ptr %0, align 8, !tbaa !255
  br label %478

174:                                              ; preds = %9
  %.lcssa7 = phi i32 [ %10, %9 ]
  %175 = load ptr, ptr %6, align 8, !tbaa !251
  %176 = load i64, ptr %175, align 8, !tbaa !252
  %177 = add i64 %176, -1
  store i64 %177, ptr %175, align 8, !tbaa !252
  %178 = icmp eq i64 %176, 0
  br i1 %178, label %185, label %179

179:                                              ; preds = %174
  %180 = getelementptr inbounds %struct.Zio, ptr %175, i64 0, i32 1
  %181 = load ptr, ptr %180, align 8, !tbaa !254
  %182 = getelementptr inbounds i8, ptr %181, i64 1
  store ptr %182, ptr %180, align 8, !tbaa !254
  %183 = load i8, ptr %181, align 1, !tbaa !33
  %184 = zext i8 %183 to i32
  br label %187

185:                                              ; preds = %174
  %186 = tail call i32 @luaZ_fill(ptr noundef nonnull %175) #46
  br label %187

187:                                              ; preds = %185, %179
  %188 = phi i32 [ %184, %179 ], [ %186, %185 ]
  store i32 %188, ptr %0, align 8, !tbaa !255
  %189 = icmp eq i32 %188, 61
  br i1 %189, label %190, label %478

190:                                              ; preds = %187
  %191 = load ptr, ptr %6, align 8, !tbaa !251
  %192 = load i64, ptr %191, align 8, !tbaa !252
  %193 = add i64 %192, -1
  store i64 %193, ptr %191, align 8, !tbaa !252
  %194 = icmp eq i64 %192, 0
  br i1 %194, label %201, label %195

195:                                              ; preds = %190
  %196 = getelementptr inbounds %struct.Zio, ptr %191, i64 0, i32 1
  %197 = load ptr, ptr %196, align 8, !tbaa !254
  %198 = getelementptr inbounds i8, ptr %197, i64 1
  store ptr %198, ptr %196, align 8, !tbaa !254
  %199 = load i8, ptr %197, align 1, !tbaa !33
  %200 = zext i8 %199 to i32
  br label %203

201:                                              ; preds = %190
  %202 = tail call i32 @luaZ_fill(ptr noundef nonnull %191) #46
  br label %203

203:                                              ; preds = %201, %195
  %204 = phi i32 [ %200, %195 ], [ %202, %201 ]
  store i32 %204, ptr %0, align 8, !tbaa !255
  br label %478

205:                                              ; preds = %9, %9
  %.lcssa8 = phi i32 [ %10, %9 ], [ %10, %9 ]
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef %.lcssa8) #47
  %206 = load ptr, ptr %6, align 8, !tbaa !251
  %207 = load i64, ptr %206, align 8, !tbaa !252
  %208 = add i64 %207, -1
  store i64 %208, ptr %206, align 8, !tbaa !252
  %209 = icmp eq i64 %207, 0
  br i1 %209, label %216, label %210

210:                                              ; preds = %205
  %211 = getelementptr inbounds %struct.Zio, ptr %206, i64 0, i32 1
  %212 = load ptr, ptr %211, align 8, !tbaa !254
  %213 = getelementptr inbounds i8, ptr %212, i64 1
  store ptr %213, ptr %211, align 8, !tbaa !254
  %214 = load i8, ptr %212, align 1, !tbaa !33
  %215 = zext i8 %214 to i32
  br label %218

216:                                              ; preds = %205
  %217 = tail call i32 @luaZ_fill(ptr noundef nonnull %206) #46
  br label %218

218:                                              ; preds = %216, %210
  %219 = phi i32 [ %215, %210 ], [ %217, %216 ]
  store i32 %219, ptr %0, align 8, !tbaa !255
  %220 = icmp eq i32 %219, %.lcssa8
  br i1 %220, label %340, label %223

221:                                              ; preds = %320, %305, %270, %248, %240, %226, %225
  %222 = load i32, ptr %0, align 8, !tbaa !255
  br label %337

223:                                              ; preds = %337, %218
  %224 = phi i32 [ %338, %337 ], [ %219, %218 ]
  switch i32 %224, label %322 [
    i32 -1, label %225
    i32 10, label %226
    i32 13, label %226
    i32 92, label %227
  ]

225:                                              ; preds = %223
  tail call void @luaX_lexerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.42, i32 noundef 287) #47
  br label %221, !llvm.loop !258

226:                                              ; preds = %223, %223
  tail call void @luaX_lexerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.42, i32 noundef 286) #47
  br label %221, !llvm.loop !258

227:                                              ; preds = %223
  %228 = load ptr, ptr %6, align 8, !tbaa !251
  %229 = load i64, ptr %228, align 8, !tbaa !252
  %230 = add i64 %229, -1
  store i64 %230, ptr %228, align 8, !tbaa !252
  %231 = icmp eq i64 %229, 0
  br i1 %231, label %238, label %232

232:                                              ; preds = %227
  %233 = getelementptr inbounds %struct.Zio, ptr %228, i64 0, i32 1
  %234 = load ptr, ptr %233, align 8, !tbaa !254
  %235 = getelementptr inbounds i8, ptr %234, i64 1
  store ptr %235, ptr %233, align 8, !tbaa !254
  %236 = load i8, ptr %234, align 1, !tbaa !33
  %237 = zext i8 %236 to i32
  br label %240

238:                                              ; preds = %227
  %239 = tail call i32 @luaZ_fill(ptr noundef nonnull %228) #46
  br label %240

240:                                              ; preds = %238, %232
  %241 = phi i32 [ %237, %232 ], [ %239, %238 ]
  store i32 %241, ptr %0, align 8, !tbaa !255
  switch i32 %241, label %249 [
    i32 97, label %306
    i32 98, label %242
    i32 102, label %243
    i32 110, label %244
    i32 114, label %245
    i32 116, label %246
    i32 118, label %247
    i32 10, label %248
    i32 13, label %248
    i32 -1, label %221
  ], !llvm.loop !258

242:                                              ; preds = %240
  br label %306

243:                                              ; preds = %240
  br label %306

244:                                              ; preds = %240
  br label %306

245:                                              ; preds = %240
  br label %306

246:                                              ; preds = %240
  br label %306

247:                                              ; preds = %240
  br label %306

248:                                              ; preds = %240, %240
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef 10) #47
  tail call fastcc void @inclinenumber(ptr noundef nonnull %0) #47
  br label %221, !llvm.loop !258

249:                                              ; preds = %240
  %250 = tail call ptr @__ctype_b_loc() #52
  %251 = load ptr, ptr %250, align 8, !tbaa !39
  %252 = sext i32 %241 to i64
  %253 = getelementptr inbounds i16, ptr %251, i64 %252
  %254 = load i16, ptr %253, align 2, !tbaa !239
  %255 = and i16 %254, 2048
  %256 = icmp eq i16 %255, 0
  br i1 %256, label %257, label %272

257:                                              ; preds = %249
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef %241) #47
  %258 = load ptr, ptr %6, align 8, !tbaa !251
  %259 = load i64, ptr %258, align 8, !tbaa !252
  %260 = add i64 %259, -1
  store i64 %260, ptr %258, align 8, !tbaa !252
  %261 = icmp eq i64 %259, 0
  br i1 %261, label %268, label %262

262:                                              ; preds = %257
  %263 = getelementptr inbounds %struct.Zio, ptr %258, i64 0, i32 1
  %264 = load ptr, ptr %263, align 8, !tbaa !254
  %265 = getelementptr inbounds i8, ptr %264, i64 1
  store ptr %265, ptr %263, align 8, !tbaa !254
  %266 = load i8, ptr %264, align 1, !tbaa !33
  %267 = zext i8 %266 to i32
  br label %270

268:                                              ; preds = %257
  %269 = tail call i32 @luaZ_fill(ptr noundef nonnull %258) #46
  br label %270

270:                                              ; preds = %268, %262
  %271 = phi i32 [ %267, %262 ], [ %269, %268 ]
  store i32 %271, ptr %0, align 8, !tbaa !255
  br label %221, !llvm.loop !258

272:                                              ; preds = %294, %249
  %273 = phi i32 [ %292, %294 ], [ %241, %249 ]
  %274 = phi i32 [ %278, %294 ], [ 0, %249 ]
  %275 = phi i32 [ %295, %294 ], [ 0, %249 ]
  %276 = mul nsw i32 %274, 10
  %277 = add i32 %273, -48
  %278 = add i32 %277, %276
  %279 = load ptr, ptr %6, align 8, !tbaa !251
  %280 = load i64, ptr %279, align 8, !tbaa !252
  %281 = add i64 %280, -1
  store i64 %281, ptr %279, align 8, !tbaa !252
  %282 = icmp eq i64 %280, 0
  br i1 %282, label %289, label %283

283:                                              ; preds = %272
  %284 = getelementptr inbounds %struct.Zio, ptr %279, i64 0, i32 1
  %285 = load ptr, ptr %284, align 8, !tbaa !254
  %286 = getelementptr inbounds i8, ptr %285, i64 1
  store ptr %286, ptr %284, align 8, !tbaa !254
  %287 = load i8, ptr %285, align 1, !tbaa !33
  %288 = zext i8 %287 to i32
  br label %291

289:                                              ; preds = %272
  %290 = tail call i32 @luaZ_fill(ptr noundef nonnull %279) #46
  br label %291

291:                                              ; preds = %289, %283
  %292 = phi i32 [ %288, %283 ], [ %290, %289 ]
  store i32 %292, ptr %0, align 8, !tbaa !255
  %293 = icmp eq i32 %275, 2
  br i1 %293, label %302, label %294

294:                                              ; preds = %291
  %295 = add nuw nsw i32 %275, 1
  %296 = load ptr, ptr %250, align 8, !tbaa !39
  %297 = sext i32 %292 to i64
  %298 = getelementptr inbounds i16, ptr %296, i64 %297
  %299 = load i16, ptr %298, align 2, !tbaa !239
  %300 = and i16 %299, 2048
  %301 = icmp eq i16 %300, 0
  br i1 %301, label %302, label %272, !llvm.loop !259

302:                                              ; preds = %294, %291
  %.lcssa = phi i32 [ %278, %294 ], [ %278, %291 ]
  %303 = icmp sgt i32 %.lcssa, 255
  br i1 %303, label %304, label %305

304:                                              ; preds = %302
  tail call void @luaX_lexerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.43, i32 noundef 286) #47
  br label %305

305:                                              ; preds = %304, %302
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef %.lcssa) #47
  br label %221, !llvm.loop !258

306:                                              ; preds = %247, %246, %245, %244, %243, %242, %240
  %307 = phi i32 [ 11, %247 ], [ 9, %246 ], [ 13, %245 ], [ 10, %244 ], [ 12, %243 ], [ 8, %242 ], [ 7, %240 ]
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef %307) #47
  %308 = load ptr, ptr %6, align 8, !tbaa !251
  %309 = load i64, ptr %308, align 8, !tbaa !252
  %310 = add i64 %309, -1
  store i64 %310, ptr %308, align 8, !tbaa !252
  %311 = icmp eq i64 %309, 0
  br i1 %311, label %318, label %312

312:                                              ; preds = %306
  %313 = getelementptr inbounds %struct.Zio, ptr %308, i64 0, i32 1
  %314 = load ptr, ptr %313, align 8, !tbaa !254
  %315 = getelementptr inbounds i8, ptr %314, i64 1
  store ptr %315, ptr %313, align 8, !tbaa !254
  %316 = load i8, ptr %314, align 1, !tbaa !33
  %317 = zext i8 %316 to i32
  br label %320

318:                                              ; preds = %306
  %319 = tail call i32 @luaZ_fill(ptr noundef nonnull %308) #46
  br label %320

320:                                              ; preds = %318, %312
  %321 = phi i32 [ %317, %312 ], [ %319, %318 ]
  store i32 %321, ptr %0, align 8, !tbaa !255
  br label %221, !llvm.loop !258

322:                                              ; preds = %223
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef %224) #47
  %323 = load ptr, ptr %6, align 8, !tbaa !251
  %324 = load i64, ptr %323, align 8, !tbaa !252
  %325 = add i64 %324, -1
  store i64 %325, ptr %323, align 8, !tbaa !252
  %326 = icmp eq i64 %324, 0
  br i1 %326, label %333, label %327

327:                                              ; preds = %322
  %328 = getelementptr inbounds %struct.Zio, ptr %323, i64 0, i32 1
  %329 = load ptr, ptr %328, align 8, !tbaa !254
  %330 = getelementptr inbounds i8, ptr %329, i64 1
  store ptr %330, ptr %328, align 8, !tbaa !254
  %331 = load i8, ptr %329, align 1, !tbaa !33
  %332 = zext i8 %331 to i32
  br label %335

333:                                              ; preds = %322
  %334 = tail call i32 @luaZ_fill(ptr noundef nonnull %323) #46
  br label %335

335:                                              ; preds = %333, %327
  %336 = phi i32 [ %332, %327 ], [ %334, %333 ]
  store i32 %336, ptr %0, align 8, !tbaa !255
  br label %337

337:                                              ; preds = %335, %221
  %338 = phi i32 [ %222, %221 ], [ %336, %335 ]
  %339 = icmp eq i32 %338, %.lcssa8
  br i1 %339, label %340, label %223, !llvm.loop !258

340:                                              ; preds = %337, %218
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef %.lcssa8) #47
  %341 = load ptr, ptr %6, align 8, !tbaa !251
  %342 = load i64, ptr %341, align 8, !tbaa !252
  %343 = add i64 %342, -1
  store i64 %343, ptr %341, align 8, !tbaa !252
  %344 = icmp eq i64 %342, 0
  br i1 %344, label %351, label %345

345:                                              ; preds = %340
  %346 = getelementptr inbounds %struct.Zio, ptr %341, i64 0, i32 1
  %347 = load ptr, ptr %346, align 8, !tbaa !254
  %348 = getelementptr inbounds i8, ptr %347, i64 1
  store ptr %348, ptr %346, align 8, !tbaa !254
  %349 = load i8, ptr %347, align 1, !tbaa !33
  %350 = zext i8 %349 to i32
  br label %353

351:                                              ; preds = %340
  %352 = tail call i32 @luaZ_fill(ptr noundef nonnull %341) #46
  br label %353

353:                                              ; preds = %351, %345
  %354 = phi i32 [ %350, %345 ], [ %352, %351 ]
  store i32 %354, ptr %0, align 8, !tbaa !255
  %355 = load ptr, ptr %3, align 8, !tbaa !243
  %356 = load ptr, ptr %355, align 8, !tbaa !244
  %357 = getelementptr inbounds i8, ptr %356, i64 1
  %358 = getelementptr inbounds %struct.Mbuffer, ptr %355, i64 0, i32 1
  %359 = load i64, ptr %358, align 8, !tbaa !245
  %360 = add i64 %359, -2
  %361 = tail call ptr @luaX_newstring(ptr noundef nonnull %0, ptr noundef nonnull %357, i64 noundef %360) #47
  store ptr %361, ptr %1, align 8, !tbaa !33
  br label %478

362:                                              ; preds = %9
  %.lcssa9 = phi i32 [ %10, %9 ]
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef 46) #47
  %363 = load ptr, ptr %6, align 8, !tbaa !251
  %364 = load i64, ptr %363, align 8, !tbaa !252
  %365 = add i64 %364, -1
  store i64 %365, ptr %363, align 8, !tbaa !252
  %366 = icmp eq i64 %364, 0
  br i1 %366, label %373, label %367

367:                                              ; preds = %362
  %368 = getelementptr inbounds %struct.Zio, ptr %363, i64 0, i32 1
  %369 = load ptr, ptr %368, align 8, !tbaa !254
  %370 = getelementptr inbounds i8, ptr %369, i64 1
  store ptr %370, ptr %368, align 8, !tbaa !254
  %371 = load i8, ptr %369, align 1, !tbaa !33
  %372 = zext i8 %371 to i32
  br label %375

373:                                              ; preds = %362
  %374 = tail call i32 @luaZ_fill(ptr noundef nonnull %363) #46
  br label %375

375:                                              ; preds = %373, %367
  %376 = phi i32 [ %372, %367 ], [ %374, %373 ]
  store i32 %376, ptr %0, align 8, !tbaa !255
  %377 = tail call fastcc i32 @check_next(ptr noundef nonnull %0, ptr noundef nonnull @.str.37) #47, !range !75
  %378 = icmp eq i32 %377, 0
  br i1 %378, label %383, label %379

379:                                              ; preds = %375
  %380 = tail call fastcc i32 @check_next(ptr noundef nonnull %0, ptr noundef nonnull @.str.37) #47, !range !75
  %381 = icmp eq i32 %380, 0
  %382 = select i1 %381, i32 278, i32 279
  br label %478

383:                                              ; preds = %375
  %384 = tail call ptr @__ctype_b_loc() #52
  %385 = load ptr, ptr %384, align 8, !tbaa !39
  %386 = load i32, ptr %0, align 8, !tbaa !255
  %387 = sext i32 %386 to i64
  %388 = getelementptr inbounds i16, ptr %385, i64 %387
  %389 = load i16, ptr %388, align 2, !tbaa !239
  %390 = and i16 %389, 2048
  %391 = icmp eq i16 %390, 0
  br i1 %391, label %478, label %392

392:                                              ; preds = %383
  tail call fastcc void @read_numeral(ptr noundef nonnull %0, ptr noundef %1) #47
  br label %478

393:                                              ; preds = %9
  %394 = tail call ptr @__ctype_b_loc() #52
  %395 = load ptr, ptr %394, align 8, !tbaa !39
  %396 = sext i32 %10 to i64
  %397 = getelementptr inbounds i16, ptr %395, i64 %396
  %398 = load i16, ptr %397, align 2, !tbaa !239
  %399 = zext i16 %398 to i32
  %400 = and i32 %399, 8192
  %401 = icmp eq i32 %400, 0
  br i1 %401, label %417, label %402

402:                                              ; preds = %393
  %403 = load ptr, ptr %6, align 8, !tbaa !251
  %404 = load i64, ptr %403, align 8, !tbaa !252
  %405 = add i64 %404, -1
  store i64 %405, ptr %403, align 8, !tbaa !252
  %406 = icmp eq i64 %404, 0
  br i1 %406, label %413, label %407

407:                                              ; preds = %402
  %408 = getelementptr inbounds %struct.Zio, ptr %403, i64 0, i32 1
  %409 = load ptr, ptr %408, align 8, !tbaa !254
  %410 = getelementptr inbounds i8, ptr %409, i64 1
  store ptr %410, ptr %408, align 8, !tbaa !254
  %411 = load i8, ptr %409, align 1, !tbaa !33
  %412 = zext i8 %411 to i32
  br label %415

413:                                              ; preds = %402
  %414 = tail call i32 @luaZ_fill(ptr noundef nonnull %403) #46
  br label %415

415:                                              ; preds = %413, %407
  %416 = phi i32 [ %412, %407 ], [ %414, %413 ]
  store i32 %416, ptr %0, align 8, !tbaa !255
  br label %9

417:                                              ; preds = %393
  %.lcssa13 = phi ptr [ %394, %393 ]
  %.lcssa12 = phi i32 [ %399, %393 ]
  %.lcssa11 = phi i32 [ %10, %393 ]
  %418 = and i32 %.lcssa12, 2048
  %419 = icmp eq i32 %418, 0
  br i1 %419, label %421, label %420

420:                                              ; preds = %417
  tail call fastcc void @read_numeral(ptr noundef nonnull %0, ptr noundef %1) #47
  br label %478

421:                                              ; preds = %417
  %422 = and i32 %.lcssa12, 1024
  %423 = icmp ne i32 %422, 0
  %424 = icmp eq i32 %.lcssa11, 95
  %425 = or i1 %424, %423
  br i1 %425, label %426, label %463

426:                                              ; preds = %440, %421
  %427 = phi i32 [ %441, %440 ], [ %.lcssa11, %421 ]
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef %427) #47
  %428 = load ptr, ptr %6, align 8, !tbaa !251
  %429 = load i64, ptr %428, align 8, !tbaa !252
  %430 = add i64 %429, -1
  store i64 %430, ptr %428, align 8, !tbaa !252
  %431 = icmp eq i64 %429, 0
  br i1 %431, label %438, label %432

432:                                              ; preds = %426
  %433 = getelementptr inbounds %struct.Zio, ptr %428, i64 0, i32 1
  %434 = load ptr, ptr %433, align 8, !tbaa !254
  %435 = getelementptr inbounds i8, ptr %434, i64 1
  store ptr %435, ptr %433, align 8, !tbaa !254
  %436 = load i8, ptr %434, align 1, !tbaa !33
  %437 = zext i8 %436 to i32
  br label %440

438:                                              ; preds = %426
  %439 = tail call i32 @luaZ_fill(ptr noundef nonnull %428) #46
  br label %440

440:                                              ; preds = %438, %432
  %441 = phi i32 [ %437, %432 ], [ %439, %438 ]
  store i32 %441, ptr %0, align 8, !tbaa !255
  %442 = load ptr, ptr %.lcssa13, align 8, !tbaa !39
  %443 = sext i32 %441 to i64
  %444 = getelementptr inbounds i16, ptr %442, i64 %443
  %445 = load i16, ptr %444, align 2, !tbaa !239
  %446 = and i16 %445, 8
  %447 = icmp ne i16 %446, 0
  %448 = icmp eq i32 %441, 95
  %449 = or i1 %448, %447
  br i1 %449, label %426, label %450, !llvm.loop !260

450:                                              ; preds = %440
  %451 = load ptr, ptr %3, align 8, !tbaa !243
  %452 = load ptr, ptr %451, align 8, !tbaa !244
  %453 = getelementptr inbounds %struct.Mbuffer, ptr %451, i64 0, i32 1
  %454 = load i64, ptr %453, align 8, !tbaa !245
  %455 = tail call ptr @luaX_newstring(ptr noundef nonnull %0, ptr noundef %452, i64 noundef %454) #47
  %456 = getelementptr inbounds %struct.anon.0, ptr %455, i64 0, i32 3
  %457 = load i8, ptr %456, align 2, !tbaa !33
  %458 = icmp eq i8 %457, 0
  br i1 %458, label %462, label %459

459:                                              ; preds = %450
  %460 = zext i8 %457 to i32
  %461 = or i32 %460, 256
  br label %478

462:                                              ; preds = %450
  store ptr %455, ptr %1, align 8, !tbaa !33
  br label %478

463:                                              ; preds = %421
  %464 = load ptr, ptr %6, align 8, !tbaa !251
  %465 = load i64, ptr %464, align 8, !tbaa !252
  %466 = add i64 %465, -1
  store i64 %466, ptr %464, align 8, !tbaa !252
  %467 = icmp eq i64 %465, 0
  br i1 %467, label %474, label %468

468:                                              ; preds = %463
  %469 = getelementptr inbounds %struct.Zio, ptr %464, i64 0, i32 1
  %470 = load ptr, ptr %469, align 8, !tbaa !254
  %471 = getelementptr inbounds i8, ptr %470, i64 1
  store ptr %471, ptr %469, align 8, !tbaa !254
  %472 = load i8, ptr %470, align 1, !tbaa !33
  %473 = zext i8 %472 to i32
  br label %476

474:                                              ; preds = %463
  %475 = tail call i32 @luaZ_fill(ptr noundef nonnull %464) #46
  br label %476

476:                                              ; preds = %474, %468
  %477 = phi i32 [ %473, %468 ], [ %475, %474 ]
  store i32 %477, ptr %0, align 8, !tbaa !255
  br label %478

478:                                              ; preds = %476, %462, %459, %420, %392, %383, %379, %353, %203, %187, %172, %156, %141, %125, %110, %94, %78, %77, %26, %9
  %479 = phi i32 [ 284, %420 ], [ %.lcssa11, %476 ], [ 284, %392 ], [ 286, %353 ], [ 283, %203 ], [ 281, %172 ], [ 282, %141 ], [ 280, %110 ], [ 61, %94 ], [ 60, %125 ], [ 62, %156 ], [ 126, %187 ], [ %382, %379 ], [ 46, %383 ], [ %461, %459 ], [ 285, %462 ], [ 91, %78 ], [ 286, %77 ], [ 287, %9 ], [ 45, %26 ]
  ret i32 %479
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @inclinenumber(ptr nocapture noundef %0) unnamed_addr #1 {
  %2 = load i32, ptr %0, align 8, !tbaa !255
  %3 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 7
  %4 = load ptr, ptr %3, align 8, !tbaa !251
  %5 = load i64, ptr %4, align 8, !tbaa !252
  %6 = add i64 %5, -1
  store i64 %6, ptr %4, align 8, !tbaa !252
  %7 = icmp eq i64 %5, 0
  br i1 %7, label %14, label %8

8:                                                ; preds = %1
  %9 = getelementptr inbounds %struct.Zio, ptr %4, i64 0, i32 1
  %10 = load ptr, ptr %9, align 8, !tbaa !254
  %11 = getelementptr inbounds i8, ptr %10, i64 1
  store ptr %11, ptr %9, align 8, !tbaa !254
  %12 = load i8, ptr %10, align 1, !tbaa !33
  %13 = zext i8 %12 to i32
  br label %16

14:                                               ; preds = %1
  %15 = tail call i32 @luaZ_fill(ptr noundef nonnull %4) #46
  br label %16

16:                                               ; preds = %14, %8
  %17 = phi i32 [ %13, %8 ], [ %15, %14 ]
  store i32 %17, ptr %0, align 8, !tbaa !255
  switch i32 %17, label %35 [
    i32 10, label %18
    i32 13, label %18
  ]

18:                                               ; preds = %16, %16
  %19 = icmp eq i32 %17, %2
  br i1 %19, label %35, label %20

20:                                               ; preds = %18
  %21 = load ptr, ptr %3, align 8, !tbaa !251
  %22 = load i64, ptr %21, align 8, !tbaa !252
  %23 = add i64 %22, -1
  store i64 %23, ptr %21, align 8, !tbaa !252
  %24 = icmp eq i64 %22, 0
  br i1 %24, label %31, label %25

25:                                               ; preds = %20
  %26 = getelementptr inbounds %struct.Zio, ptr %21, i64 0, i32 1
  %27 = load ptr, ptr %26, align 8, !tbaa !254
  %28 = getelementptr inbounds i8, ptr %27, i64 1
  store ptr %28, ptr %26, align 8, !tbaa !254
  %29 = load i8, ptr %27, align 1, !tbaa !33
  %30 = zext i8 %29 to i32
  br label %33

31:                                               ; preds = %20
  %32 = tail call i32 @luaZ_fill(ptr noundef nonnull %21) #46
  br label %33

33:                                               ; preds = %31, %25
  %34 = phi i32 [ %30, %25 ], [ %32, %31 ]
  store i32 %34, ptr %0, align 8, !tbaa !255
  br label %35

35:                                               ; preds = %33, %18, %16
  %36 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 1
  %37 = load i32, ptr %36, align 4, !tbaa !242
  %38 = add nsw i32 %37, 1
  store i32 %38, ptr %36, align 4, !tbaa !242
  %39 = icmp sgt i32 %37, 2147483643
  br i1 %39, label %40, label %43

40:                                               ; preds = %35
  %41 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  %42 = load i32, ptr %41, align 8, !tbaa !247
  tail call void @luaX_lexerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.38, i32 noundef %42) #47
  br label %43

43:                                               ; preds = %40, %35
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @skip_sep(ptr nocapture noundef %0) unnamed_addr #1 {
  %2 = load i32, ptr %0, align 8, !tbaa !255
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef %2) #47
  %3 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 7
  %4 = load ptr, ptr %3, align 8, !tbaa !251
  %5 = load i64, ptr %4, align 8, !tbaa !252
  %6 = add i64 %5, -1
  store i64 %6, ptr %4, align 8, !tbaa !252
  %7 = icmp eq i64 %5, 0
  br i1 %7, label %14, label %8

8:                                                ; preds = %1
  %9 = getelementptr inbounds %struct.Zio, ptr %4, i64 0, i32 1
  %10 = load ptr, ptr %9, align 8, !tbaa !254
  %11 = getelementptr inbounds i8, ptr %10, i64 1
  store ptr %11, ptr %9, align 8, !tbaa !254
  %12 = load i8, ptr %10, align 1, !tbaa !33
  %13 = zext i8 %12 to i32
  br label %16

14:                                               ; preds = %1
  %15 = tail call i32 @luaZ_fill(ptr noundef nonnull %4) #46
  br label %16

16:                                               ; preds = %14, %8
  %17 = phi i32 [ %13, %8 ], [ %15, %14 ]
  store i32 %17, ptr %0, align 8, !tbaa !255
  %18 = icmp eq i32 %17, 61
  br i1 %18, label %19, label %37

19:                                               ; preds = %33, %16
  %20 = phi i32 [ %35, %33 ], [ 0, %16 ]
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef 61) #47
  %21 = load ptr, ptr %3, align 8, !tbaa !251
  %22 = load i64, ptr %21, align 8, !tbaa !252
  %23 = add i64 %22, -1
  store i64 %23, ptr %21, align 8, !tbaa !252
  %24 = icmp eq i64 %22, 0
  br i1 %24, label %31, label %25

25:                                               ; preds = %19
  %26 = getelementptr inbounds %struct.Zio, ptr %21, i64 0, i32 1
  %27 = load ptr, ptr %26, align 8, !tbaa !254
  %28 = getelementptr inbounds i8, ptr %27, i64 1
  store ptr %28, ptr %26, align 8, !tbaa !254
  %29 = load i8, ptr %27, align 1, !tbaa !33
  %30 = zext i8 %29 to i32
  br label %33

31:                                               ; preds = %19
  %32 = tail call i32 @luaZ_fill(ptr noundef nonnull %21) #46
  br label %33

33:                                               ; preds = %31, %25
  %34 = phi i32 [ %30, %25 ], [ %32, %31 ]
  store i32 %34, ptr %0, align 8, !tbaa !255
  %35 = add nuw nsw i32 %20, 1
  %36 = icmp eq i32 %34, 61
  br i1 %36, label %19, label %37, !llvm.loop !261

37:                                               ; preds = %33, %16
  %38 = phi i32 [ %17, %16 ], [ %34, %33 ]
  %39 = phi i32 [ 0, %16 ], [ %35, %33 ]
  %40 = icmp ne i32 %38, %2
  %41 = sext i1 %40 to i32
  %42 = xor i32 %39, %41
  ret i32 %42
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @read_long_string(ptr nocapture noundef %0, ptr noundef writeonly %1, i32 noundef %2) unnamed_addr #1 {
  %4 = load i32, ptr %0, align 8, !tbaa !255
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef %4) #47
  %5 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 7
  %6 = load ptr, ptr %5, align 8, !tbaa !251
  %7 = load i64, ptr %6, align 8, !tbaa !252
  %8 = add i64 %7, -1
  store i64 %8, ptr %6, align 8, !tbaa !252
  %9 = icmp eq i64 %7, 0
  br i1 %9, label %16, label %10

10:                                               ; preds = %3
  %11 = getelementptr inbounds %struct.Zio, ptr %6, i64 0, i32 1
  %12 = load ptr, ptr %11, align 8, !tbaa !254
  %13 = getelementptr inbounds i8, ptr %12, i64 1
  store ptr %13, ptr %11, align 8, !tbaa !254
  %14 = load i8, ptr %12, align 1, !tbaa !33
  %15 = zext i8 %14 to i32
  br label %18

16:                                               ; preds = %3
  %17 = tail call i32 @luaZ_fill(ptr noundef nonnull %6) #46
  br label %18

18:                                               ; preds = %16, %10
  %19 = phi i32 [ %15, %10 ], [ %17, %16 ]
  store i32 %19, ptr %0, align 8, !tbaa !255
  switch i32 %19, label %21 [
    i32 10, label %20
    i32 13, label %20
  ]

20:                                               ; preds = %18, %18
  tail call fastcc void @inclinenumber(ptr noundef nonnull %0) #47
  br label %21

21:                                               ; preds = %20, %18
  %22 = icmp eq ptr %1, null
  %23 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 8
  %24 = icmp eq i32 %2, 0
  %25 = select i1 %22, ptr @.str.40, ptr @.str.39
  br label %26

26:                                               ; preds = %88, %21
  %27 = load i32, ptr %0, align 8, !tbaa !255
  switch i32 %27, label %72 [
    i32 -1, label %28
    i32 91, label %29
    i32 93, label %49
    i32 10, label %68
    i32 13, label %68
  ]

28:                                               ; preds = %26
  tail call void @luaX_lexerror(ptr noundef nonnull %0, ptr noundef nonnull %25, i32 noundef 287) #47
  br label %88

29:                                               ; preds = %26
  %30 = tail call fastcc i32 @skip_sep(ptr noundef nonnull %0) #47
  %31 = icmp eq i32 %30, %2
  br i1 %31, label %32, label %88

32:                                               ; preds = %29
  %33 = load i32, ptr %0, align 8, !tbaa !255
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef %33) #47
  %34 = load ptr, ptr %5, align 8, !tbaa !251
  %35 = load i64, ptr %34, align 8, !tbaa !252
  %36 = add i64 %35, -1
  store i64 %36, ptr %34, align 8, !tbaa !252
  %37 = icmp eq i64 %35, 0
  br i1 %37, label %44, label %38

38:                                               ; preds = %32
  %39 = getelementptr inbounds %struct.Zio, ptr %34, i64 0, i32 1
  %40 = load ptr, ptr %39, align 8, !tbaa !254
  %41 = getelementptr inbounds i8, ptr %40, i64 1
  store ptr %41, ptr %39, align 8, !tbaa !254
  %42 = load i8, ptr %40, align 1, !tbaa !33
  %43 = zext i8 %42 to i32
  br label %46

44:                                               ; preds = %32
  %45 = tail call i32 @luaZ_fill(ptr noundef nonnull %34) #46
  br label %46

46:                                               ; preds = %44, %38
  %47 = phi i32 [ %43, %38 ], [ %45, %44 ]
  store i32 %47, ptr %0, align 8, !tbaa !255
  br i1 %24, label %48, label %88

48:                                               ; preds = %46
  tail call void @luaX_lexerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.41, i32 noundef 91) #47
  br label %88

49:                                               ; preds = %26
  %50 = tail call fastcc i32 @skip_sep(ptr noundef nonnull %0) #47
  %51 = icmp eq i32 %50, %2
  br i1 %51, label %52, label %88

52:                                               ; preds = %49
  %53 = load i32, ptr %0, align 8, !tbaa !255
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef %53) #47
  %54 = load ptr, ptr %5, align 8, !tbaa !251
  %55 = load i64, ptr %54, align 8, !tbaa !252
  %56 = add i64 %55, -1
  store i64 %56, ptr %54, align 8, !tbaa !252
  %57 = icmp eq i64 %55, 0
  br i1 %57, label %64, label %58

58:                                               ; preds = %52
  %59 = getelementptr inbounds %struct.Zio, ptr %54, i64 0, i32 1
  %60 = load ptr, ptr %59, align 8, !tbaa !254
  %61 = getelementptr inbounds i8, ptr %60, i64 1
  store ptr %61, ptr %59, align 8, !tbaa !254
  %62 = load i8, ptr %60, align 1, !tbaa !33
  %63 = zext i8 %62 to i32
  br label %66

64:                                               ; preds = %52
  %65 = tail call i32 @luaZ_fill(ptr noundef nonnull %54) #46
  br label %66

66:                                               ; preds = %64, %58
  %67 = phi i32 [ %63, %58 ], [ %65, %64 ]
  store i32 %67, ptr %0, align 8, !tbaa !255
  br i1 %22, label %116, label %104

68:                                               ; preds = %26, %26
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef 10) #47
  tail call fastcc void @inclinenumber(ptr noundef nonnull %0) #47
  br i1 %22, label %69, label %88

69:                                               ; preds = %68
  %70 = load ptr, ptr %23, align 8, !tbaa !243
  %71 = getelementptr inbounds %struct.Mbuffer, ptr %70, i64 0, i32 1
  store i64 0, ptr %71, align 8, !tbaa !245
  br label %88

72:                                               ; preds = %26
  br i1 %22, label %89, label %73

73:                                               ; preds = %72
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef %27) #47
  %74 = load ptr, ptr %5, align 8, !tbaa !251
  %75 = load i64, ptr %74, align 8, !tbaa !252
  %76 = add i64 %75, -1
  store i64 %76, ptr %74, align 8, !tbaa !252
  %77 = icmp eq i64 %75, 0
  br i1 %77, label %84, label %78

78:                                               ; preds = %73
  %79 = getelementptr inbounds %struct.Zio, ptr %74, i64 0, i32 1
  %80 = load ptr, ptr %79, align 8, !tbaa !254
  %81 = getelementptr inbounds i8, ptr %80, i64 1
  store ptr %81, ptr %79, align 8, !tbaa !254
  %82 = load i8, ptr %80, align 1, !tbaa !33
  %83 = zext i8 %82 to i32
  br label %86

84:                                               ; preds = %73
  %85 = tail call i32 @luaZ_fill(ptr noundef nonnull %74) #46
  br label %86

86:                                               ; preds = %84, %78
  %87 = phi i32 [ %83, %78 ], [ %85, %84 ]
  store i32 %87, ptr %0, align 8, !tbaa !255
  br label %88

88:                                               ; preds = %102, %86, %69, %68, %49, %48, %46, %29, %28
  br label %26

89:                                               ; preds = %72
  %90 = load ptr, ptr %5, align 8, !tbaa !251
  %91 = load i64, ptr %90, align 8, !tbaa !252
  %92 = add i64 %91, -1
  store i64 %92, ptr %90, align 8, !tbaa !252
  %93 = icmp eq i64 %91, 0
  br i1 %93, label %100, label %94

94:                                               ; preds = %89
  %95 = getelementptr inbounds %struct.Zio, ptr %90, i64 0, i32 1
  %96 = load ptr, ptr %95, align 8, !tbaa !254
  %97 = getelementptr inbounds i8, ptr %96, i64 1
  store ptr %97, ptr %95, align 8, !tbaa !254
  %98 = load i8, ptr %96, align 1, !tbaa !33
  %99 = zext i8 %98 to i32
  br label %102

100:                                              ; preds = %89
  %101 = tail call i32 @luaZ_fill(ptr noundef nonnull %90) #46
  br label %102

102:                                              ; preds = %100, %94
  %103 = phi i32 [ %99, %94 ], [ %101, %100 ]
  store i32 %103, ptr %0, align 8, !tbaa !255
  br label %88

104:                                              ; preds = %66
  %105 = load ptr, ptr %23, align 8, !tbaa !243
  %106 = load ptr, ptr %105, align 8, !tbaa !244
  %107 = add nuw nsw i32 %2, 2
  %108 = sext i32 %107 to i64
  %109 = getelementptr inbounds i8, ptr %106, i64 %108
  %110 = getelementptr inbounds %struct.Mbuffer, ptr %105, i64 0, i32 1
  %111 = load i64, ptr %110, align 8, !tbaa !245
  %112 = shl nsw i32 %107, 1
  %113 = sext i32 %112 to i64
  %114 = sub i64 %111, %113
  %115 = tail call ptr @luaX_newstring(ptr noundef nonnull %0, ptr noundef nonnull %109, i64 noundef %114) #47
  store ptr %115, ptr %1, align 8, !tbaa !33
  br label %116

116:                                              ; preds = %104, %66
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @check_next(ptr nocapture noundef %0, ptr noundef readonly %1) unnamed_addr #1 {
  %3 = load i32, ptr %0, align 8, !tbaa !255
  %4 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %1, i32 noundef %3) #49
  %5 = icmp eq ptr %4, null
  br i1 %5, label %22, label %6

6:                                                ; preds = %2
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef %3) #47
  %7 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 7
  %8 = load ptr, ptr %7, align 8, !tbaa !251
  %9 = load i64, ptr %8, align 8, !tbaa !252
  %10 = add i64 %9, -1
  store i64 %10, ptr %8, align 8, !tbaa !252
  %11 = icmp eq i64 %9, 0
  br i1 %11, label %18, label %12

12:                                               ; preds = %6
  %13 = getelementptr inbounds %struct.Zio, ptr %8, i64 0, i32 1
  %14 = load ptr, ptr %13, align 8, !tbaa !254
  %15 = getelementptr inbounds i8, ptr %14, i64 1
  store ptr %15, ptr %13, align 8, !tbaa !254
  %16 = load i8, ptr %14, align 1, !tbaa !33
  %17 = zext i8 %16 to i32
  br label %20

18:                                               ; preds = %6
  %19 = tail call i32 @luaZ_fill(ptr noundef nonnull %8) #46
  br label %20

20:                                               ; preds = %18, %12
  %21 = phi i32 [ %17, %12 ], [ %19, %18 ]
  store i32 %21, ptr %0, align 8, !tbaa !255
  br label %22

22:                                               ; preds = %20, %2
  %23 = phi i32 [ 1, %20 ], [ 0, %2 ]
  ret i32 %23
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @read_numeral(ptr nocapture noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 7
  %4 = load i32, ptr %0, align 8, !tbaa !255
  br label %5

5:                                                ; preds = %19, %2
  %6 = phi i32 [ %20, %19 ], [ %4, %2 ]
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef %6) #47
  %7 = load ptr, ptr %3, align 8, !tbaa !251
  %8 = load i64, ptr %7, align 8, !tbaa !252
  %9 = add i64 %8, -1
  store i64 %9, ptr %7, align 8, !tbaa !252
  %10 = icmp eq i64 %8, 0
  br i1 %10, label %17, label %11

11:                                               ; preds = %5
  %12 = getelementptr inbounds %struct.Zio, ptr %7, i64 0, i32 1
  %13 = load ptr, ptr %12, align 8, !tbaa !254
  %14 = getelementptr inbounds i8, ptr %13, i64 1
  store ptr %14, ptr %12, align 8, !tbaa !254
  %15 = load i8, ptr %13, align 1, !tbaa !33
  %16 = zext i8 %15 to i32
  br label %19

17:                                               ; preds = %5
  %18 = tail call i32 @luaZ_fill(ptr noundef nonnull %7) #46
  br label %19

19:                                               ; preds = %17, %11
  %20 = phi i32 [ %16, %11 ], [ %18, %17 ]
  store i32 %20, ptr %0, align 8, !tbaa !255
  %21 = tail call ptr @__ctype_b_loc() #52
  %22 = load ptr, ptr %21, align 8, !tbaa !39
  %23 = sext i32 %20 to i64
  %24 = getelementptr inbounds i16, ptr %22, i64 %23
  %25 = load i16, ptr %24, align 2, !tbaa !239
  %26 = and i16 %25, 2048
  %27 = icmp ne i16 %26, 0
  %28 = icmp eq i32 %20, 46
  %29 = or i1 %28, %27
  br i1 %29, label %5, label %30, !llvm.loop !262

30:                                               ; preds = %19
  %.lcssa = phi ptr [ %21, %19 ]
  %31 = tail call fastcc i32 @check_next(ptr noundef nonnull %0, ptr noundef nonnull @.str.44) #47, !range !75
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %35, label %33

33:                                               ; preds = %30
  %34 = tail call fastcc i32 @check_next(ptr noundef nonnull %0, ptr noundef nonnull @.str.45) #47, !range !75
  br label %35

35:                                               ; preds = %33, %30
  %36 = load ptr, ptr %.lcssa, align 8, !tbaa !39
  %37 = load i32, ptr %0, align 8, !tbaa !255
  %38 = sext i32 %37 to i64
  %39 = getelementptr inbounds i16, ptr %36, i64 %38
  %40 = load i16, ptr %39, align 2, !tbaa !239
  %41 = and i16 %40, 8
  %42 = icmp ne i16 %41, 0
  %43 = icmp eq i32 %37, 95
  %44 = or i1 %43, %42
  br i1 %44, label %45, label %69

45:                                               ; preds = %59, %35
  %46 = phi i32 [ %60, %59 ], [ %37, %35 ]
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef %46) #47
  %47 = load ptr, ptr %3, align 8, !tbaa !251
  %48 = load i64, ptr %47, align 8, !tbaa !252
  %49 = add i64 %48, -1
  store i64 %49, ptr %47, align 8, !tbaa !252
  %50 = icmp eq i64 %48, 0
  br i1 %50, label %57, label %51

51:                                               ; preds = %45
  %52 = getelementptr inbounds %struct.Zio, ptr %47, i64 0, i32 1
  %53 = load ptr, ptr %52, align 8, !tbaa !254
  %54 = getelementptr inbounds i8, ptr %53, i64 1
  store ptr %54, ptr %52, align 8, !tbaa !254
  %55 = load i8, ptr %53, align 1, !tbaa !33
  %56 = zext i8 %55 to i32
  br label %59

57:                                               ; preds = %45
  %58 = tail call i32 @luaZ_fill(ptr noundef nonnull %47) #46
  br label %59

59:                                               ; preds = %57, %51
  %60 = phi i32 [ %56, %51 ], [ %58, %57 ]
  store i32 %60, ptr %0, align 8, !tbaa !255
  %61 = load ptr, ptr %.lcssa, align 8, !tbaa !39
  %62 = sext i32 %60 to i64
  %63 = getelementptr inbounds i16, ptr %61, i64 %62
  %64 = load i16, ptr %63, align 2, !tbaa !239
  %65 = and i16 %64, 8
  %66 = icmp ne i16 %65, 0
  %67 = icmp eq i32 %60, 95
  %68 = or i1 %67, %66
  br i1 %68, label %45, label %69, !llvm.loop !263

69:                                               ; preds = %59, %35
  tail call fastcc void @save(ptr noundef nonnull %0, i32 noundef 0) #47
  %70 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 10
  %71 = load i8, ptr %70, align 8, !tbaa !249
  %72 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 8
  %73 = load ptr, ptr %72, align 8, !tbaa !243
  %74 = getelementptr inbounds %struct.Mbuffer, ptr %73, i64 0, i32 1
  %75 = load i64, ptr %74, align 8, !tbaa !245
  %76 = load ptr, ptr %73, align 8, !tbaa !244
  %77 = icmp eq i64 %75, 0
  br i1 %77, label %90, label %78

78:                                               ; preds = %85, %69
  %79 = phi i64 [ %80, %85 ], [ %75, %69 ]
  %80 = add i64 %79, -1
  %81 = getelementptr inbounds i8, ptr %76, i64 %80
  %82 = load i8, ptr %81, align 1, !tbaa !33
  %83 = icmp eq i8 %82, 46
  br i1 %83, label %84, label %85

84:                                               ; preds = %78
  store i8 %71, ptr %81, align 1, !tbaa !33
  br label %85

85:                                               ; preds = %84, %78
  %86 = icmp eq i64 %80, 0
  br i1 %86, label %87, label %78, !llvm.loop !264

87:                                               ; preds = %85
  %88 = load ptr, ptr %72, align 8, !tbaa !243
  %89 = load ptr, ptr %88, align 8, !tbaa !244
  br label %90

90:                                               ; preds = %87, %69
  %91 = phi ptr [ %89, %87 ], [ %76, %69 ]
  %92 = tail call i32 @luaO_str2d(ptr noundef %91, ptr noundef %1) #46
  %93 = icmp eq i32 %92, 0
  br i1 %93, label %94, label %141

94:                                               ; preds = %90
  %95 = tail call ptr @localeconv() #46
  %96 = load i8, ptr %70, align 8, !tbaa !249
  %97 = icmp eq ptr %95, null
  br i1 %97, label %101, label %98

98:                                               ; preds = %94
  %99 = load ptr, ptr %95, align 8, !tbaa !265
  %100 = load i8, ptr %99, align 1, !tbaa !33
  br label %101

101:                                              ; preds = %98, %94
  %102 = phi i8 [ %100, %98 ], [ 46, %94 ]
  store i8 %102, ptr %70, align 8, !tbaa !249
  %103 = load ptr, ptr %72, align 8, !tbaa !243
  %104 = getelementptr inbounds %struct.Mbuffer, ptr %103, i64 0, i32 1
  %105 = load i64, ptr %104, align 8, !tbaa !245
  %106 = load ptr, ptr %103, align 8, !tbaa !244
  %107 = icmp eq i64 %105, 0
  br i1 %107, label %120, label %108

108:                                              ; preds = %115, %101
  %109 = phi i64 [ %110, %115 ], [ %105, %101 ]
  %110 = add i64 %109, -1
  %111 = getelementptr inbounds i8, ptr %106, i64 %110
  %112 = load i8, ptr %111, align 1, !tbaa !33
  %113 = icmp eq i8 %112, %96
  br i1 %113, label %114, label %115

114:                                              ; preds = %108
  store i8 %102, ptr %111, align 1, !tbaa !33
  br label %115

115:                                              ; preds = %114, %108
  %116 = icmp eq i64 %110, 0
  br i1 %116, label %117, label %108, !llvm.loop !264

117:                                              ; preds = %115
  %118 = load ptr, ptr %72, align 8, !tbaa !243
  %119 = load ptr, ptr %118, align 8, !tbaa !244
  br label %120

120:                                              ; preds = %117, %101
  %121 = phi ptr [ %119, %117 ], [ %106, %101 ]
  %122 = tail call i32 @luaO_str2d(ptr noundef %121, ptr noundef %1) #46
  %123 = icmp eq i32 %122, 0
  br i1 %123, label %124, label %141

124:                                              ; preds = %120
  %125 = load i8, ptr %70, align 8, !tbaa !249
  %126 = load ptr, ptr %72, align 8, !tbaa !243
  %127 = getelementptr inbounds %struct.Mbuffer, ptr %126, i64 0, i32 1
  %128 = load i64, ptr %127, align 8, !tbaa !245
  %129 = load ptr, ptr %126, align 8, !tbaa !244
  %130 = icmp eq i64 %128, 0
  br i1 %130, label %140, label %131

131:                                              ; preds = %138, %124
  %132 = phi i64 [ %133, %138 ], [ %128, %124 ]
  %133 = add i64 %132, -1
  %134 = getelementptr inbounds i8, ptr %129, i64 %133
  %135 = load i8, ptr %134, align 1, !tbaa !33
  %136 = icmp eq i8 %135, %125
  br i1 %136, label %137, label %138

137:                                              ; preds = %131
  store i8 46, ptr %134, align 1, !tbaa !33
  br label %138

138:                                              ; preds = %137, %131
  %139 = icmp eq i64 %133, 0
  br i1 %139, label %140, label %131, !llvm.loop !264

140:                                              ; preds = %138, %124
  tail call void @luaX_lexerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.46, i32 noundef 284) #47
  br label %141

141:                                              ; preds = %140, %120, %90
  ret void
}

; Function Attrs: nounwind optsize
declare ptr @localeconv() local_unnamed_addr #27

; Function Attrs: nounwind optsize uwtable
define internal void @luaX_lookahead(ptr noundef %0) #1 {
  %2 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 4
  %3 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 4, i32 1
  %4 = tail call fastcc i32 @llex(ptr noundef %0, ptr noundef nonnull %3) #47
  store i32 %4, ptr %2, align 8, !tbaa !250
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaM_growaux_(ptr noundef %0, ptr noundef %1, ptr nocapture noundef %2, i64 noundef %3, i32 noundef %4, ptr noundef %5) #1 {
  %7 = load i32, ptr %2, align 4, !tbaa !65
  %8 = sdiv i32 %4, 2
  %9 = icmp slt i32 %7, %8
  br i1 %9, label %13, label %10

10:                                               ; preds = %6
  %11 = icmp slt i32 %7, %4
  br i1 %11, label %16, label %12

12:                                               ; preds = %10
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %0, ptr noundef %5) #46
  br label %16

13:                                               ; preds = %6
  %14 = shl nsw i32 %7, 1
  %15 = tail call i32 @llvm.smax.i32(i32 %14, i32 4)
  br label %16

16:                                               ; preds = %13, %12, %10
  %17 = phi i32 [ %15, %13 ], [ %4, %12 ], [ %4, %10 ]
  %18 = add nsw i32 %17, 1
  %19 = sext i32 %18 to i64
  %20 = udiv i64 -3, %3
  %21 = icmp ult i64 %20, %19
  br i1 %21, label %29, label %22

22:                                               ; preds = %16
  %23 = load i32, ptr %2, align 4, !tbaa !65
  %24 = sext i32 %23 to i64
  %25 = mul i64 %24, %3
  %26 = sext i32 %17 to i64
  %27 = mul i64 %26, %3
  %28 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %1, i64 noundef %25, i64 noundef %27) #47
  br label %30

29:                                               ; preds = %16
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %0, ptr noundef nonnull @.str.100) #46
  br label %30

30:                                               ; preds = %29, %22
  %31 = phi ptr [ %28, %22 ], [ null, %29 ]
  store i32 %17, ptr %2, align 4, !tbaa !65
  ret ptr %31
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #12

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaM_realloc_(ptr noundef %0, ptr noundef %1, i64 noundef %2, i64 noundef %3) #1 {
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %6 = load ptr, ptr %5, align 8, !tbaa !25
  %7 = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 1
  %8 = load ptr, ptr %7, align 8, !tbaa !267
  %9 = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 2
  %10 = load ptr, ptr %9, align 8, !tbaa !268
  %11 = tail call ptr %8(ptr noundef %10, ptr noundef %1, i64 noundef %2, i64 noundef %3) #46
  %12 = icmp eq ptr %11, null
  %13 = icmp ne i64 %3, 0
  %14 = and i1 %13, %12
  br i1 %14, label %15, label %16

15:                                               ; preds = %4
  tail call void @luaD_throw(ptr noundef nonnull %0, i32 noundef 4) #46
  br label %16

16:                                               ; preds = %15, %4
  %17 = getelementptr inbounds %struct.global_State, ptr %6, i64 0, i32 14
  %18 = load i64, ptr %17, align 8, !tbaa !31
  %19 = sub i64 %3, %2
  %20 = add i64 %19, %18
  store i64 %20, ptr %17, align 8, !tbaa !31
  ret ptr %11
}

; Function Attrs: nounwind optsize uwtable
define internal noalias ptr @luaM_toobig(ptr noundef %0) #1 {
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %0, ptr noundef nonnull @.str.100) #46
  ret ptr null
}

; Function Attrs: nofree norecurse nosync nounwind optsize memory(none) uwtable
define internal i32 @luaO_int2fb(i32 noundef %0) #28 {
  %2 = icmp ugt i32 %0, 15
  br i1 %2, label %3, label %13

3:                                                ; preds = %3, %1
  %4 = phi i32 [ %8, %3 ], [ 0, %1 ]
  %5 = phi i32 [ %7, %3 ], [ %0, %1 ]
  %6 = add i32 %5, 1
  %7 = lshr i32 %6, 1
  %8 = add nuw nsw i32 %4, 1
  %9 = icmp ugt i32 %6, 31
  br i1 %9, label %3, label %10, !llvm.loop !269

10:                                               ; preds = %3
  %.lcssa1 = phi i32 [ %7, %3 ]
  %.lcssa = phi i32 [ %8, %3 ]
  %11 = shl i32 %.lcssa, 3
  %12 = add i32 %11, 8
  br label %13

13:                                               ; preds = %10, %1
  %14 = phi i32 [ %0, %1 ], [ %.lcssa1, %10 ]
  %15 = phi i32 [ 8, %1 ], [ %12, %10 ]
  %16 = icmp ult i32 %14, 8
  %17 = add nsw i32 %14, -8
  %18 = or i32 %15, %17
  %19 = select i1 %16, i32 %14, i32 %18
  ret i32 %19
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable
define internal i32 @luaO_fb2int(i32 noundef %0) #8 {
  %2 = lshr i32 %0, 3
  %3 = and i32 %2, 31
  %4 = icmp eq i32 %3, 0
  %5 = and i32 %0, 7
  %6 = or i32 %5, 8
  %7 = add nsw i32 %3, -1
  %8 = shl i32 %6, %7
  %9 = select i1 %4, i32 %0, i32 %8
  ret i32 %9
}

; Function Attrs: nofree norecurse nosync nounwind optsize memory(none) uwtable
define internal i32 @luaO_log2(i32 noundef %0) #28 {
  %2 = icmp ugt i32 %0, 255
  br i1 %2, label %3, label %9

3:                                                ; preds = %3, %1
  %4 = phi i32 [ %6, %3 ], [ -1, %1 ]
  %5 = phi i32 [ %7, %3 ], [ %0, %1 ]
  %6 = add nsw i32 %4, 8
  %7 = lshr i32 %5, 8
  %8 = icmp ugt i32 %5, 65535
  br i1 %8, label %3, label %9, !llvm.loop !270

9:                                                ; preds = %3, %1
  %10 = phi i32 [ %0, %1 ], [ %7, %3 ]
  %11 = phi i32 [ -1, %1 ], [ %6, %3 ]
  %12 = zext i32 %10 to i64
  %13 = getelementptr inbounds [256 x i8], ptr @luaO_log2.log_2, i64 0, i64 %12
  %14 = load i8, ptr %13, align 1, !tbaa !33
  %15 = zext i8 %14 to i32
  %16 = add nsw i32 %11, %15
  ret i32 %16
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: read) uwtable
define internal i32 @luaO_rawequalObj(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) #5 {
  %3 = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %4 = load i32, ptr %3, align 8, !tbaa !16
  %5 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  %6 = load i32, ptr %5, align 8, !tbaa !16
  %7 = icmp eq i32 %4, %6
  br i1 %7, label %8, label %25

8:                                                ; preds = %2
  switch i32 %4, label %21 [
    i32 0, label %25
    i32 3, label %9
    i32 1, label %13
    i32 2, label %17
  ]

9:                                                ; preds = %8
  %10 = load double, ptr %0, align 8, !tbaa !33
  %11 = load double, ptr %1, align 8, !tbaa !33
  %12 = fcmp oeq double %10, %11
  br label %25

13:                                               ; preds = %8
  %14 = load i32, ptr %0, align 8, !tbaa !33
  %15 = load i32, ptr %1, align 8, !tbaa !33
  %16 = icmp eq i32 %14, %15
  br label %25

17:                                               ; preds = %8
  %18 = load ptr, ptr %0, align 8, !tbaa !33
  %19 = load ptr, ptr %1, align 8, !tbaa !33
  %20 = icmp eq ptr %18, %19
  br label %25

21:                                               ; preds = %8
  %22 = load ptr, ptr %0, align 8, !tbaa !33
  %23 = load ptr, ptr %1, align 8, !tbaa !33
  %24 = icmp eq ptr %22, %23
  br label %25

25:                                               ; preds = %21, %17, %13, %9, %8, %2
  %26 = phi i1 [ %24, %21 ], [ %20, %17 ], [ %16, %13 ], [ %12, %9 ], [ false, %2 ], [ true, %8 ]
  %27 = zext i1 %26 to i32
  ret i32 %27
}

; Function Attrs: nofree nounwind optsize uwtable
define internal i32 @luaO_str2d(ptr noundef %0, ptr nocapture noundef writeonly %1) #29 {
  %3 = alloca ptr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #48
  %4 = call double @strtod(ptr noundef %0, ptr noundef nonnull %3) #46
  store double %4, ptr %1, align 8, !tbaa !90
  %5 = load ptr, ptr %3, align 8, !tbaa !39
  %6 = icmp eq ptr %5, %0
  br i1 %6, label %33, label %7

7:                                                ; preds = %2
  %8 = load i8, ptr %5, align 1, !tbaa !33
  switch i8 %8, label %14 [
    i8 120, label %9
    i8 88, label %9
  ]

9:                                                ; preds = %7, %7
  %10 = call i64 @strtoul(ptr noundef %0, ptr noundef nonnull %3, i32 noundef 16) #46
  %11 = uitofp i64 %10 to double
  store double %11, ptr %1, align 8, !tbaa !90
  %12 = load ptr, ptr %3, align 8, !tbaa !39
  %13 = load i8, ptr %12, align 1, !tbaa !33
  br label %14

14:                                               ; preds = %9, %7
  %15 = phi i8 [ %8, %7 ], [ %13, %9 ]
  %16 = phi ptr [ %5, %7 ], [ %12, %9 ]
  %17 = icmp eq i8 %15, 0
  br i1 %17, label %33, label %18

18:                                               ; preds = %14
  %19 = tail call ptr @__ctype_b_loc() #52
  %20 = load ptr, ptr %19, align 8, !tbaa !39
  br label %21

21:                                               ; preds = %21, %18
  %22 = phi ptr [ %16, %18 ], [ %29, %21 ]
  %23 = load i8, ptr %22, align 1, !tbaa !33
  %24 = zext i8 %23 to i64
  %25 = getelementptr inbounds i16, ptr %20, i64 %24
  %26 = load i16, ptr %25, align 2, !tbaa !239
  %27 = and i16 %26, 8192
  %28 = icmp eq i16 %27, 0
  %29 = getelementptr inbounds i8, ptr %22, i64 1
  br i1 %28, label %30, label %21, !llvm.loop !271

30:                                               ; preds = %21
  %.lcssa = phi i8 [ %23, %21 ]
  %31 = icmp eq i8 %.lcssa, 0
  %32 = zext i1 %31 to i32
  br label %33

33:                                               ; preds = %30, %14, %2
  %34 = phi i32 [ 0, %2 ], [ 1, %14 ], [ %32, %30 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #48
  ret i32 %34
}

; Function Attrs: mustprogress nofree nounwind optsize willreturn
declare double @strtod(ptr noundef readonly, ptr nocapture noundef) local_unnamed_addr #30

; Function Attrs: mustprogress nofree nounwind optsize willreturn
declare i64 @strtoul(ptr noundef readonly, ptr nocapture noundef, i32 noundef) local_unnamed_addr #30

; Function Attrs: nounwind optsize uwtable
define internal nonnull ptr @luaO_pushvfstring(ptr noundef %0, ptr noundef %1, ptr nocapture noundef %2) #1 {
  %4 = alloca [2 x i8], align 1
  %5 = alloca [40 x i8], align 16
  %6 = alloca [3 x i8], align 1
  tail call fastcc void @pushstr(ptr noundef %0, ptr noundef nonnull @.str.109) #47
  %7 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %8 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %9 = getelementptr inbounds %struct.__va_list_tag, ptr %2, i64 0, i32 2
  %10 = getelementptr inbounds %struct.__va_list_tag, ptr %2, i64 0, i32 3
  %11 = getelementptr inbounds %struct.__va_list_tag, ptr %2, i64 0, i32 1
  %12 = getelementptr inbounds [2 x i8], ptr %4, i64 0, i64 1
  %13 = getelementptr inbounds [3 x i8], ptr %6, i64 0, i64 1
  %14 = getelementptr inbounds [3 x i8], ptr %6, i64 0, i64 2
  br label %15

15:                                               ; preds = %142, %3
  %16 = phi i32 [ 1, %3 ], [ %143, %142 ]
  %17 = phi ptr [ %1, %3 ], [ %144, %142 ]
  %18 = call ptr @strchr(ptr noundef nonnull dereferenceable(1) %17, i32 noundef 37) #49
  %19 = icmp eq ptr %18, null
  br i1 %19, label %145, label %20

20:                                               ; preds = %15
  %21 = load ptr, ptr %7, align 8, !tbaa !7
  %22 = ptrtoint ptr %18 to i64
  %23 = ptrtoint ptr %17 to i64
  %24 = sub i64 %22, %23
  %25 = call ptr @luaS_newlstr(ptr noundef %0, ptr noundef %17, i64 noundef %24) #46
  store ptr %25, ptr %21, align 8, !tbaa !33
  %26 = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 0, i32 1
  store i32 4, ptr %26, align 8, !tbaa !16
  %27 = load ptr, ptr %8, align 8, !tbaa !18
  %28 = load ptr, ptr %7, align 8, !tbaa !7
  %29 = ptrtoint ptr %27 to i64
  %30 = ptrtoint ptr %28 to i64
  %31 = sub i64 %29, %30
  %32 = icmp slt i64 %31, 17
  br i1 %32, label %33, label %35

33:                                               ; preds = %20
  call void @luaD_growstack(ptr noundef nonnull %0, i32 noundef 1) #46
  %34 = load ptr, ptr %7, align 8, !tbaa !7
  br label %35

35:                                               ; preds = %33, %20
  %36 = phi ptr [ %28, %20 ], [ %34, %33 ]
  %37 = getelementptr inbounds %struct.lua_TValue, ptr %36, i64 1
  store ptr %37, ptr %7, align 8, !tbaa !7
  %38 = getelementptr inbounds i8, ptr %18, i64 1
  %39 = load i8, ptr %38, align 1, !tbaa !33
  %40 = sext i8 %39 to i32
  switch i32 %40, label %141 [
    i32 115, label %41
    i32 99, label %57
    i32 100, label %72
    i32 102, label %99
    i32 112, label %125
    i32 37, label %140
  ]

41:                                               ; preds = %35
  %42 = load i32, ptr %2, align 8
  %43 = icmp ult i32 %42, 41
  br i1 %43, label %44, label %49

44:                                               ; preds = %41
  %45 = load ptr, ptr %10, align 8
  %46 = zext i32 %42 to i64
  %47 = getelementptr i8, ptr %45, i64 %46
  %48 = add nuw nsw i32 %42, 8
  store i32 %48, ptr %2, align 8
  br label %52

49:                                               ; preds = %41
  %50 = load ptr, ptr %9, align 8
  %51 = getelementptr i8, ptr %50, i64 8
  store ptr %51, ptr %9, align 8
  br label %52

52:                                               ; preds = %49, %44
  %53 = phi ptr [ %47, %44 ], [ %50, %49 ]
  %54 = load ptr, ptr %53, align 8
  %55 = icmp eq ptr %54, null
  %56 = select i1 %55, ptr @.str.1.110, ptr %54
  call fastcc void @pushstr(ptr noundef nonnull %0, ptr noundef nonnull %56) #47
  br label %142

57:                                               ; preds = %35
  call void @llvm.lifetime.start.p0(i64 2, ptr nonnull %4) #48
  %58 = load i32, ptr %2, align 8
  %59 = icmp ult i32 %58, 41
  br i1 %59, label %60, label %65

60:                                               ; preds = %57
  %61 = load ptr, ptr %10, align 8
  %62 = zext i32 %58 to i64
  %63 = getelementptr i8, ptr %61, i64 %62
  %64 = add nuw nsw i32 %58, 8
  store i32 %64, ptr %2, align 8
  br label %68

65:                                               ; preds = %57
  %66 = load ptr, ptr %9, align 8
  %67 = getelementptr i8, ptr %66, i64 8
  store ptr %67, ptr %9, align 8
  br label %68

68:                                               ; preds = %65, %60
  %69 = phi ptr [ %63, %60 ], [ %66, %65 ]
  %70 = load i32, ptr %69, align 4
  %71 = trunc i32 %70 to i8
  store i8 %71, ptr %4, align 1, !tbaa !33
  store i8 0, ptr %12, align 1, !tbaa !33
  call fastcc void @pushstr(ptr noundef nonnull %0, ptr noundef nonnull %4) #47
  call void @llvm.lifetime.end.p0(i64 2, ptr nonnull %4) #48
  br label %142

72:                                               ; preds = %35
  %73 = load i32, ptr %2, align 8
  %74 = icmp ult i32 %73, 41
  br i1 %74, label %75, label %80

75:                                               ; preds = %72
  %76 = load ptr, ptr %10, align 8
  %77 = zext i32 %73 to i64
  %78 = getelementptr i8, ptr %76, i64 %77
  %79 = add nuw nsw i32 %73, 8
  store i32 %79, ptr %2, align 8
  br label %83

80:                                               ; preds = %72
  %81 = load ptr, ptr %9, align 8
  %82 = getelementptr i8, ptr %81, i64 8
  store ptr %82, ptr %9, align 8
  br label %83

83:                                               ; preds = %80, %75
  %84 = phi ptr [ %78, %75 ], [ %81, %80 ]
  %85 = load i32, ptr %84, align 4
  %86 = sitofp i32 %85 to double
  store double %86, ptr %37, align 8, !tbaa !33
  %87 = getelementptr inbounds %struct.lua_TValue, ptr %36, i64 1, i32 1
  store i32 3, ptr %87, align 8, !tbaa !16
  %88 = load ptr, ptr %8, align 8, !tbaa !18
  %89 = load ptr, ptr %7, align 8, !tbaa !7
  %90 = ptrtoint ptr %88 to i64
  %91 = ptrtoint ptr %89 to i64
  %92 = sub i64 %90, %91
  %93 = icmp slt i64 %92, 17
  br i1 %93, label %94, label %96

94:                                               ; preds = %83
  call void @luaD_growstack(ptr noundef nonnull %0, i32 noundef 1) #46
  %95 = load ptr, ptr %7, align 8, !tbaa !7
  br label %96

96:                                               ; preds = %94, %83
  %97 = phi ptr [ %89, %83 ], [ %95, %94 ]
  %98 = getelementptr inbounds %struct.lua_TValue, ptr %97, i64 1
  store ptr %98, ptr %7, align 8, !tbaa !7
  br label %142

99:                                               ; preds = %35
  %100 = load i32, ptr %11, align 4
  %101 = icmp ult i32 %100, 161
  br i1 %101, label %102, label %107

102:                                              ; preds = %99
  %103 = load ptr, ptr %10, align 8
  %104 = zext i32 %100 to i64
  %105 = getelementptr i8, ptr %103, i64 %104
  %106 = add nuw nsw i32 %100, 16
  store i32 %106, ptr %11, align 4
  br label %110

107:                                              ; preds = %99
  %108 = load ptr, ptr %9, align 8
  %109 = getelementptr i8, ptr %108, i64 8
  store ptr %109, ptr %9, align 8
  br label %110

110:                                              ; preds = %107, %102
  %111 = phi ptr [ %105, %102 ], [ %108, %107 ]
  %112 = load double, ptr %111, align 8
  store double %112, ptr %37, align 8, !tbaa !33
  %113 = getelementptr inbounds %struct.lua_TValue, ptr %36, i64 1, i32 1
  store i32 3, ptr %113, align 8, !tbaa !16
  %114 = load ptr, ptr %8, align 8, !tbaa !18
  %115 = load ptr, ptr %7, align 8, !tbaa !7
  %116 = ptrtoint ptr %114 to i64
  %117 = ptrtoint ptr %115 to i64
  %118 = sub i64 %116, %117
  %119 = icmp slt i64 %118, 17
  br i1 %119, label %120, label %122

120:                                              ; preds = %110
  call void @luaD_growstack(ptr noundef nonnull %0, i32 noundef 1) #46
  %121 = load ptr, ptr %7, align 8, !tbaa !7
  br label %122

122:                                              ; preds = %120, %110
  %123 = phi ptr [ %115, %110 ], [ %121, %120 ]
  %124 = getelementptr inbounds %struct.lua_TValue, ptr %123, i64 1
  store ptr %124, ptr %7, align 8, !tbaa !7
  br label %142

125:                                              ; preds = %35
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %5) #48
  %126 = load i32, ptr %2, align 8
  %127 = icmp ult i32 %126, 41
  br i1 %127, label %128, label %133

128:                                              ; preds = %125
  %129 = load ptr, ptr %10, align 8
  %130 = zext i32 %126 to i64
  %131 = getelementptr i8, ptr %129, i64 %130
  %132 = add nuw nsw i32 %126, 8
  store i32 %132, ptr %2, align 8
  br label %136

133:                                              ; preds = %125
  %134 = load ptr, ptr %9, align 8
  %135 = getelementptr i8, ptr %134, i64 8
  store ptr %135, ptr %9, align 8
  br label %136

136:                                              ; preds = %133, %128
  %137 = phi ptr [ %131, %128 ], [ %134, %133 ]
  %138 = load ptr, ptr %137, align 8
  %139 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %5, ptr noundef nonnull dereferenceable(1) @.str.2.111, ptr noundef %138) #46
  call fastcc void @pushstr(ptr noundef nonnull %0, ptr noundef nonnull %5) #47
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %5) #48
  br label %142

140:                                              ; preds = %35
  call fastcc void @pushstr(ptr noundef nonnull %0, ptr noundef nonnull @.str.3.112) #47
  br label %142

141:                                              ; preds = %35
  call void @llvm.lifetime.start.p0(i64 3, ptr nonnull %6) #48
  store i8 37, ptr %6, align 1, !tbaa !33
  store i8 %39, ptr %13, align 1, !tbaa !33
  store i8 0, ptr %14, align 1, !tbaa !33
  call fastcc void @pushstr(ptr noundef nonnull %0, ptr noundef nonnull %6) #47
  call void @llvm.lifetime.end.p0(i64 3, ptr nonnull %6) #48
  br label %142

142:                                              ; preds = %141, %140, %136, %122, %96, %68, %52
  %143 = add nuw nsw i32 %16, 2
  %144 = getelementptr inbounds i8, ptr %18, i64 2
  br label %15

145:                                              ; preds = %15
  %.lcssa1 = phi i32 [ %16, %15 ]
  %.lcssa = phi ptr [ %17, %15 ]
  call fastcc void @pushstr(ptr noundef %0, ptr noundef %.lcssa) #47
  %146 = add nuw nsw i32 %.lcssa1, 1
  %147 = load ptr, ptr %7, align 8, !tbaa !7
  %148 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  %149 = load ptr, ptr %148, align 8, !tbaa !17
  %150 = ptrtoint ptr %147 to i64
  %151 = ptrtoint ptr %149 to i64
  %152 = sub i64 %150, %151
  %153 = lshr exact i64 %152, 4
  %154 = trunc i64 %153 to i32
  %155 = add nsw i32 %154, -1
  call void @luaV_concat(ptr noundef %0, i32 noundef %146, i32 noundef %155) #46
  %156 = load ptr, ptr %7, align 8, !tbaa !7
  %157 = zext i32 %.lcssa1 to i64
  %158 = sub nsw i64 0, %157
  %159 = getelementptr inbounds %struct.lua_TValue, ptr %156, i64 %158
  store ptr %159, ptr %7, align 8, !tbaa !7
  %160 = getelementptr inbounds %struct.lua_TValue, ptr %159, i64 -1
  %161 = load ptr, ptr %160, align 8, !tbaa !33
  %162 = getelementptr inbounds %union.TString, ptr %161, i64 1
  ret ptr %162
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @pushstr(ptr noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %4 = load ptr, ptr %3, align 8, !tbaa !7
  %5 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %1) #49
  %6 = tail call ptr @luaS_newlstr(ptr noundef %0, ptr noundef %1, i64 noundef %5) #46
  store ptr %6, ptr %4, align 8, !tbaa !33
  %7 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  store i32 4, ptr %7, align 8, !tbaa !16
  %8 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %9 = load ptr, ptr %8, align 8, !tbaa !18
  %10 = load ptr, ptr %3, align 8, !tbaa !7
  %11 = ptrtoint ptr %9 to i64
  %12 = ptrtoint ptr %10 to i64
  %13 = sub i64 %11, %12
  %14 = icmp slt i64 %13, 17
  br i1 %14, label %15, label %17

15:                                               ; preds = %2
  tail call void @luaD_growstack(ptr noundef nonnull %0, i32 noundef 1) #46
  %16 = load ptr, ptr %3, align 8, !tbaa !7
  br label %17

17:                                               ; preds = %15, %2
  %18 = phi ptr [ %10, %2 ], [ %16, %15 ]
  %19 = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 1
  store ptr %19, ptr %3, align 8, !tbaa !7
  ret void
}

; Function Attrs: nofree nounwind optsize
declare noundef i32 @sprintf(ptr noalias nocapture noundef writeonly, ptr nocapture noundef readonly, ...) local_unnamed_addr #31

; Function Attrs: nounwind optsize uwtable
define internal nonnull ptr @luaO_pushfstring(ptr noundef %0, ptr noundef %1, ...) #1 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3) #48
  call void @llvm.va_start(ptr nonnull %3)
  %4 = call ptr @luaO_pushvfstring(ptr noundef %0, ptr noundef %1, ptr noundef nonnull %3) #47
  call void @llvm.va_end(ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3) #48
  ret ptr %4
}

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable
define internal void @luaO_chunkid(ptr noundef %0, ptr nocapture noundef readonly %1, i64 noundef %2) #32 {
  %4 = load i8, ptr %1, align 1, !tbaa !33
  switch i8 %4, label %23 [
    i8 61, label %5
    i8 64, label %10
  ]

5:                                                ; preds = %3
  %6 = getelementptr inbounds i8, ptr %1, i64 1
  %7 = tail call ptr @strncpy(ptr noundef %0, ptr noundef nonnull %6, i64 noundef %2) #46
  %8 = add i64 %2, -1
  %9 = getelementptr inbounds i8, ptr %0, i64 %8
  store i8 0, ptr %9, align 1, !tbaa !33
  br label %39

10:                                               ; preds = %3
  %11 = getelementptr inbounds i8, ptr %1, i64 1
  %12 = add i64 %2, -8
  %13 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %11) #49
  store i8 0, ptr %0, align 1
  %14 = icmp ugt i64 %13, %12
  br i1 %14, label %15, label %20

15:                                               ; preds = %10
  %16 = sub i64 %13, %12
  %17 = getelementptr inbounds i8, ptr %11, i64 %16
  %18 = tail call i64 @strlen(ptr nonnull dereferenceable(1) %0)
  %19 = getelementptr inbounds i8, ptr %0, i64 %18
  store i32 3026478, ptr %19, align 1
  br label %20

20:                                               ; preds = %15, %10
  %21 = phi ptr [ %17, %15 ], [ %11, %10 ]
  %22 = tail call ptr @strcat(ptr noundef nonnull dereferenceable(1) %0, ptr noundef nonnull dereferenceable(1) %21) #46
  br label %39

23:                                               ; preds = %3
  %24 = tail call i64 @strcspn(ptr noundef nonnull %1, ptr noundef nonnull @.str.5.117) #49
  %25 = add i64 %2, -17
  %26 = tail call i64 @llvm.umin.i64(i64 %24, i64 %25)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(10) %0, ptr noundef nonnull align 1 dereferenceable(10) @.str.6.118, i64 10, i1 false) #46
  %27 = getelementptr inbounds i8, ptr %1, i64 %26
  %28 = load i8, ptr %27, align 1, !tbaa !33
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %34, label %30

30:                                               ; preds = %23
  %31 = tail call ptr @strncat(ptr noundef nonnull dereferenceable(1) %0, ptr noundef nonnull %1, i64 noundef %26) #46
  %32 = tail call i64 @strlen(ptr nonnull dereferenceable(1) %0)
  %33 = getelementptr inbounds i8, ptr %0, i64 %32
  store i32 3026478, ptr %33, align 1
  br label %36

34:                                               ; preds = %23
  %35 = tail call ptr @strcat(ptr noundef nonnull dereferenceable(1) %0, ptr noundef nonnull dereferenceable(1) %1) #46
  br label %36

36:                                               ; preds = %34, %30
  %37 = tail call i64 @strlen(ptr nonnull dereferenceable(1) %0)
  %38 = getelementptr inbounds i8, ptr %0, i64 %37
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %38, ptr noundef nonnull align 1 dereferenceable(3) @.str.7.119, i64 3, i1 false)
  br label %39

39:                                               ; preds = %36, %20, %5
  ret void
}

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(argmem: readwrite)
declare ptr @strncpy(ptr noalias noundef returned writeonly, ptr noalias nocapture noundef readonly, i64 noundef) local_unnamed_addr #33

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(argmem: readwrite)
declare ptr @strcat(ptr noalias noundef returned, ptr noalias nocapture noundef readonly) local_unnamed_addr #33

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(argmem: read)
declare i64 @strcspn(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #10

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umin.i64(i64, i64) #12

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(argmem: readwrite)
declare ptr @strncat(ptr noalias noundef returned, ptr noalias nocapture noundef readonly, i64 noundef) local_unnamed_addr #33

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaY_parser(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3) #1 {
  %5 = alloca %struct.LexState, align 8
  %6 = alloca %struct.FuncState, align 8
  call void @llvm.lifetime.start.p0(i64 96, ptr nonnull %5) #48
  call void @llvm.lifetime.start.p0(i64 600, ptr nonnull %6) #48
  %7 = getelementptr inbounds %struct.LexState, ptr %5, i64 0, i32 8
  store ptr %2, ptr %7, align 8, !tbaa !243
  %8 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %3) #49
  %9 = tail call ptr @luaS_newlstr(ptr noundef %0, ptr noundef %3, i64 noundef %8) #46
  call void @luaX_setinput(ptr noundef %0, ptr noundef nonnull %5, ptr noundef %1, ptr noundef %9) #46
  call fastcc void @open_func(ptr noundef nonnull %5, ptr noundef nonnull %6) #47
  %10 = load ptr, ptr %6, align 8, !tbaa !63
  %11 = getelementptr inbounds %struct.Proto, ptr %10, i64 0, i32 21
  store i8 2, ptr %11, align 2, !tbaa !117
  call void @luaX_next(ptr noundef nonnull %5) #46
  call fastcc void @chunk(ptr noundef nonnull %5) #47
  %12 = getelementptr inbounds %struct.LexState, ptr %5, i64 0, i32 3
  %13 = load i32, ptr %12, align 8, !tbaa !247
  %14 = icmp eq i32 %13, 287
  br i1 %14, label %16, label %15

15:                                               ; preds = %4
  call fastcc void @error_expected(ptr noundef nonnull %5, i32 noundef 287) #47
  br label %16

16:                                               ; preds = %15, %4
  call fastcc void @close_func(ptr noundef nonnull %5) #47
  %17 = load ptr, ptr %6, align 8, !tbaa !63
  call void @llvm.lifetime.end.p0(i64 600, ptr nonnull %6) #48
  call void @llvm.lifetime.end.p0(i64 96, ptr nonnull %5) #48
  ret ptr %17
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @open_func(ptr noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 6
  %4 = load ptr, ptr %3, align 8, !tbaa !240
  %5 = tail call ptr @luaF_newproto(ptr noundef %4) #46
  store ptr %5, ptr %1, align 8, !tbaa !63
  %6 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %7 = load ptr, ptr %6, align 8, !tbaa !248
  %8 = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 2
  store ptr %7, ptr %8, align 8, !tbaa !272
  %9 = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 3
  store ptr %0, ptr %9, align 8, !tbaa !66
  %10 = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 4
  store ptr %4, ptr %10, align 8, !tbaa !72
  store ptr %1, ptr %6, align 8, !tbaa !248
  %11 = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 6
  store i32 0, ptr %11, align 8, !tbaa !59
  %12 = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 7
  store i32 -1, ptr %12, align 4, !tbaa !61
  %13 = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 8
  store i32 -1, ptr %13, align 8, !tbaa !70
  %14 = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 9
  %15 = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 5
  store ptr null, ptr %15, align 8, !tbaa !273
  %16 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 9
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(15) %14, i8 0, i64 15, i1 false)
  %17 = load ptr, ptr %16, align 8, !tbaa !241
  %18 = getelementptr inbounds %struct.Proto, ptr %5, i64 0, i32 9
  store ptr %17, ptr %18, align 8, !tbaa !105
  %19 = getelementptr inbounds %struct.Proto, ptr %5, i64 0, i32 22
  store i8 2, ptr %19, align 1, !tbaa !79
  %20 = tail call ptr @luaH_new(ptr noundef %4, i32 noundef 0, i32 noundef 0) #46
  %21 = getelementptr inbounds %struct.FuncState, ptr %1, i64 0, i32 1
  store ptr %20, ptr %21, align 8, !tbaa !80
  %22 = getelementptr inbounds %struct.lua_State, ptr %4, i64 0, i32 4
  %23 = load ptr, ptr %22, align 8, !tbaa !7
  store ptr %20, ptr %23, align 8, !tbaa !33
  %24 = getelementptr inbounds %struct.lua_TValue, ptr %23, i64 0, i32 1
  store i32 5, ptr %24, align 8, !tbaa !16
  %25 = getelementptr inbounds %struct.lua_State, ptr %4, i64 0, i32 9
  %26 = load ptr, ptr %25, align 8, !tbaa !18
  %27 = load ptr, ptr %22, align 8, !tbaa !7
  %28 = ptrtoint ptr %26 to i64
  %29 = ptrtoint ptr %27 to i64
  %30 = sub i64 %28, %29
  %31 = icmp slt i64 %30, 17
  br i1 %31, label %32, label %34

32:                                               ; preds = %2
  tail call void @luaD_growstack(ptr noundef nonnull %4, i32 noundef 1) #46
  %33 = load ptr, ptr %22, align 8, !tbaa !7
  br label %34

34:                                               ; preds = %32, %2
  %35 = phi ptr [ %27, %2 ], [ %33, %32 ]
  %36 = getelementptr inbounds %struct.lua_TValue, ptr %35, i64 1
  store ptr %36, ptr %22, align 8, !tbaa !7
  store ptr %5, ptr %36, align 8, !tbaa !33
  %37 = getelementptr inbounds %struct.lua_TValue, ptr %35, i64 1, i32 1
  store i32 9, ptr %37, align 8, !tbaa !16
  %38 = load ptr, ptr %25, align 8, !tbaa !18
  %39 = load ptr, ptr %22, align 8, !tbaa !7
  %40 = ptrtoint ptr %38 to i64
  %41 = ptrtoint ptr %39 to i64
  %42 = sub i64 %40, %41
  %43 = icmp slt i64 %42, 17
  br i1 %43, label %44, label %46

44:                                               ; preds = %34
  tail call void @luaD_growstack(ptr noundef nonnull %4, i32 noundef 1) #46
  %45 = load ptr, ptr %22, align 8, !tbaa !7
  br label %46

46:                                               ; preds = %44, %34
  %47 = phi ptr [ %39, %34 ], [ %45, %44 ]
  %48 = getelementptr inbounds %struct.lua_TValue, ptr %47, i64 1
  store ptr %48, ptr %22, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @chunk(ptr noundef %0) unnamed_addr #1 {
  %2 = alloca %struct.expdesc, align 8
  %3 = alloca %struct.expdesc, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = alloca i32, align 4
  %6 = alloca %struct.BlockCnt, align 8
  %7 = alloca %struct.expdesc, align 8
  %8 = alloca %struct.BlockCnt, align 8
  %9 = alloca %struct.BlockCnt, align 8
  %10 = alloca %struct.BlockCnt, align 8
  %11 = alloca %struct.expdesc, align 8
  %12 = alloca %struct.expdesc, align 8
  %13 = alloca %struct.expdesc, align 8
  %14 = alloca %struct.expdesc, align 8
  %15 = alloca %struct.expdesc, align 8
  %16 = alloca %struct.expdesc, align 8
  %17 = alloca %struct.LHS_assign, align 8
  %18 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 6
  %19 = load ptr, ptr %18, align 8, !tbaa !240
  %20 = getelementptr inbounds %struct.lua_State, ptr %19, i64 0, i32 15
  %21 = load i16, ptr %20, align 8, !tbaa !24
  %22 = add i16 %21, 1
  store i16 %22, ptr %20, align 8, !tbaa !24
  %23 = icmp ugt i16 %22, 200
  br i1 %23, label %24, label %25

24:                                               ; preds = %1
  tail call void @luaX_lexerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.1.127, i32 noundef 0) #46
  br label %25

25:                                               ; preds = %24, %1
  %26 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  %27 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 1
  %28 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %29 = getelementptr inbounds %struct.expdesc, ptr %16, i64 0, i32 1
  %30 = getelementptr inbounds %struct.expdesc, ptr %13, i64 0, i32 2
  %31 = getelementptr inbounds %struct.expdesc, ptr %13, i64 0, i32 3
  %32 = getelementptr inbounds %struct.expdesc, ptr %13, i64 0, i32 1
  %33 = getelementptr inbounds %struct.BlockCnt, ptr %9, i64 0, i32 1
  %34 = getelementptr inbounds %struct.BlockCnt, ptr %9, i64 0, i32 4
  %35 = getelementptr inbounds %struct.BlockCnt, ptr %9, i64 0, i32 2
  %36 = getelementptr inbounds %struct.BlockCnt, ptr %9, i64 0, i32 3
  %37 = getelementptr inbounds %struct.BlockCnt, ptr %10, i64 0, i32 1
  %38 = getelementptr inbounds %struct.BlockCnt, ptr %10, i64 0, i32 4
  %39 = getelementptr inbounds %struct.BlockCnt, ptr %10, i64 0, i32 2
  %40 = getelementptr inbounds %struct.BlockCnt, ptr %10, i64 0, i32 3
  %41 = getelementptr inbounds %struct.BlockCnt, ptr %8, i64 0, i32 1
  %42 = getelementptr inbounds %struct.BlockCnt, ptr %8, i64 0, i32 4
  %43 = getelementptr inbounds %struct.BlockCnt, ptr %8, i64 0, i32 2
  %44 = getelementptr inbounds %struct.BlockCnt, ptr %8, i64 0, i32 3
  %45 = getelementptr inbounds %struct.BlockCnt, ptr %6, i64 0, i32 1
  %46 = getelementptr inbounds %struct.BlockCnt, ptr %6, i64 0, i32 4
  %47 = getelementptr inbounds %struct.BlockCnt, ptr %6, i64 0, i32 2
  %48 = getelementptr inbounds %struct.BlockCnt, ptr %6, i64 0, i32 3
  %49 = getelementptr inbounds %struct.LHS_assign, ptr %17, i64 0, i32 1
  %50 = getelementptr inbounds %struct.LHS_assign, ptr %17, i64 0, i32 1, i32 1
  br label %51

51:                                               ; preds = %264, %25
  %52 = load i32, ptr %26, align 8, !tbaa !247
  switch i32 %52, label %53 [
    i32 260, label %270
    i32 261, label %270
    i32 262, label %270
    i32 276, label %270
    i32 287, label %270
  ]

53:                                               ; preds = %51
  %54 = load i32, ptr %27, align 4, !tbaa !242
  switch i32 %52, label %243 [
    i32 266, label %55
    i32 277, label %67
    i32 259, label %76
    i32 264, label %77
    i32 272, label %128
    i32 265, label %145
    i32 268, label %154
    i32 273, label %204
    i32 258, label %242
  ]

55:                                               ; preds = %53
  %56 = load ptr, ptr %28, align 8, !tbaa !248
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #48
  store i32 -1, ptr %5, align 4, !tbaa !65
  br label %57

57:                                               ; preds = %60, %55
  call void @luaX_next(ptr noundef nonnull %0) #46
  %58 = call fastcc i32 @cond(ptr noundef nonnull %0) #47
  call fastcc void @checknext(ptr noundef nonnull %0, i32 noundef 274) #47
  call fastcc void @block(ptr noundef nonnull %0) #47
  %59 = load i32, ptr %26, align 8, !tbaa !247
  switch i32 %59, label %64 [
    i32 261, label %60
    i32 260, label %62
  ]

60:                                               ; preds = %57
  %61 = call i32 @luaK_jump(ptr noundef %56) #46
  call void @luaK_concat(ptr noundef %56, ptr noundef nonnull %5, i32 noundef %61) #46
  call void @luaK_patchtohere(ptr noundef %56, i32 noundef %58) #46
  br label %57, !llvm.loop !274

62:                                               ; preds = %57
  %.lcssa3 = phi i32 [ %58, %57 ]
  %63 = call i32 @luaK_jump(ptr noundef %56) #46
  call void @luaK_concat(ptr noundef %56, ptr noundef nonnull %5, i32 noundef %63) #46
  call void @luaK_patchtohere(ptr noundef %56, i32 noundef %.lcssa3) #46
  call void @luaX_next(ptr noundef nonnull %0) #46
  call fastcc void @block(ptr noundef nonnull %0) #47
  br label %65

64:                                               ; preds = %57
  %.lcssa2 = phi i32 [ %58, %57 ]
  call void @luaK_concat(ptr noundef %56, ptr noundef nonnull %5, i32 noundef %.lcssa2) #46
  br label %65

65:                                               ; preds = %64, %62
  %66 = load i32, ptr %5, align 4, !tbaa !65
  call void @luaK_patchtohere(ptr noundef %56, i32 noundef %66) #46
  call fastcc void @check_match(ptr noundef nonnull %0, i32 noundef 262, i32 noundef 266, i32 noundef %54) #47
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #48
  br label %259

67:                                               ; preds = %53
  %68 = load ptr, ptr %28, align 8, !tbaa !248
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %6) #48
  call void @luaX_next(ptr noundef nonnull %0) #46
  %69 = call i32 @luaK_getlabel(ptr noundef %68) #46
  %70 = call fastcc i32 @cond(ptr noundef nonnull %0) #47
  store i32 -1, ptr %45, align 8, !tbaa !275
  store i8 1, ptr %46, align 2, !tbaa !277
  %71 = getelementptr inbounds %struct.FuncState, ptr %68, i64 0, i32 13
  %72 = load i8, ptr %71, align 2, !tbaa !62
  store i8 %72, ptr %47, align 4, !tbaa !278
  store i8 0, ptr %48, align 1, !tbaa !279
  %73 = getelementptr inbounds %struct.FuncState, ptr %68, i64 0, i32 5
  %74 = load ptr, ptr %73, align 8, !tbaa !273
  store ptr %74, ptr %6, align 8, !tbaa !280
  store ptr %6, ptr %73, align 8, !tbaa !273
  call fastcc void @checknext(ptr noundef nonnull %0, i32 noundef 259) #47
  call fastcc void @block(ptr noundef nonnull %0) #47
  %75 = call i32 @luaK_jump(ptr noundef %68) #46
  call void @luaK_patchlist(ptr noundef %68, i32 noundef %75, i32 noundef %69) #46
  call fastcc void @check_match(ptr noundef nonnull %0, i32 noundef 262, i32 noundef 277, i32 noundef %54) #47
  call fastcc void @leaveblock(ptr noundef %68) #47
  call void @luaK_patchtohere(ptr noundef %68, i32 noundef %70) #46
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %6) #48
  br label %259

76:                                               ; preds = %53
  call void @luaX_next(ptr noundef nonnull %0) #46
  call fastcc void @block(ptr noundef nonnull %0) #47
  call fastcc void @check_match(ptr noundef nonnull %0, i32 noundef 262, i32 noundef 259, i32 noundef %54) #47
  br label %259

77:                                               ; preds = %53
  %78 = load ptr, ptr %28, align 8, !tbaa !248
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %8) #48
  store i32 -1, ptr %41, align 8, !tbaa !275
  store i8 1, ptr %42, align 2, !tbaa !277
  %79 = getelementptr inbounds %struct.FuncState, ptr %78, i64 0, i32 13
  %80 = load i8, ptr %79, align 2, !tbaa !62
  store i8 %80, ptr %43, align 4, !tbaa !278
  store i8 0, ptr %44, align 1, !tbaa !279
  %81 = getelementptr inbounds %struct.FuncState, ptr %78, i64 0, i32 5
  %82 = load ptr, ptr %81, align 8, !tbaa !273
  store ptr %82, ptr %8, align 8, !tbaa !280
  store ptr %8, ptr %81, align 8, !tbaa !273
  call void @luaX_next(ptr noundef nonnull %0) #46
  %83 = call fastcc ptr @str_checkname(ptr noundef nonnull %0) #47
  %84 = load i32, ptr %26, align 8, !tbaa !247
  switch i32 %84, label %126 [
    i32 61, label %85
    i32 44, label %106
    i32 267, label %106
  ]

85:                                               ; preds = %77
  %86 = load ptr, ptr %28, align 8, !tbaa !248
  %87 = getelementptr inbounds %struct.FuncState, ptr %86, i64 0, i32 9
  %88 = load i32, ptr %87, align 4, !tbaa !78
  %89 = call ptr @luaX_newstring(ptr noundef nonnull %0, ptr noundef nonnull @.str.19.128, i64 noundef 11) #46
  call fastcc void @new_localvar(ptr noundef nonnull %0, ptr noundef %89, i32 noundef 0) #47
  %90 = call ptr @luaX_newstring(ptr noundef nonnull %0, ptr noundef nonnull @.str.20.129, i64 noundef 11) #46
  call fastcc void @new_localvar(ptr noundef nonnull %0, ptr noundef %90, i32 noundef 1) #47
  %91 = call ptr @luaX_newstring(ptr noundef nonnull %0, ptr noundef nonnull @.str.21.130, i64 noundef 10) #46
  call fastcc void @new_localvar(ptr noundef nonnull %0, ptr noundef %91, i32 noundef 2) #47
  call fastcc void @new_localvar(ptr noundef nonnull %0, ptr noundef %83, i32 noundef 3) #47
  call fastcc void @checknext(ptr noundef nonnull %0, i32 noundef 61) #47
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %2) #48
  %92 = call fastcc i32 @subexpr(ptr noundef nonnull %0, ptr noundef nonnull %2, i32 noundef 0) #47, !range !281
  %93 = load ptr, ptr %28, align 8, !tbaa !248
  call void @luaK_exp2nextreg(ptr noundef %93, ptr noundef nonnull %2) #46
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %2) #48
  call fastcc void @checknext(ptr noundef nonnull %0, i32 noundef 44) #47
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3) #48
  %94 = call fastcc i32 @subexpr(ptr noundef nonnull %0, ptr noundef nonnull %3, i32 noundef 0) #47, !range !281
  %95 = load ptr, ptr %28, align 8, !tbaa !248
  call void @luaK_exp2nextreg(ptr noundef %95, ptr noundef nonnull %3) #46
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3) #48
  %96 = load i32, ptr %26, align 8, !tbaa !247
  %97 = icmp eq i32 %96, 44
  br i1 %97, label %98, label %101

98:                                               ; preds = %85
  call void @luaX_next(ptr noundef nonnull %0) #46
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4) #48
  %99 = call fastcc i32 @subexpr(ptr noundef nonnull %0, ptr noundef nonnull %4, i32 noundef 0) #47, !range !281
  %100 = load ptr, ptr %28, align 8, !tbaa !248
  call void @luaK_exp2nextreg(ptr noundef %100, ptr noundef nonnull %4) #46
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4) #48
  br label %105

101:                                              ; preds = %85
  %102 = load i32, ptr %87, align 4, !tbaa !78
  %103 = call i32 @luaK_numberK(ptr noundef nonnull %86, double noundef 1.000000e+00) #46
  %104 = call i32 @luaK_codeABx(ptr noundef nonnull %86, i32 noundef 1, i32 noundef %102, i32 noundef %103) #46
  call void @luaK_reserveregs(ptr noundef nonnull %86, i32 noundef 1) #46
  br label %105

105:                                              ; preds = %101, %98
  call fastcc void @forbody(ptr noundef nonnull %0, i32 noundef %88, i32 noundef %54, i32 noundef 1, i32 noundef 1) #47
  br label %127

106:                                              ; preds = %77, %77
  %107 = load ptr, ptr %28, align 8, !tbaa !248
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %7) #48
  %108 = getelementptr inbounds %struct.FuncState, ptr %107, i64 0, i32 9
  %109 = load i32, ptr %108, align 4, !tbaa !78
  %110 = call ptr @luaX_newstring(ptr noundef nonnull %0, ptr noundef nonnull @.str.22.131, i64 noundef 15) #46
  call fastcc void @new_localvar(ptr noundef nonnull %0, ptr noundef %110, i32 noundef 0) #47
  %111 = call ptr @luaX_newstring(ptr noundef nonnull %0, ptr noundef nonnull @.str.23.132, i64 noundef 11) #46
  call fastcc void @new_localvar(ptr noundef nonnull %0, ptr noundef %111, i32 noundef 1) #47
  %112 = call ptr @luaX_newstring(ptr noundef nonnull %0, ptr noundef nonnull @.str.24.133, i64 noundef 13) #46
  call fastcc void @new_localvar(ptr noundef nonnull %0, ptr noundef %112, i32 noundef 2) #47
  call fastcc void @new_localvar(ptr noundef nonnull %0, ptr noundef %83, i32 noundef 3) #47
  %113 = load i32, ptr %26, align 8, !tbaa !247
  %114 = icmp eq i32 %113, 44
  br i1 %114, label %115, label %121

115:                                              ; preds = %115, %106
  %116 = phi i32 [ %118, %115 ], [ 4, %106 ]
  call void @luaX_next(ptr noundef nonnull %0) #46
  %117 = call fastcc ptr @str_checkname(ptr noundef nonnull %0) #47
  %118 = add nuw nsw i32 %116, 1
  call fastcc void @new_localvar(ptr noundef nonnull %0, ptr noundef %117, i32 noundef %116) #47
  %119 = load i32, ptr %26, align 8, !tbaa !247
  %120 = icmp eq i32 %119, 44
  br i1 %120, label %115, label %121, !llvm.loop !282

121:                                              ; preds = %115, %106
  %122 = phi i32 [ 4, %106 ], [ %118, %115 ]
  call fastcc void @checknext(ptr noundef nonnull %0, i32 noundef 267) #47
  %123 = load i32, ptr %27, align 4, !tbaa !242
  %124 = call fastcc i32 @explist1(ptr noundef nonnull %0, ptr noundef nonnull %7) #47
  call fastcc void @adjust_assign(ptr noundef nonnull %0, i32 noundef 3, i32 noundef %124, ptr noundef nonnull %7) #47
  call void @luaK_checkstack(ptr noundef %107, i32 noundef 3) #46
  %125 = add nsw i32 %122, -3
  call fastcc void @forbody(ptr noundef nonnull %0, i32 noundef %109, i32 noundef %123, i32 noundef %125, i32 noundef 0) #47
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %7) #48
  br label %127

126:                                              ; preds = %77
  call void @luaX_syntaxerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.18.134) #46
  br label %127

127:                                              ; preds = %126, %121, %105
  call fastcc void @check_match(ptr noundef nonnull %0, i32 noundef 262, i32 noundef 264, i32 noundef %54) #47
  call fastcc void @leaveblock(ptr noundef %78) #47
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %8) #48
  br label %259

128:                                              ; preds = %53
  %129 = load ptr, ptr %28, align 8, !tbaa !248
  %130 = call i32 @luaK_getlabel(ptr noundef %129) #46
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %9) #48
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %10) #48
  store i32 -1, ptr %33, align 8, !tbaa !275
  store i8 1, ptr %34, align 2, !tbaa !277
  %131 = getelementptr inbounds %struct.FuncState, ptr %129, i64 0, i32 13
  %132 = load i8, ptr %131, align 2, !tbaa !62
  store i8 %132, ptr %35, align 4, !tbaa !278
  store i8 0, ptr %36, align 1, !tbaa !279
  %133 = getelementptr inbounds %struct.FuncState, ptr %129, i64 0, i32 5
  %134 = load ptr, ptr %133, align 8, !tbaa !273
  store ptr %134, ptr %9, align 8, !tbaa !280
  store i32 -1, ptr %37, align 8, !tbaa !275
  store i8 0, ptr %38, align 2, !tbaa !277
  store i8 %132, ptr %39, align 4, !tbaa !278
  store i8 0, ptr %40, align 1, !tbaa !279
  store ptr %9, ptr %10, align 8, !tbaa !280
  store ptr %10, ptr %133, align 8, !tbaa !273
  call void @luaX_next(ptr noundef nonnull %0) #46
  call fastcc void @chunk(ptr noundef nonnull %0) #47
  call fastcc void @check_match(ptr noundef nonnull %0, i32 noundef 276, i32 noundef 272, i32 noundef %54) #47
  %135 = call fastcc i32 @cond(ptr noundef nonnull %0) #47
  %136 = load i8, ptr %40, align 1, !tbaa !279
  %137 = icmp eq i8 %136, 0
  br i1 %137, label %138, label %140

138:                                              ; preds = %128
  call fastcc void @leaveblock(ptr noundef nonnull %129) #47
  %139 = load ptr, ptr %28, align 8, !tbaa !248
  call void @luaK_patchlist(ptr noundef %139, i32 noundef %135, i32 noundef %130) #46
  br label %144

140:                                              ; preds = %128
  call fastcc void @breakstat(ptr noundef nonnull %0) #47
  %141 = load ptr, ptr %28, align 8, !tbaa !248
  call void @luaK_patchtohere(ptr noundef %141, i32 noundef %135) #46
  call fastcc void @leaveblock(ptr noundef nonnull %129) #47
  %142 = load ptr, ptr %28, align 8, !tbaa !248
  %143 = call i32 @luaK_jump(ptr noundef nonnull %129) #46
  call void @luaK_patchlist(ptr noundef %142, i32 noundef %143, i32 noundef %130) #46
  br label %144

144:                                              ; preds = %140, %138
  call fastcc void @leaveblock(ptr noundef nonnull %129) #47
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %10) #48
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %9) #48
  br label %259

145:                                              ; preds = %53
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %11) #48
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %12) #48
  call void @luaX_next(ptr noundef nonnull %0) #46
  call fastcc void @singlevar(ptr noundef nonnull %0, ptr noundef nonnull %11) #47
  br label %146

146:                                              ; preds = %148, %145
  %147 = load i32, ptr %26, align 8, !tbaa !247
  switch i32 %147, label %150 [
    i32 46, label %148
    i32 58, label %149
  ]

148:                                              ; preds = %146
  call fastcc void @field(ptr noundef nonnull %0, ptr noundef nonnull %11) #47
  br label %146, !llvm.loop !283

149:                                              ; preds = %146
  call fastcc void @field(ptr noundef nonnull %0, ptr noundef nonnull %11) #47
  br label %150

150:                                              ; preds = %149, %146
  %151 = phi i32 [ 1, %149 ], [ 0, %146 ]
  call fastcc void @body(ptr noundef nonnull %0, ptr noundef nonnull %12, i32 noundef %151, i32 noundef %54) #47
  %152 = load ptr, ptr %28, align 8, !tbaa !248
  call void @luaK_storevar(ptr noundef %152, ptr noundef nonnull %11, ptr noundef nonnull %12) #46
  %153 = load ptr, ptr %28, align 8, !tbaa !248
  call void @luaK_fixline(ptr noundef %153, i32 noundef %54) #46
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %12) #48
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %11) #48
  br label %259

154:                                              ; preds = %53
  call void @luaX_next(ptr noundef nonnull %0) #46
  %155 = load i32, ptr %26, align 8, !tbaa !247
  %156 = icmp eq i32 %155, 265
  br i1 %156, label %157, label %191

157:                                              ; preds = %154
  call void @luaX_next(ptr noundef nonnull %0) #46
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %13) #48
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %14) #48
  %158 = load ptr, ptr %28, align 8, !tbaa !248
  %159 = call fastcc ptr @str_checkname(ptr noundef nonnull %0) #47
  call fastcc void @new_localvar(ptr noundef nonnull %0, ptr noundef %159, i32 noundef 0) #47
  %160 = getelementptr inbounds %struct.FuncState, ptr %158, i64 0, i32 9
  %161 = load i32, ptr %160, align 4, !tbaa !78
  store i32 -1, ptr %30, align 8, !tbaa !87
  store i32 -1, ptr %31, align 4, !tbaa !88
  store i32 6, ptr %13, align 8, !tbaa !85
  store i32 %161, ptr %32, align 8, !tbaa !33
  call void @luaK_reserveregs(ptr noundef %158, i32 noundef 1) #46
  %162 = load ptr, ptr %28, align 8, !tbaa !248
  %163 = getelementptr inbounds %struct.FuncState, ptr %162, i64 0, i32 13
  %164 = load i8, ptr %163, align 2, !tbaa !62
  %165 = add i8 %164, 1
  store i8 %165, ptr %163, align 2, !tbaa !62
  %166 = getelementptr inbounds %struct.FuncState, ptr %162, i64 0, i32 6
  %167 = load i32, ptr %166, align 8, !tbaa !59
  %168 = load ptr, ptr %162, align 8, !tbaa !63
  %169 = getelementptr inbounds %struct.Proto, ptr %168, i64 0, i32 7
  %170 = load ptr, ptr %169, align 8, !tbaa !167
  %171 = zext i8 %165 to i64
  %172 = add nsw i64 %171, -1
  %173 = getelementptr inbounds %struct.FuncState, ptr %162, i64 0, i32 15, i64 %172
  %174 = load i16, ptr %173, align 2, !tbaa !239
  %175 = zext i16 %174 to i64
  %176 = getelementptr inbounds %struct.stringtable, ptr %170, i64 %175, i32 1
  store i32 %167, ptr %176, align 8, !tbaa !170
  %177 = load i32, ptr %27, align 4, !tbaa !242
  call fastcc void @body(ptr noundef nonnull %0, ptr noundef nonnull %14, i32 noundef 0, i32 noundef %177) #47
  call void @luaK_storevar(ptr noundef %158, ptr noundef nonnull %13, ptr noundef nonnull %14) #46
  %178 = getelementptr inbounds %struct.FuncState, ptr %158, i64 0, i32 6
  %179 = load i32, ptr %178, align 8, !tbaa !59
  %180 = load ptr, ptr %158, align 8, !tbaa !63
  %181 = getelementptr inbounds %struct.Proto, ptr %180, i64 0, i32 7
  %182 = load ptr, ptr %181, align 8, !tbaa !167
  %183 = getelementptr inbounds %struct.FuncState, ptr %158, i64 0, i32 13
  %184 = load i8, ptr %183, align 2, !tbaa !62
  %185 = zext i8 %184 to i64
  %186 = add nsw i64 %185, -1
  %187 = getelementptr inbounds %struct.FuncState, ptr %158, i64 0, i32 15, i64 %186
  %188 = load i16, ptr %187, align 2, !tbaa !239
  %189 = zext i16 %188 to i64
  %190 = getelementptr inbounds %struct.stringtable, ptr %182, i64 %189, i32 1
  store i32 %179, ptr %190, align 8, !tbaa !170
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %14) #48
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %13) #48
  br label %259

191:                                              ; preds = %154
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %15) #48
  br label %192

192:                                              ; preds = %197, %191
  %193 = phi i32 [ 0, %191 ], [ %195, %197 ]
  %194 = call fastcc ptr @str_checkname(ptr noundef nonnull %0) #47
  %195 = add nuw nsw i32 %193, 1
  call fastcc void @new_localvar(ptr noundef nonnull %0, ptr noundef %194, i32 noundef %193) #47
  %196 = load i32, ptr %26, align 8, !tbaa !247
  switch i32 %196, label %200 [
    i32 44, label %197
    i32 61, label %198
  ]

197:                                              ; preds = %192
  call void @luaX_next(ptr noundef nonnull %0) #46
  br label %192, !llvm.loop !284

198:                                              ; preds = %192
  %.lcssa1 = phi i32 [ %195, %192 ]
  call void @luaX_next(ptr noundef nonnull %0) #46
  %199 = call fastcc i32 @explist1(ptr noundef nonnull %0, ptr noundef nonnull %15) #47
  br label %201

200:                                              ; preds = %192
  %.lcssa = phi i32 [ %195, %192 ]
  store i32 0, ptr %15, align 8, !tbaa !85
  br label %201

201:                                              ; preds = %200, %198
  %202 = phi i32 [ %.lcssa1, %198 ], [ %.lcssa, %200 ]
  %203 = phi i32 [ %199, %198 ], [ 0, %200 ]
  call fastcc void @adjust_assign(ptr noundef nonnull %0, i32 noundef %202, i32 noundef %203, ptr noundef nonnull %15) #47
  call fastcc void @adjustlocalvars(ptr noundef nonnull %0, i32 noundef %202) #47
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %15) #48
  br label %259

204:                                              ; preds = %53
  %205 = load ptr, ptr %28, align 8, !tbaa !248
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %16) #48
  call void @luaX_next(ptr noundef nonnull %0) #46
  %206 = load i32, ptr %26, align 8, !tbaa !247
  switch i32 %206, label %207 [
    i32 260, label %239
    i32 261, label %239
    i32 262, label %239
    i32 276, label %239
    i32 287, label %239
    i32 59, label %239
  ]

207:                                              ; preds = %204
  %208 = call fastcc i32 @explist1(ptr noundef nonnull %0, ptr noundef nonnull %16) #47
  %209 = load i32, ptr %16, align 8
  %210 = add i32 %209, -13
  %211 = icmp ult i32 %210, 2
  br i1 %211, label %212, label %231

212:                                              ; preds = %207
  call void @luaK_setreturns(ptr noundef %205, ptr noundef nonnull %16, i32 noundef -1) #46
  %213 = load i32, ptr %16, align 8, !tbaa !85
  %214 = icmp eq i32 %213, 13
  %215 = icmp eq i32 %208, 1
  %216 = select i1 %214, i1 %215, i1 false
  br i1 %216, label %217, label %227

217:                                              ; preds = %212
  %218 = load ptr, ptr %205, align 8, !tbaa !63
  %219 = getelementptr inbounds %struct.Proto, ptr %218, i64 0, i32 4
  %220 = load ptr, ptr %219, align 8, !tbaa !64
  %221 = load i32, ptr %29, align 8, !tbaa !33
  %222 = sext i32 %221 to i64
  %223 = getelementptr inbounds i32, ptr %220, i64 %222
  %224 = load i32, ptr %223, align 4, !tbaa !65
  %225 = and i32 %224, -64
  %226 = or i32 %225, 29
  store i32 %226, ptr %223, align 4, !tbaa !65
  br label %227

227:                                              ; preds = %217, %212
  %228 = getelementptr inbounds %struct.FuncState, ptr %205, i64 0, i32 13
  %229 = load i8, ptr %228, align 2, !tbaa !62
  %230 = zext i8 %229 to i32
  br label %239

231:                                              ; preds = %207
  %232 = icmp eq i32 %208, 1
  br i1 %232, label %233, label %235

233:                                              ; preds = %231
  %234 = call i32 @luaK_exp2anyreg(ptr noundef %205, ptr noundef nonnull %16) #46
  br label %239

235:                                              ; preds = %231
  call void @luaK_exp2nextreg(ptr noundef %205, ptr noundef nonnull %16) #46
  %236 = getelementptr inbounds %struct.FuncState, ptr %205, i64 0, i32 13
  %237 = load i8, ptr %236, align 2, !tbaa !62
  %238 = zext i8 %237 to i32
  br label %239

239:                                              ; preds = %235, %233, %227, %204, %204, %204, %204, %204, %204
  %240 = phi i32 [ %230, %227 ], [ %234, %233 ], [ %238, %235 ], [ 0, %204 ], [ 0, %204 ], [ 0, %204 ], [ 0, %204 ], [ 0, %204 ], [ 0, %204 ]
  %241 = phi i32 [ -1, %227 ], [ 1, %233 ], [ %208, %235 ], [ 0, %204 ], [ 0, %204 ], [ 0, %204 ], [ 0, %204 ], [ 0, %204 ], [ 0, %204 ]
  call void @luaK_ret(ptr noundef %205, i32 noundef %240, i32 noundef %241) #46
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %16) #48
  br label %259

242:                                              ; preds = %53
  call void @luaX_next(ptr noundef nonnull %0) #46
  call fastcc void @breakstat(ptr noundef nonnull %0) #47
  br label %259

243:                                              ; preds = %53
  %244 = load ptr, ptr %28, align 8, !tbaa !248
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %17) #48
  call fastcc void @primaryexp(ptr noundef nonnull %0, ptr noundef nonnull %49) #47
  %245 = load i32, ptr %49, align 8, !tbaa !285
  %246 = icmp eq i32 %245, 13
  br i1 %246, label %247, label %257

247:                                              ; preds = %243
  %248 = load ptr, ptr %244, align 8, !tbaa !63
  %249 = getelementptr inbounds %struct.Proto, ptr %248, i64 0, i32 4
  %250 = load ptr, ptr %249, align 8, !tbaa !64
  %251 = load i32, ptr %50, align 8, !tbaa !33
  %252 = sext i32 %251 to i64
  %253 = getelementptr inbounds i32, ptr %250, i64 %252
  %254 = load i32, ptr %253, align 4, !tbaa !65
  %255 = and i32 %254, -8372225
  %256 = or i32 %255, 16384
  store i32 %256, ptr %253, align 4, !tbaa !65
  br label %258

257:                                              ; preds = %243
  store ptr null, ptr %17, align 8, !tbaa !287
  call fastcc void @assignment(ptr noundef nonnull %0, ptr noundef nonnull %17, i32 noundef 1) #47
  br label %258

258:                                              ; preds = %257, %247
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %17) #48
  br label %259

259:                                              ; preds = %258, %242, %239, %201, %157, %150, %144, %127, %76, %67, %65
  %260 = phi i1 [ true, %258 ], [ false, %242 ], [ false, %239 ], [ true, %150 ], [ true, %144 ], [ true, %127 ], [ true, %76 ], [ true, %67 ], [ true, %65 ], [ true, %201 ], [ true, %157 ]
  %261 = load i32, ptr %26, align 8, !tbaa !247
  %262 = icmp eq i32 %261, 59
  br i1 %262, label %263, label %264

263:                                              ; preds = %259
  call void @luaX_next(ptr noundef nonnull %0) #46
  br label %264

264:                                              ; preds = %263, %259
  %265 = load ptr, ptr %28, align 8, !tbaa !248
  %266 = getelementptr inbounds %struct.FuncState, ptr %265, i64 0, i32 13
  %267 = load i8, ptr %266, align 2, !tbaa !62
  %268 = zext i8 %267 to i32
  %269 = getelementptr inbounds %struct.FuncState, ptr %265, i64 0, i32 9
  store i32 %268, ptr %269, align 4, !tbaa !78
  br i1 %260, label %51, label %270, !llvm.loop !288

270:                                              ; preds = %264, %51, %51, %51, %51, %51
  %271 = load ptr, ptr %18, align 8, !tbaa !240
  %272 = getelementptr inbounds %struct.lua_State, ptr %271, i64 0, i32 15
  %273 = load i16, ptr %272, align 8, !tbaa !24
  %274 = add i16 %273, -1
  store i16 %274, ptr %272, align 8, !tbaa !24
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @error_expected(ptr noundef %0, i32 noundef %1) unnamed_addr #1 {
  %3 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 6
  %4 = load ptr, ptr %3, align 8, !tbaa !240
  %5 = tail call ptr @luaX_token2str(ptr noundef %0, i32 noundef %1) #46
  %6 = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %4, ptr noundef nonnull @.str.126, ptr noundef %5) #46
  tail call void @luaX_syntaxerror(ptr noundef %0, ptr noundef %6) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @close_func(ptr noundef %0) unnamed_addr #1 {
  %2 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 6
  %3 = load ptr, ptr %2, align 8, !tbaa !240
  %4 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %5 = load ptr, ptr %4, align 8, !tbaa !248
  %6 = load ptr, ptr %5, align 8, !tbaa !63
  %7 = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 13
  %8 = load i8, ptr %7, align 2, !tbaa !62
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %27, label %10

10:                                               ; preds = %1
  %11 = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 6
  %12 = load i32, ptr %11, align 8, !tbaa !59
  %13 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 7
  %14 = load ptr, ptr %13, align 8, !tbaa !167
  %15 = zext i8 %8 to i64
  br label %16

16:                                               ; preds = %16, %10
  %17 = phi i64 [ %18, %16 ], [ %15, %10 ]
  %18 = add nsw i64 %17, -1
  %19 = and i64 %18, 255
  %20 = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 15, i64 %19
  %21 = load i16, ptr %20, align 2, !tbaa !239
  %22 = zext i16 %21 to i64
  %23 = getelementptr inbounds %struct.stringtable, ptr %14, i64 %22, i32 2
  store i32 %12, ptr %23, align 4, !tbaa !171
  %24 = and i64 %18, 255
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %26, label %16, !llvm.loop !289

26:                                               ; preds = %16
  store i8 0, ptr %7, align 2, !tbaa !62
  br label %27

27:                                               ; preds = %26, %1
  tail call void @luaK_ret(ptr noundef nonnull %5, i32 noundef 0, i32 noundef 0) #46
  %28 = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 6
  %29 = load i32, ptr %28, align 8, !tbaa !59
  %30 = icmp sgt i32 %29, -2
  br i1 %30, label %31, label %41

31:                                               ; preds = %27
  %32 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 4
  %33 = load ptr, ptr %32, align 8, !tbaa !64
  %34 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 12
  %35 = load i32, ptr %34, align 8, !tbaa !71
  %36 = sext i32 %35 to i64
  %37 = shl nsw i64 %36, 2
  %38 = sext i32 %29 to i64
  %39 = shl nsw i64 %38, 2
  %40 = tail call ptr @luaM_realloc_(ptr noundef %3, ptr noundef %33, i64 noundef %37, i64 noundef %39) #46
  br label %43

41:                                               ; preds = %27
  %42 = tail call ptr @luaM_toobig(ptr noundef %3) #46
  br label %43

43:                                               ; preds = %41, %31
  %44 = phi ptr [ %40, %31 ], [ %42, %41 ]
  %45 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 4
  store ptr %44, ptr %45, align 8, !tbaa !64
  %46 = load i32, ptr %28, align 8, !tbaa !59
  %47 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 12
  store i32 %46, ptr %47, align 8, !tbaa !71
  %48 = icmp sgt i32 %46, -2
  br i1 %48, label %49, label %59

49:                                               ; preds = %43
  %50 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 6
  %51 = load ptr, ptr %50, align 8, !tbaa !74
  %52 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 13
  %53 = load i32, ptr %52, align 4, !tbaa !73
  %54 = sext i32 %53 to i64
  %55 = shl nsw i64 %54, 2
  %56 = sext i32 %46 to i64
  %57 = shl nsw i64 %56, 2
  %58 = tail call ptr @luaM_realloc_(ptr noundef %3, ptr noundef %51, i64 noundef %55, i64 noundef %57) #46
  br label %61

59:                                               ; preds = %43
  %60 = tail call ptr @luaM_toobig(ptr noundef %3) #46
  br label %61

61:                                               ; preds = %59, %49
  %62 = phi ptr [ %58, %49 ], [ %60, %59 ]
  %63 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 6
  store ptr %62, ptr %63, align 8, !tbaa !74
  %64 = load i32, ptr %28, align 8, !tbaa !59
  %65 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 13
  store i32 %64, ptr %65, align 4, !tbaa !73
  %66 = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 10
  %67 = load i32, ptr %66, align 8, !tbaa !82
  %68 = icmp sgt i32 %67, -2
  br i1 %68, label %69, label %79

69:                                               ; preds = %61
  %70 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 3
  %71 = load ptr, ptr %70, align 8, !tbaa !83
  %72 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 11
  %73 = load i32, ptr %72, align 4, !tbaa !81
  %74 = sext i32 %73 to i64
  %75 = shl nsw i64 %74, 4
  %76 = sext i32 %67 to i64
  %77 = shl nsw i64 %76, 4
  %78 = tail call ptr @luaM_realloc_(ptr noundef %3, ptr noundef %71, i64 noundef %75, i64 noundef %77) #46
  br label %81

79:                                               ; preds = %61
  %80 = tail call ptr @luaM_toobig(ptr noundef %3) #46
  br label %81

81:                                               ; preds = %79, %69
  %82 = phi ptr [ %78, %69 ], [ %80, %79 ]
  %83 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 3
  store ptr %82, ptr %83, align 8, !tbaa !83
  %84 = load i32, ptr %66, align 8, !tbaa !82
  %85 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 11
  store i32 %84, ptr %85, align 4, !tbaa !81
  %86 = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 11
  %87 = load i32, ptr %86, align 4, !tbaa !290
  %88 = icmp sgt i32 %87, -2
  br i1 %88, label %89, label %99

89:                                               ; preds = %81
  %90 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 5
  %91 = load ptr, ptr %90, align 8, !tbaa !121
  %92 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 14
  %93 = load i32, ptr %92, align 8, !tbaa !120
  %94 = sext i32 %93 to i64
  %95 = shl nsw i64 %94, 3
  %96 = sext i32 %87 to i64
  %97 = shl nsw i64 %96, 3
  %98 = tail call ptr @luaM_realloc_(ptr noundef %3, ptr noundef %91, i64 noundef %95, i64 noundef %97) #46
  br label %101

99:                                               ; preds = %81
  %100 = tail call ptr @luaM_toobig(ptr noundef %3) #46
  br label %101

101:                                              ; preds = %99, %89
  %102 = phi ptr [ %98, %89 ], [ %100, %99 ]
  %103 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 5
  store ptr %102, ptr %103, align 8, !tbaa !121
  %104 = load i32, ptr %86, align 4, !tbaa !290
  %105 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 14
  store i32 %104, ptr %105, align 8, !tbaa !120
  %106 = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 12
  %107 = load i16, ptr %106, align 8, !tbaa !291
  %108 = sext i16 %107 to i64
  %109 = add nsw i64 %108, 1
  %110 = icmp ult i64 %109, 1152921504606846976
  br i1 %110, label %111, label %120

111:                                              ; preds = %101
  %112 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 7
  %113 = load ptr, ptr %112, align 8, !tbaa !167
  %114 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 15
  %115 = load i32, ptr %114, align 4, !tbaa !166
  %116 = sext i32 %115 to i64
  %117 = shl nsw i64 %116, 4
  %118 = shl nsw i64 %108, 4
  %119 = tail call ptr @luaM_realloc_(ptr noundef %3, ptr noundef %113, i64 noundef %117, i64 noundef %118) #46
  br label %122

120:                                              ; preds = %101
  %121 = tail call ptr @luaM_toobig(ptr noundef %3) #46
  br label %122

122:                                              ; preds = %120, %111
  %123 = phi ptr [ %119, %111 ], [ %121, %120 ]
  %124 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 7
  store ptr %123, ptr %124, align 8, !tbaa !167
  %125 = load i16, ptr %106, align 8, !tbaa !291
  %126 = sext i16 %125 to i32
  %127 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 15
  store i32 %126, ptr %127, align 4, !tbaa !166
  %128 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 19
  %129 = load i8, ptr %128, align 8, !tbaa !118
  %130 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 8
  %131 = load ptr, ptr %130, align 8, !tbaa !58
  %132 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 10
  %133 = load i32, ptr %132, align 8, !tbaa !55
  %134 = sext i32 %133 to i64
  %135 = shl nsw i64 %134, 3
  %136 = zext i8 %129 to i64
  %137 = shl nuw nsw i64 %136, 3
  %138 = tail call ptr @luaM_realloc_(ptr noundef %3, ptr noundef %131, i64 noundef %135, i64 noundef %137) #46
  store ptr %138, ptr %130, align 8, !tbaa !58
  %139 = load i8, ptr %128, align 8, !tbaa !118
  %140 = zext i8 %139 to i32
  store i32 %140, ptr %132, align 8, !tbaa !55
  %141 = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 2
  %142 = load ptr, ptr %141, align 8, !tbaa !272
  store ptr %142, ptr %4, align 8, !tbaa !248
  %143 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 4
  %144 = load ptr, ptr %143, align 8, !tbaa !7
  %145 = getelementptr inbounds %struct.lua_TValue, ptr %144, i64 -2
  store ptr %145, ptr %143, align 8, !tbaa !7
  %146 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  %147 = load i32, ptr %146, align 8, !tbaa !247
  %148 = add i32 %147, -285
  %149 = icmp ult i32 %148, 2
  br i1 %149, label %150, label %157

150:                                              ; preds = %122
  %151 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3, i32 1
  %152 = load ptr, ptr %151, align 8, !tbaa !33
  %153 = getelementptr inbounds %union.TString, ptr %152, i64 1
  %154 = getelementptr inbounds %struct.anon.0, ptr %152, i64 0, i32 5
  %155 = load i64, ptr %154, align 8, !tbaa !33
  %156 = tail call ptr @luaX_newstring(ptr noundef nonnull %0, ptr noundef nonnull %153, i64 noundef %155) #46
  br label %157

157:                                              ; preds = %150, %122
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @cond(ptr noundef %0) unnamed_addr #1 {
  %2 = alloca %struct.expdesc, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %2) #48
  %3 = call fastcc i32 @subexpr(ptr noundef %0, ptr noundef nonnull %2, i32 noundef 0) #47, !range !281
  %4 = load i32, ptr %2, align 8, !tbaa !85
  %5 = icmp eq i32 %4, 1
  br i1 %5, label %6, label %7

6:                                                ; preds = %1
  store i32 3, ptr %2, align 8, !tbaa !85
  br label %7

7:                                                ; preds = %6, %1
  %8 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %9 = load ptr, ptr %8, align 8, !tbaa !248
  call void @luaK_goiftrue(ptr noundef %9, ptr noundef nonnull %2) #46
  %10 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 3
  %11 = load i32, ptr %10, align 4, !tbaa !88
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %2) #48
  ret i32 %11
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @checknext(ptr noundef %0, i32 noundef %1) unnamed_addr #1 {
  %3 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  %4 = load i32, ptr %3, align 8, !tbaa !247
  %5 = icmp eq i32 %4, %1
  br i1 %5, label %7, label %6

6:                                                ; preds = %2
  tail call fastcc void @error_expected(ptr noundef nonnull %0, i32 noundef %1) #47
  br label %7

7:                                                ; preds = %6, %2
  tail call void @luaX_next(ptr noundef nonnull %0) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @block(ptr noundef %0) unnamed_addr #1 {
  %2 = alloca %struct.BlockCnt, align 8
  %3 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %4 = load ptr, ptr %3, align 8, !tbaa !248
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %2) #48
  %5 = getelementptr inbounds %struct.BlockCnt, ptr %2, i64 0, i32 1
  store i32 -1, ptr %5, align 8, !tbaa !275
  %6 = getelementptr inbounds %struct.BlockCnt, ptr %2, i64 0, i32 4
  store i8 0, ptr %6, align 2, !tbaa !277
  %7 = getelementptr inbounds %struct.FuncState, ptr %4, i64 0, i32 13
  %8 = load i8, ptr %7, align 2, !tbaa !62
  %9 = getelementptr inbounds %struct.BlockCnt, ptr %2, i64 0, i32 2
  store i8 %8, ptr %9, align 4, !tbaa !278
  %10 = getelementptr inbounds %struct.BlockCnt, ptr %2, i64 0, i32 3
  store i8 0, ptr %10, align 1, !tbaa !279
  %11 = getelementptr inbounds %struct.FuncState, ptr %4, i64 0, i32 5
  %12 = load ptr, ptr %11, align 8, !tbaa !273
  store ptr %12, ptr %2, align 8, !tbaa !280
  store ptr %2, ptr %11, align 8, !tbaa !273
  call fastcc void @chunk(ptr noundef %0) #47
  call fastcc void @leaveblock(ptr noundef %4) #47
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %2) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @check_match(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) unnamed_addr #1 {
  %5 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  %6 = load i32, ptr %5, align 8, !tbaa !247
  %7 = icmp eq i32 %6, %1
  br i1 %7, label %8, label %9

8:                                                ; preds = %4
  tail call void @luaX_next(ptr noundef nonnull %0) #46
  br label %20

9:                                                ; preds = %4
  %10 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 1
  %11 = load i32, ptr %10, align 4, !tbaa !242
  %12 = icmp eq i32 %11, %3
  br i1 %12, label %13, label %14

13:                                               ; preds = %9
  tail call fastcc void @error_expected(ptr noundef nonnull %0, i32 noundef %1) #47
  br label %20

14:                                               ; preds = %9
  %15 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 6
  %16 = load ptr, ptr %15, align 8, !tbaa !240
  %17 = tail call ptr @luaX_token2str(ptr noundef nonnull %0, i32 noundef %1) #46
  %18 = tail call ptr @luaX_token2str(ptr noundef nonnull %0, i32 noundef %2) #46
  %19 = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %16, ptr noundef nonnull @.str.17.153, ptr noundef %17, ptr noundef %18, i32 noundef %3) #46
  tail call void @luaX_syntaxerror(ptr noundef nonnull %0, ptr noundef %19) #46
  br label %20

20:                                               ; preds = %14, %13, %8
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @leaveblock(ptr noundef %0) unnamed_addr #1 {
  %2 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 5
  %3 = load ptr, ptr %2, align 8, !tbaa !273
  %4 = load ptr, ptr %3, align 8, !tbaa !280
  store ptr %4, ptr %2, align 8, !tbaa !273
  %5 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %6 = load ptr, ptr %5, align 8, !tbaa !66
  %7 = getelementptr inbounds %struct.BlockCnt, ptr %3, i64 0, i32 2
  %8 = load i8, ptr %7, align 4, !tbaa !278
  %9 = zext i8 %8 to i32
  %10 = getelementptr inbounds %struct.LexState, ptr %6, i64 0, i32 5
  %11 = load ptr, ptr %10, align 8, !tbaa !248
  %12 = getelementptr inbounds %struct.FuncState, ptr %11, i64 0, i32 13
  %13 = load i8, ptr %12, align 2, !tbaa !62
  %14 = icmp ugt i8 %13, %8
  br i1 %14, label %15, label %33

15:                                               ; preds = %1
  %16 = getelementptr inbounds %struct.FuncState, ptr %11, i64 0, i32 6
  %17 = load i32, ptr %16, align 8, !tbaa !59
  %18 = load ptr, ptr %11, align 8, !tbaa !63
  %19 = getelementptr inbounds %struct.Proto, ptr %18, i64 0, i32 7
  %20 = load ptr, ptr %19, align 8, !tbaa !167
  %21 = zext i8 %13 to i64
  br label %22

22:                                               ; preds = %22, %15
  %23 = phi i64 [ %24, %22 ], [ %21, %15 ]
  %24 = add nsw i64 %23, -1
  %25 = trunc i64 %24 to i8
  %26 = and i64 %24, 255
  %27 = getelementptr inbounds %struct.FuncState, ptr %11, i64 0, i32 15, i64 %26
  %28 = load i16, ptr %27, align 2, !tbaa !239
  %29 = zext i16 %28 to i64
  %30 = getelementptr inbounds %struct.stringtable, ptr %20, i64 %29, i32 2
  store i32 %17, ptr %30, align 4, !tbaa !171
  %31 = icmp ult i8 %8, %25
  br i1 %31, label %22, label %32, !llvm.loop !289

32:                                               ; preds = %22
  store i8 %8, ptr %12, align 2, !tbaa !62
  br label %33

33:                                               ; preds = %32, %1
  %34 = getelementptr inbounds %struct.BlockCnt, ptr %3, i64 0, i32 3
  %35 = load i8, ptr %34, align 1, !tbaa !279
  %36 = icmp eq i8 %35, 0
  br i1 %36, label %39, label %37

37:                                               ; preds = %33
  %38 = tail call i32 @luaK_codeABC(ptr noundef %0, i32 noundef 35, i32 noundef %9, i32 noundef 0, i32 noundef 0) #46
  br label %39

39:                                               ; preds = %37, %33
  %40 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %41 = load i8, ptr %40, align 2, !tbaa !62
  %42 = zext i8 %41 to i32
  %43 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 9
  store i32 %42, ptr %43, align 4, !tbaa !78
  %44 = getelementptr inbounds %struct.BlockCnt, ptr %3, i64 0, i32 1
  %45 = load i32, ptr %44, align 8, !tbaa !275
  tail call void @luaK_patchtohere(ptr noundef %0, i32 noundef %45) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @str_checkname(ptr noundef %0) unnamed_addr #1 {
  %2 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  %3 = load i32, ptr %2, align 8, !tbaa !247
  %4 = icmp eq i32 %3, 285
  br i1 %4, label %6, label %5

5:                                                ; preds = %1
  tail call fastcc void @error_expected(ptr noundef nonnull %0, i32 noundef 285) #47
  br label %6

6:                                                ; preds = %5, %1
  %7 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3, i32 1
  %8 = load ptr, ptr %7, align 8, !tbaa !33
  tail call void @luaX_next(ptr noundef nonnull %0) #46
  ret ptr %8
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @new_localvar(ptr nocapture noundef readonly %0, ptr noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %5 = load ptr, ptr %4, align 8, !tbaa !248
  %6 = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 13
  %7 = load i8, ptr %6, align 2, !tbaa !62
  %8 = zext i8 %7 to i32
  %9 = add nsw i32 %8, %2
  %10 = icmp sgt i32 %9, 199
  br i1 %10, label %11, label %13

11:                                               ; preds = %3
  tail call fastcc void @errorlimit(ptr noundef nonnull %5, i32 noundef 200, ptr noundef nonnull @.str.7.151) #47
  %12 = load ptr, ptr %4, align 8, !tbaa !248
  br label %13

13:                                               ; preds = %11, %3
  %14 = phi ptr [ %12, %11 ], [ %5, %3 ]
  %15 = load ptr, ptr %14, align 8, !tbaa !63
  %16 = getelementptr inbounds %struct.Proto, ptr %15, i64 0, i32 15
  %17 = load i32, ptr %16, align 4, !tbaa !166
  %18 = getelementptr inbounds %struct.FuncState, ptr %14, i64 0, i32 12
  %19 = load i16, ptr %18, align 8, !tbaa !291
  %20 = sext i16 %19 to i32
  %21 = icmp sgt i32 %17, %20
  br i1 %21, label %22, label %25

22:                                               ; preds = %13
  %23 = getelementptr inbounds %struct.Proto, ptr %15, i64 0, i32 7
  %24 = load ptr, ptr %23, align 8, !tbaa !167
  br label %41

25:                                               ; preds = %13
  %26 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 6
  %27 = load ptr, ptr %26, align 8, !tbaa !240
  %28 = getelementptr inbounds %struct.Proto, ptr %15, i64 0, i32 7
  %29 = load ptr, ptr %28, align 8, !tbaa !167
  %30 = tail call ptr @luaM_growaux_(ptr noundef %27, ptr noundef %29, ptr noundef nonnull %16, i64 noundef 16, i32 noundef 32767, ptr noundef nonnull @.str.8.152) #46
  store ptr %30, ptr %28, align 8, !tbaa !167
  %31 = load i32, ptr %16, align 4, !tbaa !166
  %32 = icmp slt i32 %17, %31
  br i1 %32, label %33, label %41

33:                                               ; preds = %25
  %34 = sext i32 %17 to i64
  %35 = sext i32 %31 to i64
  br label %36

36:                                               ; preds = %36, %33
  %37 = phi i64 [ %34, %33 ], [ %38, %36 ]
  %38 = add nsw i64 %37, 1
  %39 = getelementptr inbounds %struct.stringtable, ptr %30, i64 %37
  store ptr null, ptr %39, align 8, !tbaa !168
  %40 = icmp eq i64 %38, %35
  br i1 %40, label %41, label %36, !llvm.loop !292

41:                                               ; preds = %36, %25, %22
  %42 = phi ptr [ %24, %22 ], [ %30, %25 ], [ %30, %36 ]
  %43 = load i16, ptr %18, align 8, !tbaa !291
  %44 = sext i16 %43 to i64
  %45 = getelementptr inbounds %struct.stringtable, ptr %42, i64 %44
  store ptr %1, ptr %45, align 8, !tbaa !168
  %46 = getelementptr inbounds %struct.GCheader, ptr %1, i64 0, i32 2
  %47 = load i8, ptr %46, align 1, !tbaa !33
  %48 = and i8 %47, 3
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %59, label %50

50:                                               ; preds = %41
  %51 = getelementptr inbounds %struct.GCheader, ptr %15, i64 0, i32 2
  %52 = load i8, ptr %51, align 1, !tbaa !33
  %53 = and i8 %52, 4
  %54 = icmp eq i8 %53, 0
  br i1 %54, label %59, label %55

55:                                               ; preds = %50
  %56 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 6
  %57 = load ptr, ptr %56, align 8, !tbaa !240
  tail call void @luaC_barrierf(ptr noundef %57, ptr noundef nonnull %15, ptr noundef nonnull %1) #46
  %58 = load i16, ptr %18, align 8, !tbaa !291
  br label %59

59:                                               ; preds = %55, %50, %41
  %60 = phi i16 [ %58, %55 ], [ %43, %50 ], [ %43, %41 ]
  %61 = add i16 %60, 1
  store i16 %61, ptr %18, align 8, !tbaa !291
  %62 = load i8, ptr %6, align 2, !tbaa !62
  %63 = zext i8 %62 to i32
  %64 = add nsw i32 %63, %2
  %65 = sext i32 %64 to i64
  %66 = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 15, i64 %65
  store i16 %60, ptr %66, align 2, !tbaa !239
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @subexpr(ptr noundef %0, ptr noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = alloca %struct.expdesc, align 8
  %5 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 6
  %6 = load ptr, ptr %5, align 8, !tbaa !240
  %7 = getelementptr inbounds %struct.lua_State, ptr %6, i64 0, i32 15
  %8 = load i16, ptr %7, align 8, !tbaa !24
  %9 = add i16 %8, 1
  store i16 %9, ptr %7, align 8, !tbaa !24
  %10 = icmp ugt i16 %9, 200
  br i1 %10, label %11, label %12

11:                                               ; preds = %3
  tail call void @luaX_lexerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.1.127, i32 noundef 0) #46
  br label %12

12:                                               ; preds = %11, %3
  %13 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  %14 = load i32, ptr %13, align 8, !tbaa !247
  switch i32 %14, label %73 [
    i32 270, label %17
    i32 45, label %15
    i32 35, label %16
    i32 284, label %22
    i32 286, label %28
    i32 269, label %37
    i32 275, label %41
    i32 263, label %45
    i32 279, label %49
    i32 123, label %69
    i32 265, label %70
  ]

15:                                               ; preds = %12
  br label %17

16:                                               ; preds = %12
  br label %17

17:                                               ; preds = %16, %15, %12
  %18 = phi i32 [ 1, %12 ], [ 0, %15 ], [ 2, %16 ]
  tail call void @luaX_next(ptr noundef nonnull %0) #46
  %19 = tail call fastcc i32 @subexpr(ptr noundef nonnull %0, ptr noundef %1, i32 noundef 8) #47, !range !281
  %20 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %21 = load ptr, ptr %20, align 8, !tbaa !248
  tail call void @luaK_prefix(ptr noundef %21, i32 noundef %18, ptr noundef %1) #46
  br label %75

22:                                               ; preds = %12
  %23 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 2
  store i32 -1, ptr %23, align 8, !tbaa !87
  %24 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 3
  store i32 -1, ptr %24, align 4, !tbaa !88
  store i32 5, ptr %1, align 8, !tbaa !85
  %25 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  store i32 0, ptr %25, align 8, !tbaa !33
  %26 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3, i32 1
  %27 = load double, ptr %26, align 8, !tbaa !33
  store double %27, ptr %25, align 8, !tbaa !33
  br label %74

28:                                               ; preds = %12
  %29 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3, i32 1
  %30 = load ptr, ptr %29, align 8, !tbaa !33
  %31 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %32 = load ptr, ptr %31, align 8, !tbaa !248
  %33 = tail call i32 @luaK_stringK(ptr noundef %32, ptr noundef %30) #46
  %34 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 2
  store i32 -1, ptr %34, align 8, !tbaa !87
  %35 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 3
  store i32 -1, ptr %35, align 4, !tbaa !88
  store i32 4, ptr %1, align 8, !tbaa !85
  %36 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  store i32 %33, ptr %36, align 8, !tbaa !33
  br label %74

37:                                               ; preds = %12
  %38 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 2
  store i32 -1, ptr %38, align 8, !tbaa !87
  %39 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 3
  store i32 -1, ptr %39, align 4, !tbaa !88
  store i32 1, ptr %1, align 8, !tbaa !85
  %40 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  store i32 0, ptr %40, align 8, !tbaa !33
  br label %74

41:                                               ; preds = %12
  %42 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 2
  store i32 -1, ptr %42, align 8, !tbaa !87
  %43 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 3
  store i32 -1, ptr %43, align 4, !tbaa !88
  store i32 2, ptr %1, align 8, !tbaa !85
  %44 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  store i32 0, ptr %44, align 8, !tbaa !33
  br label %74

45:                                               ; preds = %12
  %46 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 2
  store i32 -1, ptr %46, align 8, !tbaa !87
  %47 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 3
  store i32 -1, ptr %47, align 4, !tbaa !88
  store i32 3, ptr %1, align 8, !tbaa !85
  %48 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  store i32 0, ptr %48, align 8, !tbaa !33
  br label %74

49:                                               ; preds = %12
  %50 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %51 = load ptr, ptr %50, align 8, !tbaa !248
  %52 = load ptr, ptr %51, align 8, !tbaa !63
  %53 = getelementptr inbounds %struct.Proto, ptr %52, i64 0, i32 21
  %54 = load i8, ptr %53, align 2, !tbaa !117
  %55 = icmp eq i8 %54, 0
  br i1 %55, label %56, label %60

56:                                               ; preds = %49
  tail call void @luaX_syntaxerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.2.150) #46
  %57 = load ptr, ptr %51, align 8, !tbaa !63
  %58 = getelementptr inbounds %struct.Proto, ptr %57, i64 0, i32 21
  %59 = load i8, ptr %58, align 2, !tbaa !117
  br label %60

60:                                               ; preds = %56, %49
  %61 = phi i8 [ %59, %56 ], [ %54, %49 ]
  %62 = phi ptr [ %57, %56 ], [ %52, %49 ]
  %63 = getelementptr inbounds %struct.Proto, ptr %62, i64 0, i32 21
  %64 = and i8 %61, -5
  store i8 %64, ptr %63, align 2, !tbaa !117
  %65 = tail call i32 @luaK_codeABC(ptr noundef nonnull %51, i32 noundef 37, i32 noundef 0, i32 noundef 1, i32 noundef 0) #46
  %66 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 2
  store i32 -1, ptr %66, align 8, !tbaa !87
  %67 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 3
  store i32 -1, ptr %67, align 4, !tbaa !88
  store i32 14, ptr %1, align 8, !tbaa !85
  %68 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  store i32 %65, ptr %68, align 8, !tbaa !33
  br label %74

69:                                               ; preds = %12
  tail call fastcc void @constructor(ptr noundef nonnull %0, ptr noundef %1) #47
  br label %75

70:                                               ; preds = %12
  tail call void @luaX_next(ptr noundef nonnull %0) #46
  %71 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 1
  %72 = load i32, ptr %71, align 4, !tbaa !242
  tail call fastcc void @body(ptr noundef nonnull %0, ptr noundef %1, i32 noundef 0, i32 noundef %72) #47
  br label %75

73:                                               ; preds = %12
  tail call fastcc void @primaryexp(ptr noundef nonnull %0, ptr noundef %1) #47
  br label %75

74:                                               ; preds = %60, %45, %41, %37, %28, %22
  tail call void @luaX_next(ptr noundef nonnull %0) #46
  br label %75

75:                                               ; preds = %74, %73, %70, %69, %17
  %76 = load i32, ptr %13, align 8, !tbaa !247
  switch i32 %76, label %109 [
    i32 43, label %91
    i32 45, label %77
    i32 42, label %78
    i32 47, label %79
    i32 37, label %80
    i32 94, label %81
    i32 278, label %82
    i32 283, label %83
    i32 280, label %84
    i32 60, label %85
    i32 282, label %86
    i32 62, label %87
    i32 281, label %88
    i32 257, label %89
    i32 271, label %90
  ]

77:                                               ; preds = %75
  br label %91

78:                                               ; preds = %75
  br label %91

79:                                               ; preds = %75
  br label %91

80:                                               ; preds = %75
  br label %91

81:                                               ; preds = %75
  br label %91

82:                                               ; preds = %75
  br label %91

83:                                               ; preds = %75
  br label %91

84:                                               ; preds = %75
  br label %91

85:                                               ; preds = %75
  br label %91

86:                                               ; preds = %75
  br label %91

87:                                               ; preds = %75
  br label %91

88:                                               ; preds = %75
  br label %91

89:                                               ; preds = %75
  br label %91

90:                                               ; preds = %75
  br label %91

91:                                               ; preds = %90, %89, %88, %87, %86, %85, %84, %83, %82, %81, %80, %79, %78, %77, %75
  %92 = phi i32 [ 0, %75 ], [ 1, %77 ], [ 2, %78 ], [ 3, %79 ], [ 4, %80 ], [ 5, %81 ], [ 6, %82 ], [ 7, %83 ], [ 8, %84 ], [ 9, %85 ], [ 10, %86 ], [ 11, %87 ], [ 12, %88 ], [ 13, %89 ], [ 14, %90 ]
  %93 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  br label %94

94:                                               ; preds = %101, %91
  %95 = phi i32 [ %92, %91 ], [ %106, %101 ]
  %96 = zext i32 %95 to i64
  %97 = getelementptr inbounds [15 x %struct.upvaldesc], ptr @priority, i64 0, i64 %96
  %98 = load i8, ptr %97, align 2, !tbaa !293
  %99 = zext i8 %98 to i32
  %100 = icmp ugt i32 %99, %2
  br i1 %100, label %101, label %109

101:                                              ; preds = %94
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4) #48
  call void @luaX_next(ptr noundef nonnull %0) #46
  %102 = load ptr, ptr %93, align 8, !tbaa !248
  call void @luaK_infix(ptr noundef %102, i32 noundef %95, ptr noundef %1) #46
  %103 = getelementptr inbounds [15 x %struct.upvaldesc], ptr @priority, i64 0, i64 %96, i32 1
  %104 = load i8, ptr %103, align 1, !tbaa !295
  %105 = zext i8 %104 to i32
  %106 = call fastcc i32 @subexpr(ptr noundef nonnull %0, ptr noundef nonnull %4, i32 noundef %105) #47, !range !281
  %107 = load ptr, ptr %93, align 8, !tbaa !248
  call void @luaK_posfix(ptr noundef %107, i32 noundef %95, ptr noundef %1, ptr noundef nonnull %4) #46
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4) #48
  %108 = icmp eq i32 %106, 15
  br i1 %108, label %109, label %94, !llvm.loop !296

109:                                              ; preds = %101, %94, %75
  %110 = phi i32 [ 15, %75 ], [ 15, %101 ], [ %95, %94 ]
  %111 = load ptr, ptr %5, align 8, !tbaa !240
  %112 = getelementptr inbounds %struct.lua_State, ptr %111, i64 0, i32 15
  %113 = load i16, ptr %112, align 8, !tbaa !24
  %114 = add i16 %113, -1
  store i16 %114, ptr %112, align 8, !tbaa !24
  ret i32 %110
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @forbody(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) unnamed_addr #1 {
  %6 = alloca %struct.BlockCnt, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %6) #48
  %7 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %8 = load ptr, ptr %7, align 8, !tbaa !248
  %9 = getelementptr inbounds %struct.FuncState, ptr %8, i64 0, i32 13
  %10 = load i8, ptr %9, align 2, !tbaa !62
  %11 = add i8 %10, 3
  store i8 %11, ptr %9, align 2, !tbaa !62
  %12 = getelementptr inbounds %struct.FuncState, ptr %8, i64 0, i32 6
  %13 = load i32, ptr %12, align 8, !tbaa !59
  %14 = load ptr, ptr %8, align 8, !tbaa !63
  %15 = getelementptr inbounds %struct.Proto, ptr %14, i64 0, i32 7
  %16 = load ptr, ptr %15, align 8, !tbaa !167
  %17 = zext i8 %11 to i64
  br label %18

18:                                               ; preds = %18, %5
  %19 = phi i64 [ 3, %5 ], [ %25, %18 ]
  %20 = sub nsw i64 %17, %19
  %21 = getelementptr inbounds %struct.FuncState, ptr %8, i64 0, i32 15, i64 %20
  %22 = load i16, ptr %21, align 2, !tbaa !239
  %23 = zext i16 %22 to i64
  %24 = getelementptr inbounds %struct.stringtable, ptr %16, i64 %23, i32 1
  store i32 %13, ptr %24, align 8, !tbaa !170
  %25 = add nsw i64 %19, -1
  %26 = and i64 %25, 4294967295
  %27 = icmp eq i64 %26, 0
  br i1 %27, label %28, label %18, !llvm.loop !297

28:                                               ; preds = %18
  tail call fastcc void @checknext(ptr noundef %0, i32 noundef 259) #47
  %29 = icmp eq i32 %4, 0
  br i1 %29, label %32, label %30

30:                                               ; preds = %28
  %31 = tail call i32 @luaK_codeABx(ptr noundef nonnull %8, i32 noundef 32, i32 noundef %1, i32 noundef 131070) #46
  br label %34

32:                                               ; preds = %28
  %33 = tail call i32 @luaK_jump(ptr noundef nonnull %8) #46
  br label %34

34:                                               ; preds = %32, %30
  %35 = phi i32 [ %31, %30 ], [ %33, %32 ]
  %36 = getelementptr inbounds %struct.BlockCnt, ptr %6, i64 0, i32 1
  store i32 -1, ptr %36, align 8, !tbaa !275
  %37 = getelementptr inbounds %struct.BlockCnt, ptr %6, i64 0, i32 4
  store i8 0, ptr %37, align 2, !tbaa !277
  %38 = load i8, ptr %9, align 2, !tbaa !62
  %39 = getelementptr inbounds %struct.BlockCnt, ptr %6, i64 0, i32 2
  store i8 %38, ptr %39, align 4, !tbaa !278
  %40 = getelementptr inbounds %struct.BlockCnt, ptr %6, i64 0, i32 3
  store i8 0, ptr %40, align 1, !tbaa !279
  %41 = getelementptr inbounds %struct.FuncState, ptr %8, i64 0, i32 5
  %42 = load ptr, ptr %41, align 8, !tbaa !273
  store ptr %42, ptr %6, align 8, !tbaa !280
  store ptr %6, ptr %41, align 8, !tbaa !273
  call fastcc void @adjustlocalvars(ptr noundef %0, i32 noundef %3) #47
  call void @luaK_reserveregs(ptr noundef nonnull %8, i32 noundef %3) #46
  call fastcc void @block(ptr noundef %0) #47
  call fastcc void @leaveblock(ptr noundef nonnull %8) #47
  call void @luaK_patchtohere(ptr noundef nonnull %8, i32 noundef %35) #46
  br i1 %29, label %45, label %43

43:                                               ; preds = %34
  %44 = call i32 @luaK_codeABx(ptr noundef nonnull %8, i32 noundef 31, i32 noundef %1, i32 noundef 131070) #46
  call void @luaK_fixline(ptr noundef nonnull %8, i32 noundef %2) #46
  br label %48

45:                                               ; preds = %34
  %46 = call i32 @luaK_codeABC(ptr noundef nonnull %8, i32 noundef 33, i32 noundef %1, i32 noundef 0, i32 noundef %3) #46
  call void @luaK_fixline(ptr noundef nonnull %8, i32 noundef %2) #46
  %47 = call i32 @luaK_jump(ptr noundef nonnull %8) #46
  br label %48

48:                                               ; preds = %45, %43
  %49 = phi i32 [ %47, %45 ], [ %44, %43 ]
  %50 = add nsw i32 %35, 1
  call void @luaK_patchlist(ptr noundef nonnull %8, i32 noundef %49, i32 noundef %50) #46
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %6) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @explist1(ptr noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = tail call fastcc i32 @subexpr(ptr noundef %0, ptr noundef %1, i32 noundef 0) #47, !range !281
  %4 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  %5 = load i32, ptr %4, align 8, !tbaa !247
  %6 = icmp eq i32 %5, 44
  br i1 %6, label %7, label %16

7:                                                ; preds = %2
  %8 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  br label %9

9:                                                ; preds = %9, %7
  %10 = phi i32 [ 1, %7 ], [ %13, %9 ]
  tail call void @luaX_next(ptr noundef nonnull %0) #46
  %11 = load ptr, ptr %8, align 8, !tbaa !248
  tail call void @luaK_exp2nextreg(ptr noundef %11, ptr noundef %1) #46
  %12 = tail call fastcc i32 @subexpr(ptr noundef nonnull %0, ptr noundef %1, i32 noundef 0) #47, !range !281
  %13 = add nuw nsw i32 %10, 1
  %14 = load i32, ptr %4, align 8, !tbaa !247
  %15 = icmp eq i32 %14, 44
  br i1 %15, label %9, label %16, !llvm.loop !298

16:                                               ; preds = %9, %2
  %17 = phi i32 [ 1, %2 ], [ %13, %9 ]
  ret i32 %17
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @adjust_assign(ptr nocapture noundef readonly %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) unnamed_addr #1 {
  %5 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %6 = load ptr, ptr %5, align 8, !tbaa !248
  %7 = sub nsw i32 %1, %2
  %8 = load i32, ptr %3, align 8, !tbaa !85
  switch i32 %8, label %14 [
    i32 13, label %9
    i32 14, label %9
    i32 0, label %15
  ]

9:                                                ; preds = %4, %4
  %10 = tail call i32 @llvm.smax.i32(i32 %7, i32 -1)
  %11 = add nsw i32 %10, 1
  tail call void @luaK_setreturns(ptr noundef %6, ptr noundef nonnull %3, i32 noundef %11) #46
  %12 = icmp sgt i32 %10, 0
  br i1 %12, label %13, label %20

13:                                               ; preds = %9
  tail call void @luaK_reserveregs(ptr noundef %6, i32 noundef %10) #46
  br label %20

14:                                               ; preds = %4
  tail call void @luaK_exp2nextreg(ptr noundef %6, ptr noundef nonnull %3) #46
  br label %15

15:                                               ; preds = %14, %4
  %16 = icmp sgt i32 %7, 0
  br i1 %16, label %17, label %20

17:                                               ; preds = %15
  %18 = getelementptr inbounds %struct.FuncState, ptr %6, i64 0, i32 9
  %19 = load i32, ptr %18, align 4, !tbaa !78
  tail call void @luaK_reserveregs(ptr noundef %6, i32 noundef %7) #46
  tail call void @luaK_nil(ptr noundef %6, i32 noundef %19, i32 noundef %7) #46
  br label %20

20:                                               ; preds = %17, %15, %13, %9
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @breakstat(ptr noundef %0) unnamed_addr #1 {
  %2 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %3 = load ptr, ptr %2, align 8, !tbaa !248
  %4 = getelementptr inbounds %struct.FuncState, ptr %3, i64 0, i32 5
  %5 = load ptr, ptr %4, align 8, !tbaa !39
  %6 = icmp eq ptr %5, null
  br i1 %6, label %20, label %7

7:                                                ; preds = %13, %1
  %8 = phi ptr [ %18, %13 ], [ %5, %1 ]
  %9 = phi i32 [ %17, %13 ], [ 0, %1 ]
  %10 = getelementptr inbounds %struct.BlockCnt, ptr %8, i64 0, i32 4
  %11 = load i8, ptr %10, align 2, !tbaa !277
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %13, label %22

13:                                               ; preds = %7
  %14 = getelementptr inbounds %struct.BlockCnt, ptr %8, i64 0, i32 3
  %15 = load i8, ptr %14, align 1, !tbaa !279
  %16 = zext i8 %15 to i32
  %17 = or i32 %9, %16
  %18 = load ptr, ptr %8, align 8, !tbaa !39
  %19 = icmp eq ptr %18, null
  br i1 %19, label %20, label %7, !llvm.loop !299

20:                                               ; preds = %13, %1
  %21 = phi i32 [ 0, %1 ], [ %17, %13 ]
  tail call void @luaX_syntaxerror(ptr noundef %0, ptr noundef nonnull @.str.25.149) #46
  br label %22

22:                                               ; preds = %20, %7
  %23 = phi i32 [ %21, %20 ], [ %9, %7 ]
  %24 = phi ptr [ null, %20 ], [ %8, %7 ]
  %25 = icmp eq i32 %23, 0
  br i1 %25, label %31, label %26

26:                                               ; preds = %22
  %27 = getelementptr inbounds %struct.BlockCnt, ptr %24, i64 0, i32 2
  %28 = load i8, ptr %27, align 4, !tbaa !278
  %29 = zext i8 %28 to i32
  %30 = tail call i32 @luaK_codeABC(ptr noundef %3, i32 noundef 35, i32 noundef %29, i32 noundef 0, i32 noundef 0) #46
  br label %31

31:                                               ; preds = %26, %22
  %32 = getelementptr inbounds %struct.BlockCnt, ptr %24, i64 0, i32 1
  %33 = tail call i32 @luaK_jump(ptr noundef %3) #46
  tail call void @luaK_concat(ptr noundef %3, ptr noundef nonnull %32, i32 noundef %33) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @singlevar(ptr noundef %0, ptr nocapture noundef %1) unnamed_addr #1 {
  %3 = tail call fastcc ptr @str_checkname(ptr noundef %0) #47
  %4 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %5 = load ptr, ptr %4, align 8, !tbaa !248
  %6 = tail call fastcc i32 @singlevaraux(ptr noundef %5, ptr noundef %3, ptr noundef %1, i32 noundef 1) #47, !range !300
  %7 = icmp eq i32 %6, 8
  br i1 %7, label %8, label %11

8:                                                ; preds = %2
  %9 = tail call i32 @luaK_stringK(ptr noundef %5, ptr noundef %3) #46
  %10 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  store i32 %9, ptr %10, align 8, !tbaa !33
  br label %11

11:                                               ; preds = %8, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @field(ptr noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = alloca %struct.expdesc, align 8
  %4 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %5 = load ptr, ptr %4, align 8, !tbaa !248
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3) #48
  %6 = tail call i32 @luaK_exp2anyreg(ptr noundef %5, ptr noundef %1) #46
  tail call void @luaX_next(ptr noundef %0) #46
  %7 = tail call fastcc ptr @str_checkname(ptr noundef %0) #47
  %8 = load ptr, ptr %4, align 8, !tbaa !248
  %9 = tail call i32 @luaK_stringK(ptr noundef %8, ptr noundef %7) #46
  %10 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 2
  store i32 -1, ptr %10, align 8, !tbaa !87
  %11 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 3
  store i32 -1, ptr %11, align 4, !tbaa !88
  store i32 4, ptr %3, align 8, !tbaa !85
  %12 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 1
  store i32 %9, ptr %12, align 8, !tbaa !33
  call void @luaK_indexed(ptr noundef %5, ptr noundef %1, ptr noundef nonnull %3) #46
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @body(ptr noundef %0, ptr nocapture noundef writeonly %1, i32 noundef %2, i32 noundef %3) unnamed_addr #1 {
  %5 = alloca %struct.FuncState, align 8
  call void @llvm.lifetime.start.p0(i64 600, ptr nonnull %5) #48
  call fastcc void @open_func(ptr noundef %0, ptr noundef nonnull %5) #47
  %6 = load ptr, ptr %5, align 8, !tbaa !63
  %7 = getelementptr inbounds %struct.Proto, ptr %6, i64 0, i32 16
  store i32 %3, ptr %7, align 8, !tbaa !106
  call fastcc void @checknext(ptr noundef %0, i32 noundef 40) #47
  %8 = icmp eq i32 %2, 0
  br i1 %8, label %9, label %13

9:                                                ; preds = %4
  %10 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %11 = load ptr, ptr %10, align 8, !tbaa !248
  %12 = load ptr, ptr %11, align 8, !tbaa !63
  br label %31

13:                                               ; preds = %4
  %14 = call ptr @luaX_newstring(ptr noundef %0, ptr noundef nonnull @.str.6.143, i64 noundef 4) #46
  call fastcc void @new_localvar(ptr noundef %0, ptr noundef %14, i32 noundef 0) #47
  %15 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %16 = load ptr, ptr %15, align 8, !tbaa !248
  %17 = getelementptr inbounds %struct.FuncState, ptr %16, i64 0, i32 13
  %18 = load i8, ptr %17, align 2, !tbaa !62
  %19 = add i8 %18, 1
  store i8 %19, ptr %17, align 2, !tbaa !62
  %20 = getelementptr inbounds %struct.FuncState, ptr %16, i64 0, i32 6
  %21 = load i32, ptr %20, align 8, !tbaa !59
  %22 = load ptr, ptr %16, align 8, !tbaa !63
  %23 = getelementptr inbounds %struct.Proto, ptr %22, i64 0, i32 7
  %24 = load ptr, ptr %23, align 8, !tbaa !167
  %25 = zext i8 %19 to i64
  %26 = add nsw i64 %25, -1
  %27 = getelementptr inbounds %struct.FuncState, ptr %16, i64 0, i32 15, i64 %26
  %28 = load i16, ptr %27, align 2, !tbaa !239
  %29 = zext i16 %28 to i64
  %30 = getelementptr inbounds %struct.stringtable, ptr %24, i64 %29, i32 1
  store i32 %21, ptr %30, align 8, !tbaa !170
  br label %31

31:                                               ; preds = %13, %9
  %32 = phi ptr [ %12, %9 ], [ %22, %13 ]
  %33 = phi ptr [ %11, %9 ], [ %16, %13 ]
  %34 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %35 = getelementptr inbounds %struct.Proto, ptr %32, i64 0, i32 21
  store i8 0, ptr %35, align 2, !tbaa !117
  %36 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  %37 = load i32, ptr %36, align 8, !tbaa !247
  %38 = icmp eq i32 %37, 41
  br i1 %38, label %58, label %41

39:                                               ; preds = %55
  call void @luaX_next(ptr noundef nonnull %0) #46
  %40 = load i32, ptr %36, align 8, !tbaa !247
  br label %41

41:                                               ; preds = %39, %31
  %42 = phi i32 [ %40, %39 ], [ %37, %31 ]
  %43 = phi i32 [ %52, %39 ], [ 0, %31 ]
  switch i32 %42, label %50 [
    i32 285, label %44
    i32 279, label %47
  ]

44:                                               ; preds = %41
  %45 = call fastcc ptr @str_checkname(ptr noundef nonnull %0) #47
  %46 = add nsw i32 %43, 1
  call fastcc void @new_localvar(ptr noundef nonnull %0, ptr noundef %45, i32 noundef %43) #47
  br label %51

47:                                               ; preds = %41
  %.lcssa = phi i32 [ %43, %41 ]
  call void @luaX_next(ptr noundef nonnull %0) #46
  %48 = call ptr @luaX_newstring(ptr noundef nonnull %0, ptr noundef nonnull @.str.9.144, i64 noundef 3) #46
  %49 = add nsw i32 %.lcssa, 1
  call fastcc void @new_localvar(ptr noundef nonnull %0, ptr noundef %48, i32 noundef %.lcssa) #47
  store i8 7, ptr %35, align 2, !tbaa !117
  br label %58

50:                                               ; preds = %41
  call void @luaX_syntaxerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.10.145) #46
  br label %51

51:                                               ; preds = %50, %44
  %52 = phi i32 [ %46, %44 ], [ %43, %50 ]
  %53 = load i8, ptr %35, align 2, !tbaa !117
  %54 = icmp eq i8 %53, 0
  br i1 %54, label %55, label %58

55:                                               ; preds = %51
  %56 = load i32, ptr %36, align 8, !tbaa !247
  %57 = icmp eq i32 %56, 44
  br i1 %57, label %39, label %58

58:                                               ; preds = %55, %51, %47, %31
  %59 = phi i32 [ 0, %31 ], [ %49, %47 ], [ %52, %55 ], [ %52, %51 ]
  call fastcc void @adjustlocalvars(ptr noundef nonnull %0, i32 noundef %59) #47
  %60 = getelementptr inbounds %struct.FuncState, ptr %33, i64 0, i32 13
  %61 = load i8, ptr %60, align 2, !tbaa !62
  %62 = load i8, ptr %35, align 2, !tbaa !117
  %63 = and i8 %62, 1
  %64 = sub i8 %61, %63
  %65 = getelementptr inbounds %struct.Proto, ptr %32, i64 0, i32 20
  store i8 %64, ptr %65, align 1, !tbaa !116
  %66 = zext i8 %61 to i32
  call void @luaK_reserveregs(ptr noundef nonnull %33, i32 noundef %66) #46
  call fastcc void @checknext(ptr noundef nonnull %0, i32 noundef 41) #47
  call fastcc void @chunk(ptr noundef nonnull %0) #47
  %67 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 1
  %68 = load i32, ptr %67, align 4, !tbaa !242
  %69 = load ptr, ptr %5, align 8, !tbaa !63
  %70 = getelementptr inbounds %struct.Proto, ptr %69, i64 0, i32 17
  store i32 %68, ptr %70, align 4, !tbaa !107
  call fastcc void @check_match(ptr noundef nonnull %0, i32 noundef 262, i32 noundef 265, i32 noundef %3) #47
  call fastcc void @close_func(ptr noundef nonnull %0) #47
  %71 = load ptr, ptr %34, align 8, !tbaa !248
  %72 = load ptr, ptr %71, align 8, !tbaa !63
  %73 = getelementptr inbounds %struct.Proto, ptr %72, i64 0, i32 14
  %74 = load i32, ptr %73, align 8, !tbaa !120
  %75 = getelementptr inbounds %struct.FuncState, ptr %71, i64 0, i32 11
  %76 = load i32, ptr %75, align 4, !tbaa !290
  %77 = icmp slt i32 %76, %74
  br i1 %77, label %95, label %78

78:                                               ; preds = %58
  %79 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 6
  %80 = load ptr, ptr %79, align 8, !tbaa !240
  %81 = getelementptr inbounds %struct.Proto, ptr %72, i64 0, i32 5
  %82 = load ptr, ptr %81, align 8, !tbaa !121
  %83 = call ptr @luaM_growaux_(ptr noundef %80, ptr noundef %82, ptr noundef nonnull %73, i64 noundef 8, i32 noundef 262143, ptr noundef nonnull @.str.11.146) #46
  store ptr %83, ptr %81, align 8, !tbaa !121
  %84 = load i32, ptr %73, align 8, !tbaa !120
  %85 = icmp slt i32 %74, %84
  br i1 %85, label %86, label %95

86:                                               ; preds = %78
  %87 = sext i32 %74 to i64
  %88 = sext i32 %84 to i64
  br label %89

89:                                               ; preds = %89, %86
  %90 = phi i64 [ %87, %86 ], [ %92, %89 ]
  %91 = load ptr, ptr %81, align 8, !tbaa !121
  %92 = add nsw i64 %90, 1
  %93 = getelementptr inbounds ptr, ptr %91, i64 %90
  store ptr null, ptr %93, align 8, !tbaa !39
  %94 = icmp eq i64 %92, %88
  br i1 %94, label %95, label %89, !llvm.loop !301

95:                                               ; preds = %89, %78, %58
  %96 = load ptr, ptr %5, align 8, !tbaa !63
  %97 = getelementptr inbounds %struct.Proto, ptr %72, i64 0, i32 5
  %98 = load ptr, ptr %97, align 8, !tbaa !121
  %99 = load i32, ptr %75, align 4, !tbaa !290
  %100 = add nsw i32 %99, 1
  store i32 %100, ptr %75, align 4, !tbaa !290
  %101 = sext i32 %99 to i64
  %102 = getelementptr inbounds ptr, ptr %98, i64 %101
  store ptr %96, ptr %102, align 8, !tbaa !39
  %103 = load ptr, ptr %5, align 8, !tbaa !63
  %104 = getelementptr inbounds %struct.GCheader, ptr %103, i64 0, i32 2
  %105 = load i8, ptr %104, align 1, !tbaa !33
  %106 = and i8 %105, 3
  %107 = icmp eq i8 %106, 0
  br i1 %107, label %118, label %108

108:                                              ; preds = %95
  %109 = getelementptr inbounds %struct.GCheader, ptr %72, i64 0, i32 2
  %110 = load i8, ptr %109, align 1, !tbaa !33
  %111 = and i8 %110, 4
  %112 = icmp eq i8 %111, 0
  br i1 %112, label %118, label %113

113:                                              ; preds = %108
  %114 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 6
  %115 = load ptr, ptr %114, align 8, !tbaa !240
  call void @luaC_barrierf(ptr noundef %115, ptr noundef nonnull %72, ptr noundef nonnull %103) #46
  %116 = load i32, ptr %75, align 4, !tbaa !290
  %117 = add nsw i32 %116, -1
  br label %118

118:                                              ; preds = %113, %108, %95
  %119 = phi i32 [ %117, %113 ], [ %99, %108 ], [ %99, %95 ]
  %120 = call i32 @luaK_codeABx(ptr noundef nonnull %71, i32 noundef 36, i32 noundef 0, i32 noundef %119) #46
  %121 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 2
  store i32 -1, ptr %121, align 8, !tbaa !87
  %122 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 3
  store i32 -1, ptr %122, align 4, !tbaa !88
  store i32 11, ptr %1, align 8, !tbaa !85
  %123 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  store i32 %120, ptr %123, align 8, !tbaa !33
  %124 = load ptr, ptr %5, align 8, !tbaa !63
  %125 = getelementptr inbounds %struct.Proto, ptr %124, i64 0, i32 19
  %126 = load i8, ptr %125, align 8, !tbaa !118
  %127 = icmp eq i8 %126, 0
  br i1 %127, label %144, label %128

128:                                              ; preds = %128, %118
  %129 = phi i64 [ %138, %128 ], [ 0, %118 ]
  %130 = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 14, i64 %129
  %131 = load i8, ptr %130, align 1, !tbaa !302
  %132 = icmp eq i8 %131, 6
  %133 = select i1 %132, i32 0, i32 4
  %134 = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 14, i64 %129, i32 1
  %135 = load i8, ptr %134, align 2, !tbaa !304
  %136 = zext i8 %135 to i32
  %137 = call i32 @luaK_codeABC(ptr noundef nonnull %71, i32 noundef %133, i32 noundef 0, i32 noundef %136, i32 noundef 0) #46
  %138 = add nuw nsw i64 %129, 1
  %139 = load ptr, ptr %5, align 8, !tbaa !63
  %140 = getelementptr inbounds %struct.Proto, ptr %139, i64 0, i32 19
  %141 = load i8, ptr %140, align 8, !tbaa !118
  %142 = zext i8 %141 to i64
  %143 = icmp ult i64 %138, %142
  br i1 %143, label %128, label %144, !llvm.loop !305

144:                                              ; preds = %128, %118
  call void @llvm.lifetime.end.p0(i64 600, ptr nonnull %5) #48
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind optsize memory(readwrite, inaccessiblemem: none) uwtable
define internal fastcc void @adjustlocalvars(ptr nocapture noundef readonly %0, i32 noundef %1) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %4 = load ptr, ptr %3, align 8, !tbaa !248
  %5 = getelementptr inbounds %struct.FuncState, ptr %4, i64 0, i32 13
  %6 = load i8, ptr %5, align 2, !tbaa !62
  %7 = trunc i32 %1 to i8
  %8 = add i8 %6, %7
  store i8 %8, ptr %5, align 2, !tbaa !62
  %9 = icmp eq i32 %1, 0
  br i1 %9, label %28, label %10

10:                                               ; preds = %2
  %11 = getelementptr inbounds %struct.FuncState, ptr %4, i64 0, i32 6
  %12 = load i32, ptr %11, align 8, !tbaa !59
  %13 = load ptr, ptr %4, align 8, !tbaa !63
  %14 = getelementptr inbounds %struct.Proto, ptr %13, i64 0, i32 7
  %15 = load ptr, ptr %14, align 8, !tbaa !167
  %16 = sext i32 %1 to i64
  %17 = zext i8 %8 to i64
  br label %18

18:                                               ; preds = %18, %10
  %19 = phi i64 [ %16, %10 ], [ %25, %18 ]
  %20 = sub nsw i64 %17, %19
  %21 = getelementptr inbounds %struct.FuncState, ptr %4, i64 0, i32 15, i64 %20
  %22 = load i16, ptr %21, align 2, !tbaa !239
  %23 = zext i16 %22 to i64
  %24 = getelementptr inbounds %struct.stringtable, ptr %15, i64 %23, i32 1
  store i32 %12, ptr %24, align 8, !tbaa !170
  %25 = add nsw i64 %19, -1
  %26 = and i64 %25, 4294967295
  %27 = icmp eq i64 %26, 0
  br i1 %27, label %28, label %18, !llvm.loop !297

28:                                               ; preds = %18, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @primaryexp(ptr noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = alloca %struct.expdesc, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %6 = load ptr, ptr %5, align 8, !tbaa !248
  %7 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  %8 = load i32, ptr %7, align 8, !tbaa !247
  switch i32 %8, label %15 [
    i32 40, label %9
    i32 285, label %14
  ]

9:                                                ; preds = %2
  %10 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 1
  %11 = load i32, ptr %10, align 4, !tbaa !242
  tail call void @luaX_next(ptr noundef nonnull %0) #46
  %12 = tail call fastcc i32 @subexpr(ptr noundef nonnull %0, ptr noundef %1, i32 noundef 0) #47, !range !281
  tail call fastcc void @check_match(ptr noundef nonnull %0, i32 noundef 41, i32 noundef 40, i32 noundef %11) #47
  %13 = load ptr, ptr %5, align 8, !tbaa !248
  tail call void @luaK_dischargevars(ptr noundef %13, ptr noundef %1) #46
  br label %16

14:                                               ; preds = %2
  tail call fastcc void @singlevar(ptr noundef nonnull %0, ptr noundef %1) #47
  br label %16

15:                                               ; preds = %2
  tail call void @luaX_syntaxerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.12.139) #46
  br label %16

16:                                               ; preds = %15, %14, %9
  %17 = getelementptr inbounds %struct.expdesc, ptr %4, i64 0, i32 2
  %18 = getelementptr inbounds %struct.expdesc, ptr %4, i64 0, i32 3
  %19 = getelementptr inbounds %struct.expdesc, ptr %4, i64 0, i32 1
  br label %20

20:                                               ; preds = %30, %16
  %21 = load i32, ptr %7, align 8, !tbaa !247
  switch i32 %21, label %31 [
    i32 46, label %22
    i32 91, label %23
    i32 58, label %25
    i32 40, label %29
    i32 286, label %29
    i32 123, label %29
  ]

22:                                               ; preds = %20
  call fastcc void @field(ptr noundef nonnull %0, ptr noundef %1) #47
  br label %30

23:                                               ; preds = %20
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3) #48
  %24 = call i32 @luaK_exp2anyreg(ptr noundef %6, ptr noundef %1) #46
  call fastcc void @yindex(ptr noundef nonnull %0, ptr noundef nonnull %3) #47
  call void @luaK_indexed(ptr noundef %6, ptr noundef %1, ptr noundef nonnull %3) #46
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3) #48
  br label %30

25:                                               ; preds = %20
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4) #48
  call void @luaX_next(ptr noundef nonnull %0) #46
  %26 = call fastcc ptr @str_checkname(ptr noundef nonnull %0) #47
  %27 = load ptr, ptr %5, align 8, !tbaa !248
  %28 = call i32 @luaK_stringK(ptr noundef %27, ptr noundef %26) #46
  store i32 -1, ptr %17, align 8, !tbaa !87
  store i32 -1, ptr %18, align 4, !tbaa !88
  store i32 4, ptr %4, align 8, !tbaa !85
  store i32 %28, ptr %19, align 8, !tbaa !33
  call void @luaK_self(ptr noundef %6, ptr noundef %1, ptr noundef nonnull %4) #46
  call fastcc void @funcargs(ptr noundef nonnull %0, ptr noundef %1) #47
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4) #48
  br label %30

29:                                               ; preds = %20, %20, %20
  call void @luaK_exp2nextreg(ptr noundef %6, ptr noundef %1) #46
  call fastcc void @funcargs(ptr noundef nonnull %0, ptr noundef %1) #47
  br label %30

30:                                               ; preds = %29, %25, %23, %22
  br label %20

31:                                               ; preds = %20
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @assignment(ptr noundef %0, ptr noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = alloca %struct.expdesc, align 8
  %5 = alloca %struct.LHS_assign, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4) #48
  %6 = getelementptr inbounds %struct.LHS_assign, ptr %1, i64 0, i32 1
  %7 = load i32, ptr %6, align 8, !tbaa !285
  %8 = add i32 %7, -6
  %9 = icmp ult i32 %8, 4
  br i1 %9, label %11, label %10

10:                                               ; preds = %3
  tail call void @luaX_syntaxerror(ptr noundef %0, ptr noundef nonnull @.str.26.135) #46
  br label %11

11:                                               ; preds = %10, %3
  %12 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  %13 = load i32, ptr %12, align 8, !tbaa !247
  %14 = icmp eq i32 %13, 44
  br i1 %14, label %15, label %75

15:                                               ; preds = %11
  tail call void @luaX_next(ptr noundef nonnull %0) #46
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %5) #48
  store ptr %1, ptr %5, align 8, !tbaa !287
  %16 = getelementptr inbounds %struct.LHS_assign, ptr %5, i64 0, i32 1
  call fastcc void @primaryexp(ptr noundef nonnull %0, ptr noundef nonnull %16) #47
  %17 = load i32, ptr %16, align 8, !tbaa !285
  %18 = icmp eq i32 %17, 6
  br i1 %18, label %19, label %62

19:                                               ; preds = %15
  %20 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %21 = load ptr, ptr %20, align 8, !tbaa !248
  %22 = getelementptr inbounds %struct.FuncState, ptr %21, i64 0, i32 9
  %23 = load i32, ptr %22, align 4, !tbaa !78
  %24 = getelementptr inbounds %struct.LHS_assign, ptr %5, i64 0, i32 1, i32 1
  br label %25

25:                                               ; preds = %48, %19
  %26 = phi i32 [ 0, %19 ], [ %49, %48 ]
  %27 = phi ptr [ %1, %19 ], [ %50, %48 ]
  %28 = getelementptr inbounds %struct.LHS_assign, ptr %27, i64 0, i32 1
  %29 = load i32, ptr %28, align 8, !tbaa !285
  %30 = icmp eq i32 %29, 9
  br i1 %30, label %31, label %44

31:                                               ; preds = %25
  %32 = getelementptr inbounds %struct.LHS_assign, ptr %27, i64 0, i32 1, i32 1
  %33 = load i32, ptr %32, align 8, !tbaa !33
  %34 = load i32, ptr %24, align 8, !tbaa !33
  %35 = icmp eq i32 %33, %34
  br i1 %35, label %36, label %38

36:                                               ; preds = %31
  store i32 %23, ptr %32, align 8, !tbaa !33
  %37 = load i32, ptr %24, align 8, !tbaa !33
  br label %38

38:                                               ; preds = %36, %31
  %39 = phi i32 [ %37, %36 ], [ %34, %31 ]
  %40 = phi i32 [ 1, %36 ], [ %26, %31 ]
  %41 = getelementptr inbounds i8, ptr %27, i64 20
  %42 = load i32, ptr %41, align 4, !tbaa !33
  %43 = icmp eq i32 %42, %39
  br i1 %43, label %51, label %44

44:                                               ; preds = %38, %25
  %45 = phi i32 [ %40, %38 ], [ %26, %25 ]
  %46 = load ptr, ptr %27, align 8, !tbaa !287
  %47 = icmp eq ptr %46, null
  br i1 %47, label %54, label %48

48:                                               ; preds = %51, %44
  %49 = phi i32 [ %45, %44 ], [ 1, %51 ]
  %50 = phi ptr [ %46, %44 ], [ %52, %51 ]
  br label %25, !llvm.loop !306

51:                                               ; preds = %38
  store i32 %23, ptr %41, align 4, !tbaa !33
  %52 = load ptr, ptr %27, align 8, !tbaa !287
  %53 = icmp eq ptr %52, null
  br i1 %53, label %58, label %48

54:                                               ; preds = %44
  %.lcssa = phi i32 [ %45, %44 ]
  %55 = icmp eq i32 %.lcssa, 0
  br i1 %55, label %62, label %56

56:                                               ; preds = %54
  %57 = load i32, ptr %24, align 8, !tbaa !33
  br label %58

58:                                               ; preds = %56, %51
  %59 = phi i32 [ %57, %56 ], [ %39, %51 ]
  %60 = load i32, ptr %22, align 4, !tbaa !78
  %61 = call i32 @luaK_codeABC(ptr noundef %21, i32 noundef 0, i32 noundef %60, i32 noundef %59, i32 noundef 0) #46
  call void @luaK_reserveregs(ptr noundef %21, i32 noundef 1) #46
  br label %62

62:                                               ; preds = %58, %54, %15
  %63 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 6
  %64 = load ptr, ptr %63, align 8, !tbaa !240
  %65 = getelementptr inbounds %struct.lua_State, ptr %64, i64 0, i32 15
  %66 = load i16, ptr %65, align 8, !tbaa !24
  %67 = zext i16 %66 to i32
  %68 = sub nsw i32 200, %67
  %69 = icmp slt i32 %68, %2
  br i1 %69, label %70, label %73

70:                                               ; preds = %62
  %71 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %72 = load ptr, ptr %71, align 8, !tbaa !248
  call fastcc void @errorlimit(ptr noundef %72, i32 noundef %68, ptr noundef nonnull @.str.27.136) #47
  br label %73

73:                                               ; preds = %70, %62
  %74 = add nsw i32 %2, 1
  call fastcc void @assignment(ptr noundef nonnull %0, ptr noundef nonnull %5, i32 noundef %74) #47
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %5) #48
  br label %91

75:                                               ; preds = %11
  tail call fastcc void @checknext(ptr noundef nonnull %0, i32 noundef 61) #47
  %76 = call fastcc i32 @explist1(ptr noundef nonnull %0, ptr noundef nonnull %4) #47
  %77 = icmp eq i32 %76, %2
  br i1 %77, label %87, label %78

78:                                               ; preds = %75
  call fastcc void @adjust_assign(ptr noundef nonnull %0, i32 noundef %2, i32 noundef %76, ptr noundef nonnull %4) #47
  %79 = icmp sgt i32 %76, %2
  br i1 %79, label %80, label %91

80:                                               ; preds = %78
  %81 = sub i32 %2, %76
  %82 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %83 = load ptr, ptr %82, align 8, !tbaa !248
  %84 = getelementptr inbounds %struct.FuncState, ptr %83, i64 0, i32 9
  %85 = load i32, ptr %84, align 4, !tbaa !78
  %86 = add i32 %81, %85
  store i32 %86, ptr %84, align 4, !tbaa !78
  br label %91

87:                                               ; preds = %75
  %88 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %89 = load ptr, ptr %88, align 8, !tbaa !248
  call void @luaK_setoneret(ptr noundef %89, ptr noundef nonnull %4) #46
  %90 = load ptr, ptr %88, align 8, !tbaa !248
  br label %100

91:                                               ; preds = %80, %78, %73
  %92 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %93 = load ptr, ptr %92, align 8, !tbaa !248
  %94 = getelementptr inbounds %struct.FuncState, ptr %93, i64 0, i32 9
  %95 = load i32, ptr %94, align 4, !tbaa !78
  %96 = add nsw i32 %95, -1
  %97 = getelementptr inbounds %struct.expdesc, ptr %4, i64 0, i32 2
  store i32 -1, ptr %97, align 8, !tbaa !87
  %98 = getelementptr inbounds %struct.expdesc, ptr %4, i64 0, i32 3
  store i32 -1, ptr %98, align 4, !tbaa !88
  store i32 12, ptr %4, align 8, !tbaa !85
  %99 = getelementptr inbounds %struct.expdesc, ptr %4, i64 0, i32 1
  store i32 %96, ptr %99, align 8, !tbaa !33
  br label %100

100:                                              ; preds = %91, %87
  %101 = phi ptr [ %90, %87 ], [ %93, %91 ]
  call void @luaK_storevar(ptr noundef %101, ptr noundef nonnull %6, ptr noundef nonnull %4) #46
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @errorlimit(ptr nocapture noundef readonly %0, i32 noundef %1, ptr noundef %2) unnamed_addr #1 {
  %4 = load ptr, ptr %0, align 8, !tbaa !63
  %5 = getelementptr inbounds %struct.Proto, ptr %4, i64 0, i32 16
  %6 = load i32, ptr %5, align 8, !tbaa !106
  %7 = icmp eq i32 %6, 0
  %8 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 4
  %9 = load ptr, ptr %8, align 8, !tbaa !72
  br i1 %7, label %10, label %12

10:                                               ; preds = %3
  %11 = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %9, ptr noundef nonnull @.str.4.137, i32 noundef %1, ptr noundef %2) #46
  br label %14

12:                                               ; preds = %3
  %13 = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %9, ptr noundef nonnull @.str.5.138, i32 noundef %6, i32 noundef %1, ptr noundef %2) #46
  br label %14

14:                                               ; preds = %12, %10
  %15 = phi ptr [ %11, %10 ], [ %13, %12 ]
  %16 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 3
  %17 = load ptr, ptr %16, align 8, !tbaa !66
  tail call void @luaX_lexerror(ptr noundef %17, ptr noundef %15, i32 noundef 0) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @yindex(ptr noundef %0, ptr noundef %1) unnamed_addr #1 {
  tail call void @luaX_next(ptr noundef %0) #46
  %3 = tail call fastcc i32 @subexpr(ptr noundef %0, ptr noundef %1, i32 noundef 0) #47, !range !281
  %4 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %5 = load ptr, ptr %4, align 8, !tbaa !248
  tail call void @luaK_exp2val(ptr noundef %5, ptr noundef %1) #46
  tail call fastcc void @checknext(ptr noundef %0, i32 noundef 93) #47
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @funcargs(ptr noundef %0, ptr nocapture noundef %1) unnamed_addr #1 {
  %3 = alloca %struct.expdesc, align 8
  %4 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %5 = load ptr, ptr %4, align 8, !tbaa !248
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3) #48
  %6 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 1
  %7 = load i32, ptr %6, align 4, !tbaa !242
  %8 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  %9 = load i32, ptr %8, align 8, !tbaa !247
  switch i32 %9, label %23 [
    i32 40, label %10
    i32 123, label %22
    i32 286, label %30
  ]

10:                                               ; preds = %2
  %11 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 2
  %12 = load i32, ptr %11, align 8, !tbaa !67
  %13 = icmp eq i32 %7, %12
  br i1 %13, label %15, label %14

14:                                               ; preds = %10
  tail call void @luaX_syntaxerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.15.140) #46
  br label %15

15:                                               ; preds = %14, %10
  tail call void @luaX_next(ptr noundef nonnull %0) #46
  %16 = load i32, ptr %8, align 8, !tbaa !247
  %17 = icmp eq i32 %16, 41
  br i1 %17, label %18, label %19

18:                                               ; preds = %15
  store i32 0, ptr %3, align 8, !tbaa !85
  br label %21

19:                                               ; preds = %15
  %20 = call fastcc i32 @explist1(ptr noundef nonnull %0, ptr noundef nonnull %3) #47
  call void @luaK_setreturns(ptr noundef %5, ptr noundef nonnull %3, i32 noundef -1) #46
  br label %21

21:                                               ; preds = %19, %18
  call fastcc void @check_match(ptr noundef nonnull %0, i32 noundef 41, i32 noundef 40, i32 noundef %7) #47
  br label %24

22:                                               ; preds = %2
  call fastcc void @constructor(ptr noundef nonnull %0, ptr noundef nonnull %3) #47
  br label %24

23:                                               ; preds = %2
  tail call void @luaX_syntaxerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.16.141) #46
  br label %59

24:                                               ; preds = %22, %21
  %25 = load i32, ptr %3, align 8
  %26 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %27 = load i32, ptr %26, align 8, !tbaa !33
  %28 = add i32 %25, -13
  %29 = icmp ult i32 %28, 2
  br i1 %29, label %50, label %39

30:                                               ; preds = %2
  %31 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3, i32 1
  %32 = load ptr, ptr %31, align 8, !tbaa !33
  %33 = tail call i32 @luaK_stringK(ptr noundef %5, ptr noundef %32) #46
  %34 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 2
  store i32 -1, ptr %34, align 8, !tbaa !87
  %35 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 3
  store i32 -1, ptr %35, align 4, !tbaa !88
  store i32 4, ptr %3, align 8, !tbaa !85
  %36 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 1
  store i32 %33, ptr %36, align 8, !tbaa !33
  tail call void @luaX_next(ptr noundef nonnull %0) #46
  %37 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  %38 = load i32, ptr %37, align 8, !tbaa !33
  br label %41

39:                                               ; preds = %24
  %40 = icmp eq i32 %25, 0
  br i1 %40, label %44, label %41

41:                                               ; preds = %39, %30
  %42 = phi ptr [ %37, %30 ], [ %26, %39 ]
  %43 = phi i32 [ %38, %30 ], [ %27, %39 ]
  call void @luaK_exp2nextreg(ptr noundef %5, ptr noundef nonnull %3) #46
  br label %44

44:                                               ; preds = %41, %39
  %45 = phi ptr [ %42, %41 ], [ %26, %39 ]
  %46 = phi i32 [ %43, %41 ], [ %27, %39 ]
  %47 = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 9
  %48 = load i32, ptr %47, align 4, !tbaa !78
  %49 = sub i32 %48, %46
  br label %50

50:                                               ; preds = %44, %24
  %51 = phi i32 [ %46, %44 ], [ %27, %24 ]
  %52 = phi ptr [ %45, %44 ], [ %26, %24 ]
  %53 = phi i32 [ %49, %44 ], [ 0, %24 ]
  %54 = call i32 @luaK_codeABC(ptr noundef %5, i32 noundef 28, i32 noundef %51, i32 noundef %53, i32 noundef 2) #46
  %55 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 2
  store i32 -1, ptr %55, align 8, !tbaa !87
  %56 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 3
  store i32 -1, ptr %56, align 4, !tbaa !88
  store i32 13, ptr %1, align 8, !tbaa !85
  store i32 %54, ptr %52, align 8, !tbaa !33
  call void @luaK_fixline(ptr noundef %5, i32 noundef %7) #46
  %57 = add nsw i32 %51, 1
  %58 = getelementptr inbounds %struct.FuncState, ptr %5, i64 0, i32 9
  store i32 %57, ptr %58, align 4, !tbaa !78
  br label %59

59:                                               ; preds = %50, %23
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @constructor(ptr noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = alloca %struct.ConsControl, align 8
  %4 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %5 = load ptr, ptr %4, align 8, !tbaa !248
  %6 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 1
  %7 = load i32, ptr %6, align 4, !tbaa !242
  %8 = tail call i32 @luaK_codeABC(ptr noundef %5, i32 noundef 10, i32 noundef 0, i32 noundef 0, i32 noundef 0) #46
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3) #48
  %9 = getelementptr inbounds %struct.ConsControl, ptr %3, i64 0, i32 4
  store i32 0, ptr %9, align 8, !tbaa !307
  %10 = getelementptr inbounds %struct.ConsControl, ptr %3, i64 0, i32 2
  store i32 0, ptr %10, align 8, !tbaa !309
  %11 = getelementptr inbounds %struct.ConsControl, ptr %3, i64 0, i32 3
  store i32 0, ptr %11, align 4, !tbaa !310
  %12 = getelementptr inbounds %struct.ConsControl, ptr %3, i64 0, i32 1
  store ptr %1, ptr %12, align 8, !tbaa !311
  %13 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 2
  store i32 -1, ptr %13, align 8, !tbaa !87
  %14 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 3
  store i32 -1, ptr %14, align 4, !tbaa !88
  store i32 11, ptr %1, align 8, !tbaa !85
  %15 = getelementptr inbounds %struct.expdesc, ptr %1, i64 0, i32 1
  store i32 %8, ptr %15, align 8, !tbaa !33
  %16 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 2
  store i32 -1, ptr %16, align 8, !tbaa !87
  %17 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 3
  store i32 -1, ptr %17, align 4, !tbaa !88
  store i32 0, ptr %3, align 8, !tbaa !85
  %18 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 1
  store i32 0, ptr %18, align 8, !tbaa !33
  %19 = load ptr, ptr %4, align 8, !tbaa !248
  tail call void @luaK_exp2nextreg(ptr noundef %19, ptr noundef nonnull %1) #46
  tail call fastcc void @checknext(ptr noundef %0, i32 noundef 123) #47
  %20 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  %21 = load i32, ptr %20, align 8, !tbaa !247
  %22 = icmp eq i32 %21, 125
  br i1 %22, label %53, label %23

23:                                               ; preds = %2
  %24 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 4
  br label %25

25:                                               ; preds = %50, %23
  %26 = phi i32 [ %21, %23 ], [ %51, %50 ]
  %27 = load i32, ptr %3, align 8, !tbaa !312
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %39, label %29

29:                                               ; preds = %25
  call void @luaK_exp2nextreg(ptr noundef %5, ptr noundef nonnull %3) #46
  store i32 0, ptr %3, align 8, !tbaa !312
  %30 = load i32, ptr %9, align 8, !tbaa !307
  %31 = icmp eq i32 %30, 50
  br i1 %31, label %32, label %37

32:                                               ; preds = %29
  %33 = load ptr, ptr %12, align 8, !tbaa !311
  %34 = getelementptr inbounds %struct.expdesc, ptr %33, i64 0, i32 1
  %35 = load i32, ptr %34, align 8, !tbaa !33
  %36 = load i32, ptr %11, align 4, !tbaa !310
  call void @luaK_setlist(ptr noundef %5, i32 noundef %35, i32 noundef %36, i32 noundef 50) #46
  store i32 0, ptr %9, align 8, !tbaa !307
  br label %37

37:                                               ; preds = %32, %29
  %38 = load i32, ptr %20, align 8, !tbaa !247
  br label %39

39:                                               ; preds = %37, %25
  %40 = phi i32 [ %38, %37 ], [ %26, %25 ]
  switch i32 %40, label %47 [
    i32 285, label %41
    i32 91, label %46
  ]

41:                                               ; preds = %39
  call void @luaX_lookahead(ptr noundef nonnull %0) #46
  %42 = load i32, ptr %24, align 8, !tbaa !250
  %43 = icmp eq i32 %42, 61
  br i1 %43, label %45, label %44

44:                                               ; preds = %41
  call fastcc void @listfield(ptr noundef nonnull %0, ptr noundef nonnull %3) #47
  br label %48

45:                                               ; preds = %41
  call fastcc void @recfield(ptr noundef nonnull %0, ptr noundef nonnull %3) #47
  br label %48

46:                                               ; preds = %39
  call fastcc void @recfield(ptr noundef nonnull %0, ptr noundef nonnull %3) #47
  br label %48

47:                                               ; preds = %39
  call fastcc void @listfield(ptr noundef nonnull %0, ptr noundef nonnull %3) #47
  br label %48

48:                                               ; preds = %47, %46, %45, %44
  %49 = load i32, ptr %20, align 8, !tbaa !247
  switch i32 %49, label %53 [
    i32 44, label %50
    i32 59, label %50
  ]

50:                                               ; preds = %48, %48
  call void @luaX_next(ptr noundef nonnull %0) #46
  %51 = load i32, ptr %20, align 8, !tbaa !247
  %52 = icmp eq i32 %51, 125
  br i1 %52, label %53, label %25, !llvm.loop !313

53:                                               ; preds = %50, %48, %2
  call fastcc void @check_match(ptr noundef nonnull %0, i32 noundef 125, i32 noundef 123, i32 noundef %7) #47
  %54 = load i32, ptr %9, align 8, !tbaa !307
  %55 = icmp eq i32 %54, 0
  br i1 %55, label %73, label %56

56:                                               ; preds = %53
  %57 = load i32, ptr %3, align 8, !tbaa !312
  switch i32 %57, label %65 [
    i32 13, label %58
    i32 14, label %58
    i32 0, label %67
  ]

58:                                               ; preds = %56, %56
  call void @luaK_setreturns(ptr noundef %5, ptr noundef nonnull %3, i32 noundef -1) #46
  %59 = load ptr, ptr %12, align 8, !tbaa !311
  %60 = getelementptr inbounds %struct.expdesc, ptr %59, i64 0, i32 1
  %61 = load i32, ptr %60, align 8, !tbaa !33
  %62 = load i32, ptr %11, align 4, !tbaa !310
  call void @luaK_setlist(ptr noundef %5, i32 noundef %61, i32 noundef %62, i32 noundef -1) #46
  %63 = load i32, ptr %11, align 4, !tbaa !310
  %64 = add nsw i32 %63, -1
  store i32 %64, ptr %11, align 4, !tbaa !310
  br label %73

65:                                               ; preds = %56
  call void @luaK_exp2nextreg(ptr noundef %5, ptr noundef nonnull %3) #46
  %66 = load i32, ptr %9, align 8, !tbaa !307
  br label %67

67:                                               ; preds = %65, %56
  %68 = phi i32 [ %54, %56 ], [ %66, %65 ]
  %69 = load ptr, ptr %12, align 8, !tbaa !311
  %70 = getelementptr inbounds %struct.expdesc, ptr %69, i64 0, i32 1
  %71 = load i32, ptr %70, align 8, !tbaa !33
  %72 = load i32, ptr %11, align 4, !tbaa !310
  call void @luaK_setlist(ptr noundef %5, i32 noundef %71, i32 noundef %72, i32 noundef %68) #46
  br label %73

73:                                               ; preds = %67, %58, %53
  %74 = load ptr, ptr %5, align 8, !tbaa !63
  %75 = getelementptr inbounds %struct.Proto, ptr %74, i64 0, i32 4
  %76 = load ptr, ptr %75, align 8, !tbaa !64
  %77 = sext i32 %8 to i64
  %78 = getelementptr inbounds i32, ptr %76, i64 %77
  %79 = load i32, ptr %78, align 4, !tbaa !65
  %80 = and i32 %79, 8388607
  %81 = load i32, ptr %11, align 4, !tbaa !310
  %82 = call i32 @luaO_int2fb(i32 noundef %81) #46
  %83 = shl i32 %82, 23
  %84 = or i32 %83, %80
  %85 = load ptr, ptr %5, align 8, !tbaa !63
  %86 = getelementptr inbounds %struct.Proto, ptr %85, i64 0, i32 4
  %87 = load ptr, ptr %86, align 8, !tbaa !64
  %88 = getelementptr inbounds i32, ptr %87, i64 %77
  store i32 %84, ptr %88, align 4, !tbaa !65
  %89 = and i32 %84, -8372225
  %90 = load i32, ptr %10, align 8, !tbaa !309
  %91 = call i32 @luaO_int2fb(i32 noundef %90) #46
  %92 = shl i32 %91, 14
  %93 = and i32 %92, 8372224
  %94 = or i32 %93, %89
  %95 = load ptr, ptr %5, align 8, !tbaa !63
  %96 = getelementptr inbounds %struct.Proto, ptr %95, i64 0, i32 4
  %97 = load ptr, ptr %96, align 8, !tbaa !64
  %98 = getelementptr inbounds i32, ptr %97, i64 %77
  store i32 %94, ptr %98, align 4, !tbaa !65
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @listfield(ptr noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = tail call fastcc i32 @subexpr(ptr noundef %0, ptr noundef %1, i32 noundef 0) #47, !range !281
  %4 = getelementptr inbounds %struct.ConsControl, ptr %1, i64 0, i32 3
  %5 = load i32, ptr %4, align 4, !tbaa !310
  %6 = icmp sgt i32 %5, 2147483645
  br i1 %6, label %7, label %11

7:                                                ; preds = %2
  %8 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %9 = load ptr, ptr %8, align 8, !tbaa !248
  tail call fastcc void @errorlimit(ptr noundef %9, i32 noundef 2147483645, ptr noundef nonnull @.str.3.142) #47
  %10 = load i32, ptr %4, align 4, !tbaa !310
  br label %11

11:                                               ; preds = %7, %2
  %12 = phi i32 [ %10, %7 ], [ %5, %2 ]
  %13 = add nsw i32 %12, 1
  store i32 %13, ptr %4, align 4, !tbaa !310
  %14 = getelementptr inbounds %struct.ConsControl, ptr %1, i64 0, i32 4
  %15 = load i32, ptr %14, align 8, !tbaa !307
  %16 = add nsw i32 %15, 1
  store i32 %16, ptr %14, align 8, !tbaa !307
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @recfield(ptr noundef %0, ptr nocapture noundef %1) unnamed_addr #1 {
  %3 = alloca %struct.expdesc, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 5
  %6 = load ptr, ptr %5, align 8, !tbaa !248
  %7 = getelementptr inbounds %struct.FuncState, ptr %6, i64 0, i32 9
  %8 = load i32, ptr %7, align 4, !tbaa !78
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3) #48
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4) #48
  %9 = getelementptr inbounds %struct.LexState, ptr %0, i64 0, i32 3
  %10 = load i32, ptr %9, align 8, !tbaa !247
  %11 = icmp eq i32 %10, 285
  br i1 %11, label %12, label %24

12:                                               ; preds = %2
  %13 = getelementptr inbounds %struct.ConsControl, ptr %1, i64 0, i32 2
  %14 = load i32, ptr %13, align 8, !tbaa !309
  %15 = icmp sgt i32 %14, 2147483645
  br i1 %15, label %16, label %17

16:                                               ; preds = %12
  tail call fastcc void @errorlimit(ptr noundef nonnull %6, i32 noundef 2147483645, ptr noundef nonnull @.str.3.142) #47
  br label %17

17:                                               ; preds = %16, %12
  %18 = tail call fastcc ptr @str_checkname(ptr noundef nonnull %0) #47
  %19 = load ptr, ptr %5, align 8, !tbaa !248
  %20 = tail call i32 @luaK_stringK(ptr noundef %19, ptr noundef %18) #46
  %21 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 2
  store i32 -1, ptr %21, align 8, !tbaa !87
  %22 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 3
  store i32 -1, ptr %22, align 4, !tbaa !88
  store i32 4, ptr %3, align 8, !tbaa !85
  %23 = getelementptr inbounds %struct.expdesc, ptr %3, i64 0, i32 1
  store i32 %20, ptr %23, align 8, !tbaa !33
  br label %25

24:                                               ; preds = %2
  call fastcc void @yindex(ptr noundef nonnull %0, ptr noundef nonnull %3) #47
  br label %25

25:                                               ; preds = %24, %17
  %26 = getelementptr inbounds %struct.ConsControl, ptr %1, i64 0, i32 2
  %27 = load i32, ptr %26, align 8, !tbaa !309
  %28 = add nsw i32 %27, 1
  store i32 %28, ptr %26, align 8, !tbaa !309
  call fastcc void @checknext(ptr noundef nonnull %0, i32 noundef 61) #47
  %29 = call i32 @luaK_exp2RK(ptr noundef nonnull %6, ptr noundef nonnull %3) #46
  %30 = call fastcc i32 @subexpr(ptr noundef nonnull %0, ptr noundef nonnull %4, i32 noundef 0) #47, !range !281
  %31 = getelementptr inbounds %struct.ConsControl, ptr %1, i64 0, i32 1
  %32 = load ptr, ptr %31, align 8, !tbaa !311
  %33 = getelementptr inbounds %struct.expdesc, ptr %32, i64 0, i32 1
  %34 = load i32, ptr %33, align 8, !tbaa !33
  %35 = call i32 @luaK_exp2RK(ptr noundef nonnull %6, ptr noundef nonnull %4) #46
  %36 = call i32 @luaK_codeABC(ptr noundef nonnull %6, i32 noundef 9, i32 noundef %34, i32 noundef %29, i32 noundef %35) #46
  store i32 %8, ptr %7, align 4, !tbaa !78
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4) #48
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @singlevaraux(ptr noundef %0, ptr noundef %1, ptr nocapture noundef %2, i32 noundef %3) unnamed_addr #1 {
  %5 = icmp eq ptr %0, null
  br i1 %5, label %6, label %10

6:                                                ; preds = %4
  %7 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 2
  store i32 -1, ptr %7, align 8, !tbaa !87
  %8 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 3
  store i32 -1, ptr %8, align 4, !tbaa !88
  store i32 8, ptr %2, align 8, !tbaa !85
  %9 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  store i32 255, ptr %9, align 8, !tbaa !33
  br label %148

10:                                               ; preds = %4
  %11 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 13
  %12 = load i8, ptr %11, align 2, !tbaa !62
  %13 = zext i8 %12 to i64
  br label %14

14:                                               ; preds = %17, %10
  %15 = phi i64 [ %18, %17 ], [ %13, %10 ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %17, label %50

17:                                               ; preds = %14
  %18 = add nsw i64 %15, -1
  %19 = load ptr, ptr %0, align 8, !tbaa !63
  %20 = getelementptr inbounds %struct.Proto, ptr %19, i64 0, i32 7
  %21 = load ptr, ptr %20, align 8, !tbaa !167
  %22 = and i64 %18, 4294967295
  %23 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 15, i64 %22
  %24 = load i16, ptr %23, align 2, !tbaa !239
  %25 = zext i16 %24 to i64
  %26 = getelementptr inbounds %struct.stringtable, ptr %21, i64 %25
  %27 = load ptr, ptr %26, align 8, !tbaa !168
  %28 = icmp eq ptr %27, %1
  br i1 %28, label %29, label %14, !llvm.loop !314

29:                                               ; preds = %17
  %.lcssa3 = phi i64 [ %18, %17 ]
  %30 = trunc i64 %.lcssa3 to i32
  %31 = icmp sgt i32 %30, -1
  br i1 %31, label %32, label %50

32:                                               ; preds = %29
  %33 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 2
  store i32 -1, ptr %33, align 8, !tbaa !87
  %34 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 3
  store i32 -1, ptr %34, align 4, !tbaa !88
  store i32 6, ptr %2, align 8, !tbaa !85
  %35 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  store i32 %30, ptr %35, align 8, !tbaa !33
  %36 = icmp eq i32 %3, 0
  br i1 %36, label %37, label %148

37:                                               ; preds = %32
  %38 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 5
  br label %39

39:                                               ; preds = %43, %37
  %40 = phi ptr [ %38, %37 ], [ %41, %43 ]
  %41 = load ptr, ptr %40, align 8, !tbaa !39
  %42 = icmp eq ptr %41, null
  br i1 %42, label %148, label %43

43:                                               ; preds = %39
  %44 = getelementptr inbounds %struct.BlockCnt, ptr %41, i64 0, i32 2
  %45 = load i8, ptr %44, align 4, !tbaa !278
  %46 = zext i8 %45 to i32
  %47 = icmp sgt i32 %46, %30
  br i1 %47, label %39, label %48, !llvm.loop !315

48:                                               ; preds = %43
  %.lcssa = phi ptr [ %41, %43 ]
  %49 = getelementptr inbounds %struct.BlockCnt, ptr %.lcssa, i64 0, i32 3
  store i8 1, ptr %49, align 1, !tbaa !279
  br label %148

50:                                               ; preds = %29, %14
  %51 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 2
  %52 = load ptr, ptr %51, align 8, !tbaa !272
  %53 = tail call fastcc i32 @singlevaraux(ptr noundef %52, ptr noundef %1, ptr noundef %2, i32 noundef 0) #47, !range !300
  %54 = icmp eq i32 %53, 8
  br i1 %54, label %148, label %55

55:                                               ; preds = %50
  %56 = load ptr, ptr %0, align 8, !tbaa !63
  %57 = getelementptr inbounds %struct.Proto, ptr %56, i64 0, i32 10
  %58 = load i32, ptr %57, align 8, !tbaa !55
  %59 = getelementptr inbounds %struct.Proto, ptr %56, i64 0, i32 19
  %60 = load i8, ptr %59, align 8, !tbaa !118
  %61 = icmp eq i8 %60, 0
  br i1 %61, label %86, label %62

62:                                               ; preds = %55
  %63 = load i32, ptr %2, align 8, !tbaa !85
  %64 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  %65 = zext i8 %60 to i64
  br label %66

66:                                               ; preds = %78, %62
  %67 = phi i64 [ 0, %62 ], [ %79, %78 ]
  %68 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 14, i64 %67
  %69 = load i8, ptr %68, align 1, !tbaa !302
  %70 = zext i8 %69 to i32
  %71 = icmp eq i32 %63, %70
  br i1 %71, label %72, label %78

72:                                               ; preds = %66
  %73 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 14, i64 %67, i32 1
  %74 = load i8, ptr %73, align 1, !tbaa !304
  %75 = zext i8 %74 to i32
  %76 = load i32, ptr %64, align 8, !tbaa !33
  %77 = icmp eq i32 %76, %75
  br i1 %77, label %143, label %78

78:                                               ; preds = %72, %66
  %79 = add nuw nsw i64 %67, 1
  %80 = icmp eq i64 %79, %65
  br i1 %80, label %81, label %66, !llvm.loop !316

81:                                               ; preds = %78
  %82 = icmp ugt i8 %60, 59
  br i1 %82, label %83, label %86

83:                                               ; preds = %81
  tail call fastcc void @errorlimit(ptr noundef nonnull %0, i32 noundef 60, ptr noundef nonnull @.str.13.147) #47
  %84 = load i8, ptr %59, align 8, !tbaa !118
  %85 = load i32, ptr %57, align 8, !tbaa !55
  br label %86

86:                                               ; preds = %83, %81, %55
  %87 = phi i8 [ %84, %83 ], [ %60, %81 ], [ 0, %55 ]
  %88 = phi i32 [ %85, %83 ], [ %58, %81 ], [ %58, %55 ]
  %89 = zext i8 %87 to i32
  %90 = icmp sgt i32 %88, %89
  br i1 %90, label %98, label %91

91:                                               ; preds = %86
  %92 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 4
  %93 = load ptr, ptr %92, align 8, !tbaa !72
  %94 = getelementptr inbounds %struct.Proto, ptr %56, i64 0, i32 8
  %95 = load ptr, ptr %94, align 8, !tbaa !58
  %96 = tail call ptr @luaM_growaux_(ptr noundef %93, ptr noundef %95, ptr noundef nonnull %57, i64 noundef 8, i32 noundef 2147483645, ptr noundef nonnull @.str.14.148) #46
  store ptr %96, ptr %94, align 8, !tbaa !58
  %97 = load i32, ptr %57, align 8, !tbaa !55
  br label %98

98:                                               ; preds = %91, %86
  %99 = phi i32 [ %97, %91 ], [ %88, %86 ]
  %100 = icmp slt i32 %58, %99
  br i1 %100, label %101, label %111

101:                                              ; preds = %98
  %102 = getelementptr inbounds %struct.Proto, ptr %56, i64 0, i32 8
  %103 = sext i32 %58 to i64
  %104 = sext i32 %99 to i64
  br label %105

105:                                              ; preds = %105, %101
  %106 = phi i64 [ %103, %101 ], [ %108, %105 ]
  %107 = load ptr, ptr %102, align 8, !tbaa !58
  %108 = add nsw i64 %106, 1
  %109 = getelementptr inbounds ptr, ptr %107, i64 %106
  store ptr null, ptr %109, align 8, !tbaa !39
  %110 = icmp eq i64 %108, %104
  br i1 %110, label %111, label %105, !llvm.loop !317

111:                                              ; preds = %105, %98
  %112 = getelementptr inbounds %struct.Proto, ptr %56, i64 0, i32 8
  %113 = load ptr, ptr %112, align 8, !tbaa !58
  %114 = load i8, ptr %59, align 8, !tbaa !118
  %115 = zext i8 %114 to i64
  %116 = getelementptr inbounds ptr, ptr %113, i64 %115
  store ptr %1, ptr %116, align 8, !tbaa !39
  %117 = getelementptr inbounds %struct.GCheader, ptr %1, i64 0, i32 2
  %118 = load i8, ptr %117, align 1, !tbaa !33
  %119 = and i8 %118, 3
  %120 = icmp eq i8 %119, 0
  br i1 %120, label %131, label %121

121:                                              ; preds = %111
  %122 = getelementptr inbounds %struct.GCheader, ptr %56, i64 0, i32 2
  %123 = load i8, ptr %122, align 1, !tbaa !33
  %124 = and i8 %123, 4
  %125 = icmp eq i8 %124, 0
  br i1 %125, label %131, label %126

126:                                              ; preds = %121
  %127 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 4
  %128 = load ptr, ptr %127, align 8, !tbaa !72
  tail call void @luaC_barrierf(ptr noundef %128, ptr noundef nonnull %56, ptr noundef nonnull %1) #46
  %129 = load i8, ptr %59, align 8, !tbaa !118
  %130 = zext i8 %129 to i64
  br label %131

131:                                              ; preds = %126, %121, %111
  %132 = phi i64 [ %130, %126 ], [ %115, %121 ], [ %115, %111 ]
  %133 = phi i8 [ %129, %126 ], [ %114, %121 ], [ %114, %111 ]
  %134 = load i32, ptr %2, align 8, !tbaa !85
  %135 = trunc i32 %134 to i8
  %136 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 14, i64 %132
  store i8 %135, ptr %136, align 1, !tbaa !302
  %137 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  %138 = load i32, ptr %137, align 8, !tbaa !33
  %139 = trunc i32 %138 to i8
  %140 = getelementptr inbounds %struct.FuncState, ptr %0, i64 0, i32 14, i64 %132, i32 1
  store i8 %139, ptr %140, align 1, !tbaa !304
  %141 = add i8 %133, 1
  store i8 %141, ptr %59, align 8, !tbaa !118
  %142 = zext i8 %133 to i32
  br label %145

143:                                              ; preds = %72
  %.lcssa1 = phi i64 [ %67, %72 ]
  %144 = trunc i64 %.lcssa1 to i32
  br label %145

145:                                              ; preds = %143, %131
  %146 = phi i32 [ %142, %131 ], [ %144, %143 ]
  %147 = getelementptr inbounds %struct.expdesc, ptr %2, i64 0, i32 1
  store i32 %146, ptr %147, align 8, !tbaa !33
  store i32 7, ptr %2, align 8, !tbaa !85
  br label %148

148:                                              ; preds = %145, %50, %48, %39, %32, %6
  %149 = phi i32 [ 8, %6 ], [ 7, %145 ], [ 6, %32 ], [ 8, %50 ], [ 6, %48 ], [ 6, %39 ]
  ret i32 %149
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaE_newthread(ptr noundef %0) #1 {
  %2 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef null, i64 noundef 0, i64 noundef 184) #46
  tail call void @luaC_link(ptr noundef %0, ptr noundef %2, i8 noundef zeroext 8) #46
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %4 = load ptr, ptr %3, align 8, !tbaa !25
  %5 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 6
  store ptr %4, ptr %5, align 8, !tbaa !25
  %6 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 10
  store ptr null, ptr %6, align 8, !tbaa !43
  %7 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 13
  store i32 0, ptr %7, align 8, !tbaa !134
  %8 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 26
  store ptr null, ptr %8, align 8, !tbaa !126
  %9 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 21
  store ptr null, ptr %9, align 8, !tbaa !92
  %10 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 17
  store i8 0, ptr %10, align 4, !tbaa !95
  %11 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 19
  store i32 0, ptr %11, align 8, !tbaa !93
  %12 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 18
  store i8 1, ptr %12, align 1, !tbaa !130
  %13 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 20
  store i32 0, ptr %13, align 4, !tbaa !94
  %14 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 24
  store ptr null, ptr %14, align 8, !tbaa !179
  %15 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 14
  %16 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 3
  store i8 0, ptr %16, align 2, !tbaa !50
  %17 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 7
  %18 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 12
  store ptr null, ptr %18, align 8, !tbaa !38
  %19 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 27
  store i64 0, ptr %19, align 8, !tbaa !125
  %20 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 22, i32 1
  store i32 0, ptr %20, align 8, !tbaa !219
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %17, i8 0, i64 16, i1 false)
  store i64 0, ptr %15, align 4
  tail call fastcc void @stack_init(ptr noundef %2, ptr noundef %0) #47
  %21 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 22
  %22 = getelementptr inbounds %struct.lua_State, ptr %2, i64 0, i32 22
  %23 = load i64, ptr %21, align 8
  store i64 %23, ptr %22, align 8
  %24 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 22, i32 1
  %25 = load i32, ptr %24, align 8, !tbaa !16
  store i32 %25, ptr %20, align 8, !tbaa !16
  %26 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 17
  %27 = load i8, ptr %26, align 4, !tbaa !95
  store i8 %27, ptr %10, align 4, !tbaa !95
  %28 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 19
  %29 = load i32, ptr %28, align 8, !tbaa !93
  store i32 %29, ptr %11, align 8, !tbaa !93
  %30 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 21
  %31 = load ptr, ptr %30, align 8, !tbaa !92
  store ptr %31, ptr %9, align 8, !tbaa !92
  store i32 %29, ptr %13, align 4, !tbaa !94
  ret ptr %2
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @stack_init(ptr nocapture noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = tail call ptr @luaM_realloc_(ptr noundef %1, ptr noundef null, i64 noundef 0, i64 noundef 320) #46
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 12
  store ptr %3, ptr %4, align 8, !tbaa !38
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  store ptr %3, ptr %5, align 8, !tbaa !19
  %6 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 14
  store i32 8, ptr %6, align 4, !tbaa !131
  %7 = getelementptr inbounds %struct.CallInfo, ptr %3, i64 7
  %8 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 11
  store ptr %7, ptr %8, align 8, !tbaa !132
  %9 = tail call ptr @luaM_realloc_(ptr noundef %1, ptr noundef null, i64 noundef 0, i64 noundef 720) #46
  %10 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 10
  store ptr %9, ptr %10, align 8, !tbaa !43
  %11 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 13
  store i32 45, ptr %11, align 8, !tbaa !134
  %12 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %13 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 39
  %14 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  store ptr %13, ptr %14, align 8, !tbaa !18
  %15 = load ptr, ptr %5, align 8, !tbaa !19
  %16 = getelementptr inbounds %struct.CallInfo, ptr %15, i64 0, i32 1
  store ptr %9, ptr %16, align 8, !tbaa !36
  %17 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 1
  store ptr %17, ptr %12, align 8, !tbaa !7
  %18 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 0, i32 1
  store i32 0, ptr %18, align 8, !tbaa !16
  store ptr %17, ptr %15, align 8, !tbaa !100
  %19 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  store ptr %17, ptr %19, align 8, !tbaa !17
  %20 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 21
  %21 = getelementptr inbounds %struct.CallInfo, ptr %15, i64 0, i32 2
  store ptr %20, ptr %21, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaE_freethread(ptr noundef %0, ptr noundef %1) #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 10
  %4 = load ptr, ptr %3, align 8, !tbaa !43
  tail call void @luaF_close(ptr noundef %1, ptr noundef %4) #46
  tail call fastcc void @freestack(ptr noundef %0, ptr noundef %1) #47
  %5 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %1, i64 noundef 184, i64 noundef 0) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @freestack(ptr noundef %0, ptr nocapture noundef readonly %1) unnamed_addr #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 12
  %4 = load ptr, ptr %3, align 8, !tbaa !38
  %5 = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 14
  %6 = load i32, ptr %5, align 4, !tbaa !131
  %7 = sext i32 %6 to i64
  %8 = mul nsw i64 %7, 40
  %9 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %4, i64 noundef %8, i64 noundef 0) #46
  %10 = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 10
  %11 = load ptr, ptr %10, align 8, !tbaa !43
  %12 = getelementptr inbounds %struct.lua_State, ptr %1, i64 0, i32 13
  %13 = load i32, ptr %12, align 8, !tbaa !134
  %14 = sext i32 %13 to i64
  %15 = shl nsw i64 %14, 4
  %16 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %11, i64 noundef %15, i64 noundef 0) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @lua_newstate(ptr noundef %0, ptr noundef %1) #1 {
  %3 = tail call ptr %0(ptr noundef %1, ptr noundef null, i64 noundef 0, i64 noundef 616) #46
  %4 = icmp eq ptr %3, null
  br i1 %4, label %49, label %5

5:                                                ; preds = %2
  %6 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1
  store ptr null, ptr %3, align 8, !tbaa !187
  %7 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 1
  store i8 8, ptr %7, align 8, !tbaa !318
  %8 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 3
  store i8 33, ptr %8, align 8, !tbaa !175
  %9 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 2
  store i8 97, ptr %9, align 1, !tbaa !319
  %10 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 6
  store ptr %6, ptr %10, align 8, !tbaa !25
  %11 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 10
  store ptr null, ptr %11, align 8, !tbaa !43
  %12 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 13
  store i32 0, ptr %12, align 8, !tbaa !134
  %13 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 26
  store ptr null, ptr %13, align 8, !tbaa !126
  %14 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 21
  store ptr null, ptr %14, align 8, !tbaa !92
  %15 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 17
  store i8 0, ptr %15, align 4, !tbaa !95
  %16 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 19
  store i32 0, ptr %16, align 8, !tbaa !93
  %17 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 18
  store i8 1, ptr %17, align 1, !tbaa !130
  %18 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 20
  store i32 0, ptr %18, align 4, !tbaa !94
  %19 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 24
  store ptr null, ptr %19, align 8, !tbaa !179
  %20 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 14
  %21 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 3
  store i8 0, ptr %21, align 2, !tbaa !50
  %22 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 7
  %23 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 12
  store ptr null, ptr %23, align 8, !tbaa !38
  %24 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 27
  store i64 0, ptr %24, align 8, !tbaa !125
  %25 = getelementptr inbounds %struct.lua_State, ptr %3, i64 0, i32 22, i32 1
  store i32 0, ptr %25, align 8, !tbaa !219
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %22, i8 0, i64 16, i1 false)
  store i64 0, ptr %20, align 4
  %26 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 1
  store ptr %0, ptr %26, align 8, !tbaa !267
  %27 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 2
  store ptr %1, ptr %27, align 8, !tbaa !268
  %28 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 21
  store ptr %3, ptr %28, align 8, !tbaa !42
  %29 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 22
  %30 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 22, i32 4
  store ptr %29, ptr %30, align 8, !tbaa !33
  %31 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 22, i32 4, i32 0, i32 1
  store ptr %29, ptr %31, align 8, !tbaa !33
  %32 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 20, i32 1
  store i32 0, ptr %32, align 8, !tbaa !220
  %33 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 12
  store ptr null, ptr %33, align 8, !tbaa !218
  %34 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 12, i32 2
  %35 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 19
  store ptr null, ptr %35, align 8, !tbaa !26
  %36 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 4
  store i8 0, ptr %36, align 1, !tbaa !51
  %37 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 6
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %6, i8 0, i64 16, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %34, i8 0, i64 16, i1 false)
  store ptr %3, ptr %37, align 8, !tbaa !191
  %38 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 5
  store i32 0, ptr %38, align 4, !tbaa !215
  %39 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 7
  store ptr %37, ptr %39, align 8, !tbaa !216
  %40 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 8
  %41 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 14
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %40, i8 0, i64 32, i1 false)
  store i64 616, ptr %41, align 8, !tbaa !31
  %42 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 17
  store i32 200, ptr %42, align 8, !tbaa !53
  %43 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 18
  store i32 200, ptr %43, align 4, !tbaa !54
  %44 = getelementptr inbounds %struct.LG, ptr %3, i64 0, i32 1, i32 16
  store i64 0, ptr %44, align 8, !tbaa !194
  %45 = getelementptr i8, ptr %3, i64 408
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(72) %45, i8 0, i64 72, i1 false), !tbaa !39
  %46 = tail call i32 @luaD_rawrunprotected(ptr noundef nonnull %3, ptr noundef nonnull @f_luaopen, ptr noundef null) #46
  %47 = icmp eq i32 %46, 0
  br i1 %47, label %49, label %48

48:                                               ; preds = %5
  tail call fastcc void @close_state(ptr noundef nonnull %3) #47
  br label %49

49:                                               ; preds = %48, %5, %2
  %50 = phi ptr [ null, %2 ], [ null, %48 ], [ %3, %5 ]
  ret ptr %50
}

; Function Attrs: nounwind optsize uwtable
define internal void @f_luaopen(ptr noundef %0, ptr nocapture readnone %1) #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %4 = load ptr, ptr %3, align 8, !tbaa !25
  tail call fastcc void @stack_init(ptr noundef %0, ptr noundef %0) #47
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 22
  %6 = tail call ptr @luaH_new(ptr noundef %0, i32 noundef 0, i32 noundef 2) #46
  store ptr %6, ptr %5, align 8, !tbaa !33
  %7 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 22, i32 1
  store i32 5, ptr %7, align 8, !tbaa !16
  %8 = load ptr, ptr %3, align 8, !tbaa !25
  %9 = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 20
  %10 = tail call ptr @luaH_new(ptr noundef %0, i32 noundef 0, i32 noundef 2) #46
  store ptr %10, ptr %9, align 8, !tbaa !33
  %11 = getelementptr inbounds %struct.global_State, ptr %8, i64 0, i32 20, i32 1
  store i32 5, ptr %11, align 8, !tbaa !16
  tail call void @luaS_resize(ptr noundef %0, i32 noundef 32) #46
  tail call void @luaT_init(ptr noundef %0) #46
  tail call void @luaX_init(ptr noundef %0) #46
  %12 = tail call ptr @luaS_newlstr(ptr noundef %0, ptr noundef nonnull @.str.158, i64 noundef 17) #46
  %13 = getelementptr inbounds %struct.anon.0, ptr %12, i64 0, i32 2
  %14 = load i8, ptr %13, align 1, !tbaa !33
  %15 = or i8 %14, 32
  store i8 %15, ptr %13, align 1, !tbaa !33
  %16 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 14
  %17 = load i64, ptr %16, align 8, !tbaa !31
  %18 = shl i64 %17, 2
  %19 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 13
  store i64 %18, ptr %19, align 8, !tbaa !32
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @close_state(ptr noundef %0) unnamed_addr #1 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %3 = load ptr, ptr %2, align 8, !tbaa !25
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 10
  %5 = load ptr, ptr %4, align 8, !tbaa !43
  tail call void @luaF_close(ptr noundef %0, ptr noundef %5) #46
  tail call void @luaC_freeall(ptr noundef %0) #46
  %6 = load ptr, ptr %2, align 8, !tbaa !25
  %7 = load ptr, ptr %6, align 8, !tbaa !189
  %8 = getelementptr inbounds %struct.stringtable, ptr %6, i64 0, i32 2
  %9 = load i32, ptr %8, align 4, !tbaa !188
  %10 = sext i32 %9 to i64
  %11 = shl nsw i64 %10, 3
  %12 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %7, i64 noundef %11, i64 noundef 0) #46
  %13 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 12
  %14 = load ptr, ptr %13, align 8, !tbaa !218
  %15 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 12, i32 2
  %16 = load i64, ptr %15, align 8, !tbaa !217
  %17 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %14, i64 noundef %16, i64 noundef 0) #46
  store ptr %17, ptr %13, align 8, !tbaa !218
  store i64 0, ptr %15, align 8, !tbaa !217
  tail call fastcc void @freestack(ptr noundef %0, ptr noundef %0) #47
  %18 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 1
  %19 = load ptr, ptr %18, align 8, !tbaa !267
  %20 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 2
  %21 = load ptr, ptr %20, align 8, !tbaa !268
  %22 = tail call ptr %19(ptr noundef %21, ptr noundef %0, i64 noundef 616, i64 noundef 0) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @lua_close(ptr nocapture noundef readonly %0) #1 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %3 = load ptr, ptr %2, align 8, !tbaa !25
  %4 = getelementptr inbounds %struct.global_State, ptr %3, i64 0, i32 21
  %5 = load ptr, ptr %4, align 8, !tbaa !42
  %6 = getelementptr inbounds %struct.lua_State, ptr %5, i64 0, i32 10
  %7 = load ptr, ptr %6, align 8, !tbaa !43
  tail call void @luaF_close(ptr noundef %5, ptr noundef %7) #46
  %8 = tail call i64 @luaC_separateudata(ptr noundef %5, i32 noundef 1) #46
  %9 = getelementptr inbounds %struct.lua_State, ptr %5, i64 0, i32 27
  store i64 0, ptr %9, align 8, !tbaa !125
  %10 = getelementptr inbounds %struct.lua_State, ptr %5, i64 0, i32 12
  %11 = getelementptr inbounds %struct.lua_State, ptr %5, i64 0, i32 7
  %12 = getelementptr inbounds %struct.lua_State, ptr %5, i64 0, i32 4
  %13 = getelementptr inbounds %struct.lua_State, ptr %5, i64 0, i32 5
  %14 = getelementptr inbounds %struct.lua_State, ptr %5, i64 0, i32 16
  %15 = getelementptr inbounds %struct.lua_State, ptr %5, i64 0, i32 15
  br label %16

16:                                               ; preds = %16, %1
  %17 = load ptr, ptr %10, align 8, !tbaa !38
  store ptr %17, ptr %11, align 8, !tbaa !19
  %18 = load ptr, ptr %17, align 8, !tbaa !100
  store ptr %18, ptr %12, align 8, !tbaa !7
  store ptr %18, ptr %13, align 8, !tbaa !17
  store i16 0, ptr %14, align 2, !tbaa !129
  store i16 0, ptr %15, align 8, !tbaa !24
  %19 = tail call i32 @luaD_rawrunprotected(ptr noundef nonnull %5, ptr noundef nonnull @callallgcTM, ptr noundef null) #46
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %21, label %16, !llvm.loop !320

21:                                               ; preds = %16
  tail call fastcc void @close_state(ptr noundef nonnull %5) #47
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @callallgcTM(ptr noundef %0, ptr nocapture readnone %1) #1 {
  tail call void @luaC_callGCTM(ptr noundef %0) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaS_resize(ptr noundef %0, i32 noundef %1) #1 {
  %3 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %4 = load ptr, ptr %3, align 8, !tbaa !25
  %5 = getelementptr inbounds %struct.global_State, ptr %4, i64 0, i32 4
  %6 = load i8, ptr %5, align 1, !tbaa !51
  %7 = icmp eq i8 %6, 2
  br i1 %7, label %61, label %8

8:                                                ; preds = %2
  %9 = icmp sgt i32 %1, -2
  br i1 %9, label %13, label %10

10:                                               ; preds = %8
  %11 = tail call ptr @luaM_toobig(ptr noundef nonnull %0) #46
  %12 = load ptr, ptr %3, align 8, !tbaa !25
  br label %22

13:                                               ; preds = %8
  %14 = sext i32 %1 to i64
  %15 = shl nsw i64 %14, 3
  %16 = tail call ptr @luaM_realloc_(ptr noundef nonnull %0, ptr noundef null, i64 noundef 0, i64 noundef %15) #46
  %17 = load ptr, ptr %3, align 8, !tbaa !25
  %18 = icmp sgt i32 %1, 0
  br i1 %18, label %19, label %22

19:                                               ; preds = %13
  %20 = zext i32 %1 to i64
  %21 = shl nuw nsw i64 %20, 3
  tail call void @llvm.memset.p0.i64(ptr align 8 %16, i8 0, i64 %21, i1 false), !tbaa !39
  br label %22

22:                                               ; preds = %19, %13, %10
  %23 = phi ptr [ %12, %10 ], [ %17, %19 ], [ %17, %13 ]
  %24 = phi ptr [ %11, %10 ], [ %16, %19 ], [ %16, %13 ]
  %25 = getelementptr inbounds %struct.stringtable, ptr %23, i64 0, i32 2
  %26 = load i32, ptr %25, align 4, !tbaa !321
  %27 = icmp sgt i32 %26, 0
  br i1 %27, label %30, label %28

28:                                               ; preds = %22
  %29 = sext i32 %26 to i64
  br label %56

30:                                               ; preds = %22
  %31 = add nsw i32 %1, -1
  br label %32

32:                                               ; preds = %51, %30
  %33 = phi i32 [ %26, %30 ], [ %52, %51 ]
  %34 = phi i64 [ 0, %30 ], [ %53, %51 ]
  %35 = load ptr, ptr %23, align 8, !tbaa !322
  %36 = getelementptr inbounds ptr, ptr %35, i64 %34
  %37 = load ptr, ptr %36, align 8, !tbaa !39
  %38 = icmp eq ptr %37, null
  br i1 %38, label %51, label %39

39:                                               ; preds = %39, %32
  %40 = phi ptr [ %41, %39 ], [ %37, %32 ]
  %41 = load ptr, ptr %40, align 8, !tbaa !33
  %42 = getelementptr inbounds %struct.anon.0, ptr %40, i64 0, i32 4
  %43 = load i32, ptr %42, align 4, !tbaa !33
  %44 = and i32 %43, %31
  %45 = sext i32 %44 to i64
  %46 = getelementptr inbounds ptr, ptr %24, i64 %45
  %47 = load ptr, ptr %46, align 8, !tbaa !39
  store ptr %47, ptr %40, align 8, !tbaa !33
  store ptr %40, ptr %46, align 8, !tbaa !39
  %48 = icmp eq ptr %41, null
  br i1 %48, label %49, label %39, !llvm.loop !323

49:                                               ; preds = %39
  %50 = load i32, ptr %25, align 4, !tbaa !321
  br label %51

51:                                               ; preds = %49, %32
  %52 = phi i32 [ %50, %49 ], [ %33, %32 ]
  %53 = add nuw nsw i64 %34, 1
  %54 = sext i32 %52 to i64
  %55 = icmp slt i64 %53, %54
  br i1 %55, label %32, label %56, !llvm.loop !324

56:                                               ; preds = %51, %28
  %57 = phi i64 [ %29, %28 ], [ %54, %51 ]
  %58 = load ptr, ptr %23, align 8, !tbaa !322
  %59 = shl nsw i64 %57, 3
  %60 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %58, i64 noundef %59, i64 noundef 0) #46
  store i32 %1, ptr %25, align 4, !tbaa !321
  store ptr %24, ptr %23, align 8, !tbaa !322
  br label %61

61:                                               ; preds = %56, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaS_newlstr(ptr noundef %0, ptr nocapture noundef readonly %1, i64 noundef %2) #1 {
  %4 = trunc i64 %2 to i32
  %5 = lshr i64 %2, 5
  %6 = xor i64 %5, -1
  %7 = icmp ult i64 %5, %2
  br i1 %7, label %8, label %22

8:                                                ; preds = %8, %3
  %9 = phi i64 [ %20, %8 ], [ %2, %3 ]
  %10 = phi i32 [ %19, %8 ], [ %4, %3 ]
  %11 = shl i32 %10, 5
  %12 = lshr i32 %10, 2
  %13 = add i32 %11, %12
  %14 = add i64 %9, -1
  %15 = getelementptr inbounds i8, ptr %1, i64 %14
  %16 = load i8, ptr %15, align 1, !tbaa !33
  %17 = zext i8 %16 to i32
  %18 = add i32 %13, %17
  %19 = xor i32 %18, %10
  %20 = add i64 %9, %6
  %21 = icmp ugt i64 %20, %5
  br i1 %21, label %8, label %22, !llvm.loop !325

22:                                               ; preds = %8, %3
  %23 = phi i32 [ %4, %3 ], [ %19, %8 ]
  %24 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %25 = load ptr, ptr %24, align 8, !tbaa !25
  %26 = load ptr, ptr %25, align 8, !tbaa !189
  %27 = getelementptr inbounds %struct.stringtable, ptr %25, i64 0, i32 2
  %28 = load i32, ptr %27, align 4, !tbaa !188
  %29 = add nsw i32 %28, -1
  %30 = and i32 %29, %23
  %31 = sext i32 %30 to i64
  %32 = getelementptr inbounds ptr, ptr %26, i64 %31
  %33 = load ptr, ptr %32, align 8, !tbaa !33
  %34 = icmp eq ptr %33, null
  br i1 %34, label %58, label %35

35:                                               ; preds = %55, %22
  %36 = phi ptr [ %56, %55 ], [ %33, %22 ]
  %37 = getelementptr inbounds %struct.anon.0, ptr %36, i64 0, i32 5
  %38 = load i64, ptr %37, align 8, !tbaa !33
  %39 = icmp eq i64 %38, %2
  br i1 %39, label %40, label %55

40:                                               ; preds = %35
  %41 = getelementptr inbounds %union.TString, ptr %36, i64 1
  %42 = tail call i32 @bcmp(ptr %1, ptr nonnull %41, i64 %2)
  %43 = icmp eq i32 %42, 0
  br i1 %43, label %44, label %55

44:                                               ; preds = %40
  %.lcssa = phi ptr [ %36, %40 ]
  %45 = getelementptr inbounds %struct.GCheader, ptr %.lcssa, i64 0, i32 2
  %46 = load i8, ptr %45, align 1, !tbaa !33
  %47 = getelementptr inbounds %struct.global_State, ptr %25, i64 0, i32 3
  %48 = load i8, ptr %47, align 8, !tbaa !175
  %49 = xor i8 %48, -1
  %50 = and i8 %46, 3
  %51 = and i8 %50, %49
  %52 = icmp eq i8 %51, 0
  br i1 %52, label %97, label %53

53:                                               ; preds = %44
  %54 = xor i8 %46, 3
  store i8 %54, ptr %45, align 1, !tbaa !33
  br label %97

55:                                               ; preds = %40, %35
  %56 = load ptr, ptr %36, align 8, !tbaa !33
  %57 = icmp eq ptr %56, null
  br i1 %57, label %58, label %35, !llvm.loop !326

58:                                               ; preds = %55, %22
  %59 = add i64 %2, 27
  %60 = icmp ult i64 %59, 26
  br i1 %60, label %61, label %63

61:                                               ; preds = %58
  %62 = tail call ptr @luaM_toobig(ptr noundef %0) #46
  br label %63

63:                                               ; preds = %61, %58
  %64 = add i64 %2, 25
  %65 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef null, i64 noundef 0, i64 noundef %64) #46
  %66 = getelementptr inbounds %struct.anon.0, ptr %65, i64 0, i32 5
  store i64 %2, ptr %66, align 8, !tbaa !33
  %67 = getelementptr inbounds %struct.anon.0, ptr %65, i64 0, i32 4
  store i32 %23, ptr %67, align 4, !tbaa !33
  %68 = load ptr, ptr %24, align 8, !tbaa !25
  %69 = getelementptr inbounds %struct.global_State, ptr %68, i64 0, i32 3
  %70 = load i8, ptr %69, align 8, !tbaa !175
  %71 = and i8 %70, 3
  %72 = getelementptr inbounds %struct.anon.0, ptr %65, i64 0, i32 2
  store i8 %71, ptr %72, align 1, !tbaa !33
  %73 = getelementptr inbounds %struct.anon.0, ptr %65, i64 0, i32 1
  store i8 4, ptr %73, align 8, !tbaa !33
  %74 = getelementptr inbounds %struct.anon.0, ptr %65, i64 0, i32 3
  store i8 0, ptr %74, align 2, !tbaa !33
  %75 = getelementptr inbounds %union.TString, ptr %65, i64 1
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %75, ptr align 1 %1, i64 %2, i1 false)
  %76 = getelementptr inbounds i8, ptr %75, i64 %2
  store i8 0, ptr %76, align 1, !tbaa !33
  %77 = load ptr, ptr %24, align 8, !tbaa !25
  %78 = getelementptr inbounds %struct.stringtable, ptr %77, i64 0, i32 2
  %79 = load i32, ptr %78, align 4, !tbaa !321
  %80 = add nsw i32 %79, -1
  %81 = and i32 %80, %23
  %82 = load ptr, ptr %77, align 8, !tbaa !322
  %83 = zext i32 %81 to i64
  %84 = getelementptr inbounds ptr, ptr %82, i64 %83
  %85 = load ptr, ptr %84, align 8, !tbaa !39
  store ptr %85, ptr %65, align 8, !tbaa !33
  %86 = load ptr, ptr %77, align 8, !tbaa !322
  %87 = getelementptr inbounds ptr, ptr %86, i64 %83
  store ptr %65, ptr %87, align 8, !tbaa !39
  %88 = getelementptr inbounds %struct.stringtable, ptr %77, i64 0, i32 1
  %89 = load i32, ptr %88, align 8, !tbaa !327
  %90 = add i32 %89, 1
  store i32 %90, ptr %88, align 8, !tbaa !327
  %91 = load i32, ptr %78, align 4, !tbaa !321
  %92 = icmp ugt i32 %90, %91
  %93 = icmp slt i32 %91, 1073741823
  %94 = and i1 %92, %93
  br i1 %94, label %95, label %97

95:                                               ; preds = %63
  %96 = shl nsw i32 %91, 1
  tail call void @luaS_resize(ptr noundef nonnull %0, i32 noundef %96) #47
  br label %97

97:                                               ; preds = %95, %63, %53, %44
  %98 = phi ptr [ %65, %63 ], [ %65, %95 ], [ %.lcssa, %53 ], [ %.lcssa, %44 ]
  ret ptr %98
}

; Function Attrs: nofree nounwind willreturn memory(argmem: read)
declare i32 @bcmp(ptr nocapture, ptr nocapture, i64) local_unnamed_addr #34

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaS_newudata(ptr noundef %0, i64 noundef %1, ptr noundef %2) #1 {
  %4 = icmp ugt i64 %1, -43
  br i1 %4, label %5, label %7

5:                                                ; preds = %3
  %6 = tail call ptr @luaM_toobig(ptr noundef %0) #46
  br label %7

7:                                                ; preds = %5, %3
  %8 = add i64 %1, 40
  %9 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef null, i64 noundef 0, i64 noundef %8) #46
  %10 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %11 = load ptr, ptr %10, align 8, !tbaa !25
  %12 = getelementptr inbounds %struct.global_State, ptr %11, i64 0, i32 3
  %13 = load i8, ptr %12, align 8, !tbaa !175
  %14 = and i8 %13, 3
  %15 = getelementptr inbounds %struct.anon.1, ptr %9, i64 0, i32 2
  store i8 %14, ptr %15, align 1, !tbaa !33
  %16 = getelementptr inbounds %struct.anon.1, ptr %9, i64 0, i32 1
  store i8 7, ptr %16, align 8, !tbaa !33
  %17 = getelementptr inbounds %struct.anon.1, ptr %9, i64 0, i32 5
  store i64 %1, ptr %17, align 8, !tbaa !33
  %18 = getelementptr inbounds %struct.anon.1, ptr %9, i64 0, i32 3
  store ptr null, ptr %18, align 8, !tbaa !33
  %19 = getelementptr inbounds %struct.anon.1, ptr %9, i64 0, i32 4
  store ptr %2, ptr %19, align 8, !tbaa !33
  %20 = load ptr, ptr %10, align 8, !tbaa !25
  %21 = getelementptr inbounds %struct.global_State, ptr %20, i64 0, i32 21
  %22 = load ptr, ptr %21, align 8, !tbaa !42
  %23 = load ptr, ptr %22, align 8, !tbaa !187
  store ptr %23, ptr %9, align 8, !tbaa !33
  %24 = load ptr, ptr %10, align 8, !tbaa !25
  %25 = getelementptr inbounds %struct.global_State, ptr %24, i64 0, i32 21
  %26 = load ptr, ptr %25, align 8, !tbaa !42
  store ptr %9, ptr %26, align 8, !tbaa !187
  ret ptr %9
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaH_next(ptr noundef %0, ptr nocapture noundef readonly %1, ptr noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  switch i32 %5, label %19 [
    i32 0, label %53
    i32 3, label %6
  ]

6:                                                ; preds = %3
  %7 = load double, ptr %2, align 8, !tbaa !33
  %8 = fptosi double %7 to i32
  %9 = sitofp i32 %8 to double
  %10 = fcmp oeq double %7, %9
  %11 = icmp sgt i32 %8, 0
  %12 = and i1 %11, %10
  br i1 %12, label %13, label %19

13:                                               ; preds = %6
  %14 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 10
  %15 = load i32, ptr %14, align 8, !tbaa !205
  %16 = icmp slt i32 %15, %8
  br i1 %16, label %19, label %17

17:                                               ; preds = %13
  %18 = add nsw i32 %8, -1
  br label %53

19:                                               ; preds = %13, %6, %3
  %20 = tail call fastcc ptr @mainposition(ptr noundef %1, ptr noundef nonnull %2) #47
  br label %21

21:                                               ; preds = %48, %19
  %22 = phi ptr [ %20, %19 ], [ %50, %48 ]
  %23 = getelementptr inbounds %struct.Node, ptr %22, i64 0, i32 1
  %24 = tail call i32 @luaO_rawequalObj(ptr noundef nonnull %23, ptr noundef %2) #46
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %26, label %37

26:                                               ; preds = %21
  %27 = getelementptr inbounds %struct.Node, ptr %22, i64 0, i32 1, i32 0, i32 1
  %28 = load i32, ptr %27, align 8, !tbaa !33
  %29 = icmp eq i32 %28, 11
  br i1 %29, label %30, label %48

30:                                               ; preds = %26
  %31 = load i32, ptr %4, align 8, !tbaa !16
  %32 = icmp sgt i32 %31, 3
  br i1 %32, label %33, label %48

33:                                               ; preds = %30
  %34 = load ptr, ptr %23, align 8, !tbaa !33
  %35 = load ptr, ptr %2, align 8, !tbaa !33
  %36 = icmp eq ptr %34, %35
  br i1 %36, label %37, label %48

37:                                               ; preds = %33, %21
  %.lcssa7 = phi ptr [ %22, %33 ], [ %22, %21 ]
  %38 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 7
  %39 = load ptr, ptr %38, align 8, !tbaa !209
  %40 = ptrtoint ptr %.lcssa7 to i64
  %41 = ptrtoint ptr %39 to i64
  %42 = sub i64 %40, %41
  %43 = sdiv exact i64 %42, 40
  %44 = trunc i64 %43 to i32
  %45 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 10
  %46 = load i32, ptr %45, align 8, !tbaa !205
  %47 = add nsw i32 %46, %44
  br label %53

48:                                               ; preds = %33, %30, %26
  %49 = getelementptr inbounds %struct.Node, ptr %22, i64 0, i32 1, i32 0, i32 2
  %50 = load ptr, ptr %49, align 8, !tbaa !33
  %51 = icmp eq ptr %50, null
  br i1 %51, label %52, label %21, !llvm.loop !328

52:                                               ; preds = %48
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %0, ptr noundef nonnull @.str.2.167) #46
  br label %53

53:                                               ; preds = %52, %37, %17, %3
  %54 = phi i32 [ %18, %17 ], [ -1, %3 ], [ %47, %37 ], [ 0, %52 ]
  %55 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 10
  %56 = load i32, ptr %55, align 8, !tbaa !205
  %57 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 6
  %58 = sext i32 %54 to i64
  %59 = sext i32 %56 to i64
  %60 = add i32 %54, 1
  %61 = sub i32 %60, %56
  br label %62

62:                                               ; preds = %67, %53
  %63 = phi i32 [ %72, %67 ], [ %61, %53 ]
  %64 = phi i64 [ %65, %67 ], [ %58, %53 ]
  %65 = add nsw i64 %64, 1
  %66 = icmp slt i64 %65, %59
  br i1 %66, label %67, label %82

67:                                               ; preds = %62
  %68 = load ptr, ptr %57, align 8, !tbaa !206
  %69 = getelementptr inbounds %struct.lua_TValue, ptr %68, i64 %65, i32 1
  %70 = load i32, ptr %69, align 8, !tbaa !16
  %71 = icmp eq i32 %70, 0
  %72 = add i32 %63, 1
  br i1 %71, label %62, label %73, !llvm.loop !329

73:                                               ; preds = %67
  %.lcssa4 = phi i64 [ %64, %67 ]
  %.lcssa2 = phi i64 [ %65, %67 ]
  %74 = trunc i64 %.lcssa4 to i32
  %75 = add nsw i32 %74, 2
  %76 = sitofp i32 %75 to double
  store double %76, ptr %2, align 8, !tbaa !33
  store i32 3, ptr %4, align 8, !tbaa !16
  %77 = load ptr, ptr %57, align 8, !tbaa !206
  %78 = getelementptr inbounds %struct.lua_TValue, ptr %77, i64 %.lcssa2
  %79 = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 1
  %80 = load i64, ptr %78, align 8
  store i64 %80, ptr %79, align 8
  %81 = getelementptr inbounds %struct.lua_TValue, ptr %77, i64 %.lcssa2, i32 1
  br label %113

82:                                               ; preds = %62
  %.lcssa5 = phi i32 [ %63, %62 ]
  %.lcssa1 = phi i64 [ %65, %62 ]
  %83 = trunc i64 %.lcssa1 to i32
  %84 = sub nsw i32 %83, %56
  %85 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 4
  %86 = load i8, ptr %85, align 1, !tbaa !208
  %87 = zext i8 %86 to i32
  %88 = shl nuw i32 1, %87
  %89 = icmp slt i32 %84, %88
  br i1 %89, label %90, label %117

90:                                               ; preds = %82
  %91 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 7
  %92 = load ptr, ptr %91, align 8, !tbaa !209
  %93 = sext i32 %.lcssa5 to i64
  %94 = sext i32 %88 to i64
  br label %98

95:                                               ; preds = %98
  %96 = add nsw i64 %99, 1
  %97 = icmp slt i64 %96, %94
  br i1 %97, label %98, label %117, !llvm.loop !330

98:                                               ; preds = %95, %90
  %99 = phi i64 [ %93, %90 ], [ %96, %95 ]
  %100 = getelementptr inbounds %struct.Node, ptr %92, i64 %99, i32 0, i32 1
  %101 = load i32, ptr %100, align 8, !tbaa !210
  %102 = icmp eq i32 %101, 0
  br i1 %102, label %95, label %103

103:                                              ; preds = %98
  %.lcssa = phi i64 [ %99, %98 ]
  %104 = getelementptr inbounds %struct.Node, ptr %92, i64 %.lcssa, i32 1
  %105 = load i64, ptr %104, align 8
  store i64 %105, ptr %2, align 8
  %106 = getelementptr inbounds %struct.lua_TValue, ptr %104, i64 0, i32 1
  %107 = load i32, ptr %106, align 8, !tbaa !16
  store i32 %107, ptr %4, align 8, !tbaa !16
  %108 = load ptr, ptr %91, align 8, !tbaa !209
  %109 = getelementptr inbounds %struct.Node, ptr %108, i64 %.lcssa
  %110 = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 1
  %111 = load i64, ptr %109, align 8
  store i64 %111, ptr %110, align 8
  %112 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 0, i32 1
  br label %113

113:                                              ; preds = %103, %73
  %114 = phi ptr [ %112, %103 ], [ %81, %73 ]
  %115 = load i32, ptr %114, align 8, !tbaa !16
  %116 = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 1, i32 1
  store i32 %115, ptr %116, align 8, !tbaa !16
  br label %117

117:                                              ; preds = %113, %95, %82
  %118 = phi i32 [ 0, %82 ], [ 1, %113 ], [ 0, %95 ]
  ret i32 %118
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(read, inaccessiblemem: none) uwtable
define internal fastcc ptr @mainposition(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) unnamed_addr #35 {
  %3 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  %4 = load i32, ptr %3, align 8, !tbaa !16
  switch i32 %4, label %68 [
    i32 3, label %5
    i32 4, label %27
    i32 1, label %41
    i32 2, label %53
  ]

5:                                                ; preds = %2
  %6 = load double, ptr %1, align 8, !tbaa !33
  %7 = fcmp oeq double %6, 0.000000e+00
  br i1 %7, label %8, label %11

8:                                                ; preds = %5
  %9 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 7
  %10 = load ptr, ptr %9, align 8, !tbaa !209
  br label %83

11:                                               ; preds = %5
  %12 = bitcast double %6 to i64
  %13 = lshr i64 %12, 32
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 7
  %16 = load ptr, ptr %15, align 8, !tbaa !209
  %17 = trunc i64 %14 to i32
  %18 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 4
  %19 = load i8, ptr %18, align 1, !tbaa !208
  %20 = zext i8 %19 to i32
  %21 = shl nsw i32 -1, %20
  %22 = xor i32 %21, -1
  %23 = or i32 %22, 1
  %24 = urem i32 %17, %23
  %25 = zext i32 %24 to i64
  %26 = getelementptr inbounds %struct.Node, ptr %16, i64 %25
  br label %83

27:                                               ; preds = %2
  %28 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 7
  %29 = load ptr, ptr %28, align 8, !tbaa !209
  %30 = load ptr, ptr %1, align 8, !tbaa !33
  %31 = getelementptr inbounds %struct.anon.0, ptr %30, i64 0, i32 4
  %32 = load i32, ptr %31, align 4, !tbaa !33
  %33 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 4
  %34 = load i8, ptr %33, align 1, !tbaa !208
  %35 = zext i8 %34 to i32
  %36 = shl nsw i32 -1, %35
  %37 = xor i32 %36, -1
  %38 = and i32 %32, %37
  %39 = zext i32 %38 to i64
  %40 = getelementptr inbounds %struct.Node, ptr %29, i64 %39
  br label %83

41:                                               ; preds = %2
  %42 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 7
  %43 = load ptr, ptr %42, align 8, !tbaa !209
  %44 = load i32, ptr %1, align 8, !tbaa !33
  %45 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 4
  %46 = load i8, ptr %45, align 1, !tbaa !208
  %47 = zext i8 %46 to i32
  %48 = shl nsw i32 -1, %47
  %49 = xor i32 %48, -1
  %50 = and i32 %44, %49
  %51 = zext i32 %50 to i64
  %52 = getelementptr inbounds %struct.Node, ptr %43, i64 %51
  br label %83

53:                                               ; preds = %2
  %54 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 7
  %55 = load ptr, ptr %54, align 8, !tbaa !209
  %56 = load ptr, ptr %1, align 8, !tbaa !33
  %57 = ptrtoint ptr %56 to i64
  %58 = trunc i64 %57 to i32
  %59 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 4
  %60 = load i8, ptr %59, align 1, !tbaa !208
  %61 = zext i8 %60 to i32
  %62 = shl nsw i32 -1, %61
  %63 = xor i32 %62, -1
  %64 = or i32 %63, 1
  %65 = urem i32 %58, %64
  %66 = zext i32 %65 to i64
  %67 = getelementptr inbounds %struct.Node, ptr %55, i64 %66
  br label %83

68:                                               ; preds = %2
  %69 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 7
  %70 = load ptr, ptr %69, align 8, !tbaa !209
  %71 = load ptr, ptr %1, align 8, !tbaa !33
  %72 = ptrtoint ptr %71 to i64
  %73 = trunc i64 %72 to i32
  %74 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 4
  %75 = load i8, ptr %74, align 1, !tbaa !208
  %76 = zext i8 %75 to i32
  %77 = shl nsw i32 -1, %76
  %78 = xor i32 %77, -1
  %79 = or i32 %78, 1
  %80 = urem i32 %73, %79
  %81 = zext i32 %80 to i64
  %82 = getelementptr inbounds %struct.Node, ptr %70, i64 %81
  br label %83

83:                                               ; preds = %68, %53, %41, %27, %11, %8
  %84 = phi ptr [ %82, %68 ], [ %67, %53 ], [ %52, %41 ], [ %40, %27 ], [ %10, %8 ], [ %26, %11 ]
  ret ptr %84
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaH_resizearray(ptr noundef %0, ptr noundef %1, i32 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 7
  %5 = load ptr, ptr %4, align 8, !tbaa !209
  %6 = icmp eq ptr %5, @dummynode_
  br i1 %6, label %12, label %7

7:                                                ; preds = %3
  %8 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 4
  %9 = load i8, ptr %8, align 1, !tbaa !208
  %10 = zext i8 %9 to i32
  %11 = shl nuw i32 1, %10
  br label %12

12:                                               ; preds = %7, %3
  %13 = phi i32 [ %11, %7 ], [ 0, %3 ]
  tail call fastcc void @resize(ptr noundef %0, ptr noundef nonnull %1, i32 noundef %2, i32 noundef %13) #47
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @resize(ptr noundef %0, ptr noundef %1, i32 noundef %2, i32 noundef %3) unnamed_addr #1 {
  %5 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 10
  %6 = load i32, ptr %5, align 8, !tbaa !205
  %7 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 4
  %8 = load i8, ptr %7, align 1, !tbaa !208
  %9 = zext i8 %8 to i32
  %10 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 7
  %11 = load ptr, ptr %10, align 8, !tbaa !209
  %12 = icmp slt i32 %6, %2
  br i1 %12, label %13, label %14

13:                                               ; preds = %4
  tail call fastcc void @setarrayvector(ptr noundef %0, ptr noundef nonnull %1, i32 noundef %2) #47
  br label %14

14:                                               ; preds = %13, %4
  tail call fastcc void @setnodevector(ptr noundef %0, ptr noundef nonnull %1, i32 noundef %3) #47
  %15 = icmp sgt i32 %6, %2
  br i1 %15, label %16, label %52

16:                                               ; preds = %14
  store i32 %2, ptr %5, align 8, !tbaa !205
  %17 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 6
  %18 = sext i32 %2 to i64
  br label %19

19:                                               ; preds = %36, %16
  %20 = phi i64 [ %18, %16 ], [ %38, %36 ]
  %21 = load ptr, ptr %17, align 8, !tbaa !206
  %22 = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 %20, i32 1
  %23 = load i32, ptr %22, align 8, !tbaa !16
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %25, label %28

25:                                               ; preds = %19
  %26 = add nsw i64 %20, 1
  %27 = trunc i64 %26 to i32
  br label %36

28:                                               ; preds = %19
  %29 = getelementptr inbounds %struct.lua_TValue, ptr %21, i64 %20
  %30 = add nsw i64 %20, 1
  %31 = trunc i64 %30 to i32
  %32 = tail call ptr @luaH_setnum(ptr noundef %0, ptr noundef nonnull %1, i32 noundef %31) #47
  %33 = load i64, ptr %29, align 8
  store i64 %33, ptr %32, align 8
  %34 = load i32, ptr %22, align 8, !tbaa !16
  %35 = getelementptr inbounds %struct.lua_TValue, ptr %32, i64 0, i32 1
  store i32 %34, ptr %35, align 8, !tbaa !16
  br label %36

36:                                               ; preds = %28, %25
  %37 = phi i32 [ %27, %25 ], [ %31, %28 ]
  %38 = phi i64 [ %26, %25 ], [ %30, %28 ]
  %39 = icmp eq i32 %37, %6
  br i1 %39, label %40, label %19, !llvm.loop !331

40:                                               ; preds = %36
  %41 = icmp sgt i32 %2, -2
  br i1 %41, label %42, label %48

42:                                               ; preds = %40
  %43 = load ptr, ptr %17, align 8, !tbaa !206
  %44 = sext i32 %6 to i64
  %45 = shl nsw i64 %44, 4
  %46 = shl nsw i64 %18, 4
  %47 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %43, i64 noundef %45, i64 noundef %46) #46
  br label %50

48:                                               ; preds = %40
  %49 = tail call ptr @luaM_toobig(ptr noundef %0) #46
  br label %50

50:                                               ; preds = %48, %42
  %51 = phi ptr [ %47, %42 ], [ %49, %48 ]
  store ptr %51, ptr %17, align 8, !tbaa !206
  br label %52

52:                                               ; preds = %50, %14
  %53 = shl nuw i32 1, %9
  %54 = icmp eq i8 %8, 31
  br i1 %54, label %74, label %55

55:                                               ; preds = %52
  %56 = zext i32 %53 to i64
  br label %57

57:                                               ; preds = %71, %55
  %58 = phi i64 [ %56, %55 ], [ %59, %71 ]
  %59 = add nsw i64 %58, -1
  %60 = and i64 %59, 4294967295
  %61 = getelementptr inbounds %struct.Node, ptr %11, i64 %60
  %62 = getelementptr inbounds %struct.lua_TValue, ptr %61, i64 0, i32 1
  %63 = load i32, ptr %62, align 8, !tbaa !210
  %64 = icmp eq i32 %63, 0
  br i1 %64, label %71, label %65

65:                                               ; preds = %57
  %66 = getelementptr inbounds %struct.Node, ptr %11, i64 %60, i32 1
  %67 = tail call ptr @luaH_set(ptr noundef %0, ptr noundef %1, ptr noundef nonnull %66) #47
  %68 = load i64, ptr %61, align 8
  store i64 %68, ptr %67, align 8
  %69 = load i32, ptr %62, align 8, !tbaa !16
  %70 = getelementptr inbounds %struct.lua_TValue, ptr %67, i64 0, i32 1
  store i32 %69, ptr %70, align 8, !tbaa !16
  br label %71

71:                                               ; preds = %65, %57
  %72 = trunc i64 %58 to i32
  %73 = icmp sgt i32 %72, 1
  br i1 %73, label %57, label %74, !llvm.loop !332

74:                                               ; preds = %71, %52
  %75 = icmp eq ptr %11, @dummynode_
  br i1 %75, label %80, label %76

76:                                               ; preds = %74
  %77 = sext i32 %53 to i64
  %78 = mul nsw i64 %77, 40
  %79 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %11, i64 noundef %78, i64 noundef 0) #46
  br label %80

80:                                               ; preds = %76, %74
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @setarrayvector(ptr noundef %0, ptr nocapture noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = icmp sgt i32 %2, -2
  br i1 %4, label %5, label %15

5:                                                ; preds = %3
  %6 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 6
  %7 = load ptr, ptr %6, align 8, !tbaa !206
  %8 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 10
  %9 = load i32, ptr %8, align 8, !tbaa !205
  %10 = sext i32 %9 to i64
  %11 = shl nsw i64 %10, 4
  %12 = sext i32 %2 to i64
  %13 = shl nsw i64 %12, 4
  %14 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %7, i64 noundef %11, i64 noundef %13) #46
  br label %17

15:                                               ; preds = %3
  %16 = tail call ptr @luaM_toobig(ptr noundef %0) #46
  br label %17

17:                                               ; preds = %15, %5
  %18 = phi ptr [ %14, %5 ], [ %16, %15 ]
  %19 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 6
  store ptr %18, ptr %19, align 8, !tbaa !206
  %20 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 10
  %21 = load i32, ptr %20, align 8, !tbaa !205
  %22 = icmp slt i32 %21, %2
  br i1 %22, label %23, label %31

23:                                               ; preds = %17
  %24 = sext i32 %21 to i64
  %25 = sext i32 %2 to i64
  br label %26

26:                                               ; preds = %26, %23
  %27 = phi i64 [ %24, %23 ], [ %29, %26 ]
  %28 = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 %27, i32 1
  store i32 0, ptr %28, align 8, !tbaa !16
  %29 = add nsw i64 %27, 1
  %30 = icmp eq i64 %29, %25
  br i1 %30, label %31, label %26, !llvm.loop !333

31:                                               ; preds = %26, %17
  store i32 %2, ptr %20, align 8, !tbaa !205
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @setnodevector(ptr noundef %0, ptr nocapture noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %5, label %7

5:                                                ; preds = %3
  %6 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 7
  store ptr @dummynode_, ptr %6, align 8, !tbaa !209
  br label %42

7:                                                ; preds = %3
  %8 = add nsw i32 %2, -1
  %9 = tail call i32 @luaO_log2(i32 noundef %8) #46
  %10 = add nsw i32 %9, 1
  %11 = icmp sgt i32 %9, 25
  br i1 %11, label %12, label %17

12:                                               ; preds = %7
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %0, ptr noundef nonnull @.str.3.178) #46
  %13 = icmp eq i32 %10, 31
  br i1 %13, label %14, label %17

14:                                               ; preds = %12
  %15 = tail call ptr @luaM_toobig(ptr noundef %0) #46
  %16 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 7
  store ptr %15, ptr %16, align 8, !tbaa !209
  br label %37

17:                                               ; preds = %12, %7
  %18 = shl nuw i32 1, %10
  %19 = sext i32 %18 to i64
  %20 = mul nsw i64 %19, 40
  %21 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef null, i64 noundef 0, i64 noundef %20) #46
  %22 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 7
  store ptr %21, ptr %22, align 8, !tbaa !209
  %23 = icmp eq i32 %10, 31
  br i1 %23, label %37, label %24

24:                                               ; preds = %17
  %25 = zext i32 %18 to i64
  br label %26

26:                                               ; preds = %26, %24
  %27 = phi i64 [ 0, %24 ], [ %33, %26 ]
  %28 = load ptr, ptr %22, align 8, !tbaa !209
  %29 = getelementptr inbounds %struct.Node, ptr %28, i64 %27, i32 1
  %30 = getelementptr inbounds %struct.anon.2, ptr %29, i64 0, i32 2
  store ptr null, ptr %30, align 8, !tbaa !33
  %31 = getelementptr inbounds %struct.anon.2, ptr %29, i64 0, i32 1
  store i32 0, ptr %31, align 8, !tbaa !33
  %32 = getelementptr inbounds %struct.Node, ptr %28, i64 %27, i32 0, i32 1
  store i32 0, ptr %32, align 8, !tbaa !210
  %33 = add nuw nsw i64 %27, 1
  %34 = icmp eq i64 %33, %25
  br i1 %34, label %35, label %26, !llvm.loop !334

35:                                               ; preds = %26
  %36 = load ptr, ptr %22, align 8, !tbaa !209
  br label %37

37:                                               ; preds = %35, %17, %14
  %38 = phi i32 [ %18, %35 ], [ %18, %17 ], [ -2147483648, %14 ]
  %39 = phi ptr [ %36, %35 ], [ %21, %17 ], [ %15, %14 ]
  %40 = trunc i32 %10 to i8
  %41 = sext i32 %38 to i64
  br label %42

42:                                               ; preds = %37, %5
  %43 = phi ptr [ @dummynode_, %5 ], [ %39, %37 ]
  %44 = phi i8 [ 0, %5 ], [ %40, %37 ]
  %45 = phi i64 [ 0, %5 ], [ %41, %37 ]
  %46 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 4
  store i8 %44, ptr %46, align 1, !tbaa !208
  %47 = getelementptr inbounds %struct.Node, ptr %43, i64 %45
  %48 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 8
  store ptr %47, ptr %48, align 8, !tbaa !335
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaH_setnum(ptr noundef %0, ptr noundef %1, i32 noundef %2) #1 {
  %4 = alloca %struct.lua_TValue, align 8
  %5 = tail call ptr @luaH_getnum(ptr noundef %1, i32 noundef %2) #47
  %6 = icmp eq ptr %5, @luaO_nilobject_
  br i1 %6, label %7, label %11

7:                                                ; preds = %3
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %4) #48
  %8 = sitofp i32 %2 to double
  store double %8, ptr %4, align 8, !tbaa !33
  %9 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  store i32 3, ptr %9, align 8, !tbaa !16
  %10 = call fastcc ptr @newkey(ptr noundef %0, ptr noundef %1, ptr noundef nonnull %4) #47
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %4) #48
  br label %11

11:                                               ; preds = %7, %3
  %12 = phi ptr [ %10, %7 ], [ %5, %3 ]
  ret ptr %12
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaH_set(ptr noundef %0, ptr noundef %1, ptr noundef %2) #1 {
  %4 = tail call ptr @luaH_get(ptr noundef %1, ptr noundef %2) #47
  %5 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 3
  store i8 0, ptr %5, align 2, !tbaa !182
  %6 = icmp eq ptr %4, @luaO_nilobject_
  br i1 %6, label %7, label %17

7:                                                ; preds = %3
  %8 = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  %9 = load i32, ptr %8, align 8, !tbaa !16
  switch i32 %9, label %15 [
    i32 0, label %13
    i32 3, label %10
  ]

10:                                               ; preds = %7
  %11 = load double, ptr %2, align 8, !tbaa !33
  %12 = fcmp ord double %11, 0.000000e+00
  br i1 %12, label %15, label %13

13:                                               ; preds = %10, %7
  %14 = phi ptr [ @.str.174, %7 ], [ @.str.1.175, %10 ]
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %0, ptr noundef nonnull %14) #46
  br label %15

15:                                               ; preds = %13, %10, %7
  %16 = tail call fastcc ptr @newkey(ptr noundef %0, ptr noundef nonnull %1, ptr noundef nonnull %2) #47
  br label %17

17:                                               ; preds = %15, %3
  %18 = phi ptr [ %16, %15 ], [ %4, %3 ]
  ret ptr %18
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaH_get(ptr nocapture noundef readonly %0, ptr noundef %1) #1 {
  %3 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  %4 = load i32, ptr %3, align 8, !tbaa !16
  switch i32 %4, label %39 [
    i32 0, label %50
    i32 4, label %5
    i32 3, label %32
  ]

5:                                                ; preds = %2
  %6 = load ptr, ptr %1, align 8, !tbaa !33
  %7 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 7
  %8 = load ptr, ptr %7, align 8, !tbaa !209
  %9 = getelementptr inbounds %struct.anon.0, ptr %6, i64 0, i32 4
  %10 = load i32, ptr %9, align 4, !tbaa !33
  %11 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 4
  %12 = load i8, ptr %11, align 1, !tbaa !208
  %13 = zext i8 %12 to i32
  %14 = shl nsw i32 -1, %13
  %15 = xor i32 %14, -1
  %16 = and i32 %10, %15
  %17 = zext i32 %16 to i64
  %18 = getelementptr inbounds %struct.Node, ptr %8, i64 %17
  br label %19

19:                                               ; preds = %28, %5
  %20 = phi ptr [ %18, %5 ], [ %30, %28 ]
  %21 = getelementptr inbounds %struct.Node, ptr %20, i64 0, i32 1, i32 0, i32 1
  %22 = load i32, ptr %21, align 8, !tbaa !33
  %23 = icmp eq i32 %22, 4
  br i1 %23, label %24, label %28

24:                                               ; preds = %19
  %25 = getelementptr inbounds %struct.Node, ptr %20, i64 0, i32 1
  %26 = load ptr, ptr %25, align 8, !tbaa !33
  %27 = icmp eq ptr %26, %6
  br i1 %27, label %50, label %28

28:                                               ; preds = %24, %19
  %29 = getelementptr inbounds %struct.Node, ptr %20, i64 0, i32 1, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8, !tbaa !33
  %31 = icmp eq ptr %30, null
  br i1 %31, label %50, label %19, !llvm.loop !336

32:                                               ; preds = %2
  %33 = load double, ptr %1, align 8, !tbaa !33
  %34 = fptosi double %33 to i32
  %35 = sitofp i32 %34 to double
  %36 = fcmp oeq double %33, %35
  br i1 %36, label %37, label %39

37:                                               ; preds = %32
  %38 = tail call ptr @luaH_getnum(ptr noundef %0, i32 noundef %34) #47
  br label %50

39:                                               ; preds = %32, %2
  %40 = tail call fastcc ptr @mainposition(ptr noundef %0, ptr noundef nonnull %1) #47
  br label %41

41:                                               ; preds = %46, %39
  %42 = phi ptr [ %40, %39 ], [ %48, %46 ]
  %43 = getelementptr inbounds %struct.Node, ptr %42, i64 0, i32 1
  %44 = tail call i32 @luaO_rawequalObj(ptr noundef nonnull %43, ptr noundef %1) #46
  %45 = icmp eq i32 %44, 0
  br i1 %45, label %46, label %50

46:                                               ; preds = %41
  %47 = getelementptr inbounds %struct.Node, ptr %42, i64 0, i32 1, i32 0, i32 2
  %48 = load ptr, ptr %47, align 8, !tbaa !33
  %49 = icmp eq ptr %48, null
  br i1 %49, label %50, label %41, !llvm.loop !337

50:                                               ; preds = %46, %41, %37, %28, %24, %2
  %51 = phi ptr [ %38, %37 ], [ @luaO_nilobject_, %2 ], [ @luaO_nilobject_, %46 ], [ %42, %41 ], [ @luaO_nilobject_, %28 ], [ %20, %24 ]
  ret ptr %51
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @newkey(ptr noundef %0, ptr noundef %1, ptr noundef %2) unnamed_addr #1 {
  %4 = alloca [27 x i32], align 16
  %5 = tail call fastcc ptr @mainposition(ptr noundef %1, ptr noundef %2) #47
  %6 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 0, i32 1
  %7 = load i32, ptr %6, align 8, !tbaa !210
  %8 = icmp ne i32 %7, 0
  %9 = icmp eq ptr %5, @dummynode_
  %10 = or i1 %9, %8
  br i1 %10, label %11, label %142

11:                                               ; preds = %3
  %12 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 8
  %13 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 7
  %14 = load ptr, ptr %13, align 8, !tbaa !209
  %15 = load ptr, ptr %12, align 8, !tbaa !335
  br label %16

16:                                               ; preds = %20, %11
  %17 = phi ptr [ %18, %20 ], [ %15, %11 ]
  %18 = getelementptr inbounds %struct.Node, ptr %17, i64 -1
  store ptr %18, ptr %12, align 8, !tbaa !335
  %19 = icmp ugt ptr %17, %14
  br i1 %19, label %20, label %24

20:                                               ; preds = %16
  %21 = getelementptr %struct.Node, ptr %17, i64 -1, i32 1, i32 0, i32 1
  %22 = load i32, ptr %21, align 8, !tbaa !33
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %119, label %16, !llvm.loop !338

24:                                               ; preds = %16
  call void @llvm.lifetime.start.p0(i64 108, ptr nonnull %4) #48
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(108) %4, i8 0, i64 108, i1 false), !tbaa !65
  %25 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 10
  %26 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 6
  %27 = load i32, ptr %25, align 8, !tbaa !205
  br label %28

28:                                               ; preds = %56, %24
  %29 = phi i64 [ 0, %24 ], [ %63, %56 ]
  %30 = phi i32 [ 1, %24 ], [ %57, %56 ]
  %31 = phi i32 [ 0, %24 ], [ %62, %56 ]
  %32 = phi i32 [ 1, %24 ], [ %64, %56 ]
  %33 = icmp sgt i32 %32, %27
  br i1 %33, label %34, label %36

34:                                               ; preds = %28
  %35 = icmp sgt i32 %30, %27
  br i1 %35, label %66, label %36

36:                                               ; preds = %34, %28
  %37 = phi i32 [ %27, %34 ], [ %32, %28 ]
  %38 = icmp sgt i32 %30, %37
  br i1 %38, label %56, label %39

39:                                               ; preds = %36
  %40 = load ptr, ptr %26, align 8, !tbaa !206
  %41 = sext i32 %30 to i64
  %42 = sext i32 %37 to i64
  br label %43

43:                                               ; preds = %43, %39
  %44 = phi i64 [ %41, %39 ], [ %52, %43 ]
  %45 = phi i32 [ 0, %39 ], [ %51, %43 ]
  %46 = add nsw i64 %44, -1
  %47 = getelementptr inbounds %struct.lua_TValue, ptr %40, i64 %46, i32 1
  %48 = load i32, ptr %47, align 8, !tbaa !16
  %49 = icmp ne i32 %48, 0
  %50 = zext i1 %49 to i32
  %51 = add nuw nsw i32 %45, %50
  %52 = add nsw i64 %44, 1
  %53 = icmp slt i64 %44, %42
  br i1 %53, label %43, label %54, !llvm.loop !339

54:                                               ; preds = %43
  %.lcssa3 = phi i32 [ %51, %43 ]
  %55 = add i32 %37, 1
  br label %56

56:                                               ; preds = %54, %36
  %57 = phi i32 [ %30, %36 ], [ %55, %54 ]
  %58 = phi i32 [ 0, %36 ], [ %.lcssa3, %54 ]
  %59 = getelementptr inbounds i32, ptr %4, i64 %29
  %60 = load i32, ptr %59, align 4, !tbaa !65
  %61 = add nsw i32 %60, %58
  store i32 %61, ptr %59, align 4, !tbaa !65
  %62 = add nuw nsw i32 %58, %31
  %63 = add nuw nsw i64 %29, 1
  %64 = shl nsw i32 %32, 1
  %65 = icmp eq i64 %63, 27
  br i1 %65, label %66, label %28, !llvm.loop !340

66:                                               ; preds = %56, %34
  %67 = phi i32 [ %31, %34 ], [ %62, %56 ]
  %68 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 4
  %69 = load i8, ptr %68, align 1, !tbaa !208
  %70 = zext i8 %69 to i32
  %71 = shl nsw i32 -1, %70
  %72 = xor i32 %71, -1
  %73 = zext i32 %72 to i64
  br label %74

74:                                               ; preds = %87, %66
  %75 = phi i64 [ %73, %66 ], [ %90, %87 ]
  %76 = phi i32 [ 0, %66 ], [ %89, %87 ]
  %77 = phi i32 [ 0, %66 ], [ %88, %87 ]
  %78 = load ptr, ptr %13, align 8, !tbaa !209
  %79 = getelementptr inbounds %struct.Node, ptr %78, i64 %75, i32 0, i32 1
  %80 = load i32, ptr %79, align 8, !tbaa !210
  %81 = icmp eq i32 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = getelementptr inbounds %struct.Node, ptr %78, i64 %75, i32 1
  %84 = call fastcc i32 @countint(ptr noundef nonnull %83, ptr noundef nonnull %4) #47, !range !75
  %85 = add nsw i32 %84, %77
  %86 = add nsw i32 %76, 1
  br label %87

87:                                               ; preds = %82, %74
  %88 = phi i32 [ %77, %74 ], [ %85, %82 ]
  %89 = phi i32 [ %76, %74 ], [ %86, %82 ]
  %90 = add nsw i64 %75, -1
  %91 = icmp eq i64 %75, 0
  br i1 %91, label %92, label %74, !llvm.loop !341

92:                                               ; preds = %87
  %.lcssa2 = phi i32 [ %88, %87 ]
  %.lcssa1 = phi i32 [ %89, %87 ]
  %93 = add nsw i32 %.lcssa2, %67
  %94 = call fastcc i32 @countint(ptr noundef %2, ptr noundef nonnull %4) #47, !range !75
  %95 = add nsw i32 %93, %94
  %96 = icmp sgt i32 %95, 0
  br i1 %96, label %97, label %135

97:                                               ; preds = %114, %92
  %98 = phi i64 [ %115, %114 ], [ 0, %92 ]
  %99 = phi i32 [ %117, %114 ], [ 0, %92 ]
  %100 = phi i32 [ %112, %114 ], [ 0, %92 ]
  %101 = phi i32 [ %111, %114 ], [ 0, %92 ]
  %102 = phi i32 [ %109, %114 ], [ 0, %92 ]
  %103 = phi i32 [ %116, %114 ], [ 1, %92 ]
  %104 = getelementptr inbounds i32, ptr %4, i64 %98
  %105 = load i32, ptr %104, align 4, !tbaa !65
  %106 = icmp sgt i32 %105, 0
  %107 = add nsw i32 %105, %102
  %108 = icmp sgt i32 %107, %99
  %109 = select i1 %106, i32 %107, i32 %102
  %110 = select i1 %106, i1 %108, i1 false
  %111 = select i1 %110, i32 %107, i32 %101
  %112 = select i1 %110, i32 %103, i32 %100
  %113 = icmp eq i32 %109, %95
  br i1 %113, label %135, label %114

114:                                              ; preds = %97
  %115 = add nuw i64 %98, 1
  %116 = shl nsw i32 %103, 1
  %117 = and i32 %103, 2147483647
  %118 = icmp slt i32 %117, %95
  br i1 %118, label %97, label %135, !llvm.loop !342

119:                                              ; preds = %20
  %.lcssa7 = phi ptr [ %17, %20 ]
  %.lcssa5 = phi ptr [ %18, %20 ]
  %120 = getelementptr inbounds %struct.Node, ptr %5, i64 0, i32 1
  %121 = tail call fastcc ptr @mainposition(ptr noundef nonnull %1, ptr noundef nonnull %120) #47
  %122 = icmp eq ptr %121, %5
  br i1 %122, label %131, label %123

123:                                              ; preds = %123, %119
  %124 = phi ptr [ %126, %123 ], [ %121, %119 ]
  %125 = getelementptr inbounds %struct.Node, ptr %124, i64 0, i32 1, i32 0, i32 2
  %126 = load ptr, ptr %125, align 8, !tbaa !33
  %127 = icmp eq ptr %126, %5
  br i1 %127, label %128, label %123, !llvm.loop !343

128:                                              ; preds = %123
  %.lcssa = phi ptr [ %124, %123 ]
  %129 = getelementptr inbounds %struct.Node, ptr %.lcssa, i64 0, i32 1, i32 0, i32 2
  store ptr %.lcssa5, ptr %129, align 8, !tbaa !33
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %.lcssa5, ptr noundef nonnull align 8 dereferenceable(40) %5, i64 40, i1 false), !tbaa.struct !344
  %130 = getelementptr inbounds %struct.Node, ptr %5, i64 0, i32 1, i32 0, i32 2
  store ptr null, ptr %130, align 8, !tbaa !33
  store i32 0, ptr %6, align 8, !tbaa !210
  br label %142

131:                                              ; preds = %119
  %132 = getelementptr inbounds %struct.Node, ptr %5, i64 0, i32 1, i32 0, i32 2
  %133 = load ptr, ptr %132, align 8, !tbaa !33
  %134 = getelementptr %struct.Node, ptr %.lcssa7, i64 -1, i32 1, i32 0, i32 2
  store ptr %133, ptr %134, align 8, !tbaa !33
  store ptr %.lcssa5, ptr %132, align 8, !tbaa !33
  br label %142

135:                                              ; preds = %114, %97, %92
  %136 = phi i32 [ 0, %92 ], [ %111, %97 ], [ %111, %114 ]
  %137 = phi i32 [ 0, %92 ], [ %112, %97 ], [ %112, %114 ]
  %138 = add i32 %67, 1
  %139 = add i32 %138, %.lcssa1
  %140 = sub i32 %139, %136
  tail call fastcc void @resize(ptr noundef %0, ptr noundef %1, i32 noundef %137, i32 noundef %140) #47
  call void @llvm.lifetime.end.p0(i64 108, ptr nonnull %4) #48
  %141 = tail call ptr @luaH_set(ptr noundef %0, ptr noundef %1, ptr noundef %2) #47
  br label %163

142:                                              ; preds = %131, %128, %3
  %143 = phi ptr [ %5, %3 ], [ %.lcssa5, %131 ], [ %5, %128 ]
  %144 = getelementptr inbounds %struct.Node, ptr %143, i64 0, i32 1
  %145 = load i64, ptr %2, align 8
  store i64 %145, ptr %144, align 8
  %146 = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  %147 = load i32, ptr %146, align 8, !tbaa !16
  %148 = getelementptr inbounds %struct.Node, ptr %143, i64 0, i32 1, i32 0, i32 1
  store i32 %147, ptr %148, align 8, !tbaa !33
  %149 = load i32, ptr %146, align 8, !tbaa !16
  %150 = icmp sgt i32 %149, 3
  br i1 %150, label %151, label %163

151:                                              ; preds = %142
  %152 = load ptr, ptr %2, align 8, !tbaa !33
  %153 = getelementptr inbounds %struct.GCheader, ptr %152, i64 0, i32 2
  %154 = load i8, ptr %153, align 1, !tbaa !33
  %155 = and i8 %154, 3
  %156 = icmp eq i8 %155, 0
  br i1 %156, label %163, label %157

157:                                              ; preds = %151
  %158 = getelementptr inbounds %struct.GCheader, ptr %1, i64 0, i32 2
  %159 = load i8, ptr %158, align 1, !tbaa !33
  %160 = and i8 %159, 4
  %161 = icmp eq i8 %160, 0
  br i1 %161, label %163, label %162

162:                                              ; preds = %157
  tail call void @luaC_barrierback(ptr noundef %0, ptr noundef nonnull %1) #46
  br label %163

163:                                              ; preds = %162, %157, %151, %142, %135
  %164 = phi ptr [ %141, %135 ], [ %143, %162 ], [ %143, %157 ], [ %143, %151 ], [ %143, %142 ]
  ret ptr %164
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @countint(ptr nocapture noundef readonly %0, ptr nocapture noundef %1) unnamed_addr #1 {
  %3 = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %4 = load i32, ptr %3, align 8, !tbaa !16
  %5 = icmp eq i32 %4, 3
  br i1 %5, label %6, label %21

6:                                                ; preds = %2
  %7 = load double, ptr %0, align 8, !tbaa !33
  %8 = fptosi double %7 to i32
  %9 = sitofp i32 %8 to double
  %10 = fcmp une double %7, %9
  br i1 %10, label %21, label %11

11:                                               ; preds = %6
  %12 = add i32 %8, -1
  %13 = icmp ult i32 %12, 67108864
  br i1 %13, label %14, label %21

14:                                               ; preds = %11
  %15 = tail call i32 @luaO_log2(i32 noundef %12) #46
  %16 = add nsw i32 %15, 1
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds i32, ptr %1, i64 %17
  %19 = load i32, ptr %18, align 4, !tbaa !65
  %20 = add nsw i32 %19, 1
  store i32 %20, ptr %18, align 4, !tbaa !65
  br label %21

21:                                               ; preds = %14, %11, %6, %2
  %22 = phi i32 [ 1, %14 ], [ 0, %11 ], [ 0, %2 ], [ 0, %6 ]
  ret i32 %22
}

; Function Attrs: nofree norecurse nosync nounwind optsize memory(read, inaccessiblemem: none) uwtable
define internal ptr @luaH_getnum(ptr nocapture noundef readonly %0, i32 noundef %1) #14 {
  %3 = add nsw i32 %1, -1
  %4 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 10
  %5 = load i32, ptr %4, align 8, !tbaa !205
  %6 = icmp ult i32 %3, %5
  br i1 %6, label %7, label %12

7:                                                ; preds = %2
  %8 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 6
  %9 = load ptr, ptr %8, align 8, !tbaa !206
  %10 = sext i32 %3 to i64
  %11 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 %10
  br label %49

12:                                               ; preds = %2
  %13 = sitofp i32 %1 to double
  %14 = icmp eq i32 %1, 0
  br i1 %14, label %15, label %18

15:                                               ; preds = %12
  %16 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 7
  %17 = load ptr, ptr %16, align 8, !tbaa !209
  br label %34

18:                                               ; preds = %12
  %19 = bitcast double %13 to i64
  %20 = lshr i64 %19, 32
  %21 = add i64 %20, %19
  %22 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 7
  %23 = load ptr, ptr %22, align 8, !tbaa !209
  %24 = trunc i64 %21 to i32
  %25 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 4
  %26 = load i8, ptr %25, align 1, !tbaa !208
  %27 = zext i8 %26 to i32
  %28 = shl nsw i32 -1, %27
  %29 = xor i32 %28, -1
  %30 = or i32 %29, 1
  %31 = urem i32 %24, %30
  %32 = zext i32 %31 to i64
  %33 = getelementptr inbounds %struct.Node, ptr %23, i64 %32
  br label %34

34:                                               ; preds = %18, %15
  %35 = phi ptr [ %33, %18 ], [ %17, %15 ]
  br label %36

36:                                               ; preds = %45, %34
  %37 = phi ptr [ %47, %45 ], [ %35, %34 ]
  %38 = getelementptr inbounds %struct.Node, ptr %37, i64 0, i32 1, i32 0, i32 1
  %39 = load i32, ptr %38, align 8, !tbaa !33
  %40 = icmp eq i32 %39, 3
  br i1 %40, label %41, label %45

41:                                               ; preds = %36
  %42 = getelementptr inbounds %struct.Node, ptr %37, i64 0, i32 1
  %43 = load double, ptr %42, align 8, !tbaa !33
  %44 = fcmp oeq double %43, %13
  br i1 %44, label %49, label %45

45:                                               ; preds = %41, %36
  %46 = getelementptr inbounds %struct.Node, ptr %37, i64 0, i32 1, i32 0, i32 2
  %47 = load ptr, ptr %46, align 8, !tbaa !33
  %48 = icmp eq ptr %47, null
  br i1 %48, label %49, label %36, !llvm.loop !345

49:                                               ; preds = %45, %41, %7
  %50 = phi ptr [ %11, %7 ], [ @luaO_nilobject_, %45 ], [ %37, %41 ]
  ret ptr %50
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaH_new(ptr noundef %0, i32 noundef %1, i32 noundef %2) #1 {
  %4 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef null, i64 noundef 0, i64 noundef 64) #46
  tail call void @luaC_link(ptr noundef %0, ptr noundef %4, i8 noundef zeroext 5) #46
  %5 = getelementptr inbounds %struct.Table, ptr %4, i64 0, i32 5
  store ptr null, ptr %5, align 8, !tbaa !221
  %6 = getelementptr inbounds %struct.Table, ptr %4, i64 0, i32 3
  store i8 -1, ptr %6, align 2, !tbaa !182
  %7 = getelementptr inbounds %struct.Table, ptr %4, i64 0, i32 6
  store ptr null, ptr %7, align 8, !tbaa !206
  %8 = getelementptr inbounds %struct.Table, ptr %4, i64 0, i32 10
  store i32 0, ptr %8, align 8, !tbaa !205
  %9 = getelementptr inbounds %struct.Table, ptr %4, i64 0, i32 4
  store i8 0, ptr %9, align 1, !tbaa !208
  %10 = getelementptr inbounds %struct.Table, ptr %4, i64 0, i32 7
  store ptr @dummynode_, ptr %10, align 8, !tbaa !209
  tail call fastcc void @setarrayvector(ptr noundef %0, ptr noundef %4, i32 noundef %1) #47
  tail call fastcc void @setnodevector(ptr noundef %0, ptr noundef %4, i32 noundef %2) #47
  ret ptr %4
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaH_free(ptr noundef %0, ptr noundef %1) #1 {
  %3 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 7
  %4 = load ptr, ptr %3, align 8, !tbaa !209
  %5 = icmp eq ptr %4, @dummynode_
  br i1 %5, label %14, label %6

6:                                                ; preds = %2
  %7 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 4
  %8 = load i8, ptr %7, align 1, !tbaa !208
  %9 = zext i8 %8 to i32
  %10 = shl nuw i32 1, %9
  %11 = sext i32 %10 to i64
  %12 = mul nsw i64 %11, 40
  %13 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %4, i64 noundef %12, i64 noundef 0) #46
  br label %14

14:                                               ; preds = %6, %2
  %15 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 6
  %16 = load ptr, ptr %15, align 8, !tbaa !206
  %17 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 10
  %18 = load i32, ptr %17, align 8, !tbaa !205
  %19 = sext i32 %18 to i64
  %20 = shl nsw i64 %19, 4
  %21 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %16, i64 noundef %20, i64 noundef 0) #46
  %22 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef nonnull %1, i64 noundef 64, i64 noundef 0) #46
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind optsize memory(read, inaccessiblemem: none) uwtable
define internal ptr @luaH_getstr(ptr nocapture noundef readonly %0, ptr noundef readonly %1) #14 {
  %3 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 7
  %4 = load ptr, ptr %3, align 8, !tbaa !209
  %5 = getelementptr inbounds %struct.anon.0, ptr %1, i64 0, i32 4
  %6 = load i32, ptr %5, align 4, !tbaa !33
  %7 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 4
  %8 = load i8, ptr %7, align 1, !tbaa !208
  %9 = zext i8 %8 to i32
  %10 = shl nsw i32 -1, %9
  %11 = xor i32 %10, -1
  %12 = and i32 %6, %11
  %13 = zext i32 %12 to i64
  %14 = getelementptr inbounds %struct.Node, ptr %4, i64 %13
  br label %15

15:                                               ; preds = %24, %2
  %16 = phi ptr [ %14, %2 ], [ %26, %24 ]
  %17 = getelementptr inbounds %struct.Node, ptr %16, i64 0, i32 1, i32 0, i32 1
  %18 = load i32, ptr %17, align 8, !tbaa !33
  %19 = icmp eq i32 %18, 4
  br i1 %19, label %20, label %24

20:                                               ; preds = %15
  %21 = getelementptr inbounds %struct.Node, ptr %16, i64 0, i32 1
  %22 = load ptr, ptr %21, align 8, !tbaa !33
  %23 = icmp eq ptr %22, %1
  br i1 %23, label %28, label %24

24:                                               ; preds = %20, %15
  %25 = getelementptr inbounds %struct.Node, ptr %16, i64 0, i32 1, i32 0, i32 2
  %26 = load ptr, ptr %25, align 8, !tbaa !33
  %27 = icmp eq ptr %26, null
  br i1 %27, label %28, label %15, !llvm.loop !336

28:                                               ; preds = %24, %20
  %29 = phi ptr [ %16, %20 ], [ @luaO_nilobject_, %24 ]
  ret ptr %29
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaH_setstr(ptr noundef %0, ptr noundef %1, ptr noundef %2) #1 {
  %4 = alloca %struct.lua_TValue, align 8
  %5 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 7
  %6 = load ptr, ptr %5, align 8, !tbaa !209
  %7 = getelementptr inbounds %struct.anon.0, ptr %2, i64 0, i32 4
  %8 = load i32, ptr %7, align 4, !tbaa !33
  %9 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 4
  %10 = load i8, ptr %9, align 1, !tbaa !208
  %11 = zext i8 %10 to i32
  %12 = shl nsw i32 -1, %11
  %13 = xor i32 %12, -1
  %14 = and i32 %8, %13
  %15 = zext i32 %14 to i64
  %16 = getelementptr inbounds %struct.Node, ptr %6, i64 %15
  br label %17

17:                                               ; preds = %26, %3
  %18 = phi ptr [ %16, %3 ], [ %28, %26 ]
  %19 = getelementptr inbounds %struct.Node, ptr %18, i64 0, i32 1, i32 0, i32 1
  %20 = load i32, ptr %19, align 8, !tbaa !33
  %21 = icmp eq i32 %20, 4
  br i1 %21, label %22, label %26

22:                                               ; preds = %17
  %23 = getelementptr inbounds %struct.Node, ptr %18, i64 0, i32 1
  %24 = load ptr, ptr %23, align 8, !tbaa !33
  %25 = icmp eq ptr %24, %2
  br i1 %25, label %30, label %26

26:                                               ; preds = %22, %17
  %27 = getelementptr inbounds %struct.Node, ptr %18, i64 0, i32 1, i32 0, i32 2
  %28 = load ptr, ptr %27, align 8, !tbaa !33
  %29 = icmp eq ptr %28, null
  br i1 %29, label %32, label %17, !llvm.loop !336

30:                                               ; preds = %22
  %.lcssa = phi ptr [ %18, %22 ]
  %31 = icmp eq ptr %.lcssa, @luaO_nilobject_
  br i1 %31, label %32, label %35

32:                                               ; preds = %30, %26
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %4) #48
  store ptr %2, ptr %4, align 8, !tbaa !33
  %33 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  store i32 4, ptr %33, align 8, !tbaa !16
  %34 = call fastcc ptr @newkey(ptr noundef %0, ptr noundef %1, ptr noundef nonnull %4) #47
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %4) #48
  br label %35

35:                                               ; preds = %32, %30
  %36 = phi ptr [ %34, %32 ], [ %.lcssa, %30 ]
  ret ptr %36
}

; Function Attrs: nofree norecurse nosync nounwind optsize memory(read, inaccessiblemem: none) uwtable
define internal i32 @luaH_getn(ptr nocapture noundef readonly %0) #14 {
  %2 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 10
  %3 = load i32, ptr %2, align 8, !tbaa !205
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %29, label %5

5:                                                ; preds = %1
  %6 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 6
  %7 = load ptr, ptr %6, align 8, !tbaa !206
  %8 = add i32 %3, -1
  %9 = zext i32 %8 to i64
  %10 = getelementptr inbounds %struct.lua_TValue, ptr %7, i64 %9, i32 1
  %11 = load i32, ptr %10, align 8, !tbaa !16
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %13, label %29

13:                                               ; preds = %5
  %14 = icmp ugt i32 %3, 1
  br i1 %14, label %15, label %70

15:                                               ; preds = %15, %13
  %16 = phi i32 [ %26, %15 ], [ 0, %13 ]
  %17 = phi i32 [ %25, %15 ], [ %3, %13 ]
  %18 = add i32 %16, %17
  %19 = lshr i32 %18, 1
  %20 = add nsw i32 %19, -1
  %21 = zext i32 %20 to i64
  %22 = getelementptr inbounds %struct.lua_TValue, ptr %7, i64 %21, i32 1
  %23 = load i32, ptr %22, align 8, !tbaa !16
  %24 = icmp eq i32 %23, 0
  %25 = select i1 %24, i32 %19, i32 %17
  %26 = select i1 %24, i32 %16, i32 %19
  %27 = sub i32 %25, %26
  %28 = icmp ugt i32 %27, 1
  br i1 %28, label %15, label %70, !llvm.loop !346

29:                                               ; preds = %5, %1
  %30 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 7
  %31 = load ptr, ptr %30, align 8, !tbaa !209
  %32 = icmp eq ptr %31, @dummynode_
  br i1 %32, label %70, label %33

33:                                               ; preds = %29
  %34 = add i32 %3, 1
  br label %35

35:                                               ; preds = %45, %33
  %36 = phi i32 [ %34, %33 ], [ %46, %45 ]
  %37 = phi i32 [ %3, %33 ], [ %36, %45 ]
  %38 = tail call ptr @luaH_getnum(ptr noundef %0, i32 noundef %36) #47
  %39 = getelementptr inbounds %struct.lua_TValue, ptr %38, i64 0, i32 1
  %40 = load i32, ptr %39, align 8, !tbaa !16
  %41 = icmp eq i32 %40, 0
  br i1 %41, label %42, label %45

42:                                               ; preds = %35
  %.lcssa3 = phi i32 [ %36, %35 ]
  %.lcssa1 = phi i32 [ %37, %35 ]
  %43 = sub i32 %.lcssa3, %.lcssa1
  %44 = icmp ugt i32 %43, 1
  br i1 %44, label %57, label %70

45:                                               ; preds = %35
  %46 = shl i32 %36, 1
  %47 = icmp ugt i32 %46, 2147483645
  br i1 %47, label %48, label %35, !llvm.loop !347

48:                                               ; preds = %48, %45
  %.lcssa4 = phi i32 [ %.lcssa4, %48 ], [ %36, %45 ]
  %.lcssa2 = phi i32 [ %.lcssa2, %48 ], [ %37, %45 ]
  %49 = phi i32 [ %54, %48 ], [ 1, %45 ]
  %50 = tail call ptr @luaH_getnum(ptr noundef %0, i32 noundef %49) #47
  %51 = getelementptr inbounds %struct.lua_TValue, ptr %50, i64 0, i32 1
  %52 = load i32, ptr %51, align 8, !tbaa !16
  %53 = icmp eq i32 %52, 0
  %54 = add i32 %49, 1
  br i1 %53, label %55, label %48, !llvm.loop !348

55:                                               ; preds = %48
  %.lcssa = phi i32 [ %49, %48 ]
  %56 = add i32 %.lcssa, -1
  br label %70

57:                                               ; preds = %57, %42
  %58 = phi i32 [ %67, %57 ], [ %.lcssa1, %42 ]
  %59 = phi i32 [ %66, %57 ], [ %.lcssa3, %42 ]
  %60 = add i32 %59, %58
  %61 = lshr i32 %60, 1
  %62 = tail call ptr @luaH_getnum(ptr noundef %0, i32 noundef %61) #47
  %63 = getelementptr inbounds %struct.lua_TValue, ptr %62, i64 0, i32 1
  %64 = load i32, ptr %63, align 8, !tbaa !16
  %65 = icmp eq i32 %64, 0
  %66 = select i1 %65, i32 %61, i32 %59
  %67 = select i1 %65, i32 %58, i32 %61
  %68 = sub i32 %66, %67
  %69 = icmp ugt i32 %68, 1
  br i1 %69, label %57, label %70, !llvm.loop !349

70:                                               ; preds = %57, %55, %42, %29, %15, %13
  %71 = phi i32 [ %3, %29 ], [ %56, %55 ], [ %.lcssa1, %42 ], [ 0, %13 ], [ %67, %57 ], [ %26, %15 ]
  ret i32 %71
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaT_init(ptr noundef %0) #1 {
  %2 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  br label %3

3:                                                ; preds = %3, %1
  %4 = phi i64 [ 0, %1 ], [ %17, %3 ]
  %5 = getelementptr inbounds [17 x ptr], ptr @luaT_init.luaT_eventname, i64 0, i64 %4
  %6 = load ptr, ptr %5, align 8, !tbaa !39
  %7 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %6) #49
  %8 = tail call ptr @luaS_newlstr(ptr noundef %0, ptr noundef %6, i64 noundef %7) #46
  %9 = load ptr, ptr %2, align 8, !tbaa !25
  %10 = getelementptr inbounds %struct.global_State, ptr %9, i64 0, i32 24, i64 %4
  store ptr %8, ptr %10, align 8, !tbaa !39
  %11 = load ptr, ptr %2, align 8, !tbaa !25
  %12 = getelementptr inbounds %struct.global_State, ptr %11, i64 0, i32 24, i64 %4
  %13 = load ptr, ptr %12, align 8, !tbaa !39
  %14 = getelementptr inbounds %struct.anon.0, ptr %13, i64 0, i32 2
  %15 = load i8, ptr %14, align 1, !tbaa !33
  %16 = or i8 %15, 32
  store i8 %16, ptr %14, align 1, !tbaa !33
  %17 = add nuw nsw i64 %4, 1
  %18 = icmp eq i64 %17, 17
  br i1 %18, label %19, label %3, !llvm.loop !350

19:                                               ; preds = %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaT_gettm(ptr noundef %0, i32 noundef %1, ptr noundef %2) #1 {
  %4 = tail call ptr @luaH_getstr(ptr noundef %0, ptr noundef %2) #46
  %5 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  %6 = load i32, ptr %5, align 8, !tbaa !16
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %14

8:                                                ; preds = %3
  %9 = shl nuw i32 1, %1
  %10 = getelementptr inbounds %struct.Table, ptr %0, i64 0, i32 3
  %11 = load i8, ptr %10, align 2, !tbaa !182
  %12 = trunc i32 %9 to i8
  %13 = or i8 %11, %12
  store i8 %13, ptr %10, align 2, !tbaa !182
  br label %14

14:                                               ; preds = %8, %3
  %15 = phi ptr [ null, %8 ], [ %4, %3 ]
  ret ptr %15
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaT_gettmbyobj(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1, i32 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  switch i32 %5, label %12 [
    i32 5, label %6
    i32 7, label %9
  ]

6:                                                ; preds = %3
  %7 = load ptr, ptr %1, align 8, !tbaa !33
  %8 = getelementptr inbounds %struct.Table, ptr %7, i64 0, i32 5
  br label %17

9:                                                ; preds = %3
  %10 = load ptr, ptr %1, align 8, !tbaa !33
  %11 = getelementptr inbounds %struct.anon.1, ptr %10, i64 0, i32 3
  br label %17

12:                                               ; preds = %3
  %13 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %14 = load ptr, ptr %13, align 8, !tbaa !25
  %15 = sext i32 %5 to i64
  %16 = getelementptr inbounds %struct.global_State, ptr %14, i64 0, i32 23, i64 %15
  br label %17

17:                                               ; preds = %12, %9, %6
  %18 = phi ptr [ %16, %12 ], [ %11, %9 ], [ %8, %6 ]
  %19 = load ptr, ptr %18, align 8, !tbaa !33
  %20 = icmp eq ptr %19, null
  br i1 %20, label %28, label %21

21:                                               ; preds = %17
  %22 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %23 = load ptr, ptr %22, align 8, !tbaa !25
  %24 = zext i32 %2 to i64
  %25 = getelementptr inbounds %struct.global_State, ptr %23, i64 0, i32 24, i64 %24
  %26 = load ptr, ptr %25, align 8, !tbaa !39
  %27 = tail call ptr @luaH_getstr(ptr noundef nonnull %19, ptr noundef %26) #46
  br label %28

28:                                               ; preds = %21, %17
  %29 = phi ptr [ %27, %21 ], [ @luaO_nilobject_, %17 ]
  ret ptr %29
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaU_undump(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3) #1 {
  %5 = alloca [12 x i8], align 4
  %6 = alloca [12 x i8], align 1
  %7 = alloca %struct.LoadState, align 8
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %7) #48
  %8 = load i8, ptr %3, align 1, !tbaa !33
  switch i8 %8, label %11 [
    i8 64, label %9
    i8 61, label %9
    i8 27, label %12
  ]

9:                                                ; preds = %4, %4
  %10 = getelementptr inbounds i8, ptr %3, i64 1
  br label %12

11:                                               ; preds = %4
  br label %12

12:                                               ; preds = %11, %9, %4
  %13 = phi ptr [ %3, %11 ], [ %10, %9 ], [ @.str.1.224, %4 ]
  %14 = getelementptr inbounds %struct.LoadState, ptr %7, i64 0, i32 3
  store ptr %13, ptr %14, align 8, !tbaa !351
  store ptr %0, ptr %7, align 8, !tbaa !353
  %15 = getelementptr inbounds %struct.LoadState, ptr %7, i64 0, i32 1
  store ptr %1, ptr %15, align 8, !tbaa !354
  %16 = getelementptr inbounds %struct.LoadState, ptr %7, i64 0, i32 2
  store ptr %2, ptr %16, align 8, !tbaa !355
  call void @llvm.lifetime.start.p0(i64 12, ptr nonnull %5) #48
  call void @llvm.lifetime.start.p0(i64 12, ptr nonnull %6) #48
  store i32 1635077147, ptr %5, align 4
  %17 = getelementptr inbounds i8, ptr %5, i64 4
  store <8 x i8> <i8 81, i8 0, i8 1, i8 4, i8 8, i8 4, i8 8, i8 0>, ptr %17, align 4, !tbaa !33
  call fastcc void @LoadBlock(ptr noundef nonnull %7, ptr noundef nonnull %6, i64 noundef 12) #47
  %18 = call i32 @bcmp(ptr noundef nonnull dereferenceable(12) %5, ptr noundef nonnull dereferenceable(12) %6, i64 12)
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %22, label %20

20:                                               ; preds = %12
  %21 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.5.225, ptr noundef nonnull %13, ptr noundef nonnull @.str.3.226) #46
  call void @luaD_throw(ptr noundef %0, i32 noundef 3) #46
  br label %22

22:                                               ; preds = %20, %12
  call void @llvm.lifetime.end.p0(i64 12, ptr nonnull %6) #48
  call void @llvm.lifetime.end.p0(i64 12, ptr nonnull %5) #48
  %23 = call ptr @luaS_newlstr(ptr noundef %0, ptr noundef nonnull @.str.2.227, i64 noundef 2) #46
  %24 = call fastcc ptr @LoadFunction(ptr noundef nonnull %7, ptr noundef %23) #47
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %7) #48
  ret ptr %24
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @LoadBlock(ptr nocapture noundef readonly %0, ptr noundef %1, i64 noundef %2) unnamed_addr #1 {
  %4 = getelementptr inbounds %struct.LoadState, ptr %0, i64 0, i32 1
  %5 = load ptr, ptr %4, align 8, !tbaa !354
  %6 = tail call i64 @luaZ_read(ptr noundef %5, ptr noundef %1, i64 noundef %2) #46
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %14, label %8

8:                                                ; preds = %3
  %9 = load ptr, ptr %0, align 8, !tbaa !353
  %10 = getelementptr inbounds %struct.LoadState, ptr %0, i64 0, i32 3
  %11 = load ptr, ptr %10, align 8, !tbaa !351
  %12 = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %9, ptr noundef nonnull @.str.5.225, ptr noundef %11, ptr noundef nonnull @.str.4.232) #46
  %13 = load ptr, ptr %0, align 8, !tbaa !353
  tail call void @luaD_throw(ptr noundef %13, i32 noundef 3) #46
  br label %14

14:                                               ; preds = %8, %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @LoadFunction(ptr nocapture noundef readonly %0, ptr noundef %1) unnamed_addr #1 {
  %3 = alloca i8, align 1
  %4 = alloca i8, align 1
  %5 = alloca double, align 8
  %6 = alloca i8, align 1
  %7 = alloca i8, align 1
  %8 = alloca i8, align 1
  %9 = alloca i8, align 1
  %10 = load ptr, ptr %0, align 8, !tbaa !353
  %11 = getelementptr inbounds %struct.lua_State, ptr %10, i64 0, i32 15
  %12 = load i16, ptr %11, align 8, !tbaa !24
  %13 = add i16 %12, 1
  store i16 %13, ptr %11, align 8, !tbaa !24
  %14 = icmp ugt i16 %13, 200
  br i1 %14, label %15, label %21

15:                                               ; preds = %2
  %16 = getelementptr inbounds %struct.LoadState, ptr %0, i64 0, i32 3
  %17 = load ptr, ptr %16, align 8, !tbaa !351
  %18 = tail call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef nonnull %10, ptr noundef nonnull @.str.5.225, ptr noundef %17, ptr noundef nonnull @.str.6.228) #46
  %19 = load ptr, ptr %0, align 8, !tbaa !353
  tail call void @luaD_throw(ptr noundef %19, i32 noundef 3) #46
  %20 = load ptr, ptr %0, align 8, !tbaa !353
  br label %21

21:                                               ; preds = %15, %2
  %22 = phi ptr [ %20, %15 ], [ %10, %2 ]
  %23 = tail call ptr @luaF_newproto(ptr noundef %22) #46
  %24 = load ptr, ptr %0, align 8, !tbaa !353
  %25 = getelementptr inbounds %struct.lua_State, ptr %24, i64 0, i32 4
  %26 = load ptr, ptr %25, align 8, !tbaa !7
  store ptr %23, ptr %26, align 8, !tbaa !33
  %27 = getelementptr inbounds %struct.lua_TValue, ptr %26, i64 0, i32 1
  store i32 9, ptr %27, align 8, !tbaa !16
  %28 = load ptr, ptr %0, align 8, !tbaa !353
  %29 = getelementptr inbounds %struct.lua_State, ptr %28, i64 0, i32 9
  %30 = load ptr, ptr %29, align 8, !tbaa !18
  %31 = getelementptr inbounds %struct.lua_State, ptr %28, i64 0, i32 4
  %32 = load ptr, ptr %31, align 8, !tbaa !7
  %33 = ptrtoint ptr %30 to i64
  %34 = ptrtoint ptr %32 to i64
  %35 = sub i64 %33, %34
  %36 = icmp slt i64 %35, 17
  br i1 %36, label %37, label %41

37:                                               ; preds = %21
  tail call void @luaD_growstack(ptr noundef nonnull %28, i32 noundef 1) #46
  %38 = load ptr, ptr %0, align 8, !tbaa !353
  %39 = getelementptr inbounds %struct.lua_State, ptr %38, i64 0, i32 4
  %40 = load ptr, ptr %39, align 8, !tbaa !7
  br label %41

41:                                               ; preds = %37, %21
  %42 = phi ptr [ %32, %21 ], [ %40, %37 ]
  %43 = phi ptr [ %28, %21 ], [ %38, %37 ]
  %44 = getelementptr inbounds %struct.lua_State, ptr %43, i64 0, i32 4
  %45 = getelementptr inbounds %struct.lua_TValue, ptr %42, i64 1
  store ptr %45, ptr %44, align 8, !tbaa !7
  %46 = tail call fastcc ptr @LoadString(ptr noundef nonnull %0) #47
  %47 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 9
  %48 = icmp eq ptr %46, null
  %49 = select i1 %48, ptr %1, ptr %46
  store ptr %49, ptr %47, align 8, !tbaa !105
  %50 = tail call fastcc i32 @LoadInt(ptr noundef nonnull %0) #47
  %51 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 16
  store i32 %50, ptr %51, align 8, !tbaa !106
  %52 = tail call fastcc i32 @LoadInt(ptr noundef nonnull %0) #47
  %53 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 17
  store i32 %52, ptr %53, align 4, !tbaa !107
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %9) #48
  call fastcc void @LoadBlock(ptr noundef nonnull %0, ptr noundef nonnull %9, i64 noundef 1) #47
  %54 = load i8, ptr %9, align 1, !tbaa !33
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %9) #48
  %55 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 19
  store i8 %54, ptr %55, align 8, !tbaa !118
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %8) #48
  call fastcc void @LoadBlock(ptr noundef nonnull %0, ptr noundef nonnull %8, i64 noundef 1) #47
  %56 = load i8, ptr %8, align 1, !tbaa !33
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %8) #48
  %57 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 20
  store i8 %56, ptr %57, align 1, !tbaa !116
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %7) #48
  call fastcc void @LoadBlock(ptr noundef nonnull %0, ptr noundef nonnull %7, i64 noundef 1) #47
  %58 = load i8, ptr %7, align 1, !tbaa !33
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %7) #48
  %59 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 21
  store i8 %58, ptr %59, align 2, !tbaa !117
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %6) #48
  call fastcc void @LoadBlock(ptr noundef nonnull %0, ptr noundef nonnull %6, i64 noundef 1) #47
  %60 = load i8, ptr %6, align 1, !tbaa !33
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %6) #48
  %61 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 22
  store i8 %60, ptr %61, align 1, !tbaa !79
  %62 = call fastcc i32 @LoadInt(ptr noundef nonnull %0) #47
  %63 = icmp sgt i32 %62, -2
  %64 = load ptr, ptr %0, align 8, !tbaa !353
  br i1 %63, label %65, label %69

65:                                               ; preds = %41
  %66 = sext i32 %62 to i64
  %67 = shl nsw i64 %66, 2
  %68 = call ptr @luaM_realloc_(ptr noundef %64, ptr noundef null, i64 noundef 0, i64 noundef %67) #46
  br label %73

69:                                               ; preds = %41
  %70 = call ptr @luaM_toobig(ptr noundef %64) #46
  %71 = sext i32 %62 to i64
  %72 = shl nsw i64 %71, 2
  br label %73

73:                                               ; preds = %69, %65
  %74 = phi i64 [ %72, %69 ], [ %67, %65 ]
  %75 = phi ptr [ %70, %69 ], [ %68, %65 ]
  %76 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 4
  store ptr %75, ptr %76, align 8, !tbaa !64
  %77 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 12
  store i32 %62, ptr %77, align 8, !tbaa !71
  call fastcc void @LoadBlock(ptr noundef nonnull %0, ptr noundef %75, i64 noundef %74) #47
  %78 = call fastcc i32 @LoadInt(ptr noundef nonnull %0) #47
  %79 = icmp sgt i32 %78, -2
  %80 = load ptr, ptr %0, align 8, !tbaa !353
  br i1 %79, label %85, label %81

81:                                               ; preds = %73
  %82 = call ptr @luaM_toobig(ptr noundef %80) #46
  %83 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 3
  store ptr %82, ptr %83, align 8, !tbaa !83
  %84 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 11
  store i32 %78, ptr %84, align 4, !tbaa !81
  br label %156

85:                                               ; preds = %73
  %86 = sext i32 %78 to i64
  %87 = shl nsw i64 %86, 4
  %88 = call ptr @luaM_realloc_(ptr noundef %80, ptr noundef null, i64 noundef 0, i64 noundef %87) #46
  %89 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 3
  store ptr %88, ptr %89, align 8, !tbaa !83
  %90 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 11
  store i32 %78, ptr %90, align 4, !tbaa !81
  %91 = icmp sgt i32 %78, 0
  br i1 %91, label %92, label %156

92:                                               ; preds = %85
  %93 = zext i32 %78 to i64
  %94 = add nuw nsw i64 %93, 3
  %95 = and i64 %94, 8589934588
  %96 = add nsw i64 %93, -1
  %97 = insertelement <4 x i64> poison, i64 %96, i64 0
  %98 = shufflevector <4 x i64> %97, <4 x i64> poison, <4 x i32> zeroinitializer
  br label %99

99:                                               ; preds = %121, %92
  %100 = phi i64 [ 0, %92 ], [ %122, %121 ]
  %101 = phi <4 x i64> [ <i64 0, i64 1, i64 2, i64 3>, %92 ], [ %123, %121 ]
  %102 = icmp ule <4 x i64> %101, %98
  %103 = extractelement <4 x i1> %102, i64 0
  br i1 %103, label %104, label %106

104:                                              ; preds = %99
  %105 = getelementptr inbounds %struct.lua_TValue, ptr %88, i64 %100, i32 1
  store i32 0, ptr %105, align 8, !tbaa !16
  br label %106

106:                                              ; preds = %104, %99
  %107 = extractelement <4 x i1> %102, i64 1
  br i1 %107, label %108, label %111

108:                                              ; preds = %106
  %109 = or i64 %100, 1
  %110 = getelementptr inbounds %struct.lua_TValue, ptr %88, i64 %109, i32 1
  store i32 0, ptr %110, align 8, !tbaa !16
  br label %111

111:                                              ; preds = %108, %106
  %112 = extractelement <4 x i1> %102, i64 2
  br i1 %112, label %113, label %116

113:                                              ; preds = %111
  %114 = or i64 %100, 2
  %115 = getelementptr inbounds %struct.lua_TValue, ptr %88, i64 %114, i32 1
  store i32 0, ptr %115, align 8, !tbaa !16
  br label %116

116:                                              ; preds = %113, %111
  %117 = extractelement <4 x i1> %102, i64 3
  br i1 %117, label %118, label %121

118:                                              ; preds = %116
  %119 = or i64 %100, 3
  %120 = getelementptr inbounds %struct.lua_TValue, ptr %88, i64 %119, i32 1
  store i32 0, ptr %120, align 8, !tbaa !16
  br label %121

121:                                              ; preds = %118, %116
  %122 = add i64 %100, 4
  %123 = add <4 x i64> %101, <i64 4, i64 4, i64 4, i64 4>
  %124 = icmp eq i64 %122, %95
  br i1 %124, label %125, label %99, !llvm.loop !356

125:                                              ; preds = %121
  br i1 %91, label %126, label %156

126:                                              ; preds = %125
  %127 = getelementptr inbounds %struct.LoadState, ptr %0, i64 0, i32 3
  %128 = zext i32 %78 to i64
  br label %129

129:                                              ; preds = %153, %126
  %130 = phi i64 [ 0, %126 ], [ %154, %153 ]
  %131 = load ptr, ptr %89, align 8, !tbaa !83
  %132 = getelementptr inbounds %struct.lua_TValue, ptr %131, i64 %130
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %3) #48
  call fastcc void @LoadBlock(ptr noundef %0, ptr noundef nonnull %3, i64 noundef 1) #47
  %133 = load i8, ptr %3, align 1, !tbaa !33
  %134 = sext i8 %133 to i32
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %3) #48
  switch i32 %134, label %148 [
    i32 0, label %135
    i32 1, label %137
    i32 3, label %142
    i32 4, label %145
  ]

135:                                              ; preds = %129
  %136 = getelementptr inbounds %struct.lua_TValue, ptr %131, i64 %130, i32 1
  store i32 0, ptr %136, align 8, !tbaa !16
  br label %153

137:                                              ; preds = %129
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %4) #48
  call fastcc void @LoadBlock(ptr noundef %0, ptr noundef nonnull %4, i64 noundef 1) #47
  %138 = load i8, ptr %4, align 1, !tbaa !33
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %4) #48
  %139 = icmp ne i8 %138, 0
  %140 = zext i1 %139 to i32
  store i32 %140, ptr %132, align 8, !tbaa !33
  %141 = getelementptr inbounds %struct.lua_TValue, ptr %131, i64 %130, i32 1
  store i32 1, ptr %141, align 8, !tbaa !16
  br label %153

142:                                              ; preds = %129
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5) #48
  call fastcc void @LoadBlock(ptr noundef %0, ptr noundef nonnull %5, i64 noundef 8) #47
  %143 = load double, ptr %5, align 8, !tbaa !90
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5) #48
  store double %143, ptr %132, align 8, !tbaa !33
  %144 = getelementptr inbounds %struct.lua_TValue, ptr %131, i64 %130, i32 1
  store i32 3, ptr %144, align 8, !tbaa !16
  br label %153

145:                                              ; preds = %129
  %146 = call fastcc ptr @LoadString(ptr noundef %0) #47
  store ptr %146, ptr %132, align 8, !tbaa !33
  %147 = getelementptr inbounds %struct.lua_TValue, ptr %131, i64 %130, i32 1
  store i32 4, ptr %147, align 8, !tbaa !16
  br label %153

148:                                              ; preds = %129
  %149 = load ptr, ptr %0, align 8, !tbaa !353
  %150 = load ptr, ptr %127, align 8, !tbaa !351
  %151 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %149, ptr noundef nonnull @.str.5.225, ptr noundef %150, ptr noundef nonnull @.str.9.229) #46
  %152 = load ptr, ptr %0, align 8, !tbaa !353
  call void @luaD_throw(ptr noundef %152, i32 noundef 3) #46
  br label %153

153:                                              ; preds = %148, %145, %142, %137, %135
  %154 = add nuw nsw i64 %130, 1
  %155 = icmp eq i64 %154, %128
  br i1 %155, label %156, label %129, !llvm.loop !359

156:                                              ; preds = %153, %125, %85, %81
  %157 = call fastcc i32 @LoadInt(ptr noundef %0) #47
  %158 = icmp sgt i32 %157, -2
  %159 = load ptr, ptr %0, align 8, !tbaa !353
  br i1 %158, label %164, label %160

160:                                              ; preds = %156
  %161 = call ptr @luaM_toobig(ptr noundef %159) #46
  %162 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 5
  store ptr %161, ptr %162, align 8, !tbaa !121
  %163 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 14
  store i32 %157, ptr %163, align 8, !tbaa !120
  br label %190

164:                                              ; preds = %156
  %165 = sext i32 %157 to i64
  %166 = shl nsw i64 %165, 3
  %167 = call ptr @luaM_realloc_(ptr noundef %159, ptr noundef null, i64 noundef 0, i64 noundef %166) #46
  %168 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 5
  store ptr %167, ptr %168, align 8, !tbaa !121
  %169 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 14
  store i32 %157, ptr %169, align 8, !tbaa !120
  %170 = icmp sgt i32 %157, 0
  br i1 %170, label %171, label %190

171:                                              ; preds = %164
  %172 = zext i32 %157 to i64
  br label %176

173:                                              ; preds = %176
  br i1 %170, label %174, label %190

174:                                              ; preds = %173
  %175 = zext i32 %157 to i64
  br label %182

176:                                              ; preds = %176, %171
  %177 = phi i64 [ 0, %171 ], [ %180, %176 ]
  %178 = load ptr, ptr %168, align 8, !tbaa !121
  %179 = getelementptr inbounds ptr, ptr %178, i64 %177
  store ptr null, ptr %179, align 8, !tbaa !39
  %180 = add nuw nsw i64 %177, 1
  %181 = icmp eq i64 %180, %172
  br i1 %181, label %173, label %176, !llvm.loop !360

182:                                              ; preds = %182, %174
  %183 = phi i64 [ 0, %174 ], [ %188, %182 ]
  %184 = load ptr, ptr %47, align 8, !tbaa !105
  %185 = call fastcc ptr @LoadFunction(ptr noundef %0, ptr noundef %184) #47
  %186 = load ptr, ptr %168, align 8, !tbaa !121
  %187 = getelementptr inbounds ptr, ptr %186, i64 %183
  store ptr %185, ptr %187, align 8, !tbaa !39
  %188 = add nuw nsw i64 %183, 1
  %189 = icmp eq i64 %188, %175
  br i1 %189, label %190, label %182, !llvm.loop !361

190:                                              ; preds = %182, %173, %164, %160
  %191 = call fastcc i32 @LoadInt(ptr noundef %0) #47
  %192 = icmp sgt i32 %191, -2
  %193 = load ptr, ptr %0, align 8, !tbaa !353
  br i1 %192, label %194, label %198

194:                                              ; preds = %190
  %195 = sext i32 %191 to i64
  %196 = shl nsw i64 %195, 2
  %197 = call ptr @luaM_realloc_(ptr noundef %193, ptr noundef null, i64 noundef 0, i64 noundef %196) #46
  br label %202

198:                                              ; preds = %190
  %199 = call ptr @luaM_toobig(ptr noundef %193) #46
  %200 = sext i32 %191 to i64
  %201 = shl nsw i64 %200, 2
  br label %202

202:                                              ; preds = %198, %194
  %203 = phi i64 [ %201, %198 ], [ %196, %194 ]
  %204 = phi ptr [ %199, %198 ], [ %197, %194 ]
  %205 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 6
  store ptr %204, ptr %205, align 8, !tbaa !74
  %206 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 13
  store i32 %191, ptr %206, align 4, !tbaa !73
  call fastcc void @LoadBlock(ptr noundef nonnull %0, ptr noundef %204, i64 noundef %203) #47
  %207 = call fastcc i32 @LoadInt(ptr noundef nonnull %0) #47
  %208 = icmp sgt i32 %207, -2
  %209 = load ptr, ptr %0, align 8, !tbaa !353
  br i1 %208, label %214, label %210

210:                                              ; preds = %202
  %211 = call ptr @luaM_toobig(ptr noundef %209) #46
  %212 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 7
  store ptr %211, ptr %212, align 8, !tbaa !167
  %213 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 15
  store i32 %207, ptr %213, align 4, !tbaa !166
  br label %257

214:                                              ; preds = %202
  %215 = sext i32 %207 to i64
  %216 = shl nsw i64 %215, 4
  %217 = call ptr @luaM_realloc_(ptr noundef %209, ptr noundef null, i64 noundef 0, i64 noundef %216) #46
  %218 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 7
  store ptr %217, ptr %218, align 8, !tbaa !167
  %219 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 15
  store i32 %207, ptr %219, align 4, !tbaa !166
  %220 = icmp sgt i32 %207, 0
  br i1 %220, label %221, label %257

221:                                              ; preds = %214
  %222 = zext i32 %207 to i64
  %223 = add nuw nsw i64 %222, 1
  %224 = and i64 %223, 8589934590
  %225 = add nsw i64 %222, -1
  %226 = insertelement <2 x i64> poison, i64 %225, i64 0
  %227 = shufflevector <2 x i64> %226, <2 x i64> poison, <2 x i32> zeroinitializer
  br label %228

228:                                              ; preds = %240, %221
  %229 = phi i64 [ 0, %221 ], [ %241, %240 ]
  %230 = phi <2 x i64> [ <i64 0, i64 1>, %221 ], [ %242, %240 ]
  %231 = icmp ule <2 x i64> %230, %227
  %232 = extractelement <2 x i1> %231, i64 0
  br i1 %232, label %233, label %235

233:                                              ; preds = %228
  %234 = getelementptr inbounds %struct.stringtable, ptr %217, i64 %229
  store ptr null, ptr %234, align 8, !tbaa !168
  br label %235

235:                                              ; preds = %233, %228
  %236 = extractelement <2 x i1> %231, i64 1
  br i1 %236, label %237, label %240

237:                                              ; preds = %235
  %238 = or i64 %229, 1
  %239 = getelementptr inbounds %struct.stringtable, ptr %217, i64 %238
  store ptr null, ptr %239, align 8, !tbaa !168
  br label %240

240:                                              ; preds = %237, %235
  %241 = add i64 %229, 2
  %242 = add <2 x i64> %230, <i64 2, i64 2>
  %243 = icmp eq i64 %241, %224
  br i1 %243, label %244, label %228, !llvm.loop !362

244:                                              ; preds = %244, %240
  %245 = phi i64 [ %255, %244 ], [ 0, %240 ]
  %246 = call fastcc ptr @LoadString(ptr noundef nonnull %0) #47
  %247 = load ptr, ptr %218, align 8, !tbaa !167
  %248 = getelementptr inbounds %struct.stringtable, ptr %247, i64 %245
  store ptr %246, ptr %248, align 8, !tbaa !168
  %249 = call fastcc i32 @LoadInt(ptr noundef nonnull %0) #47
  %250 = load ptr, ptr %218, align 8, !tbaa !167
  %251 = getelementptr inbounds %struct.stringtable, ptr %250, i64 %245, i32 1
  store i32 %249, ptr %251, align 8, !tbaa !170
  %252 = call fastcc i32 @LoadInt(ptr noundef nonnull %0) #47
  %253 = load ptr, ptr %218, align 8, !tbaa !167
  %254 = getelementptr inbounds %struct.stringtable, ptr %253, i64 %245, i32 2
  store i32 %252, ptr %254, align 4, !tbaa !171
  %255 = add nuw nsw i64 %245, 1
  %256 = icmp eq i64 %255, %222
  br i1 %256, label %257, label %244, !llvm.loop !363

257:                                              ; preds = %244, %214, %210
  %258 = call fastcc i32 @LoadInt(ptr noundef nonnull %0) #47
  %259 = icmp sgt i32 %258, -2
  %260 = load ptr, ptr %0, align 8, !tbaa !353
  br i1 %259, label %265, label %261

261:                                              ; preds = %257
  %262 = call ptr @luaM_toobig(ptr noundef %260) #46
  %263 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 8
  store ptr %262, ptr %263, align 8, !tbaa !58
  %264 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 10
  store i32 %258, ptr %264, align 8, !tbaa !55
  br label %287

265:                                              ; preds = %257
  %266 = sext i32 %258 to i64
  %267 = shl nsw i64 %266, 3
  %268 = call ptr @luaM_realloc_(ptr noundef %260, ptr noundef null, i64 noundef 0, i64 noundef %267) #46
  %269 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 8
  store ptr %268, ptr %269, align 8, !tbaa !58
  %270 = getelementptr inbounds %struct.Proto, ptr %23, i64 0, i32 10
  store i32 %258, ptr %270, align 8, !tbaa !55
  %271 = icmp sgt i32 %258, 0
  br i1 %271, label %272, label %287

272:                                              ; preds = %265
  %273 = zext i32 %258 to i64
  br label %274

274:                                              ; preds = %274, %272
  %275 = phi i64 [ 0, %272 ], [ %278, %274 ]
  %276 = load ptr, ptr %269, align 8, !tbaa !58
  %277 = getelementptr inbounds ptr, ptr %276, i64 %275
  store ptr null, ptr %277, align 8, !tbaa !39
  %278 = add nuw nsw i64 %275, 1
  %279 = icmp eq i64 %278, %273
  br i1 %279, label %280, label %274, !llvm.loop !364

280:                                              ; preds = %280, %274
  %281 = phi i64 [ %285, %280 ], [ 0, %274 ]
  %282 = call fastcc ptr @LoadString(ptr noundef nonnull %0) #47
  %283 = load ptr, ptr %269, align 8, !tbaa !58
  %284 = getelementptr inbounds ptr, ptr %283, i64 %281
  store ptr %282, ptr %284, align 8, !tbaa !39
  %285 = add nuw nsw i64 %281, 1
  %286 = icmp eq i64 %285, %273
  br i1 %286, label %287, label %280, !llvm.loop !365

287:                                              ; preds = %280, %265, %261
  %288 = call i32 @luaG_checkcode(ptr noundef nonnull %23) #46
  %289 = icmp eq i32 %288, 0
  br i1 %289, label %290, label %296

290:                                              ; preds = %287
  %291 = load ptr, ptr %0, align 8, !tbaa !353
  %292 = getelementptr inbounds %struct.LoadState, ptr %0, i64 0, i32 3
  %293 = load ptr, ptr %292, align 8, !tbaa !351
  %294 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %291, ptr noundef nonnull @.str.5.225, ptr noundef %293, ptr noundef nonnull @.str.7.230) #46
  %295 = load ptr, ptr %0, align 8, !tbaa !353
  call void @luaD_throw(ptr noundef %295, i32 noundef 3) #46
  br label %296

296:                                              ; preds = %290, %287
  %297 = load ptr, ptr %0, align 8, !tbaa !353
  %298 = getelementptr inbounds %struct.lua_State, ptr %297, i64 0, i32 4
  %299 = load ptr, ptr %298, align 8, !tbaa !7
  %300 = getelementptr inbounds %struct.lua_TValue, ptr %299, i64 -1
  store ptr %300, ptr %298, align 8, !tbaa !7
  %301 = getelementptr inbounds %struct.lua_State, ptr %297, i64 0, i32 15
  %302 = load i16, ptr %301, align 8, !tbaa !24
  %303 = add i16 %302, -1
  store i16 %303, ptr %301, align 8, !tbaa !24
  ret ptr %23
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @LoadString(ptr nocapture noundef readonly %0) unnamed_addr #1 {
  %2 = alloca i64, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  call fastcc void @LoadBlock(ptr noundef %0, ptr noundef nonnull %2, i64 noundef 8) #47
  %3 = load i64, ptr %2, align 8, !tbaa !40
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %15, label %5

5:                                                ; preds = %1
  %6 = load ptr, ptr %0, align 8, !tbaa !353
  %7 = getelementptr inbounds %struct.LoadState, ptr %0, i64 0, i32 2
  %8 = load ptr, ptr %7, align 8, !tbaa !355
  %9 = call ptr @luaZ_openspace(ptr noundef %6, ptr noundef %8, i64 noundef %3) #46
  %10 = load i64, ptr %2, align 8, !tbaa !40
  call fastcc void @LoadBlock(ptr noundef nonnull %0, ptr noundef %9, i64 noundef %10) #47
  %11 = load ptr, ptr %0, align 8, !tbaa !353
  %12 = load i64, ptr %2, align 8, !tbaa !40
  %13 = add i64 %12, -1
  %14 = call ptr @luaS_newlstr(ptr noundef %11, ptr noundef %9, i64 noundef %13) #46
  br label %15

15:                                               ; preds = %5, %1
  %16 = phi ptr [ %14, %5 ], [ null, %1 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  ret ptr %16
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @LoadInt(ptr nocapture noundef readonly %0) unnamed_addr #1 {
  %2 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #48
  call fastcc void @LoadBlock(ptr noundef %0, ptr noundef nonnull %2, i64 noundef 4) #47
  %3 = load i32, ptr %2, align 4, !tbaa !65
  %4 = icmp slt i32 %3, 0
  br i1 %4, label %5, label %12

5:                                                ; preds = %1
  %6 = load ptr, ptr %0, align 8, !tbaa !353
  %7 = getelementptr inbounds %struct.LoadState, ptr %0, i64 0, i32 3
  %8 = load ptr, ptr %7, align 8, !tbaa !351
  %9 = call ptr (ptr, ptr, ...) @luaO_pushfstring(ptr noundef %6, ptr noundef nonnull @.str.5.225, ptr noundef %8, ptr noundef nonnull @.str.8.231) #46
  %10 = load ptr, ptr %0, align 8, !tbaa !353
  call void @luaD_throw(ptr noundef %10, i32 noundef 3) #46
  %11 = load i32, ptr %2, align 4, !tbaa !65
  br label %12

12:                                               ; preds = %5, %1
  %13 = phi i32 [ %11, %5 ], [ %3, %1 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #48
  ret i32 %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: write) uwtable
define internal void @luaU_header(ptr nocapture noundef writeonly %0) #17 {
  store i32 1635077147, ptr %0, align 1
  %2 = getelementptr inbounds i8, ptr %0, i64 4
  store <8 x i8> <i8 81, i8 0, i8 1, i8 4, i8 8, i8 4, i8 8, i8 0>, ptr %2, align 1, !tbaa !33
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaV_tonumber(ptr noundef readonly %0, ptr noundef writeonly %1) #1 {
  %3 = alloca double, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #48
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %0, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  switch i32 %5, label %14 [
    i32 3, label %15
    i32 4, label %6
  ]

6:                                                ; preds = %2
  %7 = load ptr, ptr %0, align 8, !tbaa !33
  %8 = getelementptr inbounds %union.TString, ptr %7, i64 1
  %9 = call i32 @luaO_str2d(ptr noundef nonnull %8, ptr noundef nonnull %3) #46
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %14, label %11

11:                                               ; preds = %6
  %12 = load double, ptr %3, align 8, !tbaa !90
  store double %12, ptr %1, align 8, !tbaa !33
  %13 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 3, ptr %13, align 8, !tbaa !16
  br label %15

14:                                               ; preds = %6, %2
  br label %15

15:                                               ; preds = %14, %11, %2
  %16 = phi ptr [ %1, %11 ], [ null, %14 ], [ %0, %2 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #48
  ret ptr %16
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaV_tostring(ptr noundef %0, ptr nocapture noundef %1) #1 {
  %3 = alloca [32 x i8], align 16
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  %6 = icmp eq i32 %5, 3
  br i1 %6, label %7, label %12

7:                                                ; preds = %2
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %3) #48
  %8 = load double, ptr %1, align 8, !tbaa !33
  %9 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %3, ptr noundef nonnull dereferenceable(1) @.str.239, double noundef %8) #46
  %10 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %3) #49
  %11 = call ptr @luaS_newlstr(ptr noundef %0, ptr noundef nonnull %3, i64 noundef %10) #46
  store ptr %11, ptr %1, align 8, !tbaa !33
  store i32 4, ptr %4, align 8, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %3) #48
  br label %12

12:                                               ; preds = %7, %2
  %13 = phi i32 [ 1, %7 ], [ 0, %2 ]
  ret i32 %13
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaV_gettable(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3) #1 {
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %6 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  %7 = load i32, ptr %6, align 8, !tbaa !16
  br label %11

8:                                                ; preds = %48
  %9 = add nuw nsw i32 %14, 1
  %10 = icmp eq i32 %9, 100
  br i1 %10, label %54, label %11, !llvm.loop !366

11:                                               ; preds = %8, %4
  %12 = phi i32 [ %7, %4 ], [ %51, %8 ]
  %13 = phi ptr [ %1, %4 ], [ %49, %8 ]
  %14 = phi i32 [ 0, %4 ], [ %9, %8 ]
  %15 = icmp eq i32 %12, 5
  br i1 %15, label %16, label %42

16:                                               ; preds = %11
  %17 = load ptr, ptr %13, align 8, !tbaa !33
  %18 = tail call ptr @luaH_get(ptr noundef %17, ptr noundef %2) #46
  %19 = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 0, i32 1
  %20 = load i32, ptr %19, align 8, !tbaa !16
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %22, label %37

22:                                               ; preds = %16
  %23 = getelementptr inbounds %struct.Table, ptr %17, i64 0, i32 5
  %24 = load ptr, ptr %23, align 8, !tbaa !221
  %25 = icmp eq ptr %24, null
  br i1 %25, label %37, label %26

26:                                               ; preds = %22
  %27 = getelementptr inbounds %struct.Table, ptr %24, i64 0, i32 3
  %28 = load i8, ptr %27, align 2, !tbaa !182
  %29 = and i8 %28, 1
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %31, label %37

31:                                               ; preds = %26
  %32 = load ptr, ptr %5, align 8, !tbaa !25
  %33 = getelementptr inbounds %struct.global_State, ptr %32, i64 0, i32 24
  %34 = load ptr, ptr %33, align 8, !tbaa !39
  %35 = tail call ptr @luaT_gettm(ptr noundef nonnull %24, i32 noundef 0, ptr noundef %34) #46
  %36 = icmp eq ptr %35, null
  br i1 %36, label %37, label %48

37:                                               ; preds = %31, %26, %22, %16
  %.lcssa = phi ptr [ %18, %31 ], [ %18, %26 ], [ %18, %22 ], [ %18, %16 ]
  %38 = getelementptr inbounds %struct.lua_TValue, ptr %.lcssa, i64 0, i32 1
  %39 = load i64, ptr %.lcssa, align 8
  store i64 %39, ptr %3, align 8
  %40 = load i32, ptr %38, align 8, !tbaa !16
  %41 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  store i32 %40, ptr %41, align 8, !tbaa !16
  br label %55

42:                                               ; preds = %11
  %43 = tail call ptr @luaT_gettmbyobj(ptr noundef %0, ptr noundef nonnull %13, i32 noundef 0) #46
  %44 = getelementptr inbounds %struct.lua_TValue, ptr %43, i64 0, i32 1
  %45 = load i32, ptr %44, align 8, !tbaa !16
  %46 = icmp eq i32 %45, 0
  br i1 %46, label %47, label %48

47:                                               ; preds = %42
  tail call void @luaG_typeerror(ptr noundef %0, ptr noundef nonnull %13, ptr noundef nonnull @.str.1.242) #46
  br label %48

48:                                               ; preds = %47, %42, %31
  %49 = phi ptr [ %43, %47 ], [ %43, %42 ], [ %35, %31 ]
  %50 = getelementptr inbounds %struct.lua_TValue, ptr %49, i64 0, i32 1
  %51 = load i32, ptr %50, align 8, !tbaa !16
  %52 = icmp eq i32 %51, 6
  br i1 %52, label %53, label %8

53:                                               ; preds = %48
  %.lcssa4 = phi ptr [ %49, %48 ]
  %.lcssa2 = phi ptr [ %13, %48 ]
  tail call fastcc void @callTMres(ptr noundef %0, ptr noundef %3, ptr noundef nonnull %.lcssa4, ptr noundef nonnull %.lcssa2, ptr noundef %2) #47
  br label %55

54:                                               ; preds = %8
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %0, ptr noundef nonnull @.str.2.243) #46
  br label %55

55:                                               ; preds = %54, %53, %37
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @callTMres(ptr noundef %0, ptr noundef %1, ptr nocapture noundef readonly %2, ptr nocapture noundef readonly %3, ptr nocapture noundef readonly %4) unnamed_addr #1 {
  %6 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 10
  %7 = load ptr, ptr %6, align 8, !tbaa !43
  %8 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %9 = load ptr, ptr %8, align 8, !tbaa !7
  %10 = load i64, ptr %2, align 8
  store i64 %10, ptr %9, align 8
  %11 = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  %12 = load i32, ptr %11, align 8, !tbaa !16
  %13 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 0, i32 1
  store i32 %12, ptr %13, align 8, !tbaa !16
  %14 = load ptr, ptr %8, align 8, !tbaa !7
  %15 = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 1
  %16 = load i64, ptr %3, align 8
  store i64 %16, ptr %15, align 8
  %17 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %18 = load i32, ptr %17, align 8, !tbaa !16
  %19 = getelementptr inbounds %struct.lua_TValue, ptr %14, i64 1, i32 1
  store i32 %18, ptr %19, align 8, !tbaa !16
  %20 = load ptr, ptr %8, align 8, !tbaa !7
  %21 = getelementptr inbounds %struct.lua_TValue, ptr %20, i64 2
  %22 = load i64, ptr %4, align 8
  store i64 %22, ptr %21, align 8
  %23 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  %24 = load i32, ptr %23, align 8, !tbaa !16
  %25 = getelementptr inbounds %struct.lua_TValue, ptr %20, i64 2, i32 1
  store i32 %24, ptr %25, align 8, !tbaa !16
  %26 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %27 = load ptr, ptr %26, align 8, !tbaa !18
  %28 = load ptr, ptr %8, align 8, !tbaa !7
  %29 = ptrtoint ptr %27 to i64
  %30 = ptrtoint ptr %28 to i64
  %31 = sub i64 %29, %30
  %32 = icmp slt i64 %31, 49
  br i1 %32, label %33, label %35

33:                                               ; preds = %5
  tail call void @luaD_growstack(ptr noundef nonnull %0, i32 noundef 3) #46
  %34 = load ptr, ptr %8, align 8, !tbaa !7
  br label %35

35:                                               ; preds = %33, %5
  %36 = phi ptr [ %28, %5 ], [ %34, %33 ]
  %37 = ptrtoint ptr %1 to i64
  %38 = ptrtoint ptr %7 to i64
  %39 = sub i64 %37, %38
  %40 = getelementptr inbounds %struct.lua_TValue, ptr %36, i64 3
  store ptr %40, ptr %8, align 8, !tbaa !7
  tail call void @luaD_call(ptr noundef nonnull %0, ptr noundef %36, i32 noundef 1) #46
  %41 = load ptr, ptr %6, align 8, !tbaa !43
  %42 = getelementptr inbounds i8, ptr %41, i64 %39
  %43 = load ptr, ptr %8, align 8, !tbaa !7
  %44 = getelementptr inbounds %struct.lua_TValue, ptr %43, i64 -1
  store ptr %44, ptr %8, align 8, !tbaa !7
  %45 = load i64, ptr %44, align 8
  store i64 %45, ptr %42, align 8
  %46 = getelementptr %struct.lua_TValue, ptr %43, i64 -1, i32 1
  %47 = load i32, ptr %46, align 8, !tbaa !16
  %48 = getelementptr inbounds %struct.lua_TValue, ptr %42, i64 0, i32 1
  store i32 %47, ptr %48, align 8, !tbaa !16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaV_settable(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr nocapture noundef readonly %3) #1 {
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %6 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  %7 = load i32, ptr %6, align 8, !tbaa !16
  br label %11

8:                                                ; preds = %62
  %9 = add nuw nsw i32 %14, 1
  %10 = icmp eq i32 %9, 100
  br i1 %10, label %104, label %11, !llvm.loop !367

11:                                               ; preds = %8, %4
  %12 = phi i32 [ %7, %4 ], [ %65, %8 ]
  %13 = phi ptr [ %1, %4 ], [ %63, %8 ]
  %14 = phi i32 [ 0, %4 ], [ %9, %8 ]
  %15 = icmp eq i32 %12, 5
  br i1 %15, label %16, label %56

16:                                               ; preds = %11
  %17 = load ptr, ptr %13, align 8, !tbaa !33
  %18 = tail call ptr @luaH_set(ptr noundef %0, ptr noundef %17, ptr noundef %2) #46
  %19 = getelementptr inbounds %struct.lua_TValue, ptr %18, i64 0, i32 1
  %20 = load i32, ptr %19, align 8, !tbaa !16
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %22, label %37

22:                                               ; preds = %16
  %23 = getelementptr inbounds %struct.Table, ptr %17, i64 0, i32 5
  %24 = load ptr, ptr %23, align 8, !tbaa !221
  %25 = icmp eq ptr %24, null
  br i1 %25, label %37, label %26

26:                                               ; preds = %22
  %27 = getelementptr inbounds %struct.Table, ptr %24, i64 0, i32 3
  %28 = load i8, ptr %27, align 2, !tbaa !182
  %29 = and i8 %28, 2
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %31, label %37

31:                                               ; preds = %26
  %32 = load ptr, ptr %5, align 8, !tbaa !25
  %33 = getelementptr inbounds %struct.global_State, ptr %32, i64 0, i32 24, i64 1
  %34 = load ptr, ptr %33, align 8, !tbaa !39
  %35 = tail call ptr @luaT_gettm(ptr noundef nonnull %24, i32 noundef 1, ptr noundef %34) #46
  %36 = icmp eq ptr %35, null
  br i1 %36, label %37, label %62

37:                                               ; preds = %31, %26, %22, %16
  %.lcssa1 = phi ptr [ %17, %31 ], [ %17, %26 ], [ %17, %22 ], [ %17, %16 ]
  %.lcssa = phi ptr [ %18, %31 ], [ %18, %26 ], [ %18, %22 ], [ %18, %16 ]
  %38 = getelementptr inbounds %struct.lua_TValue, ptr %.lcssa, i64 0, i32 1
  %39 = load i64, ptr %3, align 8
  store i64 %39, ptr %.lcssa, align 8
  %40 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %41 = load i32, ptr %40, align 8, !tbaa !16
  store i32 %41, ptr %38, align 8, !tbaa !16
  %42 = load i32, ptr %40, align 8, !tbaa !16
  %43 = icmp sgt i32 %42, 3
  br i1 %43, label %44, label %105

44:                                               ; preds = %37
  %45 = load ptr, ptr %3, align 8, !tbaa !33
  %46 = getelementptr inbounds %struct.GCheader, ptr %45, i64 0, i32 2
  %47 = load i8, ptr %46, align 1, !tbaa !33
  %48 = and i8 %47, 3
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %105, label %50

50:                                               ; preds = %44
  %51 = getelementptr inbounds %struct.GCheader, ptr %.lcssa1, i64 0, i32 2
  %52 = load i8, ptr %51, align 1, !tbaa !33
  %53 = and i8 %52, 4
  %54 = icmp eq i8 %53, 0
  br i1 %54, label %105, label %55

55:                                               ; preds = %50
  tail call void @luaC_barrierback(ptr noundef %0, ptr noundef nonnull %.lcssa1) #46
  br label %105

56:                                               ; preds = %11
  %57 = tail call ptr @luaT_gettmbyobj(ptr noundef %0, ptr noundef nonnull %13, i32 noundef 1) #46
  %58 = getelementptr inbounds %struct.lua_TValue, ptr %57, i64 0, i32 1
  %59 = load i32, ptr %58, align 8, !tbaa !16
  %60 = icmp eq i32 %59, 0
  br i1 %60, label %61, label %62

61:                                               ; preds = %56
  tail call void @luaG_typeerror(ptr noundef %0, ptr noundef nonnull %13, ptr noundef nonnull @.str.1.242) #46
  br label %62

62:                                               ; preds = %61, %56, %31
  %63 = phi ptr [ %57, %61 ], [ %57, %56 ], [ %35, %31 ]
  %64 = getelementptr inbounds %struct.lua_TValue, ptr %63, i64 0, i32 1
  %65 = load i32, ptr %64, align 8, !tbaa !16
  %66 = icmp eq i32 %65, 6
  br i1 %66, label %67, label %8

67:                                               ; preds = %62
  %.lcssa5 = phi ptr [ %63, %62 ]
  %.lcssa3 = phi ptr [ %13, %62 ]
  %68 = getelementptr inbounds %struct.lua_TValue, ptr %.lcssa3, i64 0, i32 1
  %69 = getelementptr inbounds %struct.lua_TValue, ptr %.lcssa5, i64 0, i32 1
  %70 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %71 = load ptr, ptr %70, align 8, !tbaa !7
  %72 = load i64, ptr %.lcssa5, align 8
  store i64 %72, ptr %71, align 8
  %73 = load i32, ptr %69, align 8, !tbaa !16
  %74 = getelementptr inbounds %struct.lua_TValue, ptr %71, i64 0, i32 1
  store i32 %73, ptr %74, align 8, !tbaa !16
  %75 = load ptr, ptr %70, align 8, !tbaa !7
  %76 = getelementptr inbounds %struct.lua_TValue, ptr %75, i64 1
  %77 = load i64, ptr %.lcssa3, align 8
  store i64 %77, ptr %76, align 8
  %78 = load i32, ptr %68, align 8, !tbaa !16
  %79 = getelementptr inbounds %struct.lua_TValue, ptr %75, i64 1, i32 1
  store i32 %78, ptr %79, align 8, !tbaa !16
  %80 = load ptr, ptr %70, align 8, !tbaa !7
  %81 = getelementptr inbounds %struct.lua_TValue, ptr %80, i64 2
  %82 = load i64, ptr %2, align 8
  store i64 %82, ptr %81, align 8
  %83 = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  %84 = load i32, ptr %83, align 8, !tbaa !16
  %85 = getelementptr inbounds %struct.lua_TValue, ptr %80, i64 2, i32 1
  store i32 %84, ptr %85, align 8, !tbaa !16
  %86 = load ptr, ptr %70, align 8, !tbaa !7
  %87 = getelementptr inbounds %struct.lua_TValue, ptr %86, i64 3
  %88 = load i64, ptr %3, align 8
  store i64 %88, ptr %87, align 8
  %89 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  %90 = load i32, ptr %89, align 8, !tbaa !16
  %91 = getelementptr inbounds %struct.lua_TValue, ptr %86, i64 3, i32 1
  store i32 %90, ptr %91, align 8, !tbaa !16
  %92 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %93 = load ptr, ptr %92, align 8, !tbaa !18
  %94 = load ptr, ptr %70, align 8, !tbaa !7
  %95 = ptrtoint ptr %93 to i64
  %96 = ptrtoint ptr %94 to i64
  %97 = sub i64 %95, %96
  %98 = icmp slt i64 %97, 65
  br i1 %98, label %99, label %101

99:                                               ; preds = %67
  tail call void @luaD_growstack(ptr noundef nonnull %0, i32 noundef 4) #46
  %100 = load ptr, ptr %70, align 8, !tbaa !7
  br label %101

101:                                              ; preds = %99, %67
  %102 = phi ptr [ %94, %67 ], [ %100, %99 ]
  %103 = getelementptr inbounds %struct.lua_TValue, ptr %102, i64 4
  store ptr %103, ptr %70, align 8, !tbaa !7
  tail call void @luaD_call(ptr noundef nonnull %0, ptr noundef %102, i32 noundef 0) #46
  br label %105

104:                                              ; preds = %8
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %0, ptr noundef nonnull @.str.3.246) #46
  br label %105

105:                                              ; preds = %104, %101, %55, %50, %44, %37
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaV_lessthan(ptr noundef %0, ptr noundef %1, ptr noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  %6 = getelementptr inbounds %struct.lua_TValue, ptr %2, i64 0, i32 1
  %7 = load i32, ptr %6, align 8, !tbaa !16
  %8 = icmp eq i32 %5, %7
  br i1 %8, label %11, label %9

9:                                                ; preds = %3
  %10 = tail call i32 @luaG_ordererror(ptr noundef %0, ptr noundef nonnull %1, ptr noundef nonnull %2) #46
  br label %27

11:                                               ; preds = %3
  switch i32 %5, label %22 [
    i32 3, label %12
    i32 4, label %17
  ]

12:                                               ; preds = %11
  %13 = load double, ptr %1, align 8, !tbaa !33
  %14 = load double, ptr %2, align 8, !tbaa !33
  %15 = fcmp olt double %13, %14
  %16 = zext i1 %15 to i32
  br label %27

17:                                               ; preds = %11
  %18 = load ptr, ptr %1, align 8, !tbaa !33
  %19 = load ptr, ptr %2, align 8, !tbaa !33
  %20 = tail call fastcc i32 @l_strcmp(ptr noundef %18, ptr noundef %19) #47
  %21 = lshr i32 %20, 31
  br label %27

22:                                               ; preds = %11
  %23 = tail call fastcc i32 @call_orderTM(ptr noundef %0, ptr noundef nonnull %1, ptr noundef nonnull %2, i32 noundef 13) #47, !range !368
  %24 = icmp eq i32 %23, -1
  br i1 %24, label %25, label %27

25:                                               ; preds = %22
  %26 = tail call i32 @luaG_ordererror(ptr noundef %0, ptr noundef nonnull %1, ptr noundef nonnull %2) #46
  br label %27

27:                                               ; preds = %25, %22, %17, %12, %9
  %28 = phi i32 [ %10, %9 ], [ %16, %12 ], [ %21, %17 ], [ %26, %25 ], [ %23, %22 ]
  ret i32 %28
}

; Function Attrs: nofree nounwind optsize memory(read) uwtable
define internal fastcc i32 @l_strcmp(ptr nocapture noundef readonly %0, ptr nocapture noundef readonly %1) unnamed_addr #36 {
  %3 = getelementptr inbounds %union.TString, ptr %0, i64 1
  %4 = getelementptr inbounds %struct.anon.0, ptr %0, i64 0, i32 5
  %5 = load i64, ptr %4, align 8, !tbaa !33
  %6 = getelementptr inbounds %union.TString, ptr %1, i64 1
  %7 = getelementptr inbounds %struct.anon.0, ptr %1, i64 0, i32 5
  %8 = load i64, ptr %7, align 8, !tbaa !33
  br label %9

9:                                                ; preds = %24, %2
  %10 = phi ptr [ %3, %2 ], [ %26, %24 ]
  %11 = phi i64 [ %5, %2 ], [ %27, %24 ]
  %12 = phi ptr [ %6, %2 ], [ %28, %24 ]
  %13 = phi i64 [ %8, %2 ], [ %29, %24 ]
  %14 = tail call i32 @strcoll(ptr noundef %10, ptr noundef %12) #49
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %30

16:                                               ; preds = %9
  %17 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %10) #49
  %18 = icmp eq i64 %17, %13
  br i1 %18, label %19, label %22

19:                                               ; preds = %16
  %.lcssa3 = phi i64 [ %11, %16 ]
  %.lcssa1 = phi i64 [ %13, %16 ]
  %20 = icmp ne i64 %.lcssa1, %.lcssa3
  %21 = zext i1 %20 to i32
  br label %30

22:                                               ; preds = %16
  %23 = icmp eq i64 %17, %11
  br i1 %23, label %30, label %24

24:                                               ; preds = %22
  %25 = add i64 %17, 1
  %26 = getelementptr inbounds i8, ptr %10, i64 %25
  %27 = sub i64 %11, %25
  %28 = getelementptr inbounds i8, ptr %12, i64 %25
  %29 = sub i64 %13, %25
  br label %9

30:                                               ; preds = %22, %19, %9
  %31 = phi i32 [ %21, %19 ], [ %14, %9 ], [ -1, %22 ]
  ret i32 %31
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @call_orderTM(ptr noundef %0, ptr noundef %1, ptr noundef %2, i32 noundef %3) unnamed_addr #1 {
  %5 = tail call ptr @luaT_gettmbyobj(ptr noundef %0, ptr noundef %1, i32 noundef %3) #46
  %6 = getelementptr inbounds %struct.lua_TValue, ptr %5, i64 0, i32 1
  %7 = load i32, ptr %6, align 8, !tbaa !16
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %24, label %9

9:                                                ; preds = %4
  %10 = tail call ptr @luaT_gettmbyobj(ptr noundef %0, ptr noundef %2, i32 noundef %3) #46
  %11 = tail call i32 @luaO_rawequalObj(ptr noundef nonnull %5, ptr noundef %10) #46
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %24, label %13

13:                                               ; preds = %9
  %14 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %15 = load ptr, ptr %14, align 8, !tbaa !7
  tail call fastcc void @callTMres(ptr noundef %0, ptr noundef %15, ptr noundef nonnull %5, ptr noundef %1, ptr noundef %2) #47
  %16 = load ptr, ptr %14, align 8, !tbaa !7
  %17 = getelementptr inbounds %struct.lua_TValue, ptr %16, i64 0, i32 1
  %18 = load i32, ptr %17, align 8, !tbaa !16
  switch i32 %18, label %23 [
    i32 0, label %24
    i32 1, label %19
  ]

19:                                               ; preds = %13
  %20 = load i32, ptr %16, align 8, !tbaa !33
  %21 = icmp ne i32 %20, 0
  %22 = zext i1 %21 to i32
  br label %24

23:                                               ; preds = %13
  br label %24

24:                                               ; preds = %23, %19, %13, %9, %4
  %25 = phi i32 [ -1, %4 ], [ -1, %9 ], [ %18, %13 ], [ %22, %19 ], [ 1, %23 ]
  ret i32 %25
}

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(read)
declare i32 @strcoll(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #37

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaV_equalval(ptr noundef %0, ptr nocapture noundef readonly %1, ptr nocapture noundef readonly %2) #1 {
  %4 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  %5 = load i32, ptr %4, align 8, !tbaa !16
  switch i32 %5, label %32 [
    i32 0, label %53
    i32 3, label %6
    i32 1, label %10
    i32 2, label %14
    i32 7, label %18
    i32 5, label %25
  ]

6:                                                ; preds = %3
  %7 = load double, ptr %1, align 8, !tbaa !33
  %8 = load double, ptr %2, align 8, !tbaa !33
  %9 = fcmp oeq double %7, %8
  br label %53

10:                                               ; preds = %3
  %11 = load i32, ptr %1, align 8, !tbaa !33
  %12 = load i32, ptr %2, align 8, !tbaa !33
  %13 = icmp eq i32 %11, %12
  br label %53

14:                                               ; preds = %3
  %15 = load ptr, ptr %1, align 8, !tbaa !33
  %16 = load ptr, ptr %2, align 8, !tbaa !33
  %17 = icmp eq ptr %15, %16
  br label %53

18:                                               ; preds = %3
  %19 = load ptr, ptr %1, align 8, !tbaa !33
  %20 = load ptr, ptr %2, align 8, !tbaa !33
  %21 = icmp eq ptr %19, %20
  br i1 %21, label %53, label %22

22:                                               ; preds = %18
  %23 = getelementptr inbounds %struct.anon.1, ptr %19, i64 0, i32 3
  %24 = getelementptr inbounds %struct.anon.1, ptr %20, i64 0, i32 3
  br label %36

25:                                               ; preds = %3
  %26 = load ptr, ptr %1, align 8, !tbaa !33
  %27 = load ptr, ptr %2, align 8, !tbaa !33
  %28 = icmp eq ptr %26, %27
  br i1 %28, label %53, label %29

29:                                               ; preds = %25
  %30 = getelementptr inbounds %struct.Table, ptr %26, i64 0, i32 5
  %31 = getelementptr inbounds %struct.Table, ptr %27, i64 0, i32 5
  br label %36

32:                                               ; preds = %3
  %33 = load ptr, ptr %1, align 8, !tbaa !33
  %34 = load ptr, ptr %2, align 8, !tbaa !33
  %35 = icmp eq ptr %33, %34
  br label %53

36:                                               ; preds = %29, %22
  %37 = phi ptr [ %31, %29 ], [ %24, %22 ]
  %38 = phi ptr [ %30, %29 ], [ %23, %22 ]
  %39 = load ptr, ptr %38, align 8, !tbaa !33
  %40 = load ptr, ptr %37, align 8, !tbaa !33
  %41 = tail call fastcc ptr @get_compTM(ptr noundef %0, ptr noundef %39, ptr noundef %40) #47
  %42 = icmp eq ptr %41, null
  br i1 %42, label %53, label %43

43:                                               ; preds = %36
  %44 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %45 = load ptr, ptr %44, align 8, !tbaa !7
  tail call fastcc void @callTMres(ptr noundef %0, ptr noundef %45, ptr noundef nonnull %41, ptr noundef nonnull %1, ptr noundef nonnull %2) #47
  %46 = load ptr, ptr %44, align 8, !tbaa !7
  %47 = getelementptr inbounds %struct.lua_TValue, ptr %46, i64 0, i32 1
  %48 = load i32, ptr %47, align 8, !tbaa !16
  switch i32 %48, label %52 [
    i32 0, label %53
    i32 1, label %49
  ]

49:                                               ; preds = %43
  %50 = load i32, ptr %46, align 8, !tbaa !33
  %51 = icmp ne i32 %50, 0
  br label %53

52:                                               ; preds = %43
  br label %53

53:                                               ; preds = %52, %49, %43, %36, %32, %25, %18, %14, %10, %6, %3
  %54 = phi i1 [ %35, %32 ], [ %17, %14 ], [ %13, %10 ], [ %9, %6 ], [ true, %3 ], [ true, %18 ], [ true, %25 ], [ false, %36 ], [ false, %43 ], [ %51, %49 ], [ true, %52 ]
  %55 = zext i1 %54 to i32
  ret i32 %55
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @get_compTM(ptr nocapture noundef readonly %0, ptr noundef %1, ptr noundef %2) unnamed_addr #1 {
  %4 = icmp eq ptr %1, null
  br i1 %4, label %36, label %5

5:                                                ; preds = %3
  %6 = getelementptr inbounds %struct.Table, ptr %1, i64 0, i32 3
  %7 = load i8, ptr %6, align 2, !tbaa !182
  %8 = and i8 %7, 16
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %10, label %36

10:                                               ; preds = %5
  %11 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %12 = load ptr, ptr %11, align 8, !tbaa !25
  %13 = getelementptr inbounds %struct.global_State, ptr %12, i64 0, i32 24, i64 4
  %14 = load ptr, ptr %13, align 8, !tbaa !39
  %15 = tail call ptr @luaT_gettm(ptr noundef nonnull %1, i32 noundef 4, ptr noundef %14) #46
  %16 = icmp eq ptr %15, null
  br i1 %16, label %36, label %17

17:                                               ; preds = %10
  %18 = icmp eq ptr %1, %2
  br i1 %18, label %36, label %19

19:                                               ; preds = %17
  %20 = icmp eq ptr %2, null
  br i1 %20, label %36, label %21

21:                                               ; preds = %19
  %22 = getelementptr inbounds %struct.Table, ptr %2, i64 0, i32 3
  %23 = load i8, ptr %22, align 2, !tbaa !182
  %24 = and i8 %23, 16
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %26, label %36

26:                                               ; preds = %21
  %27 = load ptr, ptr %11, align 8, !tbaa !25
  %28 = getelementptr inbounds %struct.global_State, ptr %27, i64 0, i32 24, i64 4
  %29 = load ptr, ptr %28, align 8, !tbaa !39
  %30 = tail call ptr @luaT_gettm(ptr noundef nonnull %2, i32 noundef 4, ptr noundef %29) #46
  %31 = icmp eq ptr %30, null
  br i1 %31, label %36, label %32

32:                                               ; preds = %26
  %33 = tail call i32 @luaO_rawequalObj(ptr noundef nonnull %15, ptr noundef nonnull %30) #46
  %34 = icmp eq i32 %33, 0
  %35 = select i1 %34, ptr null, ptr %15
  br label %36

36:                                               ; preds = %32, %26, %21, %19, %17, %10, %5, %3
  %37 = phi ptr [ null, %10 ], [ %15, %17 ], [ null, %26 ], [ %35, %32 ], [ null, %3 ], [ null, %5 ], [ null, %19 ], [ null, %21 ]
  ret ptr %37
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaV_concat(ptr noundef %0, i32 noundef %1, i32 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  br label %6

6:                                                ; preds = %94, %3
  %7 = phi i32 [ %2, %3 ], [ %98, %94 ]
  %8 = phi i32 [ %1, %3 ], [ %97, %94 ]
  %9 = load ptr, ptr %4, align 8, !tbaa !17
  %10 = sext i32 %7 to i64
  %11 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 %10
  %12 = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 1
  %13 = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 -1
  %14 = getelementptr %struct.lua_TValue, ptr %11, i64 -1, i32 1
  %15 = load i32, ptr %14, align 8, !tbaa !16
  %16 = add i32 %15, -3
  %17 = icmp ult i32 %16, 2
  br i1 %17, label %18, label %25

18:                                               ; preds = %6
  %19 = getelementptr inbounds %struct.lua_TValue, ptr %9, i64 %10, i32 1
  %20 = load i32, ptr %19, align 8, !tbaa !16
  %21 = icmp eq i32 %20, 4
  br i1 %21, label %29, label %22

22:                                               ; preds = %18
  %23 = tail call i32 @luaV_tostring(ptr noundef nonnull %0, ptr noundef nonnull %11) #47, !range !75
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %25, label %29

25:                                               ; preds = %22, %6
  %26 = tail call fastcc i32 @call_binTM(ptr noundef nonnull %0, ptr noundef nonnull %13, ptr noundef nonnull %11, ptr noundef nonnull %13, i32 noundef 15) #47, !range !75
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %28, label %94

28:                                               ; preds = %25
  tail call void @luaG_concaterror(ptr noundef nonnull %0, ptr noundef nonnull %13, ptr noundef nonnull %11) #46
  br label %94

29:                                               ; preds = %22, %18
  %30 = load ptr, ptr %11, align 8, !tbaa !33
  %31 = getelementptr inbounds %struct.anon.0, ptr %30, i64 0, i32 5
  %32 = load i64, ptr %31, align 8, !tbaa !33
  %33 = icmp eq i64 %32, 0
  br i1 %33, label %38, label %34

34:                                               ; preds = %29
  %35 = icmp sgt i32 %8, 1
  br i1 %35, label %36, label %68

36:                                               ; preds = %34
  %37 = zext i32 %8 to i64
  br label %43

38:                                               ; preds = %29
  %39 = load i32, ptr %14, align 8, !tbaa !16
  %40 = icmp eq i32 %39, 4
  br i1 %40, label %94, label %41

41:                                               ; preds = %38
  %42 = tail call i32 @luaV_tostring(ptr noundef nonnull %0, ptr noundef nonnull %13) #47, !range !75
  br label %94

43:                                               ; preds = %62, %36
  %44 = phi i64 [ 1, %36 ], [ %64, %62 ]
  %45 = phi i64 [ %32, %36 ], [ %63, %62 ]
  %46 = sub nsw i64 0, %44
  %47 = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 %46
  %48 = getelementptr inbounds %struct.lua_TValue, ptr %47, i64 -1
  %49 = getelementptr %struct.lua_TValue, ptr %47, i64 -1, i32 1
  %50 = load i32, ptr %49, align 8, !tbaa !16
  %51 = icmp eq i32 %50, 4
  br i1 %51, label %55, label %52

52:                                               ; preds = %43
  %53 = tail call i32 @luaV_tostring(ptr noundef %0, ptr noundef nonnull %48) #47, !range !75
  %54 = icmp eq i32 %53, 0
  br i1 %54, label %66, label %55

55:                                               ; preds = %52, %43
  %56 = load ptr, ptr %48, align 8, !tbaa !33
  %57 = getelementptr inbounds %struct.anon.0, ptr %56, i64 0, i32 5
  %58 = load i64, ptr %57, align 8, !tbaa !33
  %59 = sub i64 -3, %45
  %60 = icmp ult i64 %58, %59
  br i1 %60, label %62, label %61

61:                                               ; preds = %55
  tail call void (ptr, ptr, ...) @luaG_runerror(ptr noundef %0, ptr noundef nonnull @.str.4.251) #46
  br label %62

62:                                               ; preds = %61, %55
  %63 = add i64 %58, %45
  %64 = add nuw nsw i64 %44, 1
  %65 = icmp eq i64 %64, %37
  br i1 %65, label %68, label %43, !llvm.loop !369

66:                                               ; preds = %52
  %.lcssa1 = phi i64 [ %44, %52 ]
  %.lcssa = phi i64 [ %45, %52 ]
  %67 = trunc i64 %.lcssa1 to i32
  br label %68

68:                                               ; preds = %66, %62, %34
  %69 = phi i64 [ %32, %34 ], [ %.lcssa, %66 ], [ %63, %62 ]
  %70 = phi i32 [ 1, %34 ], [ %67, %66 ], [ %8, %62 ]
  %71 = load ptr, ptr %5, align 8, !tbaa !25
  %72 = getelementptr inbounds %struct.global_State, ptr %71, i64 0, i32 12
  %73 = tail call ptr @luaZ_openspace(ptr noundef %0, ptr noundef nonnull %72, i64 noundef %69) #46
  %74 = zext i32 %70 to i64
  br label %75

75:                                               ; preds = %75, %68
  %76 = phi i64 [ %74, %68 ], [ %86, %75 ]
  %77 = phi i64 [ 0, %68 ], [ %85, %75 ]
  %78 = sub nsw i64 0, %76
  %79 = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 %78
  %80 = load ptr, ptr %79, align 8, !tbaa !33
  %81 = getelementptr inbounds %struct.anon.0, ptr %80, i64 0, i32 5
  %82 = load i64, ptr %81, align 8, !tbaa !33
  %83 = getelementptr inbounds i8, ptr %73, i64 %77
  %84 = getelementptr inbounds %union.TString, ptr %80, i64 1
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 1 %83, ptr nonnull align 1 %84, i64 %82, i1 false)
  %85 = add i64 %82, %77
  %86 = add nsw i64 %76, -1
  %87 = trunc i64 %76 to i32
  %88 = icmp sgt i32 %87, 1
  br i1 %88, label %75, label %89, !llvm.loop !370

89:                                               ; preds = %75
  %.lcssa2 = phi i64 [ %85, %75 ]
  %90 = sub nsw i64 0, %74
  %91 = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 %90
  %92 = tail call ptr @luaS_newlstr(ptr noundef %0, ptr noundef %73, i64 noundef %.lcssa2) #46
  store ptr %92, ptr %91, align 8, !tbaa !33
  %93 = getelementptr inbounds %struct.lua_TValue, ptr %12, i64 %90, i32 1
  store i32 4, ptr %93, align 8, !tbaa !16
  br label %94

94:                                               ; preds = %89, %41, %38, %28, %25
  %95 = phi i32 [ %70, %89 ], [ 2, %25 ], [ 2, %28 ], [ 2, %41 ], [ 2, %38 ]
  %96 = add nsw i32 %95, -1
  %97 = sub nsw i32 %8, %96
  %98 = sub nsw i32 %7, %96
  %99 = icmp sgt i32 %97, 1
  br i1 %99, label %6, label %100, !llvm.loop !371

100:                                              ; preds = %94
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @call_binTM(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, i32 noundef %4) unnamed_addr #1 {
  %6 = tail call ptr @luaT_gettmbyobj(ptr noundef %0, ptr noundef %1, i32 noundef %4) #46
  %7 = getelementptr inbounds %struct.lua_TValue, ptr %6, i64 0, i32 1
  %8 = load i32, ptr %7, align 8, !tbaa !16
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %15

10:                                               ; preds = %5
  %11 = tail call ptr @luaT_gettmbyobj(ptr noundef %0, ptr noundef %2, i32 noundef %4) #46
  %12 = getelementptr inbounds %struct.lua_TValue, ptr %11, i64 0, i32 1
  %13 = load i32, ptr %12, align 8, !tbaa !16
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %17, label %15

15:                                               ; preds = %10, %5
  %16 = phi ptr [ %11, %10 ], [ %6, %5 ]
  tail call fastcc void @callTMres(ptr noundef %0, ptr noundef %3, ptr noundef nonnull %16, ptr noundef %1, ptr noundef %2) #47
  br label %17

17:                                               ; preds = %15, %10
  %18 = phi i32 [ 1, %15 ], [ 0, %10 ]
  ret i32 %18
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaV_execute(ptr noundef %0, i32 noundef %1) #1 {
  %3 = alloca %struct.lua_TValue, align 8
  %4 = alloca %struct.lua_TValue, align 8
  %5 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 8
  %6 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 7
  %7 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 5
  %8 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 17
  %9 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 20
  %10 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 19
  %11 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 3
  %12 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 9
  %13 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 4
  %14 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 6
  %15 = getelementptr inbounds %struct.lua_State, ptr %0, i64 0, i32 24
  %16 = getelementptr inbounds %struct.lua_TValue, ptr %4, i64 0, i32 1
  %17 = getelementptr inbounds %struct.lua_TValue, ptr %3, i64 0, i32 1
  br label %18

18:                                               ; preds = %741, %2
  %19 = phi i32 [ %1, %2 ], [ %742, %741 ]
  br label %20

20:                                               ; preds = %793, %18
  %21 = load ptr, ptr %5, align 8, !tbaa !102
  %22 = load ptr, ptr %6, align 8, !tbaa !19
  %23 = getelementptr inbounds %struct.CallInfo, ptr %22, i64 0, i32 1
  %24 = load ptr, ptr %23, align 8, !tbaa !36
  %25 = load ptr, ptr %24, align 8, !tbaa !33
  %26 = load ptr, ptr %7, align 8, !tbaa !17
  %27 = getelementptr inbounds %struct.LClosure, ptr %25, i64 0, i32 7
  %28 = load ptr, ptr %27, align 8, !tbaa !141
  %29 = getelementptr inbounds %struct.Proto, ptr %28, i64 0, i32 3
  %30 = load ptr, ptr %29, align 8, !tbaa !83
  %31 = getelementptr inbounds %struct.LClosure, ptr %25, i64 0, i32 6
  br label %32

32:                                               ; preds = %1042, %20
  %33 = phi ptr [ %21, %20 ], [ %1043, %1042 ]
  %34 = phi ptr [ %26, %20 ], [ %1044, %1042 ]
  %35 = getelementptr inbounds i32, ptr %33, i64 1
  %36 = load i32, ptr %33, align 4, !tbaa !65
  %37 = load i8, ptr %8, align 4, !tbaa !95
  %38 = and i8 %37, 12
  %39 = icmp eq i8 %38, 0
  br i1 %39, label %108, label %40

40:                                               ; preds = %32
  %41 = load i32, ptr %9, align 4, !tbaa !94
  %42 = add nsw i32 %41, -1
  store i32 %42, ptr %9, align 4, !tbaa !94
  %43 = icmp eq i32 %42, 0
  br i1 %43, label %47, label %44

44:                                               ; preds = %40
  %45 = and i8 %37, 4
  %46 = icmp eq i8 %45, 0
  br i1 %46, label %108, label %52

47:                                               ; preds = %40
  %48 = load ptr, ptr %5, align 8, !tbaa !102
  store ptr %35, ptr %5, align 8, !tbaa !102
  %49 = zext i8 %37 to i32
  %50 = and i32 %49, 8
  %51 = icmp eq i32 %50, 0
  br i1 %51, label %57, label %55

52:                                               ; preds = %44
  %53 = load ptr, ptr %5, align 8, !tbaa !102
  store ptr %35, ptr %5, align 8, !tbaa !102
  %54 = zext i8 %37 to i32
  br label %57

55:                                               ; preds = %47
  %56 = load i32, ptr %10, align 8, !tbaa !93
  store i32 %56, ptr %9, align 4, !tbaa !94
  call void @luaD_callhook(ptr noundef nonnull %0, i32 noundef 3, i32 noundef -1) #46
  br label %57

57:                                               ; preds = %55, %52, %47
  %58 = phi i32 [ %49, %55 ], [ %49, %47 ], [ %54, %52 ]
  %59 = phi ptr [ %48, %55 ], [ %48, %47 ], [ %53, %52 ]
  %60 = and i32 %58, 4
  %61 = icmp eq i32 %60, 0
  br i1 %61, label %102, label %62

62:                                               ; preds = %57
  %63 = load ptr, ptr %6, align 8, !tbaa !19
  %64 = getelementptr inbounds %struct.CallInfo, ptr %63, i64 0, i32 1
  %65 = load ptr, ptr %64, align 8, !tbaa !36
  %66 = load ptr, ptr %65, align 8, !tbaa !33
  %67 = getelementptr inbounds %struct.LClosure, ptr %66, i64 0, i32 7
  %68 = load ptr, ptr %67, align 8, !tbaa !33
  %69 = getelementptr inbounds %struct.Proto, ptr %68, i64 0, i32 4
  %70 = load ptr, ptr %69, align 8, !tbaa !64
  %71 = ptrtoint ptr %35 to i64
  %72 = ptrtoint ptr %70 to i64
  %73 = sub i64 %71, %72
  %74 = lshr exact i64 %73, 2
  %75 = trunc i64 %74 to i32
  %76 = add nsw i32 %75, -1
  %77 = getelementptr inbounds %struct.Proto, ptr %68, i64 0, i32 6
  %78 = load ptr, ptr %77, align 8, !tbaa !74
  %79 = icmp eq ptr %78, null
  br i1 %79, label %80, label %84

80:                                               ; preds = %62
  %81 = icmp ne i32 %76, 0
  %82 = icmp ult ptr %59, %35
  %83 = select i1 %81, i1 %82, i1 false
  br i1 %83, label %102, label %100

84:                                               ; preds = %62
  %85 = sext i32 %76 to i64
  %86 = getelementptr inbounds i32, ptr %78, i64 %85
  %87 = load i32, ptr %86, align 4, !tbaa !65
  %88 = icmp ne i32 %76, 0
  %89 = icmp ult ptr %59, %35
  %90 = select i1 %88, i1 %89, i1 false
  br i1 %90, label %91, label %100

91:                                               ; preds = %84
  %92 = ptrtoint ptr %59 to i64
  %93 = sub i64 %92, %72
  %94 = shl i64 %93, 30
  %95 = add i64 %94, -4294967296
  %96 = ashr i64 %95, 32
  %97 = getelementptr inbounds i32, ptr %78, i64 %96
  %98 = load i32, ptr %97, align 4, !tbaa !65
  %99 = icmp eq i32 %87, %98
  br i1 %99, label %102, label %100

100:                                              ; preds = %91, %84, %80
  %101 = phi i32 [ %87, %84 ], [ %87, %91 ], [ 0, %80 ]
  call void @luaD_callhook(ptr noundef nonnull %0, i32 noundef 2, i32 noundef %101) #46
  br label %102

102:                                              ; preds = %100, %91, %80, %57
  %103 = load i8, ptr %11, align 2, !tbaa !50
  %104 = icmp eq i8 %103, 1
  br i1 %104, label %105, label %106

105:                                              ; preds = %102
  %.lcssa12 = phi ptr [ %33, %102 ]
  %.lcssa6 = phi ptr [ %35, %102 ]
  %.lcssa = phi i32 [ %36, %102 ]
  store ptr %.lcssa12, ptr %5, align 8, !tbaa !102
  br label %1104

106:                                              ; preds = %102
  %107 = load ptr, ptr %7, align 8, !tbaa !17
  br label %108

108:                                              ; preds = %106, %44, %32
  %109 = phi ptr [ %107, %106 ], [ %34, %44 ], [ %34, %32 ]
  %110 = lshr i32 %36, 6
  %111 = and i32 %110, 255
  %112 = zext i32 %111 to i64
  %113 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112
  %114 = and i32 %36, 63
  switch i32 %114, label %1042 [
    i32 0, label %115
    i32 1, label %123
    i32 2, label %131
    i32 3, label %138
    i32 4, label %147
    i32 5, label %158
    i32 6, label %164
    i32 7, label %179
    i32 8, label %185
    i32 9, label %210
    i32 10, label %230
    i32 11, label %247
    i32 12, label %267
    i32 13, label %300
    i32 14, label %333
    i32 15, label %366
    i32 16, label %399
    i32 17, label %435
    i32 18, label %468
    i32 19, label %481
    i32 20, label %495
    i32 21, label %518
    i32 22, label %540
    i32 23, label %545
    i32 24, label %586
    i32 25, label %617
    i32 26, label %679
    i32 27, label %701
    i32 28, label %728
    i32 29, label %751
    i32 30, label %806
    i32 31, label %827
    i32 32, label %847
    i32 33, label %882
    i32 34, label %924
    i32 35, label %992
    i32 36, label %993
    i32 37, label %1045
  ]

115:                                              ; preds = %108
  %116 = lshr i32 %36, 23
  %117 = zext i32 %116 to i64
  %118 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %117
  %119 = load i64, ptr %118, align 8
  store i64 %119, ptr %113, align 8
  %120 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %117, i32 1
  %121 = load i32, ptr %120, align 8, !tbaa !16
  %122 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 %121, ptr %122, align 8, !tbaa !16
  br label %1042

123:                                              ; preds = %108
  %124 = lshr i32 %36, 14
  %125 = zext i32 %124 to i64
  %126 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %125
  %127 = load i64, ptr %126, align 8
  store i64 %127, ptr %113, align 8
  %128 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %125, i32 1
  %129 = load i32, ptr %128, align 8, !tbaa !16
  %130 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 %129, ptr %130, align 8, !tbaa !16
  br label %1042

131:                                              ; preds = %108
  %132 = lshr i32 %36, 23
  store i32 %132, ptr %113, align 8, !tbaa !33
  %133 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 1, ptr %133, align 8, !tbaa !16
  %134 = and i32 %36, 8372224
  %135 = icmp eq i32 %134, 0
  %136 = getelementptr inbounds i32, ptr %33, i64 2
  %137 = select i1 %135, ptr %35, ptr %136
  br label %1042

138:                                              ; preds = %108
  %139 = lshr i32 %36, 23
  %140 = zext i32 %139 to i64
  %141 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %140
  br label %142

142:                                              ; preds = %142, %138
  %143 = phi ptr [ %141, %138 ], [ %144, %142 ]
  %144 = getelementptr inbounds %struct.lua_TValue, ptr %143, i64 -1
  %145 = getelementptr inbounds %struct.lua_TValue, ptr %143, i64 0, i32 1
  store i32 0, ptr %145, align 8, !tbaa !16
  %146 = icmp ult ptr %144, %113
  br i1 %146, label %1042, label %142, !llvm.loop !372

147:                                              ; preds = %108
  %148 = lshr i32 %36, 23
  %149 = zext i32 %148 to i64
  %150 = getelementptr inbounds %struct.LClosure, ptr %25, i64 0, i32 8, i64 %149
  %151 = load ptr, ptr %150, align 8, !tbaa !39
  %152 = getelementptr inbounds %struct.UpVal, ptr %151, i64 0, i32 3
  %153 = load ptr, ptr %152, align 8, !tbaa !57
  %154 = load i64, ptr %153, align 8
  store i64 %154, ptr %113, align 8
  %155 = getelementptr inbounds %struct.lua_TValue, ptr %153, i64 0, i32 1
  %156 = load i32, ptr %155, align 8, !tbaa !16
  %157 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 %156, ptr %157, align 8, !tbaa !16
  br label %1042

158:                                              ; preds = %108
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %3) #48
  %159 = lshr i32 %36, 14
  %160 = zext i32 %159 to i64
  %161 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %160
  %162 = load ptr, ptr %31, align 8, !tbaa !373
  store ptr %162, ptr %3, align 8, !tbaa !33
  store i32 5, ptr %17, align 8, !tbaa !16
  store ptr %35, ptr %5, align 8, !tbaa !102
  call void @luaV_gettable(ptr noundef nonnull %0, ptr noundef nonnull %3, ptr noundef %161, ptr noundef %113) #47
  %163 = load ptr, ptr %7, align 8, !tbaa !17
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %3) #48
  br label %1042

164:                                              ; preds = %108
  store ptr %35, ptr %5, align 8, !tbaa !102
  %165 = lshr i32 %36, 23
  %166 = zext i32 %165 to i64
  %167 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %166
  %168 = lshr i32 %36, 14
  %169 = and i32 %36, 4194304
  %170 = icmp eq i32 %169, 0
  %171 = and i32 %168, 255
  %172 = zext i32 %171 to i64
  %173 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %172
  %174 = and i32 %168, 511
  %175 = zext i32 %174 to i64
  %176 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %175
  %177 = select i1 %170, ptr %176, ptr %173
  call void @luaV_gettable(ptr noundef nonnull %0, ptr noundef %167, ptr noundef %177, ptr noundef %113) #47
  %178 = load ptr, ptr %7, align 8, !tbaa !17
  br label %1042

179:                                              ; preds = %108
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %4) #48
  %180 = load ptr, ptr %31, align 8, !tbaa !373
  store ptr %180, ptr %4, align 8, !tbaa !33
  store i32 5, ptr %16, align 8, !tbaa !16
  store ptr %35, ptr %5, align 8, !tbaa !102
  %181 = lshr i32 %36, 14
  %182 = zext i32 %181 to i64
  %183 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %182
  call void @luaV_settable(ptr noundef nonnull %0, ptr noundef nonnull %4, ptr noundef %183, ptr noundef %113) #47
  %184 = load ptr, ptr %7, align 8, !tbaa !17
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %4) #48
  br label %1042

185:                                              ; preds = %108
  %186 = lshr i32 %36, 23
  %187 = zext i32 %186 to i64
  %188 = getelementptr inbounds %struct.LClosure, ptr %25, i64 0, i32 8, i64 %187
  %189 = load ptr, ptr %188, align 8, !tbaa !39
  %190 = getelementptr inbounds %struct.UpVal, ptr %189, i64 0, i32 3
  %191 = load ptr, ptr %190, align 8, !tbaa !57
  %192 = load i64, ptr %113, align 8
  store i64 %192, ptr %191, align 8
  %193 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  %194 = load i32, ptr %193, align 8, !tbaa !16
  %195 = getelementptr inbounds %struct.lua_TValue, ptr %191, i64 0, i32 1
  store i32 %194, ptr %195, align 8, !tbaa !16
  %196 = load i32, ptr %193, align 8, !tbaa !16
  %197 = icmp sgt i32 %196, 3
  br i1 %197, label %198, label %1042

198:                                              ; preds = %185
  %199 = load ptr, ptr %113, align 8, !tbaa !33
  %200 = getelementptr inbounds %struct.GCheader, ptr %199, i64 0, i32 2
  %201 = load i8, ptr %200, align 1, !tbaa !33
  %202 = and i8 %201, 3
  %203 = icmp eq i8 %202, 0
  br i1 %203, label %1042, label %204

204:                                              ; preds = %198
  %205 = getelementptr inbounds %struct.GCheader, ptr %189, i64 0, i32 2
  %206 = load i8, ptr %205, align 1, !tbaa !33
  %207 = and i8 %206, 4
  %208 = icmp eq i8 %207, 0
  br i1 %208, label %1042, label %209

209:                                              ; preds = %204
  call void @luaC_barrierf(ptr noundef nonnull %0, ptr noundef nonnull %189, ptr noundef nonnull %199) #46
  br label %1042

210:                                              ; preds = %108
  store ptr %35, ptr %5, align 8, !tbaa !102
  %211 = lshr i32 %36, 23
  %212 = and i32 %211, 255
  %213 = zext i32 %212 to i64
  %214 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %213
  %215 = zext i32 %211 to i64
  %216 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %215
  %217 = icmp slt i32 %36, 0
  %218 = select i1 %217, ptr %214, ptr %216
  %219 = lshr i32 %36, 14
  %220 = and i32 %36, 4194304
  %221 = icmp eq i32 %220, 0
  %222 = and i32 %219, 255
  %223 = zext i32 %222 to i64
  %224 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %223
  %225 = and i32 %219, 511
  %226 = zext i32 %225 to i64
  %227 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %226
  %228 = select i1 %221, ptr %227, ptr %224
  call void @luaV_settable(ptr noundef nonnull %0, ptr noundef %113, ptr noundef %218, ptr noundef %228) #47
  %229 = load ptr, ptr %7, align 8, !tbaa !17
  br label %1042

230:                                              ; preds = %108
  %231 = lshr i32 %36, 23
  %232 = lshr i32 %36, 14
  %233 = and i32 %232, 511
  %234 = call i32 @luaO_fb2int(i32 noundef %231) #46
  %235 = call i32 @luaO_fb2int(i32 noundef %233) #46
  %236 = call ptr @luaH_new(ptr noundef nonnull %0, i32 noundef %234, i32 noundef %235) #46
  store ptr %236, ptr %113, align 8, !tbaa !33
  %237 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 5, ptr %237, align 8, !tbaa !16
  store ptr %35, ptr %5, align 8, !tbaa !102
  %238 = load ptr, ptr %14, align 8, !tbaa !25
  %239 = getelementptr inbounds %struct.global_State, ptr %238, i64 0, i32 14
  %240 = load i64, ptr %239, align 8, !tbaa !31
  %241 = getelementptr inbounds %struct.global_State, ptr %238, i64 0, i32 13
  %242 = load i64, ptr %241, align 8, !tbaa !32
  %243 = icmp ult i64 %240, %242
  br i1 %243, label %245, label %244

244:                                              ; preds = %230
  call void @luaC_step(ptr noundef nonnull %0) #46
  br label %245

245:                                              ; preds = %244, %230
  %246 = load ptr, ptr %7, align 8, !tbaa !17
  br label %1042

247:                                              ; preds = %108
  %248 = lshr i32 %36, 23
  %249 = zext i32 %248 to i64
  %250 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %249
  %251 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 1
  %252 = load i64, ptr %250, align 8
  store i64 %252, ptr %251, align 8
  %253 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %249, i32 1
  %254 = load i32, ptr %253, align 8, !tbaa !16
  %255 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 1, i32 1
  store i32 %254, ptr %255, align 8, !tbaa !16
  store ptr %35, ptr %5, align 8, !tbaa !102
  %256 = lshr i32 %36, 14
  %257 = and i32 %36, 4194304
  %258 = icmp eq i32 %257, 0
  %259 = and i32 %256, 255
  %260 = zext i32 %259 to i64
  %261 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %260
  %262 = and i32 %256, 511
  %263 = zext i32 %262 to i64
  %264 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %263
  %265 = select i1 %258, ptr %264, ptr %261
  call void @luaV_gettable(ptr noundef nonnull %0, ptr noundef nonnull %250, ptr noundef %265, ptr noundef %113) #47
  %266 = load ptr, ptr %7, align 8, !tbaa !17
  br label %1042

267:                                              ; preds = %108
  %268 = lshr i32 %36, 23
  %269 = and i32 %268, 255
  %270 = zext i32 %269 to i64
  %271 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %270
  %272 = zext i32 %268 to i64
  %273 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %272
  %274 = icmp slt i32 %36, 0
  %275 = select i1 %274, ptr %271, ptr %273
  %276 = lshr i32 %36, 14
  %277 = and i32 %36, 4194304
  %278 = icmp eq i32 %277, 0
  %279 = and i32 %276, 255
  %280 = zext i32 %279 to i64
  %281 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %280
  %282 = and i32 %276, 511
  %283 = zext i32 %282 to i64
  %284 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %283
  %285 = select i1 %278, ptr %284, ptr %281
  %286 = getelementptr inbounds %struct.lua_TValue, ptr %275, i64 0, i32 1
  %287 = load i32, ptr %286, align 8, !tbaa !16
  %288 = icmp eq i32 %287, 3
  br i1 %288, label %289, label %298

289:                                              ; preds = %267
  %290 = getelementptr inbounds %struct.lua_TValue, ptr %285, i64 0, i32 1
  %291 = load i32, ptr %290, align 8, !tbaa !16
  %292 = icmp eq i32 %291, 3
  br i1 %292, label %293, label %298

293:                                              ; preds = %289
  %294 = load double, ptr %275, align 8, !tbaa !33
  %295 = load double, ptr %285, align 8, !tbaa !33
  %296 = fadd double %294, %295
  store double %296, ptr %113, align 8, !tbaa !33
  %297 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 3, ptr %297, align 8, !tbaa !16
  br label %1042

298:                                              ; preds = %289, %267
  store ptr %35, ptr %5, align 8, !tbaa !102
  call fastcc void @Arith(ptr noundef nonnull %0, ptr noundef %113, ptr noundef nonnull %275, ptr noundef %285, i32 noundef 5) #47
  %299 = load ptr, ptr %7, align 8, !tbaa !17
  br label %1042

300:                                              ; preds = %108
  %301 = lshr i32 %36, 23
  %302 = and i32 %301, 255
  %303 = zext i32 %302 to i64
  %304 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %303
  %305 = zext i32 %301 to i64
  %306 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %305
  %307 = icmp slt i32 %36, 0
  %308 = select i1 %307, ptr %304, ptr %306
  %309 = lshr i32 %36, 14
  %310 = and i32 %36, 4194304
  %311 = icmp eq i32 %310, 0
  %312 = and i32 %309, 255
  %313 = zext i32 %312 to i64
  %314 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %313
  %315 = and i32 %309, 511
  %316 = zext i32 %315 to i64
  %317 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %316
  %318 = select i1 %311, ptr %317, ptr %314
  %319 = getelementptr inbounds %struct.lua_TValue, ptr %308, i64 0, i32 1
  %320 = load i32, ptr %319, align 8, !tbaa !16
  %321 = icmp eq i32 %320, 3
  br i1 %321, label %322, label %331

322:                                              ; preds = %300
  %323 = getelementptr inbounds %struct.lua_TValue, ptr %318, i64 0, i32 1
  %324 = load i32, ptr %323, align 8, !tbaa !16
  %325 = icmp eq i32 %324, 3
  br i1 %325, label %326, label %331

326:                                              ; preds = %322
  %327 = load double, ptr %308, align 8, !tbaa !33
  %328 = load double, ptr %318, align 8, !tbaa !33
  %329 = fsub double %327, %328
  store double %329, ptr %113, align 8, !tbaa !33
  %330 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 3, ptr %330, align 8, !tbaa !16
  br label %1042

331:                                              ; preds = %322, %300
  store ptr %35, ptr %5, align 8, !tbaa !102
  call fastcc void @Arith(ptr noundef nonnull %0, ptr noundef %113, ptr noundef nonnull %308, ptr noundef %318, i32 noundef 6) #47
  %332 = load ptr, ptr %7, align 8, !tbaa !17
  br label %1042

333:                                              ; preds = %108
  %334 = lshr i32 %36, 23
  %335 = and i32 %334, 255
  %336 = zext i32 %335 to i64
  %337 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %336
  %338 = zext i32 %334 to i64
  %339 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %338
  %340 = icmp slt i32 %36, 0
  %341 = select i1 %340, ptr %337, ptr %339
  %342 = lshr i32 %36, 14
  %343 = and i32 %36, 4194304
  %344 = icmp eq i32 %343, 0
  %345 = and i32 %342, 255
  %346 = zext i32 %345 to i64
  %347 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %346
  %348 = and i32 %342, 511
  %349 = zext i32 %348 to i64
  %350 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %349
  %351 = select i1 %344, ptr %350, ptr %347
  %352 = getelementptr inbounds %struct.lua_TValue, ptr %341, i64 0, i32 1
  %353 = load i32, ptr %352, align 8, !tbaa !16
  %354 = icmp eq i32 %353, 3
  br i1 %354, label %355, label %364

355:                                              ; preds = %333
  %356 = getelementptr inbounds %struct.lua_TValue, ptr %351, i64 0, i32 1
  %357 = load i32, ptr %356, align 8, !tbaa !16
  %358 = icmp eq i32 %357, 3
  br i1 %358, label %359, label %364

359:                                              ; preds = %355
  %360 = load double, ptr %341, align 8, !tbaa !33
  %361 = load double, ptr %351, align 8, !tbaa !33
  %362 = fmul double %360, %361
  store double %362, ptr %113, align 8, !tbaa !33
  %363 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 3, ptr %363, align 8, !tbaa !16
  br label %1042

364:                                              ; preds = %355, %333
  store ptr %35, ptr %5, align 8, !tbaa !102
  call fastcc void @Arith(ptr noundef nonnull %0, ptr noundef %113, ptr noundef nonnull %341, ptr noundef %351, i32 noundef 7) #47
  %365 = load ptr, ptr %7, align 8, !tbaa !17
  br label %1042

366:                                              ; preds = %108
  %367 = lshr i32 %36, 23
  %368 = and i32 %367, 255
  %369 = zext i32 %368 to i64
  %370 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %369
  %371 = zext i32 %367 to i64
  %372 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %371
  %373 = icmp slt i32 %36, 0
  %374 = select i1 %373, ptr %370, ptr %372
  %375 = lshr i32 %36, 14
  %376 = and i32 %36, 4194304
  %377 = icmp eq i32 %376, 0
  %378 = and i32 %375, 255
  %379 = zext i32 %378 to i64
  %380 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %379
  %381 = and i32 %375, 511
  %382 = zext i32 %381 to i64
  %383 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %382
  %384 = select i1 %377, ptr %383, ptr %380
  %385 = getelementptr inbounds %struct.lua_TValue, ptr %374, i64 0, i32 1
  %386 = load i32, ptr %385, align 8, !tbaa !16
  %387 = icmp eq i32 %386, 3
  br i1 %387, label %388, label %397

388:                                              ; preds = %366
  %389 = getelementptr inbounds %struct.lua_TValue, ptr %384, i64 0, i32 1
  %390 = load i32, ptr %389, align 8, !tbaa !16
  %391 = icmp eq i32 %390, 3
  br i1 %391, label %392, label %397

392:                                              ; preds = %388
  %393 = load double, ptr %374, align 8, !tbaa !33
  %394 = load double, ptr %384, align 8, !tbaa !33
  %395 = fdiv double %393, %394
  store double %395, ptr %113, align 8, !tbaa !33
  %396 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 3, ptr %396, align 8, !tbaa !16
  br label %1042

397:                                              ; preds = %388, %366
  store ptr %35, ptr %5, align 8, !tbaa !102
  call fastcc void @Arith(ptr noundef nonnull %0, ptr noundef %113, ptr noundef nonnull %374, ptr noundef %384, i32 noundef 8) #47
  %398 = load ptr, ptr %7, align 8, !tbaa !17
  br label %1042

399:                                              ; preds = %108
  %400 = lshr i32 %36, 23
  %401 = and i32 %400, 255
  %402 = zext i32 %401 to i64
  %403 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %402
  %404 = zext i32 %400 to i64
  %405 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %404
  %406 = icmp slt i32 %36, 0
  %407 = select i1 %406, ptr %403, ptr %405
  %408 = lshr i32 %36, 14
  %409 = and i32 %36, 4194304
  %410 = icmp eq i32 %409, 0
  %411 = and i32 %408, 255
  %412 = zext i32 %411 to i64
  %413 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %412
  %414 = and i32 %408, 511
  %415 = zext i32 %414 to i64
  %416 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %415
  %417 = select i1 %410, ptr %416, ptr %413
  %418 = getelementptr inbounds %struct.lua_TValue, ptr %407, i64 0, i32 1
  %419 = load i32, ptr %418, align 8, !tbaa !16
  %420 = icmp eq i32 %419, 3
  br i1 %420, label %421, label %433

421:                                              ; preds = %399
  %422 = getelementptr inbounds %struct.lua_TValue, ptr %417, i64 0, i32 1
  %423 = load i32, ptr %422, align 8, !tbaa !16
  %424 = icmp eq i32 %423, 3
  br i1 %424, label %425, label %433

425:                                              ; preds = %421
  %426 = load double, ptr %407, align 8, !tbaa !33
  %427 = load double, ptr %417, align 8, !tbaa !33
  %428 = fdiv double %426, %427
  %429 = call double @llvm.floor.f64(double %428)
  %430 = fneg double %429
  %431 = call double @llvm.fmuladd.f64(double %430, double %427, double %426)
  store double %431, ptr %113, align 8, !tbaa !33
  %432 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 3, ptr %432, align 8, !tbaa !16
  br label %1042

433:                                              ; preds = %421, %399
  store ptr %35, ptr %5, align 8, !tbaa !102
  call fastcc void @Arith(ptr noundef nonnull %0, ptr noundef %113, ptr noundef nonnull %407, ptr noundef %417, i32 noundef 9) #47
  %434 = load ptr, ptr %7, align 8, !tbaa !17
  br label %1042

435:                                              ; preds = %108
  %436 = lshr i32 %36, 23
  %437 = and i32 %436, 255
  %438 = zext i32 %437 to i64
  %439 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %438
  %440 = zext i32 %436 to i64
  %441 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %440
  %442 = icmp slt i32 %36, 0
  %443 = select i1 %442, ptr %439, ptr %441
  %444 = lshr i32 %36, 14
  %445 = and i32 %36, 4194304
  %446 = icmp eq i32 %445, 0
  %447 = and i32 %444, 255
  %448 = zext i32 %447 to i64
  %449 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %448
  %450 = and i32 %444, 511
  %451 = zext i32 %450 to i64
  %452 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %451
  %453 = select i1 %446, ptr %452, ptr %449
  %454 = getelementptr inbounds %struct.lua_TValue, ptr %443, i64 0, i32 1
  %455 = load i32, ptr %454, align 8, !tbaa !16
  %456 = icmp eq i32 %455, 3
  br i1 %456, label %457, label %466

457:                                              ; preds = %435
  %458 = getelementptr inbounds %struct.lua_TValue, ptr %453, i64 0, i32 1
  %459 = load i32, ptr %458, align 8, !tbaa !16
  %460 = icmp eq i32 %459, 3
  br i1 %460, label %461, label %466

461:                                              ; preds = %457
  %462 = load double, ptr %443, align 8, !tbaa !33
  %463 = load double, ptr %453, align 8, !tbaa !33
  %464 = call double @pow(double noundef %462, double noundef %463) #46
  store double %464, ptr %113, align 8, !tbaa !33
  %465 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 3, ptr %465, align 8, !tbaa !16
  br label %1042

466:                                              ; preds = %457, %435
  store ptr %35, ptr %5, align 8, !tbaa !102
  call fastcc void @Arith(ptr noundef nonnull %0, ptr noundef %113, ptr noundef nonnull %443, ptr noundef %453, i32 noundef 10) #47
  %467 = load ptr, ptr %7, align 8, !tbaa !17
  br label %1042

468:                                              ; preds = %108
  %469 = lshr i32 %36, 23
  %470 = zext i32 %469 to i64
  %471 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %470
  %472 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %470, i32 1
  %473 = load i32, ptr %472, align 8, !tbaa !16
  %474 = icmp eq i32 %473, 3
  br i1 %474, label %475, label %479

475:                                              ; preds = %468
  %476 = load double, ptr %471, align 8, !tbaa !33
  %477 = fneg double %476
  store double %477, ptr %113, align 8, !tbaa !33
  %478 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 3, ptr %478, align 8, !tbaa !16
  br label %1042

479:                                              ; preds = %468
  store ptr %35, ptr %5, align 8, !tbaa !102
  call fastcc void @Arith(ptr noundef nonnull %0, ptr noundef nonnull %113, ptr noundef nonnull %471, ptr noundef nonnull %471, i32 noundef 11) #47
  %480 = load ptr, ptr %7, align 8, !tbaa !17
  br label %1042

481:                                              ; preds = %108
  %482 = lshr i32 %36, 23
  %483 = zext i32 %482 to i64
  %484 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %483, i32 1
  %485 = load i32, ptr %484, align 8, !tbaa !16
  switch i32 %485, label %490 [
    i32 0, label %491
    i32 1, label %486
  ]

486:                                              ; preds = %481
  %487 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %483
  %488 = load i32, ptr %487, align 8, !tbaa !33
  %489 = icmp eq i32 %488, 0
  br label %491

490:                                              ; preds = %481
  br label %491

491:                                              ; preds = %490, %486, %481
  %492 = phi i1 [ true, %481 ], [ %489, %486 ], [ false, %490 ]
  %493 = zext i1 %492 to i32
  store i32 %493, ptr %113, align 8, !tbaa !33
  %494 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 1, ptr %494, align 8, !tbaa !16
  br label %1042

495:                                              ; preds = %108
  %496 = lshr i32 %36, 23
  %497 = zext i32 %496 to i64
  %498 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %497
  %499 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %497, i32 1
  %500 = load i32, ptr %499, align 8, !tbaa !16
  switch i32 %500, label %512 [
    i32 5, label %501
    i32 4, label %506
  ]

501:                                              ; preds = %495
  %502 = load ptr, ptr %498, align 8, !tbaa !33
  %503 = call i32 @luaH_getn(ptr noundef %502) #46
  %504 = sitofp i32 %503 to double
  store double %504, ptr %113, align 8, !tbaa !33
  %505 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 3, ptr %505, align 8, !tbaa !16
  br label %1042

506:                                              ; preds = %495
  %507 = load ptr, ptr %498, align 8, !tbaa !33
  %508 = getelementptr inbounds %struct.anon.0, ptr %507, i64 0, i32 5
  %509 = load i64, ptr %508, align 8, !tbaa !33
  %510 = uitofp i64 %509 to double
  store double %510, ptr %113, align 8, !tbaa !33
  %511 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 3, ptr %511, align 8, !tbaa !16
  br label %1042

512:                                              ; preds = %495
  store ptr %35, ptr %5, align 8, !tbaa !102
  %513 = call fastcc i32 @call_binTM(ptr noundef nonnull %0, ptr noundef nonnull %498, ptr noundef nonnull @luaO_nilobject_, ptr noundef nonnull %113, i32 noundef 12) #47, !range !75
  %514 = icmp eq i32 %513, 0
  br i1 %514, label %515, label %516

515:                                              ; preds = %512
  call void @luaG_typeerror(ptr noundef nonnull %0, ptr noundef nonnull %498, ptr noundef nonnull @.str.5.254) #46
  br label %516

516:                                              ; preds = %515, %512
  %517 = load ptr, ptr %7, align 8, !tbaa !17
  br label %1042

518:                                              ; preds = %108
  %519 = lshr i32 %36, 23
  %520 = lshr i32 %36, 14
  %521 = and i32 %520, 511
  store ptr %35, ptr %5, align 8, !tbaa !102
  %522 = sub nsw i32 %521, %519
  %523 = add nsw i32 %522, 1
  call void @luaV_concat(ptr noundef nonnull %0, i32 noundef %523, i32 noundef %521) #47
  %524 = load ptr, ptr %14, align 8, !tbaa !25
  %525 = getelementptr inbounds %struct.global_State, ptr %524, i64 0, i32 14
  %526 = load i64, ptr %525, align 8, !tbaa !31
  %527 = getelementptr inbounds %struct.global_State, ptr %524, i64 0, i32 13
  %528 = load i64, ptr %527, align 8, !tbaa !32
  %529 = icmp ult i64 %526, %528
  br i1 %529, label %531, label %530

530:                                              ; preds = %518
  call void @luaC_step(ptr noundef nonnull %0) #46
  br label %531

531:                                              ; preds = %530, %518
  %532 = load ptr, ptr %7, align 8, !tbaa !17
  %533 = zext i32 %519 to i64
  %534 = getelementptr inbounds %struct.lua_TValue, ptr %532, i64 %533
  %535 = getelementptr inbounds %struct.lua_TValue, ptr %532, i64 %112
  %536 = load i64, ptr %534, align 8
  store i64 %536, ptr %535, align 8
  %537 = getelementptr inbounds %struct.lua_TValue, ptr %532, i64 %533, i32 1
  %538 = load i32, ptr %537, align 8, !tbaa !16
  %539 = getelementptr inbounds %struct.lua_TValue, ptr %532, i64 %112, i32 1
  store i32 %538, ptr %539, align 8, !tbaa !16
  br label %1042

540:                                              ; preds = %108
  %541 = lshr i32 %36, 14
  %542 = add nsw i32 %541, -131071
  %543 = sext i32 %542 to i64
  %544 = getelementptr inbounds i32, ptr %35, i64 %543
  br label %1042

545:                                              ; preds = %108
  %546 = lshr i32 %36, 23
  %547 = and i32 %546, 255
  %548 = zext i32 %547 to i64
  %549 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %548
  %550 = zext i32 %546 to i64
  %551 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %550
  %552 = icmp slt i32 %36, 0
  %553 = select i1 %552, ptr %549, ptr %551
  %554 = lshr i32 %36, 14
  %555 = and i32 %36, 4194304
  %556 = icmp eq i32 %555, 0
  %557 = and i32 %554, 255
  %558 = zext i32 %557 to i64
  %559 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %558
  %560 = and i32 %554, 511
  %561 = zext i32 %560 to i64
  %562 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %561
  %563 = select i1 %556, ptr %562, ptr %559
  store ptr %35, ptr %5, align 8, !tbaa !102
  %564 = getelementptr inbounds %struct.lua_TValue, ptr %553, i64 0, i32 1
  %565 = load i32, ptr %564, align 8, !tbaa !16
  %566 = getelementptr inbounds %struct.lua_TValue, ptr %563, i64 0, i32 1
  %567 = load i32, ptr %566, align 8, !tbaa !16
  %568 = icmp eq i32 %565, %567
  br i1 %568, label %569, label %572

569:                                              ; preds = %545
  %570 = call i32 @luaV_equalval(ptr noundef nonnull %0, ptr noundef nonnull %553, ptr noundef nonnull %563) #47, !range !75
  %571 = icmp ne i32 %570, 0
  br label %572

572:                                              ; preds = %569, %545
  %573 = phi i1 [ false, %545 ], [ %571, %569 ]
  %574 = zext i1 %573 to i32
  %575 = icmp eq i32 %111, %574
  br i1 %575, label %576, label %582

576:                                              ; preds = %572
  %577 = load i32, ptr %35, align 4, !tbaa !65
  %578 = lshr i32 %577, 14
  %579 = add nsw i32 %578, -131071
  %580 = sext i32 %579 to i64
  %581 = getelementptr inbounds i32, ptr %35, i64 %580
  br label %582

582:                                              ; preds = %576, %572
  %583 = phi ptr [ %581, %576 ], [ %35, %572 ]
  %584 = load ptr, ptr %7, align 8, !tbaa !17
  %585 = getelementptr inbounds i32, ptr %583, i64 1
  br label %1042

586:                                              ; preds = %108
  store ptr %35, ptr %5, align 8, !tbaa !102
  %587 = lshr i32 %36, 23
  %588 = and i32 %587, 255
  %589 = zext i32 %588 to i64
  %590 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %589
  %591 = zext i32 %587 to i64
  %592 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %591
  %593 = icmp slt i32 %36, 0
  %594 = select i1 %593, ptr %590, ptr %592
  %595 = lshr i32 %36, 14
  %596 = and i32 %36, 4194304
  %597 = icmp eq i32 %596, 0
  %598 = and i32 %595, 255
  %599 = zext i32 %598 to i64
  %600 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %599
  %601 = and i32 %595, 511
  %602 = zext i32 %601 to i64
  %603 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %602
  %604 = select i1 %597, ptr %603, ptr %600
  %605 = call i32 @luaV_lessthan(ptr noundef nonnull %0, ptr noundef %594, ptr noundef %604) #47
  %606 = icmp eq i32 %605, %111
  br i1 %606, label %607, label %613

607:                                              ; preds = %586
  %608 = load i32, ptr %35, align 4, !tbaa !65
  %609 = lshr i32 %608, 14
  %610 = add nsw i32 %609, -131071
  %611 = sext i32 %610 to i64
  %612 = getelementptr inbounds i32, ptr %35, i64 %611
  br label %613

613:                                              ; preds = %607, %586
  %614 = phi ptr [ %612, %607 ], [ %35, %586 ]
  %615 = load ptr, ptr %7, align 8, !tbaa !17
  %616 = getelementptr inbounds i32, ptr %614, i64 1
  br label %1042

617:                                              ; preds = %108
  store ptr %35, ptr %5, align 8, !tbaa !102
  %618 = lshr i32 %36, 23
  %619 = and i32 %618, 255
  %620 = zext i32 %619 to i64
  %621 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %620
  %622 = zext i32 %618 to i64
  %623 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %622
  %624 = icmp slt i32 %36, 0
  %625 = select i1 %624, ptr %621, ptr %623
  %626 = lshr i32 %36, 14
  %627 = and i32 %36, 4194304
  %628 = icmp eq i32 %627, 0
  %629 = and i32 %626, 255
  %630 = zext i32 %629 to i64
  %631 = getelementptr inbounds %struct.lua_TValue, ptr %30, i64 %630
  %632 = and i32 %626, 511
  %633 = zext i32 %632 to i64
  %634 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %633
  %635 = select i1 %628, ptr %634, ptr %631
  %636 = getelementptr inbounds %struct.lua_TValue, ptr %625, i64 0, i32 1
  %637 = load i32, ptr %636, align 8, !tbaa !16
  %638 = getelementptr inbounds %struct.lua_TValue, ptr %635, i64 0, i32 1
  %639 = load i32, ptr %638, align 8, !tbaa !16
  %640 = icmp eq i32 %637, %639
  br i1 %640, label %643, label %641

641:                                              ; preds = %617
  %642 = call i32 @luaG_ordererror(ptr noundef nonnull %0, ptr noundef nonnull %625, ptr noundef nonnull %635) #46
  br label %666

643:                                              ; preds = %617
  switch i32 %637, label %655 [
    i32 3, label %644
    i32 4, label %649
  ]

644:                                              ; preds = %643
  %645 = load double, ptr %625, align 8, !tbaa !33
  %646 = load double, ptr %635, align 8, !tbaa !33
  %647 = fcmp ole double %645, %646
  %648 = zext i1 %647 to i32
  br label %666

649:                                              ; preds = %643
  %650 = load ptr, ptr %625, align 8, !tbaa !33
  %651 = load ptr, ptr %635, align 8, !tbaa !33
  %652 = call fastcc i32 @l_strcmp(ptr noundef %650, ptr noundef %651) #47
  %653 = icmp slt i32 %652, 1
  %654 = zext i1 %653 to i32
  br label %666

655:                                              ; preds = %643
  %656 = call fastcc i32 @call_orderTM(ptr noundef nonnull %0, ptr noundef nonnull %625, ptr noundef nonnull %635, i32 noundef 14) #47, !range !368
  %657 = icmp eq i32 %656, -1
  br i1 %657, label %658, label %666

658:                                              ; preds = %655
  %659 = call fastcc i32 @call_orderTM(ptr noundef nonnull %0, ptr noundef nonnull %635, ptr noundef nonnull %625, i32 noundef 13) #47, !range !368
  %660 = icmp eq i32 %659, -1
  br i1 %660, label %664, label %661

661:                                              ; preds = %658
  %662 = icmp eq i32 %659, 0
  %663 = zext i1 %662 to i32
  br label %666

664:                                              ; preds = %658
  %665 = call i32 @luaG_ordererror(ptr noundef nonnull %0, ptr noundef nonnull %625, ptr noundef nonnull %635) #46
  br label %666

666:                                              ; preds = %664, %661, %655, %649, %644, %641
  %667 = phi i32 [ %642, %641 ], [ %648, %644 ], [ %654, %649 ], [ %663, %661 ], [ %665, %664 ], [ %656, %655 ]
  %668 = icmp eq i32 %667, %111
  br i1 %668, label %669, label %675

669:                                              ; preds = %666
  %670 = load i32, ptr %35, align 4, !tbaa !65
  %671 = lshr i32 %670, 14
  %672 = add nsw i32 %671, -131071
  %673 = sext i32 %672 to i64
  %674 = getelementptr inbounds i32, ptr %35, i64 %673
  br label %675

675:                                              ; preds = %669, %666
  %676 = phi ptr [ %674, %669 ], [ %35, %666 ]
  %677 = load ptr, ptr %7, align 8, !tbaa !17
  %678 = getelementptr inbounds i32, ptr %676, i64 1
  br label %1042

679:                                              ; preds = %108
  %680 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  %681 = load i32, ptr %680, align 8, !tbaa !16
  switch i32 %681, label %685 [
    i32 0, label %686
    i32 1, label %682
  ]

682:                                              ; preds = %679
  %683 = load i32, ptr %113, align 8, !tbaa !33
  %684 = icmp eq i32 %683, 0
  br label %686

685:                                              ; preds = %679
  br label %686

686:                                              ; preds = %685, %682, %679
  %687 = phi i1 [ true, %679 ], [ %684, %682 ], [ false, %685 ]
  %688 = zext i1 %687 to i32
  %689 = lshr i32 %36, 14
  %690 = and i32 %689, 511
  %691 = icmp eq i32 %690, %688
  br i1 %691, label %698, label %692

692:                                              ; preds = %686
  %693 = load i32, ptr %35, align 4, !tbaa !65
  %694 = lshr i32 %693, 14
  %695 = add nsw i32 %694, -131071
  %696 = sext i32 %695 to i64
  %697 = getelementptr inbounds i32, ptr %35, i64 %696
  br label %698

698:                                              ; preds = %692, %686
  %699 = phi ptr [ %697, %692 ], [ %35, %686 ]
  %700 = getelementptr inbounds i32, ptr %699, i64 1
  br label %1042

701:                                              ; preds = %108
  %702 = lshr i32 %36, 23
  %703 = zext i32 %702 to i64
  %704 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %703
  %705 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %703, i32 1
  %706 = load i32, ptr %705, align 8, !tbaa !16
  switch i32 %706, label %710 [
    i32 0, label %711
    i32 1, label %707
  ]

707:                                              ; preds = %701
  %708 = load i32, ptr %704, align 8, !tbaa !33
  %709 = icmp eq i32 %708, 0
  br label %711

710:                                              ; preds = %701
  br label %711

711:                                              ; preds = %710, %707, %701
  %712 = phi i1 [ true, %701 ], [ %709, %707 ], [ false, %710 ]
  %713 = zext i1 %712 to i32
  %714 = lshr i32 %36, 14
  %715 = and i32 %714, 511
  %716 = icmp eq i32 %715, %713
  br i1 %716, label %725, label %717

717:                                              ; preds = %711
  %718 = load i64, ptr %704, align 8
  store i64 %718, ptr %113, align 8
  %719 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 %706, ptr %719, align 8, !tbaa !16
  %720 = load i32, ptr %35, align 4, !tbaa !65
  %721 = lshr i32 %720, 14
  %722 = add nsw i32 %721, -131071
  %723 = sext i32 %722 to i64
  %724 = getelementptr inbounds i32, ptr %35, i64 %723
  br label %725

725:                                              ; preds = %717, %711
  %726 = phi ptr [ %724, %717 ], [ %35, %711 ]
  %727 = getelementptr inbounds i32, ptr %726, i64 1
  br label %1042

728:                                              ; preds = %108
  %729 = lshr i32 %36, 14
  %730 = and i32 %729, 511
  %731 = add nsw i32 %730, -1
  %732 = icmp ult i32 %36, 8388608
  br i1 %732, label %737, label %733

733:                                              ; preds = %728
  %734 = lshr i32 %36, 23
  %735 = zext i32 %734 to i64
  %736 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 %735
  store ptr %736, ptr %13, align 8, !tbaa !7
  br label %737

737:                                              ; preds = %733, %728
  store ptr %35, ptr %5, align 8, !tbaa !102
  %738 = call i32 @luaD_precall(ptr noundef nonnull %0, ptr noundef %113, i32 noundef %731) #46
  switch i32 %738, label %1104 [
    i32 0, label %739
    i32 1, label %743
  ]

739:                                              ; preds = %737
  %740 = add nsw i32 %19, 1
  br label %741

741:                                              ; preds = %823, %821, %739
  %742 = phi i32 [ %819, %821 ], [ %819, %823 ], [ %740, %739 ]
  br label %18

743:                                              ; preds = %737
  %744 = icmp eq i32 %730, 0
  br i1 %744, label %749, label %745

745:                                              ; preds = %743
  %746 = load ptr, ptr %6, align 8, !tbaa !19
  %747 = getelementptr inbounds %struct.CallInfo, ptr %746, i64 0, i32 2
  %748 = load ptr, ptr %747, align 8, !tbaa !20
  store ptr %748, ptr %13, align 8, !tbaa !7
  br label %749

749:                                              ; preds = %745, %743
  %750 = load ptr, ptr %7, align 8, !tbaa !17
  br label %1042

751:                                              ; preds = %108
  %752 = icmp ult i32 %36, 8388608
  br i1 %752, label %757, label %753

753:                                              ; preds = %751
  %754 = lshr i32 %36, 23
  %755 = zext i32 %754 to i64
  %756 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 %755
  store ptr %756, ptr %13, align 8, !tbaa !7
  br label %757

757:                                              ; preds = %753, %751
  store ptr %35, ptr %5, align 8, !tbaa !102
  %758 = call i32 @luaD_precall(ptr noundef nonnull %0, ptr noundef %113, i32 noundef -1) #46
  switch i32 %758, label %1104 [
    i32 0, label %759
    i32 1, label %804
  ]

759:                                              ; preds = %757
  %760 = load ptr, ptr %6, align 8, !tbaa !19
  %761 = getelementptr inbounds %struct.CallInfo, ptr %760, i64 -1
  %762 = getelementptr %struct.CallInfo, ptr %760, i64 -1, i32 1
  %763 = load ptr, ptr %762, align 8, !tbaa !36
  %764 = getelementptr inbounds %struct.CallInfo, ptr %760, i64 0, i32 1
  %765 = load ptr, ptr %764, align 8, !tbaa !36
  %766 = load ptr, ptr %15, align 8, !tbaa !179
  %767 = icmp eq ptr %766, null
  br i1 %767, label %771, label %768

768:                                              ; preds = %759
  %769 = load ptr, ptr %761, align 8, !tbaa !100
  call void @luaF_close(ptr noundef nonnull %0, ptr noundef %769) #46
  %770 = load ptr, ptr %762, align 8, !tbaa !36
  br label %771

771:                                              ; preds = %768, %759
  %772 = phi ptr [ %770, %768 ], [ %763, %759 ]
  %773 = load ptr, ptr %760, align 8, !tbaa !100
  %774 = ptrtoint ptr %773 to i64
  %775 = ptrtoint ptr %765 to i64
  %776 = sub i64 %774, %775
  %777 = ashr exact i64 %776, 4
  %778 = getelementptr inbounds %struct.lua_TValue, ptr %772, i64 %777
  store ptr %778, ptr %761, align 8, !tbaa !100
  store ptr %778, ptr %7, align 8, !tbaa !17
  %779 = load ptr, ptr %13, align 8, !tbaa !7
  %780 = icmp ult ptr %765, %779
  br i1 %780, label %781, label %793

781:                                              ; preds = %781, %771
  %782 = phi i64 [ %789, %781 ], [ 0, %771 ]
  %783 = phi ptr [ %790, %781 ], [ %765, %771 ]
  %784 = getelementptr inbounds %struct.lua_TValue, ptr %763, i64 %782
  %785 = load i64, ptr %783, align 8
  store i64 %785, ptr %784, align 8
  %786 = getelementptr inbounds %struct.lua_TValue, ptr %765, i64 %782, i32 1
  %787 = load i32, ptr %786, align 8, !tbaa !16
  %788 = getelementptr inbounds %struct.lua_TValue, ptr %763, i64 %782, i32 1
  store i32 %787, ptr %788, align 8, !tbaa !16
  %789 = add nuw nsw i64 %782, 1
  %790 = getelementptr inbounds %struct.lua_TValue, ptr %765, i64 %789
  %791 = load ptr, ptr %13, align 8, !tbaa !7
  %792 = icmp ult ptr %790, %791
  br i1 %792, label %781, label %793, !llvm.loop !374

793:                                              ; preds = %781, %771
  %794 = phi i64 [ 0, %771 ], [ %789, %781 ]
  %795 = getelementptr inbounds %struct.lua_TValue, ptr %763, i64 %794
  store ptr %795, ptr %13, align 8, !tbaa !7
  %796 = getelementptr %struct.CallInfo, ptr %760, i64 -1, i32 2
  store ptr %795, ptr %796, align 8, !tbaa !20
  %797 = load ptr, ptr %5, align 8, !tbaa !102
  %798 = getelementptr %struct.CallInfo, ptr %760, i64 -1, i32 3
  store ptr %797, ptr %798, align 8, !tbaa !101
  %799 = getelementptr %struct.CallInfo, ptr %760, i64 -1, i32 5
  %800 = load i32, ptr %799, align 4, !tbaa !96
  %801 = add nsw i32 %800, 1
  store i32 %801, ptr %799, align 4, !tbaa !96
  %802 = load ptr, ptr %6, align 8, !tbaa !19
  %803 = getelementptr inbounds %struct.CallInfo, ptr %802, i64 -1
  store ptr %803, ptr %6, align 8, !tbaa !19
  br label %20

804:                                              ; preds = %757
  %805 = load ptr, ptr %7, align 8, !tbaa !17
  br label %1042

806:                                              ; preds = %108
  %.lcssa22 = phi ptr [ %109, %108 ]
  %.lcssa18 = phi ptr [ %113, %108 ]
  %.lcssa13 = phi ptr [ %33, %108 ]
  %.lcssa7 = phi ptr [ %35, %108 ]
  %.lcssa1 = phi i32 [ %36, %108 ]
  %807 = icmp ult i32 %.lcssa1, 8388608
  br i1 %807, label %813, label %808

808:                                              ; preds = %806
  %809 = lshr i32 %.lcssa1, 23
  %810 = zext i32 %809 to i64
  %811 = getelementptr inbounds %struct.lua_TValue, ptr %.lcssa18, i64 %810
  %812 = getelementptr inbounds %struct.lua_TValue, ptr %811, i64 -1
  store ptr %812, ptr %13, align 8, !tbaa !7
  br label %813

813:                                              ; preds = %808, %806
  %814 = load ptr, ptr %15, align 8, !tbaa !179
  %815 = icmp eq ptr %814, null
  br i1 %815, label %817, label %816

816:                                              ; preds = %813
  call void @luaF_close(ptr noundef nonnull %0, ptr noundef %.lcssa22) #46
  br label %817

817:                                              ; preds = %816, %813
  store ptr %.lcssa7, ptr %5, align 8, !tbaa !102
  %818 = call i32 @luaD_poscall(ptr noundef nonnull %0, ptr noundef %.lcssa18) #46
  %819 = add nsw i32 %19, -1
  %820 = icmp eq i32 %819, 0
  br i1 %820, label %1104, label %821

821:                                              ; preds = %817
  %822 = icmp eq i32 %818, 0
  br i1 %822, label %741, label %823

823:                                              ; preds = %821
  %824 = load ptr, ptr %6, align 8, !tbaa !19
  %825 = getelementptr inbounds %struct.CallInfo, ptr %824, i64 0, i32 2
  %826 = load ptr, ptr %825, align 8, !tbaa !20
  store ptr %826, ptr %13, align 8, !tbaa !7
  br label %741

827:                                              ; preds = %108
  %828 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 2
  %829 = load double, ptr %828, align 8, !tbaa !33
  %830 = load double, ptr %113, align 8, !tbaa !33
  %831 = fadd double %829, %830
  %832 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 1
  %833 = load double, ptr %832, align 8, !tbaa !33
  %834 = fcmp ogt double %829, 0.000000e+00
  br i1 %834, label %835, label %837

835:                                              ; preds = %827
  %836 = fcmp ugt double %831, %833
  br i1 %836, label %1042, label %839

837:                                              ; preds = %827
  %838 = fcmp ugt double %833, %831
  br i1 %838, label %1042, label %839

839:                                              ; preds = %837, %835
  %840 = lshr i32 %36, 14
  %841 = add nsw i32 %840, -131071
  %842 = sext i32 %841 to i64
  %843 = getelementptr inbounds i32, ptr %35, i64 %842
  store double %831, ptr %113, align 8, !tbaa !33
  %844 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 3, ptr %844, align 8, !tbaa !16
  %845 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 3
  store double %831, ptr %845, align 8, !tbaa !33
  %846 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 3, i32 1
  store i32 3, ptr %846, align 8, !tbaa !16
  br label %1042

847:                                              ; preds = %108
  %848 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 1
  %849 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 2
  store ptr %35, ptr %5, align 8, !tbaa !102
  %850 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  %851 = load i32, ptr %850, align 8, !tbaa !16
  %852 = icmp eq i32 %851, 3
  br i1 %852, label %856, label %853

853:                                              ; preds = %847
  %854 = call ptr @luaV_tonumber(ptr noundef nonnull %113, ptr noundef nonnull %113) #47
  %855 = icmp eq ptr %854, null
  br i1 %855, label %871, label %856

856:                                              ; preds = %853, %847
  %857 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 1, i32 1
  %858 = load i32, ptr %857, align 8, !tbaa !16
  %859 = icmp eq i32 %858, 3
  br i1 %859, label %863, label %860

860:                                              ; preds = %856
  %861 = call ptr @luaV_tonumber(ptr noundef nonnull %848, ptr noundef nonnull %848) #47
  %862 = icmp eq ptr %861, null
  br i1 %862, label %871, label %863

863:                                              ; preds = %860, %856
  %864 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 2, i32 1
  %865 = load i32, ptr %864, align 8, !tbaa !16
  %866 = icmp eq i32 %865, 3
  br i1 %866, label %873, label %867

867:                                              ; preds = %863
  %868 = call ptr @luaV_tonumber(ptr noundef nonnull %849, ptr noundef nonnull %849) #47
  %869 = icmp eq ptr %868, null
  br i1 %869, label %870, label %873

870:                                              ; preds = %867
  call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %0, ptr noundef nonnull @.str.8.255) #46
  unreachable

871:                                              ; preds = %860, %853
  %872 = phi ptr [ @.str.6.256, %853 ], [ @.str.7.257, %860 ]
  call void (ptr, ptr, ...) @luaG_runerror(ptr noundef nonnull %0, ptr noundef nonnull %872) #46
  br label %873

873:                                              ; preds = %871, %867, %863
  %874 = phi ptr [ %849, %863 ], [ %868, %867 ], [ %849, %871 ]
  %875 = load double, ptr %113, align 8, !tbaa !33
  %876 = load double, ptr %874, align 8, !tbaa !33
  %877 = fsub double %875, %876
  store double %877, ptr %113, align 8, !tbaa !33
  store i32 3, ptr %850, align 8, !tbaa !16
  %878 = lshr i32 %36, 14
  %879 = add nsw i32 %878, -131071
  %880 = sext i32 %879 to i64
  %881 = getelementptr inbounds i32, ptr %35, i64 %880
  br label %1042

882:                                              ; preds = %108
  %883 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 3
  %884 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 2
  %885 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 5
  %886 = load i64, ptr %884, align 8
  store i64 %886, ptr %885, align 8
  %887 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 2, i32 1
  %888 = load i32, ptr %887, align 8, !tbaa !16
  %889 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 5, i32 1
  store i32 %888, ptr %889, align 8, !tbaa !16
  %890 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 1
  %891 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 4
  %892 = load i64, ptr %890, align 8
  store i64 %892, ptr %891, align 8
  %893 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 1, i32 1
  %894 = load i32, ptr %893, align 8, !tbaa !16
  %895 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 4, i32 1
  store i32 %894, ptr %895, align 8, !tbaa !16
  %896 = load i64, ptr %113, align 8
  store i64 %896, ptr %883, align 8
  %897 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  %898 = load i32, ptr %897, align 8, !tbaa !16
  %899 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 3, i32 1
  store i32 %898, ptr %899, align 8, !tbaa !16
  %900 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 6
  store ptr %900, ptr %13, align 8, !tbaa !7
  store ptr %35, ptr %5, align 8, !tbaa !102
  %901 = lshr i32 %36, 14
  %902 = and i32 %901, 511
  call void @luaD_call(ptr noundef nonnull %0, ptr noundef nonnull %883, i32 noundef %902) #46
  %903 = load ptr, ptr %7, align 8, !tbaa !17
  %904 = load ptr, ptr %6, align 8, !tbaa !19
  %905 = getelementptr inbounds %struct.CallInfo, ptr %904, i64 0, i32 2
  %906 = load ptr, ptr %905, align 8, !tbaa !20
  store ptr %906, ptr %13, align 8, !tbaa !7
  %907 = getelementptr inbounds %struct.lua_TValue, ptr %903, i64 %112
  %908 = getelementptr inbounds %struct.lua_TValue, ptr %907, i64 3, i32 1
  %909 = load i32, ptr %908, align 8, !tbaa !16
  %910 = icmp eq i32 %909, 0
  br i1 %910, label %921, label %911

911:                                              ; preds = %882
  %912 = getelementptr inbounds %struct.lua_TValue, ptr %907, i64 3
  %913 = getelementptr inbounds %struct.lua_TValue, ptr %907, i64 2
  %914 = load i64, ptr %912, align 8
  store i64 %914, ptr %913, align 8
  %915 = getelementptr inbounds %struct.lua_TValue, ptr %907, i64 2, i32 1
  store i32 %909, ptr %915, align 8, !tbaa !16
  %916 = load i32, ptr %35, align 4, !tbaa !65
  %917 = lshr i32 %916, 14
  %918 = add nsw i32 %917, -131071
  %919 = sext i32 %918 to i64
  %920 = getelementptr inbounds i32, ptr %35, i64 %919
  br label %921

921:                                              ; preds = %911, %882
  %922 = phi ptr [ %35, %882 ], [ %920, %911 ]
  %923 = getelementptr inbounds i32, ptr %922, i64 1
  br label %1042

924:                                              ; preds = %108
  %925 = lshr i32 %36, 23
  %926 = lshr i32 %36, 14
  %927 = and i32 %926, 511
  %928 = icmp ult i32 %36, 8388608
  br i1 %928, label %929, label %940

929:                                              ; preds = %924
  %930 = load ptr, ptr %13, align 8, !tbaa !7
  %931 = ptrtoint ptr %930 to i64
  %932 = ptrtoint ptr %113 to i64
  %933 = sub i64 %931, %932
  %934 = lshr exact i64 %933, 4
  %935 = trunc i64 %934 to i32
  %936 = add nsw i32 %935, -1
  %937 = load ptr, ptr %6, align 8, !tbaa !19
  %938 = getelementptr inbounds %struct.CallInfo, ptr %937, i64 0, i32 2
  %939 = load ptr, ptr %938, align 8, !tbaa !20
  store ptr %939, ptr %13, align 8, !tbaa !7
  br label %940

940:                                              ; preds = %929, %924
  %941 = phi i32 [ %936, %929 ], [ %925, %924 ]
  %942 = icmp eq i32 %927, 0
  br i1 %942, label %943, label %946

943:                                              ; preds = %940
  %944 = getelementptr inbounds i32, ptr %33, i64 2
  %945 = load i32, ptr %35, align 4, !tbaa !65
  br label %946

946:                                              ; preds = %943, %940
  %947 = phi i32 [ %945, %943 ], [ %927, %940 ]
  %948 = phi ptr [ %944, %943 ], [ %35, %940 ]
  %949 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  %950 = load i32, ptr %949, align 8, !tbaa !16
  %951 = icmp eq i32 %950, 5
  br i1 %951, label %952, label %1042

952:                                              ; preds = %946
  %953 = load ptr, ptr %113, align 8, !tbaa !33
  %954 = mul i32 %947, 50
  %955 = add i32 %941, -50
  %956 = add i32 %955, %954
  %957 = getelementptr inbounds %struct.Table, ptr %953, i64 0, i32 10
  %958 = load i32, ptr %957, align 8, !tbaa !205
  %959 = icmp sgt i32 %956, %958
  br i1 %959, label %960, label %961

960:                                              ; preds = %952
  call void @luaH_resizearray(ptr noundef nonnull %0, ptr noundef nonnull %953, i32 noundef %956) #46
  br label %961

961:                                              ; preds = %960, %952
  %962 = icmp sgt i32 %941, 0
  br i1 %962, label %963, label %1042

963:                                              ; preds = %961
  %964 = getelementptr inbounds %struct.GCheader, ptr %953, i64 0, i32 2
  %965 = zext i32 %941 to i64
  br label %966

966:                                              ; preds = %989, %963
  %967 = phi i64 [ %965, %963 ], [ %990, %989 ]
  %968 = phi i32 [ %956, %963 ], [ %970, %989 ]
  %969 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 %967
  %970 = add nsw i32 %968, -1
  %971 = call ptr @luaH_setnum(ptr noundef %0, ptr noundef %953, i32 noundef %968) #46
  %972 = load i64, ptr %969, align 8
  store i64 %972, ptr %971, align 8
  %973 = getelementptr inbounds %struct.lua_TValue, ptr %113, i64 %967, i32 1
  %974 = load i32, ptr %973, align 8, !tbaa !16
  %975 = getelementptr inbounds %struct.lua_TValue, ptr %971, i64 0, i32 1
  store i32 %974, ptr %975, align 8, !tbaa !16
  %976 = load i32, ptr %973, align 8, !tbaa !16
  %977 = icmp sgt i32 %976, 3
  br i1 %977, label %978, label %989

978:                                              ; preds = %966
  %979 = load ptr, ptr %969, align 8, !tbaa !33
  %980 = getelementptr inbounds %struct.GCheader, ptr %979, i64 0, i32 2
  %981 = load i8, ptr %980, align 1, !tbaa !33
  %982 = and i8 %981, 3
  %983 = icmp eq i8 %982, 0
  br i1 %983, label %989, label %984

984:                                              ; preds = %978
  %985 = load i8, ptr %964, align 1, !tbaa !33
  %986 = and i8 %985, 4
  %987 = icmp eq i8 %986, 0
  br i1 %987, label %989, label %988

988:                                              ; preds = %984
  call void @luaC_barrierback(ptr noundef %0, ptr noundef nonnull %953) #46
  br label %989

989:                                              ; preds = %988, %984, %978, %966
  %990 = add nsw i64 %967, -1
  %991 = icmp sgt i64 %967, 1
  br i1 %991, label %966, label %1042, !llvm.loop !375

992:                                              ; preds = %108
  call void @luaF_close(ptr noundef nonnull %0, ptr noundef %113) #46
  br label %1042

993:                                              ; preds = %108
  %994 = load ptr, ptr %27, align 8, !tbaa !141
  %995 = getelementptr inbounds %struct.Proto, ptr %994, i64 0, i32 5
  %996 = load ptr, ptr %995, align 8, !tbaa !121
  %997 = lshr i32 %36, 14
  %998 = zext i32 %997 to i64
  %999 = getelementptr inbounds ptr, ptr %996, i64 %998
  %1000 = load ptr, ptr %999, align 8, !tbaa !39
  %1001 = getelementptr inbounds %struct.Proto, ptr %1000, i64 0, i32 19
  %1002 = load i8, ptr %1001, align 8, !tbaa !118
  %1003 = zext i8 %1002 to i32
  %1004 = load ptr, ptr %31, align 8, !tbaa !373
  %1005 = call ptr @luaF_newLclosure(ptr noundef nonnull %0, i32 noundef %1003, ptr noundef %1004) #46
  %1006 = getelementptr inbounds %struct.LClosure, ptr %1005, i64 0, i32 7
  store ptr %1000, ptr %1006, align 8, !tbaa !33
  %1007 = icmp eq i8 %1002, 0
  br i1 %1007, label %1030, label %1008

1008:                                             ; preds = %993
  %1009 = zext i8 %1002 to i64
  br label %1010

1010:                                             ; preds = %1024, %1008
  %1011 = phi i64 [ 0, %1008 ], [ %1027, %1024 ]
  %1012 = phi ptr [ %35, %1008 ], [ %1028, %1024 ]
  %1013 = load i32, ptr %1012, align 4, !tbaa !65
  %1014 = and i32 %1013, 63
  %1015 = icmp eq i32 %1014, 4
  %1016 = lshr i32 %1013, 23
  %1017 = zext i32 %1016 to i64
  br i1 %1015, label %1018, label %1021

1018:                                             ; preds = %1010
  %1019 = getelementptr inbounds %struct.LClosure, ptr %25, i64 0, i32 8, i64 %1017
  %1020 = load ptr, ptr %1019, align 8, !tbaa !39
  br label %1024

1021:                                             ; preds = %1010
  %1022 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %1017
  %1023 = call ptr @luaF_findupval(ptr noundef %0, ptr noundef %1022) #46
  br label %1024

1024:                                             ; preds = %1021, %1018
  %1025 = phi ptr [ %1020, %1018 ], [ %1023, %1021 ]
  %1026 = getelementptr inbounds %struct.LClosure, ptr %1005, i64 0, i32 8, i64 %1011
  store ptr %1025, ptr %1026, align 8
  %1027 = add nuw nsw i64 %1011, 1
  %1028 = getelementptr inbounds i32, ptr %1012, i64 1
  %1029 = icmp eq i64 %1027, %1009
  br i1 %1029, label %1030, label %1010, !llvm.loop !376

1030:                                             ; preds = %1024, %993
  %1031 = phi ptr [ %35, %993 ], [ %1028, %1024 ]
  store ptr %1005, ptr %113, align 8, !tbaa !33
  %1032 = getelementptr inbounds %struct.lua_TValue, ptr %109, i64 %112, i32 1
  store i32 6, ptr %1032, align 8, !tbaa !16
  store ptr %1031, ptr %5, align 8, !tbaa !102
  %1033 = load ptr, ptr %14, align 8, !tbaa !25
  %1034 = getelementptr inbounds %struct.global_State, ptr %1033, i64 0, i32 14
  %1035 = load i64, ptr %1034, align 8, !tbaa !31
  %1036 = getelementptr inbounds %struct.global_State, ptr %1033, i64 0, i32 13
  %1037 = load i64, ptr %1036, align 8, !tbaa !32
  %1038 = icmp ult i64 %1035, %1037
  br i1 %1038, label %1040, label %1039

1039:                                             ; preds = %1030
  call void @luaC_step(ptr noundef nonnull %0) #46
  br label %1040

1040:                                             ; preds = %1039, %1030
  %1041 = load ptr, ptr %7, align 8, !tbaa !17
  br label %1042

1042:                                             ; preds = %1099, %1079, %1040, %992, %989, %961, %946, %921, %873, %839, %837, %835, %804, %749, %725, %698, %675, %613, %582, %540, %531, %516, %506, %501, %491, %479, %475, %466, %461, %433, %425, %397, %392, %364, %359, %331, %326, %298, %293, %247, %245, %210, %209, %204, %198, %185, %179, %164, %158, %147, %142, %131, %123, %115, %108
  %1043 = phi ptr [ %35, %1079 ], [ %948, %961 ], [ %35, %108 ], [ %948, %946 ], [ %35, %835 ], [ %35, %837 ], [ %843, %839 ], [ %35, %804 ], [ %35, %749 ], [ %35, %501 ], [ %35, %506 ], [ %35, %516 ], [ %35, %475 ], [ %35, %479 ], [ %35, %461 ], [ %35, %466 ], [ %35, %425 ], [ %35, %433 ], [ %35, %392 ], [ %35, %397 ], [ %35, %359 ], [ %35, %364 ], [ %35, %326 ], [ %35, %331 ], [ %35, %293 ], [ %35, %298 ], [ %35, %185 ], [ %35, %198 ], [ %35, %204 ], [ %35, %209 ], [ %35, %115 ], [ %35, %123 ], [ %137, %131 ], [ %35, %147 ], [ %35, %158 ], [ %35, %164 ], [ %35, %179 ], [ %35, %210 ], [ %35, %245 ], [ %35, %247 ], [ %35, %491 ], [ %35, %531 ], [ %544, %540 ], [ %585, %582 ], [ %616, %613 ], [ %678, %675 ], [ %700, %698 ], [ %727, %725 ], [ %881, %873 ], [ %923, %921 ], [ %35, %992 ], [ %1031, %1040 ], [ %35, %142 ], [ %948, %989 ], [ %35, %1099 ]
  %1044 = phi ptr [ %1082, %1079 ], [ %109, %961 ], [ %109, %108 ], [ %109, %946 ], [ %109, %835 ], [ %109, %837 ], [ %109, %839 ], [ %805, %804 ], [ %750, %749 ], [ %109, %501 ], [ %109, %506 ], [ %517, %516 ], [ %109, %475 ], [ %480, %479 ], [ %109, %461 ], [ %467, %466 ], [ %109, %425 ], [ %434, %433 ], [ %109, %392 ], [ %398, %397 ], [ %109, %359 ], [ %365, %364 ], [ %109, %326 ], [ %332, %331 ], [ %109, %293 ], [ %299, %298 ], [ %109, %185 ], [ %109, %198 ], [ %109, %204 ], [ %109, %209 ], [ %109, %115 ], [ %109, %123 ], [ %109, %131 ], [ %109, %147 ], [ %163, %158 ], [ %178, %164 ], [ %184, %179 ], [ %229, %210 ], [ %246, %245 ], [ %266, %247 ], [ %109, %491 ], [ %532, %531 ], [ %109, %540 ], [ %584, %582 ], [ %615, %613 ], [ %677, %675 ], [ %109, %698 ], [ %109, %725 ], [ %109, %873 ], [ %903, %921 ], [ %109, %992 ], [ %1041, %1040 ], [ %109, %142 ], [ %109, %989 ], [ %1082, %1099 ]
  br label %32

1045:                                             ; preds = %108
  %1046 = lshr i32 %36, 23
  %1047 = add nsw i32 %1046, -1
  %1048 = load ptr, ptr %6, align 8, !tbaa !19
  %1049 = load ptr, ptr %1048, align 8, !tbaa !100
  %1050 = getelementptr inbounds %struct.CallInfo, ptr %1048, i64 0, i32 1
  %1051 = load ptr, ptr %1050, align 8, !tbaa !36
  %1052 = ptrtoint ptr %1049 to i64
  %1053 = ptrtoint ptr %1051 to i64
  %1054 = sub i64 %1052, %1053
  %1055 = lshr exact i64 %1054, 4
  %1056 = trunc i64 %1055 to i32
  %1057 = load ptr, ptr %27, align 8, !tbaa !141
  %1058 = getelementptr inbounds %struct.Proto, ptr %1057, i64 0, i32 20
  %1059 = load i8, ptr %1058, align 1, !tbaa !116
  %1060 = zext i8 %1059 to i32
  %1061 = xor i32 %1060, -1
  %1062 = add i32 %1056, %1061
  %1063 = icmp ult i32 %36, 8388608
  br i1 %1063, label %1064, label %1079

1064:                                             ; preds = %1045
  store ptr %35, ptr %5, align 8, !tbaa !102
  %1065 = load ptr, ptr %12, align 8, !tbaa !18
  %1066 = load ptr, ptr %13, align 8, !tbaa !7
  %1067 = ptrtoint ptr %1065 to i64
  %1068 = ptrtoint ptr %1066 to i64
  %1069 = sub i64 %1067, %1068
  %1070 = shl nsw i32 %1062, 4
  %1071 = sext i32 %1070 to i64
  %1072 = icmp sgt i64 %1069, %1071
  br i1 %1072, label %1074, label %1073

1073:                                             ; preds = %1064
  call void @luaD_growstack(ptr noundef nonnull %0, i32 noundef %1062) #46
  br label %1074

1074:                                             ; preds = %1073, %1064
  %1075 = load ptr, ptr %7, align 8, !tbaa !17
  %1076 = getelementptr inbounds %struct.lua_TValue, ptr %1075, i64 %112
  %1077 = sext i32 %1062 to i64
  %1078 = getelementptr inbounds %struct.lua_TValue, ptr %1076, i64 %1077
  store ptr %1078, ptr %13, align 8, !tbaa !7
  br label %1079

1079:                                             ; preds = %1074, %1045
  %1080 = phi i32 [ %1062, %1074 ], [ %1047, %1045 ]
  %1081 = phi ptr [ %1076, %1074 ], [ %113, %1045 ]
  %1082 = phi ptr [ %1075, %1074 ], [ %109, %1045 ]
  %1083 = icmp sgt i32 %1080, 0
  br i1 %1083, label %1084, label %1042

1084:                                             ; preds = %1079
  %1085 = sext i32 %1062 to i64
  %1086 = sub nsw i64 0, %1085
  %1087 = zext i32 %1080 to i64
  br label %1088

1088:                                             ; preds = %1099, %1084
  %1089 = phi i64 [ 0, %1084 ], [ %1102, %1099 ]
  %1090 = icmp slt i64 %1089, %1085
  br i1 %1090, label %1091, label %1099

1091:                                             ; preds = %1088
  %1092 = load ptr, ptr %1048, align 8, !tbaa !100
  %1093 = getelementptr inbounds %struct.lua_TValue, ptr %1092, i64 %1086
  %1094 = getelementptr inbounds %struct.lua_TValue, ptr %1093, i64 %1089
  %1095 = getelementptr inbounds %struct.lua_TValue, ptr %1081, i64 %1089
  %1096 = load i64, ptr %1094, align 8
  store i64 %1096, ptr %1095, align 8
  %1097 = getelementptr inbounds %struct.lua_TValue, ptr %1093, i64 %1089, i32 1
  %1098 = load i32, ptr %1097, align 8, !tbaa !16
  br label %1099

1099:                                             ; preds = %1091, %1088
  %1100 = phi i32 [ %1098, %1091 ], [ 0, %1088 ]
  %1101 = getelementptr inbounds %struct.lua_TValue, ptr %1081, i64 %1089, i32 1
  store i32 %1100, ptr %1101, align 8
  %1102 = add nuw nsw i64 %1089, 1
  %1103 = icmp eq i64 %1102, %1087
  br i1 %1103, label %1042, label %1088, !llvm.loop !377

1104:                                             ; preds = %817, %757, %737, %105
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @Arith(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, i32 noundef %4) unnamed_addr #1 {
  %6 = alloca %struct.lua_TValue, align 8
  %7 = alloca %struct.lua_TValue, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %6) #48
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %7) #48
  %8 = call ptr @luaV_tonumber(ptr noundef %2, ptr noundef nonnull %6) #47
  %9 = icmp eq ptr %8, null
  br i1 %9, label %40, label %10

10:                                               ; preds = %5
  %11 = call ptr @luaV_tonumber(ptr noundef %3, ptr noundef nonnull %7) #47
  %12 = icmp eq ptr %11, null
  br i1 %12, label %40, label %13

13:                                               ; preds = %10
  %14 = load double, ptr %8, align 8, !tbaa !33
  %15 = load double, ptr %11, align 8, !tbaa !33
  switch i32 %4, label %44 [
    i32 5, label %16
    i32 6, label %19
    i32 7, label %22
    i32 8, label %25
    i32 9, label %28
    i32 10, label %34
    i32 11, label %37
  ]

16:                                               ; preds = %13
  %17 = fadd double %14, %15
  store double %17, ptr %1, align 8, !tbaa !33
  %18 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 3, ptr %18, align 8, !tbaa !16
  br label %44

19:                                               ; preds = %13
  %20 = fsub double %14, %15
  store double %20, ptr %1, align 8, !tbaa !33
  %21 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 3, ptr %21, align 8, !tbaa !16
  br label %44

22:                                               ; preds = %13
  %23 = fmul double %14, %15
  store double %23, ptr %1, align 8, !tbaa !33
  %24 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 3, ptr %24, align 8, !tbaa !16
  br label %44

25:                                               ; preds = %13
  %26 = fdiv double %14, %15
  store double %26, ptr %1, align 8, !tbaa !33
  %27 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 3, ptr %27, align 8, !tbaa !16
  br label %44

28:                                               ; preds = %13
  %29 = fdiv double %14, %15
  %30 = call double @llvm.floor.f64(double %29)
  %31 = fneg double %30
  %32 = call double @llvm.fmuladd.f64(double %31, double %15, double %14)
  store double %32, ptr %1, align 8, !tbaa !33
  %33 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 3, ptr %33, align 8, !tbaa !16
  br label %44

34:                                               ; preds = %13
  %35 = call double @pow(double noundef %14, double noundef %15) #46
  store double %35, ptr %1, align 8, !tbaa !33
  %36 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 3, ptr %36, align 8, !tbaa !16
  br label %44

37:                                               ; preds = %13
  %38 = fneg double %14
  store double %38, ptr %1, align 8, !tbaa !33
  %39 = getelementptr inbounds %struct.lua_TValue, ptr %1, i64 0, i32 1
  store i32 3, ptr %39, align 8, !tbaa !16
  br label %44

40:                                               ; preds = %10, %5
  %41 = call fastcc i32 @call_binTM(ptr noundef %0, ptr noundef %2, ptr noundef %3, ptr noundef %1, i32 noundef %4) #47, !range !75
  %42 = icmp eq i32 %41, 0
  br i1 %42, label %43, label %44

43:                                               ; preds = %40
  call void @luaG_aritherror(ptr noundef %0, ptr noundef %2, ptr noundef %3) #46
  br label %44

44:                                               ; preds = %43, %40, %37, %34, %28, %25, %22, %19, %16, %13
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %7) #48
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %6) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaZ_fill(ptr nocapture noundef %0) #1 {
  %2 = alloca i64, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  %3 = getelementptr inbounds %struct.Zio, ptr %0, i64 0, i32 4
  %4 = load ptr, ptr %3, align 8, !tbaa !378
  %5 = getelementptr inbounds %struct.Zio, ptr %0, i64 0, i32 2
  %6 = load ptr, ptr %5, align 8, !tbaa !379
  %7 = getelementptr inbounds %struct.Zio, ptr %0, i64 0, i32 3
  %8 = load ptr, ptr %7, align 8, !tbaa !380
  %9 = call ptr %6(ptr noundef %4, ptr noundef %8, ptr noundef nonnull %2) #46
  %10 = icmp eq ptr %9, null
  %11 = load i64, ptr %2, align 8
  %12 = icmp eq i64 %11, 0
  %13 = select i1 %10, i1 true, i1 %12
  br i1 %13, label %20, label %14

14:                                               ; preds = %1
  %15 = add i64 %11, -1
  store i64 %15, ptr %0, align 8, !tbaa !252
  %16 = getelementptr inbounds %struct.Zio, ptr %0, i64 0, i32 1
  %17 = getelementptr inbounds i8, ptr %9, i64 1
  store ptr %17, ptr %16, align 8, !tbaa !254
  %18 = load i8, ptr %9, align 1, !tbaa !33
  %19 = zext i8 %18 to i32
  br label %20

20:                                               ; preds = %14, %1
  %21 = phi i32 [ %19, %14 ], [ -1, %1 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  ret i32 %21
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaZ_lookahead(ptr nocapture noundef %0) #1 {
  %2 = load i64, ptr %0, align 8, !tbaa !252
  %3 = icmp eq i64 %2, 0
  br i1 %3, label %7, label %4

4:                                                ; preds = %1
  %5 = getelementptr inbounds %struct.Zio, ptr %0, i64 0, i32 1
  %6 = load ptr, ptr %5, align 8, !tbaa !254
  br label %16

7:                                                ; preds = %1
  %8 = tail call i32 @luaZ_fill(ptr noundef nonnull %0) #47, !range !381
  %9 = icmp eq i32 %8, -1
  br i1 %9, label %20, label %10

10:                                               ; preds = %7
  %11 = load i64, ptr %0, align 8, !tbaa !252
  %12 = add i64 %11, 1
  store i64 %12, ptr %0, align 8, !tbaa !252
  %13 = getelementptr inbounds %struct.Zio, ptr %0, i64 0, i32 1
  %14 = load ptr, ptr %13, align 8, !tbaa !254
  %15 = getelementptr inbounds i8, ptr %14, i64 -1
  store ptr %15, ptr %13, align 8, !tbaa !254
  br label %16

16:                                               ; preds = %10, %4
  %17 = phi ptr [ %6, %4 ], [ %15, %10 ]
  %18 = load i8, ptr %17, align 1, !tbaa !33
  %19 = zext i8 %18 to i32
  br label %20

20:                                               ; preds = %16, %7
  %21 = phi i32 [ %19, %16 ], [ -1, %7 ]
  ret i32 %21
}

; Function Attrs: mustprogress nofree nosync nounwind optsize willreturn memory(argmem: write) uwtable
define internal void @luaZ_init(ptr noundef %0, ptr nocapture noundef writeonly %1, ptr noundef %2, ptr noundef %3) #38 {
  %5 = getelementptr inbounds %struct.Zio, ptr %1, i64 0, i32 4
  store ptr %0, ptr %5, align 8, !tbaa !378
  %6 = getelementptr inbounds %struct.Zio, ptr %1, i64 0, i32 2
  store ptr %2, ptr %6, align 8, !tbaa !379
  %7 = getelementptr inbounds %struct.Zio, ptr %1, i64 0, i32 3
  store ptr %3, ptr %7, align 8, !tbaa !380
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %1, i8 0, i64 16, i1 false)
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i64 @luaZ_read(ptr nocapture noundef %0, ptr nocapture noundef writeonly %1, i64 noundef %2) #1 {
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %23, label %5

5:                                                ; preds = %3
  %6 = getelementptr inbounds %struct.Zio, ptr %0, i64 0, i32 1
  br label %7

7:                                                ; preds = %12, %5
  %8 = phi i64 [ %2, %5 ], [ %21, %12 ]
  %9 = phi ptr [ %1, %5 ], [ %20, %12 ]
  %10 = tail call i32 @luaZ_lookahead(ptr noundef %0) #47, !range !381
  %11 = icmp eq i32 %10, -1
  br i1 %11, label %23, label %12

12:                                               ; preds = %7
  %13 = load i64, ptr %0, align 8, !tbaa !252
  %14 = tail call i64 @llvm.umin.i64(i64 %8, i64 %13)
  %15 = load ptr, ptr %6, align 8, !tbaa !254
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 1 %9, ptr align 1 %15, i64 %14, i1 false)
  %16 = load i64, ptr %0, align 8, !tbaa !252
  %17 = sub i64 %16, %14
  store i64 %17, ptr %0, align 8, !tbaa !252
  %18 = load ptr, ptr %6, align 8, !tbaa !254
  %19 = getelementptr inbounds i8, ptr %18, i64 %14
  store ptr %19, ptr %6, align 8, !tbaa !254
  %20 = getelementptr inbounds i8, ptr %9, i64 %14
  %21 = sub i64 %8, %14
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %23, label %7

23:                                               ; preds = %12, %7, %3
  %24 = phi i64 [ 0, %3 ], [ %8, %7 ], [ 0, %12 ]
  ret i64 %24
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaZ_openspace(ptr noundef %0, ptr nocapture noundef %1, i64 noundef %2) #1 {
  %4 = getelementptr inbounds %struct.Mbuffer, ptr %1, i64 0, i32 2
  %5 = load i64, ptr %4, align 8, !tbaa !246
  %6 = icmp ult i64 %5, %2
  br i1 %6, label %9, label %7

7:                                                ; preds = %3
  %8 = load ptr, ptr %1, align 8, !tbaa !244
  br label %20

9:                                                ; preds = %3
  %10 = tail call i64 @llvm.umax.i64(i64 %2, i64 32)
  %11 = add i64 %10, 1
  %12 = icmp ult i64 %11, -2
  br i1 %12, label %13, label %16

13:                                               ; preds = %9
  %14 = load ptr, ptr %1, align 8, !tbaa !244
  %15 = tail call ptr @luaM_realloc_(ptr noundef %0, ptr noundef %14, i64 noundef %5, i64 noundef %10) #46
  br label %18

16:                                               ; preds = %9
  %17 = tail call ptr @luaM_toobig(ptr noundef %0) #46
  br label %18

18:                                               ; preds = %16, %13
  %19 = phi ptr [ %15, %13 ], [ %17, %16 ]
  store ptr %19, ptr %1, align 8, !tbaa !244
  store i64 %10, ptr %4, align 8, !tbaa !246
  br label %20

20:                                               ; preds = %18, %7
  %21 = phi ptr [ %8, %7 ], [ %19, %18 ]
  ret ptr %21
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umax.i64(i64, i64) #12

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaL_argerror(ptr noundef %0, i32 noundef %1, ptr noundef %2) #1 {
  %4 = alloca %struct.lua_Debug, align 8
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %4) #48
  %5 = call i32 @lua_getstack(ptr noundef %0, i32 noundef 0, ptr noundef nonnull %4) #46
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %9

7:                                                ; preds = %3
  %8 = call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.268, i32 noundef %1, ptr noundef %2) #47
  br label %31

9:                                                ; preds = %3
  %10 = call i32 @lua_getinfo(ptr noundef %0, ptr noundef nonnull @.str.1.269, ptr noundef nonnull %4) #46
  %11 = getelementptr inbounds %struct.lua_Debug, ptr %4, i64 0, i32 2
  %12 = load ptr, ptr %11, align 8, !tbaa !110
  %13 = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %12, ptr noundef nonnull dereferenceable(7) @.str.2.270) #49
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %22

15:                                               ; preds = %9
  %16 = add nsw i32 %1, -1
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %22

18:                                               ; preds = %15
  %19 = getelementptr inbounds %struct.lua_Debug, ptr %4, i64 0, i32 1
  %20 = load ptr, ptr %19, align 8, !tbaa !111
  %21 = call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.3.271, ptr noundef %20, ptr noundef %2) #47
  br label %31

22:                                               ; preds = %15, %9
  %23 = phi i32 [ %16, %15 ], [ %1, %9 ]
  %24 = getelementptr inbounds %struct.lua_Debug, ptr %4, i64 0, i32 1
  %25 = load ptr, ptr %24, align 8, !tbaa !111
  %26 = icmp eq ptr %25, null
  br i1 %26, label %27, label %28

27:                                               ; preds = %22
  store ptr @.str.4.272, ptr %24, align 8, !tbaa !111
  br label %28

28:                                               ; preds = %27, %22
  %29 = phi ptr [ @.str.4.272, %27 ], [ %25, %22 ]
  %30 = call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.5.273, i32 noundef %23, ptr noundef nonnull %29, ptr noundef %2) #47
  br label %31

31:                                               ; preds = %28, %18, %7
  %32 = phi i32 [ %21, %18 ], [ %30, %28 ], [ %8, %7 ]
  call void @llvm.lifetime.end.p0(i64 120, ptr nonnull %4) #48
  ret i32 %32
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaL_error(ptr noundef %0, ptr noundef %1, ...) #1 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3) #48
  call void @llvm.va_start(ptr nonnull %3)
  call void @luaL_where(ptr noundef %0, i32 noundef 1) #47
  %4 = call ptr @lua_pushvfstring(ptr noundef %0, ptr noundef %1, ptr noundef nonnull %3) #46
  call void @llvm.va_end(ptr nonnull %3)
  call void @lua_concat(ptr noundef %0, i32 noundef 2) #46
  %5 = call i32 @lua_error(ptr noundef %0) #46
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3) #48
  ret i32 %5
}

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(argmem: read)
declare i32 @strcmp(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #10

; Function Attrs: nounwind optsize uwtable
define internal void @luaL_where(ptr noundef %0, i32 noundef %1) #1 {
  %3 = alloca %struct.lua_Debug, align 8
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %3) #48
  %4 = call i32 @lua_getstack(ptr noundef %0, i32 noundef %1, ptr noundef nonnull %3) #46
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %14, label %6

6:                                                ; preds = %2
  %7 = call i32 @lua_getinfo(ptr noundef %0, ptr noundef nonnull @.str.7.274, ptr noundef nonnull %3) #46
  %8 = getelementptr inbounds %struct.lua_Debug, ptr %3, i64 0, i32 5
  %9 = load i32, ptr %8, align 8, !tbaa !108
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %14

11:                                               ; preds = %6
  %12 = getelementptr inbounds %struct.lua_Debug, ptr %3, i64 0, i32 9
  %13 = call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.8.275, ptr noundef nonnull %12, i32 noundef %9) #46
  br label %15

14:                                               ; preds = %6, %2
  call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.9.276, i64 noundef 0) #46
  br label %15

15:                                               ; preds = %14, %11
  call void @llvm.lifetime.end.p0(i64 120, ptr nonnull %3) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaL_typerror(ptr noundef %0, i32 noundef %1, ptr noundef %2) #1 {
  %4 = tail call i32 @lua_type(ptr noundef %0, i32 noundef %1) #46
  %5 = tail call ptr @lua_typename(ptr noundef %0, i32 noundef %4) #46
  %6 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.6.277, ptr noundef %2, ptr noundef %5) #46
  %7 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef %1, ptr noundef %6) #47
  ret i32 %7
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaL_checkoption(ptr noundef %0, i32 noundef %1, ptr noundef %2, ptr nocapture noundef readonly %3) #1 {
  %5 = icmp eq ptr %2, null
  br i1 %5, label %9, label %6

6:                                                ; preds = %4
  %7 = tail call i32 @lua_type(ptr noundef %0, i32 noundef %1) #46
  %8 = icmp slt i32 %7, 1
  br i1 %8, label %11, label %9

9:                                                ; preds = %6, %4
  %10 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef %1, ptr noundef null) #47
  br label %11

11:                                               ; preds = %9, %6
  %12 = phi ptr [ %2, %6 ], [ %10, %9 ]
  %13 = load ptr, ptr %3, align 8, !tbaa !39
  %14 = icmp eq ptr %13, null
  br i1 %14, label %25, label %15

15:                                               ; preds = %20, %11
  %16 = phi i64 [ %21, %20 ], [ 0, %11 ]
  %17 = phi ptr [ %23, %20 ], [ %13, %11 ]
  %18 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %17, ptr noundef nonnull dereferenceable(1) %12) #49
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %28, label %20

20:                                               ; preds = %15
  %21 = add nuw i64 %16, 1
  %22 = getelementptr inbounds ptr, ptr %3, i64 %21
  %23 = load ptr, ptr %22, align 8, !tbaa !39
  %24 = icmp eq ptr %23, null
  br i1 %24, label %25, label %15, !llvm.loop !382

25:                                               ; preds = %20, %11
  %26 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.10.278, ptr noundef %12) #46
  %27 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef %1, ptr noundef %26) #47
  br label %30

28:                                               ; preds = %15
  %.lcssa = phi i64 [ %16, %15 ]
  %29 = trunc i64 %.lcssa to i32
  br label %30

30:                                               ; preds = %28, %25
  %31 = phi i32 [ %27, %25 ], [ %29, %28 ]
  ret i32 %31
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaL_checklstring(ptr noundef %0, i32 noundef %1, ptr noundef %2) #1 {
  %4 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef %1, ptr noundef %2) #46
  %5 = icmp eq ptr %4, null
  br i1 %5, label %6, label %9

6:                                                ; preds = %3
  %7 = tail call ptr @lua_typename(ptr noundef %0, i32 noundef 4) #46
  %8 = tail call i32 @luaL_typerror(ptr noundef %0, i32 noundef %1, ptr noundef %7) #47
  br label %9

9:                                                ; preds = %6, %3
  ret ptr %4
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaL_optlstring(ptr noundef %0, i32 noundef %1, ptr noundef readonly %2, ptr noundef %3) #1 {
  %5 = tail call i32 @lua_type(ptr noundef %0, i32 noundef %1) #46
  %6 = icmp slt i32 %5, 1
  br i1 %6, label %7, label %15

7:                                                ; preds = %4
  %8 = icmp eq ptr %3, null
  br i1 %8, label %17, label %9

9:                                                ; preds = %7
  %10 = icmp eq ptr %2, null
  br i1 %10, label %13, label %11

11:                                               ; preds = %9
  %12 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %2) #49
  br label %13

13:                                               ; preds = %11, %9
  %14 = phi i64 [ %12, %11 ], [ 0, %9 ]
  store i64 %14, ptr %3, align 8, !tbaa !40
  br label %17

15:                                               ; preds = %4
  %16 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef %1, ptr noundef %3) #47
  br label %17

17:                                               ; preds = %15, %13, %7
  %18 = phi ptr [ %16, %15 ], [ %2, %13 ], [ %2, %7 ]
  ret ptr %18
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaL_newmetatable(ptr noundef %0, ptr noundef %1) #1 {
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -10000, ptr noundef %1) #46
  %3 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %2
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_createtable(ptr noundef %0, i32 noundef 0, i32 noundef 0) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -1) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -10000, ptr noundef %1) #46
  br label %6

6:                                                ; preds = %5, %2
  %7 = phi i32 [ 1, %5 ], [ 0, %2 ]
  ret i32 %7
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaL_checkudata(ptr noundef %0, i32 noundef %1, ptr noundef %2) #1 {
  %4 = tail call ptr @lua_touserdata(ptr noundef %0, i32 noundef %1) #46
  %5 = icmp eq ptr %4, null
  br i1 %5, label %13, label %6

6:                                                ; preds = %3
  %7 = tail call i32 @lua_getmetatable(ptr noundef %0, i32 noundef %1) #46
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %13, label %9

9:                                                ; preds = %6
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -10000, ptr noundef %2) #46
  %10 = tail call i32 @lua_rawequal(ptr noundef %0, i32 noundef -1, i32 noundef -2) #46
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %13, label %12

12:                                               ; preds = %9
  tail call void @lua_settop(ptr noundef %0, i32 noundef -3) #46
  br label %15

13:                                               ; preds = %9, %6, %3
  %14 = tail call i32 @luaL_typerror(ptr noundef %0, i32 noundef %1, ptr noundef %2) #47
  br label %15

15:                                               ; preds = %13, %12
  %16 = phi ptr [ %4, %12 ], [ null, %13 ]
  ret ptr %16
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaL_checkstack(ptr noundef %0, i32 noundef %1, ptr noundef %2) #1 {
  %4 = tail call i32 @lua_checkstack(ptr noundef %0, i32 noundef %1) #46
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %8

6:                                                ; preds = %3
  %7 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.11.279, ptr noundef %2) #47
  br label %8

8:                                                ; preds = %6, %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaL_checktype(ptr noundef %0, i32 noundef %1, i32 noundef %2) #1 {
  %4 = tail call i32 @lua_type(ptr noundef %0, i32 noundef %1) #46
  %5 = icmp eq i32 %4, %2
  br i1 %5, label %9, label %6

6:                                                ; preds = %3
  %7 = tail call ptr @lua_typename(ptr noundef %0, i32 noundef %2) #46
  %8 = tail call i32 @luaL_typerror(ptr noundef %0, i32 noundef %1, ptr noundef %7) #47
  br label %9

9:                                                ; preds = %6, %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaL_checkany(ptr noundef %0, i32 noundef %1) #1 {
  %3 = tail call i32 @lua_type(ptr noundef %0, i32 noundef %1) #46
  %4 = icmp eq i32 %3, -1
  br i1 %4, label %5, label %7

5:                                                ; preds = %2
  %6 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef %1, ptr noundef nonnull @.str.12.280) #47
  br label %7

7:                                                ; preds = %5, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal double @luaL_checknumber(ptr noundef %0, i32 noundef %1) #1 {
  %3 = tail call double @lua_tonumber(ptr noundef %0, i32 noundef %1) #46
  %4 = fcmp oeq double %3, 0.000000e+00
  br i1 %4, label %5, label %11

5:                                                ; preds = %2
  %6 = tail call i32 @lua_isnumber(ptr noundef %0, i32 noundef %1) #46
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %11

8:                                                ; preds = %5
  %9 = tail call ptr @lua_typename(ptr noundef %0, i32 noundef 3) #46
  %10 = tail call i32 @luaL_typerror(ptr noundef %0, i32 noundef %1, ptr noundef %9) #47
  br label %11

11:                                               ; preds = %8, %5, %2
  ret double %3
}

; Function Attrs: nounwind optsize uwtable
define internal double @luaL_optnumber(ptr noundef %0, i32 noundef %1, double noundef %2) #1 {
  %4 = tail call i32 @lua_type(ptr noundef %0, i32 noundef %1) #46
  %5 = icmp slt i32 %4, 1
  br i1 %5, label %8, label %6

6:                                                ; preds = %3
  %7 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef %1) #47
  br label %8

8:                                                ; preds = %6, %3
  %9 = phi double [ %7, %6 ], [ %2, %3 ]
  ret double %9
}

; Function Attrs: nounwind optsize uwtable
define internal i64 @luaL_checkinteger(ptr noundef %0, i32 noundef %1) #1 {
  %3 = tail call i64 @lua_tointeger(ptr noundef %0, i32 noundef %1) #46
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %5, label %11

5:                                                ; preds = %2
  %6 = tail call i32 @lua_isnumber(ptr noundef %0, i32 noundef %1) #46
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %11

8:                                                ; preds = %5
  %9 = tail call ptr @lua_typename(ptr noundef %0, i32 noundef 3) #46
  %10 = tail call i32 @luaL_typerror(ptr noundef %0, i32 noundef %1, ptr noundef %9) #47
  br label %11

11:                                               ; preds = %8, %5, %2
  ret i64 %3
}

; Function Attrs: nounwind optsize uwtable
define internal i64 @luaL_optinteger(ptr noundef %0, i32 noundef %1, i64 noundef %2) #1 {
  %4 = tail call i32 @lua_type(ptr noundef %0, i32 noundef %1) #46
  %5 = icmp slt i32 %4, 1
  br i1 %5, label %8, label %6

6:                                                ; preds = %3
  %7 = tail call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef %1) #47
  br label %8

8:                                                ; preds = %6, %3
  %9 = phi i64 [ %7, %6 ], [ %2, %3 ]
  ret i64 %9
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaL_getmetafield(ptr noundef %0, i32 noundef %1, ptr noundef %2) #1 {
  %4 = tail call i32 @lua_getmetatable(ptr noundef %0, i32 noundef %1) #46
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %11, label %6

6:                                                ; preds = %3
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef %2) #46
  tail call void @lua_rawget(ptr noundef %0, i32 noundef -2) #46
  %7 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %9, label %10

9:                                                ; preds = %6
  tail call void @lua_settop(ptr noundef %0, i32 noundef -3) #46
  br label %11

10:                                               ; preds = %6
  tail call void @lua_remove(ptr noundef %0, i32 noundef -2) #46
  br label %11

11:                                               ; preds = %10, %9, %3
  %12 = phi i32 [ 0, %9 ], [ 1, %10 ], [ 0, %3 ]
  ret i32 %12
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaL_callmeta(ptr noundef %0, i32 noundef %1, ptr noundef %2) #1 {
  %4 = add i32 %1, -1
  %5 = icmp ult i32 %4, -10000
  br i1 %5, label %10, label %6

6:                                                ; preds = %3
  %7 = tail call i32 @lua_gettop(ptr noundef %0) #46
  %8 = add nsw i32 %1, 1
  %9 = add i32 %8, %7
  br label %10

10:                                               ; preds = %6, %3
  %11 = phi i32 [ %9, %6 ], [ %1, %3 ]
  %12 = tail call i32 @luaL_getmetafield(ptr noundef %0, i32 noundef %11, ptr noundef %2) #47, !range !75
  %13 = icmp eq i32 %12, 0
  br i1 %13, label %15, label %14

14:                                               ; preds = %10
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef %11) #46
  tail call void @lua_call(ptr noundef %0, i32 noundef 1, i32 noundef 1) #46
  br label %15

15:                                               ; preds = %14, %10
  %16 = phi i32 [ 1, %14 ], [ 0, %10 ]
  ret i32 %16
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaL_register(ptr noundef %0, ptr noundef %1, ptr nocapture noundef readonly %2) #1 {
  tail call void @luaL_openlib(ptr noundef %0, ptr noundef %1, ptr noundef %2, i32 noundef 0) #47
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaL_openlib(ptr noundef %0, ptr noundef %1, ptr nocapture noundef readonly %2, i32 noundef %3) #1 {
  %5 = icmp eq ptr %1, null
  br i1 %5, label %29, label %6

6:                                                ; preds = %4
  %7 = load ptr, ptr %2, align 8, !tbaa !383
  %8 = icmp eq ptr %7, null
  br i1 %8, label %16, label %9

9:                                                ; preds = %9, %6
  %10 = phi i32 [ %12, %9 ], [ 0, %6 ]
  %11 = phi ptr [ %13, %9 ], [ %2, %6 ]
  %12 = add nuw nsw i32 %10, 1
  %13 = getelementptr inbounds %struct.CCallS, ptr %11, i64 1
  %14 = load ptr, ptr %13, align 8, !tbaa !383
  %15 = icmp eq ptr %14, null
  br i1 %15, label %16, label %9, !llvm.loop !385

16:                                               ; preds = %9, %6
  %17 = phi i32 [ 0, %6 ], [ %12, %9 ]
  %18 = tail call ptr @luaL_findtable(ptr noundef %0, i32 noundef -10000, ptr noundef nonnull @.str.13.281, i32 noundef 1) #47
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -1, ptr noundef nonnull %1) #46
  %19 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %20 = icmp eq i32 %19, 5
  br i1 %20, label %27, label %21

21:                                               ; preds = %16
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  %22 = tail call ptr @luaL_findtable(ptr noundef %0, i32 noundef -10002, ptr noundef nonnull %1, i32 noundef %17) #47
  %23 = icmp eq ptr %22, null
  br i1 %23, label %26, label %24

24:                                               ; preds = %21
  %25 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.14.282, ptr noundef nonnull %1) #47
  br label %26

26:                                               ; preds = %24, %21
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -1) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -3, ptr noundef nonnull %1) #46
  br label %27

27:                                               ; preds = %26, %16
  tail call void @lua_remove(ptr noundef %0, i32 noundef -2) #46
  %28 = xor i32 %3, -1
  tail call void @lua_insert(ptr noundef %0, i32 noundef %28) #46
  br label %29

29:                                               ; preds = %27, %4
  %30 = load ptr, ptr %2, align 8, !tbaa !383
  %31 = icmp eq ptr %30, null
  br i1 %31, label %49, label %32

32:                                               ; preds = %29
  %33 = icmp sgt i32 %3, 0
  %34 = sub nsw i32 0, %3
  %35 = sub nsw i32 -2, %3
  br label %36

36:                                               ; preds = %42, %32
  %37 = phi ptr [ %2, %32 ], [ %46, %42 ]
  br i1 %33, label %38, label %42

38:                                               ; preds = %38, %36
  %39 = phi i32 [ %40, %38 ], [ 0, %36 ]
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef %34) #46
  %40 = add nuw nsw i32 %39, 1
  %41 = icmp eq i32 %40, %3
  br i1 %41, label %42, label %38, !llvm.loop !386

42:                                               ; preds = %38, %36
  %43 = getelementptr inbounds %struct.CCallS, ptr %37, i64 0, i32 1
  %44 = load ptr, ptr %43, align 8, !tbaa !387
  tail call void @lua_pushcclosure(ptr noundef %0, ptr noundef %44, i32 noundef %3) #46
  %45 = load ptr, ptr %37, align 8, !tbaa !383
  tail call void @lua_setfield(ptr noundef %0, i32 noundef %35, ptr noundef %45) #46
  %46 = getelementptr inbounds %struct.CCallS, ptr %37, i64 1
  %47 = load ptr, ptr %46, align 8, !tbaa !383
  %48 = icmp eq ptr %47, null
  br i1 %48, label %49, label %36, !llvm.loop !388

49:                                               ; preds = %42, %29
  %50 = xor i32 %3, -1
  tail call void @lua_settop(ptr noundef %0, i32 noundef %50) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaL_findtable(ptr noundef %0, i32 noundef %1, ptr noundef %2, i32 noundef %3) #1 {
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef %1) #46
  br label %5

5:                                                ; preds = %27, %4
  %6 = phi ptr [ %2, %4 ], [ %28, %27 ]
  %7 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %6, i32 noundef 46) #49
  %8 = icmp eq ptr %7, null
  br i1 %8, label %9, label %12

9:                                                ; preds = %5
  %10 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %6) #49
  %11 = getelementptr inbounds i8, ptr %6, i64 %10
  br label %12

12:                                               ; preds = %9, %5
  %13 = phi ptr [ %11, %9 ], [ %7, %5 ]
  %14 = ptrtoint ptr %13 to i64
  %15 = ptrtoint ptr %6 to i64
  %16 = sub i64 %14, %15
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef %6, i64 noundef %16) #46
  tail call void @lua_rawget(ptr noundef %0, i32 noundef -2) #46
  %17 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %19, label %23

19:                                               ; preds = %12
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  %20 = load i8, ptr %13, align 1, !tbaa !33
  %21 = icmp eq i8 %20, 46
  %22 = select i1 %21, i32 1, i32 %3
  tail call void @lua_createtable(ptr noundef %0, i32 noundef 0, i32 noundef %22) #46
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef %6, i64 noundef %16) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_settable(ptr noundef %0, i32 noundef -4) #46
  br label %27

23:                                               ; preds = %12
  %24 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %25 = icmp eq i32 %24, 5
  br i1 %25, label %27, label %26

26:                                               ; preds = %23
  %.lcssa = phi ptr [ %6, %23 ]
  tail call void @lua_settop(ptr noundef %0, i32 noundef -3) #46
  br label %31

27:                                               ; preds = %23, %19
  tail call void @lua_remove(ptr noundef %0, i32 noundef -2) #46
  %28 = getelementptr inbounds i8, ptr %13, i64 1
  %29 = load i8, ptr %13, align 1, !tbaa !33
  %30 = icmp eq i8 %29, 46
  br i1 %30, label %5, label %31, !llvm.loop !389

31:                                               ; preds = %27, %26
  %32 = phi ptr [ %.lcssa, %26 ], [ null, %27 ]
  ret ptr %32
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaL_gsub(ptr noundef %0, ptr noundef %1, ptr nocapture noundef readonly %2, ptr nocapture noundef readonly %3) #1 {
  %5 = alloca %struct.luaL_Buffer, align 8
  %6 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %2) #49
  call void @llvm.lifetime.start.p0(i64 8216, ptr nonnull %5) #48
  %7 = getelementptr inbounds %struct.luaL_Buffer, ptr %5, i64 0, i32 2
  store ptr %0, ptr %7, align 8, !tbaa !390
  %8 = getelementptr inbounds %struct.luaL_Buffer, ptr %5, i64 0, i32 3
  store ptr %8, ptr %5, align 8, !tbaa !392
  %9 = getelementptr inbounds %struct.luaL_Buffer, ptr %5, i64 0, i32 1
  store i32 0, ptr %9, align 8, !tbaa !393
  br label %10

10:                                               ; preds = %14, %4
  %11 = phi ptr [ %1, %4 ], [ %19, %14 ]
  %12 = call ptr @strstr(ptr noundef nonnull dereferenceable(1) %11, ptr noundef nonnull dereferenceable(1) %2) #49
  %13 = icmp eq ptr %12, null
  br i1 %13, label %20, label %14

14:                                               ; preds = %10
  %15 = ptrtoint ptr %12 to i64
  %16 = ptrtoint ptr %11 to i64
  %17 = sub i64 %15, %16
  call void @luaL_addlstring(ptr noundef nonnull %5, ptr noundef %11, i64 noundef %17) #47
  %18 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %3) #49
  call void @luaL_addlstring(ptr noundef nonnull %5, ptr noundef %3, i64 noundef %18) #47
  %19 = getelementptr inbounds i8, ptr %12, i64 %6
  br label %10, !llvm.loop !394

20:                                               ; preds = %10
  %.lcssa = phi ptr [ %11, %10 ]
  %21 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %.lcssa) #49
  call void @luaL_addlstring(ptr noundef nonnull %5, ptr noundef %.lcssa, i64 noundef %21) #47
  %22 = call fastcc i32 @emptybuffer(ptr noundef nonnull %5) #47, !range !75
  %23 = load ptr, ptr %7, align 8, !tbaa !390
  %24 = load i32, ptr %9, align 8, !tbaa !393
  call void @lua_concat(ptr noundef %23, i32 noundef %24) #46
  store i32 1, ptr %9, align 8, !tbaa !393
  %25 = call ptr @lua_tolstring(ptr noundef %0, i32 noundef -1, ptr noundef null) #46
  call void @llvm.lifetime.end.p0(i64 8216, ptr nonnull %5) #48
  ret ptr %25
}

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(argmem: read)
declare ptr @strstr(ptr noundef, ptr nocapture noundef) local_unnamed_addr #10

; Function Attrs: nounwind optsize uwtable
define internal void @luaL_addlstring(ptr noundef %0, ptr nocapture noundef readonly %1, i64 noundef %2) #1 {
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %23, label %5

5:                                                ; preds = %3
  %6 = getelementptr inbounds %struct.luaL_Buffer, ptr %0, i64 1
  br label %7

7:                                                ; preds = %17, %5
  %8 = phi i64 [ %2, %5 ], [ %10, %17 ]
  %9 = phi ptr [ %1, %5 ], [ %18, %17 ]
  %10 = add i64 %8, -1
  %11 = load ptr, ptr %0, align 8, !tbaa !392
  %12 = icmp ult ptr %11, %6
  br i1 %12, label %17, label %13

13:                                               ; preds = %7
  %14 = tail call fastcc i32 @emptybuffer(ptr noundef nonnull %0) #47, !range !75
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %17, label %16

16:                                               ; preds = %13
  tail call fastcc void @adjuststack(ptr noundef nonnull %0) #47
  br label %17

17:                                               ; preds = %16, %13, %7
  %18 = getelementptr inbounds i8, ptr %9, i64 1
  %19 = load i8, ptr %9, align 1, !tbaa !33
  %20 = load ptr, ptr %0, align 8, !tbaa !392
  %21 = getelementptr inbounds i8, ptr %20, i64 1
  store ptr %21, ptr %0, align 8, !tbaa !392
  store i8 %19, ptr %20, align 1, !tbaa !33
  %22 = icmp eq i64 %10, 0
  br i1 %22, label %23, label %7, !llvm.loop !395

23:                                               ; preds = %17, %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @emptybuffer(ptr noundef %0) unnamed_addr #1 {
  %2 = load ptr, ptr %0, align 8, !tbaa !392
  %3 = getelementptr inbounds %struct.luaL_Buffer, ptr %0, i64 0, i32 3
  %4 = icmp eq ptr %2, %3
  br i1 %4, label %14, label %5

5:                                                ; preds = %1
  %6 = ptrtoint ptr %3 to i64
  %7 = ptrtoint ptr %2 to i64
  %8 = sub i64 %7, %6
  %9 = getelementptr inbounds %struct.luaL_Buffer, ptr %0, i64 0, i32 2
  %10 = load ptr, ptr %9, align 8, !tbaa !390
  tail call void @lua_pushlstring(ptr noundef %10, ptr noundef nonnull %3, i64 noundef %8) #46
  store ptr %3, ptr %0, align 8, !tbaa !392
  %11 = getelementptr inbounds %struct.luaL_Buffer, ptr %0, i64 0, i32 1
  %12 = load i32, ptr %11, align 8, !tbaa !393
  %13 = add nsw i32 %12, 1
  store i32 %13, ptr %11, align 8, !tbaa !393
  br label %14

14:                                               ; preds = %5, %1
  %15 = phi i32 [ 1, %5 ], [ 0, %1 ]
  ret i32 %15
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @adjuststack(ptr nocapture noundef %0) unnamed_addr #1 {
  %2 = getelementptr inbounds %struct.luaL_Buffer, ptr %0, i64 0, i32 1
  %3 = load i32, ptr %2, align 8, !tbaa !393
  %4 = icmp sgt i32 %3, 1
  br i1 %4, label %5, label %28

5:                                                ; preds = %1
  %6 = getelementptr inbounds %struct.luaL_Buffer, ptr %0, i64 0, i32 2
  %7 = load ptr, ptr %6, align 8, !tbaa !390
  %8 = tail call i64 @lua_objlen(ptr noundef %7, i32 noundef -1) #46
  br label %9

9:                                                ; preds = %9, %5
  %10 = phi i64 [ %8, %5 ], [ %20, %9 ]
  %11 = phi i32 [ 1, %5 ], [ %12, %9 ]
  %12 = add nuw nsw i32 %11, 1
  %13 = xor i32 %11, -1
  %14 = tail call i64 @lua_objlen(ptr noundef %7, i32 noundef %13) #46
  %15 = load i32, ptr %2, align 8, !tbaa !393
  %16 = sub nsw i32 %15, %11
  %17 = icmp sgt i32 %16, 8
  %18 = icmp ugt i64 %10, %14
  %19 = select i1 %17, i1 true, i1 %18
  %20 = add i64 %14, %10
  %21 = icmp slt i32 %12, %15
  %22 = select i1 %19, i1 %21, i1 false
  br i1 %22, label %9, label %23, !llvm.loop !396

23:                                               ; preds = %9
  %.lcssa2 = phi i32 [ %11, %9 ]
  %.lcssa1 = phi i32 [ %12, %9 ]
  %.lcssa = phi i1 [ %19, %9 ]
  %24 = select i1 %.lcssa, i32 %.lcssa1, i32 %.lcssa2
  tail call void @lua_concat(ptr noundef %7, i32 noundef %24) #46
  %25 = load i32, ptr %2, align 8, !tbaa !393
  %26 = sub i32 %25, %24
  %27 = add i32 %26, 1
  store i32 %27, ptr %2, align 8, !tbaa !393
  br label %28

28:                                               ; preds = %23, %1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: write) uwtable
define internal void @luaL_buffinit(ptr noundef %0, ptr noundef %1) #17 {
  %3 = getelementptr inbounds %struct.luaL_Buffer, ptr %1, i64 0, i32 2
  store ptr %0, ptr %3, align 8, !tbaa !390
  %4 = getelementptr inbounds %struct.luaL_Buffer, ptr %1, i64 0, i32 3
  store ptr %4, ptr %1, align 8, !tbaa !392
  %5 = getelementptr inbounds %struct.luaL_Buffer, ptr %1, i64 0, i32 1
  store i32 0, ptr %5, align 8, !tbaa !393
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaL_pushresult(ptr noundef %0) #1 {
  %2 = tail call fastcc i32 @emptybuffer(ptr noundef %0) #47, !range !75
  %3 = getelementptr inbounds %struct.luaL_Buffer, ptr %0, i64 0, i32 2
  %4 = load ptr, ptr %3, align 8, !tbaa !390
  %5 = getelementptr inbounds %struct.luaL_Buffer, ptr %0, i64 0, i32 1
  %6 = load i32, ptr %5, align 8, !tbaa !393
  tail call void @lua_concat(ptr noundef %4, i32 noundef %6) #46
  store i32 1, ptr %5, align 8, !tbaa !393
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal nonnull ptr @luaL_prepbuffer(ptr noundef %0) #1 {
  %2 = tail call fastcc i32 @emptybuffer(ptr noundef %0) #47, !range !75
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %5, label %4

4:                                                ; preds = %1
  tail call fastcc void @adjuststack(ptr noundef %0) #47
  br label %5

5:                                                ; preds = %4, %1
  %6 = getelementptr inbounds %struct.luaL_Buffer, ptr %0, i64 0, i32 3
  ret ptr %6
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaL_addvalue(ptr noundef %0) #1 {
  %2 = alloca i64, align 8
  %3 = getelementptr inbounds %struct.luaL_Buffer, ptr %0, i64 0, i32 2
  %4 = load ptr, ptr %3, align 8, !tbaa !390
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  %5 = call ptr @lua_tolstring(ptr noundef %4, i32 noundef -1, ptr noundef nonnull %2) #46
  %6 = load i64, ptr %2, align 8, !tbaa !40
  %7 = load ptr, ptr %0, align 8, !tbaa !392
  %8 = getelementptr inbounds %struct.luaL_Buffer, ptr %0, i64 0, i32 3
  %9 = ptrtoint ptr %7 to i64
  %10 = ptrtoint ptr %8 to i64
  %11 = add i64 %10, 8192
  %12 = sub i64 %11, %9
  %13 = icmp ugt i64 %6, %12
  br i1 %13, label %18, label %14

14:                                               ; preds = %1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %7, ptr align 1 %5, i64 %6, i1 false)
  %15 = load i64, ptr %2, align 8, !tbaa !40
  %16 = load ptr, ptr %0, align 8, !tbaa !392
  %17 = getelementptr inbounds i8, ptr %16, i64 %15
  store ptr %17, ptr %0, align 8, !tbaa !392
  call void @lua_settop(ptr noundef %4, i32 noundef -2) #46
  br label %26

18:                                               ; preds = %1
  %19 = call fastcc i32 @emptybuffer(ptr noundef nonnull %0) #47, !range !75
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %22, label %21

21:                                               ; preds = %18
  call void @lua_insert(ptr noundef %4, i32 noundef -2) #46
  br label %22

22:                                               ; preds = %21, %18
  %23 = getelementptr inbounds %struct.luaL_Buffer, ptr %0, i64 0, i32 1
  %24 = load i32, ptr %23, align 8, !tbaa !393
  %25 = add nsw i32 %24, 1
  store i32 %25, ptr %23, align 8, !tbaa !393
  call fastcc void @adjuststack(ptr noundef nonnull %0) #47
  br label %26

26:                                               ; preds = %22, %14
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaL_loadfile(ptr noundef %0, ptr noundef %1) #1 {
  %3 = alloca %struct.LoadF, align 8
  call void @llvm.lifetime.start.p0(i64 8208, ptr nonnull %3) #48
  %4 = tail call i32 @lua_gettop(ptr noundef %0) #46
  %5 = add nsw i32 %4, 1
  store i32 0, ptr %3, align 8, !tbaa !397
  %6 = icmp eq ptr %1, null
  %7 = getelementptr inbounds %struct.LoadF, ptr %3, i64 0, i32 1
  br i1 %6, label %8, label %10

8:                                                ; preds = %2
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.15.283, i64 noundef 6) #46
  %9 = load ptr, ptr @stdin, align 8, !tbaa !39
  store ptr %9, ptr %7, align 8, !tbaa !399
  br label %15

10:                                               ; preds = %2
  %11 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.16.284, ptr noundef nonnull %1) #46
  %12 = tail call noalias ptr @fopen(ptr noundef nonnull %1, ptr noundef nonnull @.str.17.285) #47
  store ptr %12, ptr %7, align 8, !tbaa !399
  %13 = icmp eq ptr %12, null
  br i1 %13, label %14, label %15

14:                                               ; preds = %10
  tail call fastcc void @errfile(ptr noundef %0, ptr noundef nonnull @.str.18.286, i32 noundef %5) #47
  br label %54

15:                                               ; preds = %10, %8
  %16 = phi ptr [ %12, %10 ], [ %9, %8 ]
  %17 = getelementptr inbounds %struct.LoadF, ptr %3, i64 0, i32 1
  %18 = tail call i32 @getc(ptr noundef %16) #47
  %19 = icmp eq i32 %18, 35
  br i1 %19, label %20, label %27

20:                                               ; preds = %15
  store i32 1, ptr %3, align 8, !tbaa !397
  br label %21

21:                                               ; preds = %21, %20
  %22 = tail call i32 @getc(ptr noundef %16) #47
  switch i32 %22, label %21 [
    i32 10, label %25
    i32 -1, label %23
  ]

23:                                               ; preds = %21
  %24 = icmp ne ptr %1, null
  br label %39

25:                                               ; preds = %21
  %26 = tail call i32 @getc(ptr noundef %16) #47
  br label %27

27:                                               ; preds = %25, %15
  %28 = phi i32 [ %26, %25 ], [ %18, %15 ]
  %29 = icmp eq i32 %28, 27
  %30 = icmp ne ptr %1, null
  %31 = and i1 %30, %29
  br i1 %31, label %32, label %39

32:                                               ; preds = %27
  %33 = tail call ptr @freopen(ptr noundef nonnull %1, ptr noundef nonnull @.str.20.287, ptr noundef %16) #46
  store ptr %33, ptr %17, align 8, !tbaa !399
  %34 = icmp eq ptr %33, null
  br i1 %34, label %35, label %36

35:                                               ; preds = %32
  tail call fastcc void @errfile(ptr noundef %0, ptr noundef nonnull @.str.21.288, i32 noundef %5) #47
  br label %54

36:                                               ; preds = %36, %32
  %37 = tail call i32 @getc(ptr noundef nonnull %33) #47
  switch i32 %37, label %36 [
    i32 -1, label %38
    i32 27, label %38
  ]

38:                                               ; preds = %36, %36
  %.lcssa = phi i32 [ %37, %36 ], [ %37, %36 ]
  store i32 0, ptr %3, align 8, !tbaa !397
  br label %39

39:                                               ; preds = %38, %27, %23
  %40 = phi ptr [ %33, %38 ], [ %16, %27 ], [ %16, %23 ]
  %41 = phi i1 [ true, %38 ], [ %30, %27 ], [ %24, %23 ]
  %42 = phi i32 [ %.lcssa, %38 ], [ %28, %27 ], [ -1, %23 ]
  %43 = tail call i32 @ungetc(i32 noundef %42, ptr noundef %40) #47
  %44 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef -1, ptr noundef null) #46
  %45 = call i32 @lua_load(ptr noundef %0, ptr noundef nonnull @getF, ptr noundef nonnull %3, ptr noundef %44) #46
  %46 = load ptr, ptr %17, align 8, !tbaa !399
  %47 = call i32 @ferror(ptr noundef %46) #46
  br i1 %41, label %48, label %50

48:                                               ; preds = %39
  %49 = call i32 @fclose(ptr noundef %46) #47
  br label %50

50:                                               ; preds = %48, %39
  %51 = icmp eq i32 %47, 0
  br i1 %51, label %53, label %52

52:                                               ; preds = %50
  call void @lua_settop(ptr noundef %0, i32 noundef %5) #46
  call fastcc void @errfile(ptr noundef %0, ptr noundef nonnull @.str.22.289, i32 noundef %5) #47
  br label %54

53:                                               ; preds = %50
  call void @lua_remove(ptr noundef %0, i32 noundef %5) #46
  br label %54

54:                                               ; preds = %53, %52, %35, %14
  %55 = phi i32 [ 6, %35 ], [ 6, %52 ], [ %45, %53 ], [ 6, %14 ]
  call void @llvm.lifetime.end.p0(i64 8208, ptr nonnull %3) #48
  ret i32 %55
}

; Function Attrs: nofree nounwind optsize
declare noalias noundef ptr @fopen(ptr nocapture noundef readonly, ptr nocapture noundef readonly) local_unnamed_addr #31

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @errfile(ptr noundef %0, ptr noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = tail call ptr @__errno_location() #52
  %5 = load i32, ptr %4, align 4, !tbaa !65
  %6 = tail call ptr @strerror(i32 noundef %5) #46
  %7 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef %2, ptr noundef null) #46
  %8 = getelementptr inbounds i8, ptr %7, i64 1
  %9 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.23.291, ptr noundef %1, ptr noundef nonnull %8, ptr noundef %6) #46
  tail call void @lua_remove(ptr noundef %0, i32 noundef %2) #46
  ret void
}

; Function Attrs: nofree nounwind optsize
declare noundef i32 @getc(ptr nocapture noundef) local_unnamed_addr #31

; Function Attrs: optsize
declare ptr @freopen(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #39

; Function Attrs: nofree nounwind optsize
declare noundef i32 @ungetc(i32 noundef, ptr nocapture noundef) local_unnamed_addr #31

; Function Attrs: nofree nounwind optsize uwtable
define internal ptr @getF(ptr nocapture readnone %0, ptr noundef %1, ptr nocapture noundef writeonly %2) #29 {
  %4 = load i32, ptr %1, align 8, !tbaa !397
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %7, label %6

6:                                                ; preds = %3
  store i32 0, ptr %1, align 8, !tbaa !397
  store i64 1, ptr %2, align 8, !tbaa !40
  br label %18

7:                                                ; preds = %3
  %8 = getelementptr inbounds %struct.LoadF, ptr %1, i64 0, i32 1
  %9 = load ptr, ptr %8, align 8, !tbaa !399
  %10 = tail call i32 @feof(ptr noundef %9) #46
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %12, label %18

12:                                               ; preds = %7
  %13 = getelementptr inbounds %struct.LoadF, ptr %1, i64 0, i32 2
  %14 = load ptr, ptr %8, align 8, !tbaa !399
  %15 = tail call i64 @fread(ptr noundef nonnull %13, i64 noundef 1, i64 noundef 8192, ptr noundef %14) #47
  store i64 %15, ptr %2, align 8, !tbaa !40
  %16 = icmp eq i64 %15, 0
  %17 = select i1 %16, ptr null, ptr %13
  br label %18

18:                                               ; preds = %12, %7, %6
  %19 = phi ptr [ @.str.24.290, %6 ], [ %17, %12 ], [ null, %7 ]
  ret ptr %19
}

; Function Attrs: nofree nounwind optsize memory(read)
declare noundef i32 @ferror(ptr nocapture noundef) local_unnamed_addr #40

; Function Attrs: nofree nounwind optsize
declare noundef i32 @fclose(ptr nocapture noundef) local_unnamed_addr #31

; Function Attrs: nofree nounwind optsize
declare noundef i32 @feof(ptr nocapture noundef) local_unnamed_addr #31

; Function Attrs: nofree nounwind optsize
declare noundef i64 @fread(ptr nocapture noundef, i64 noundef, i64 noundef, ptr nocapture noundef) local_unnamed_addr #31

; Function Attrs: mustprogress nofree nosync nounwind optsize willreturn memory(none)
declare ptr @__errno_location() local_unnamed_addr #26

; Function Attrs: nounwind optsize
declare ptr @strerror(i32 noundef) local_unnamed_addr #27

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaL_loadbuffer(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3) #1 {
  %5 = alloca %struct.LoadS, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %5) #48
  store ptr %1, ptr %5, align 8, !tbaa !400
  %6 = getelementptr inbounds %struct.LoadS, ptr %5, i64 0, i32 1
  store i64 %2, ptr %6, align 8, !tbaa !402
  %7 = call i32 @lua_load(ptr noundef %0, ptr noundef nonnull @getS, ptr noundef nonnull %5, ptr noundef %3) #46
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %5) #48
  ret i32 %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: readwrite) uwtable
define internal ptr @getS(ptr nocapture readnone %0, ptr nocapture noundef %1, ptr nocapture noundef writeonly %2) #3 {
  %4 = getelementptr inbounds %struct.LoadS, ptr %1, i64 0, i32 1
  %5 = load i64, ptr %4, align 8, !tbaa !402
  %6 = icmp eq i64 %5, 0
  br i1 %6, label %9, label %7

7:                                                ; preds = %3
  store i64 %5, ptr %2, align 8, !tbaa !40
  store i64 0, ptr %4, align 8, !tbaa !402
  %8 = load ptr, ptr %1, align 8, !tbaa !400
  br label %9

9:                                                ; preds = %7, %3
  %10 = phi ptr [ %8, %7 ], [ null, %3 ]
  ret ptr %10
}

; Function Attrs: nounwind optsize uwtable
define internal ptr @luaL_newstate() #1 {
  %1 = tail call ptr @lua_newstate(ptr noundef nonnull @l_alloc, ptr noundef null) #46
  %2 = icmp eq ptr %1, null
  br i1 %2, label %5, label %3

3:                                                ; preds = %0
  %4 = tail call ptr @lua_atpanic(ptr noundef nonnull %1, ptr noundef nonnull @panic) #46
  br label %5

5:                                                ; preds = %3, %0
  ret ptr %1
}

; Function Attrs: mustprogress nounwind optsize willreturn memory(argmem: readwrite, inaccessiblemem: readwrite) uwtable
define internal noalias ptr @l_alloc(ptr nocapture readnone %0, ptr nocapture noundef %1, i64 %2, i64 noundef %3) #41 {
  %5 = icmp eq i64 %3, 0
  br i1 %5, label %6, label %7

6:                                                ; preds = %4
  tail call void @free(ptr noundef %1) #46
  br label %9

7:                                                ; preds = %4
  %8 = tail call ptr @realloc(ptr noundef %1, i64 noundef %3) #53
  br label %9

9:                                                ; preds = %7, %6
  %10 = phi ptr [ null, %6 ], [ %8, %7 ]
  ret ptr %10
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @panic(ptr noundef %0) #1 {
  %2 = load ptr, ptr @stderr, align 8, !tbaa !39
  %3 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef -1, ptr noundef null) #46
  %4 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %2, ptr noundef nonnull @.str.25.292, ptr noundef %3) #54
  ret i32 0
}

; Function Attrs: nofree nounwind optsize
declare noundef i32 @fprintf(ptr nocapture noundef, ptr nocapture noundef readonly, ...) local_unnamed_addr #31

; Function Attrs: mustprogress nounwind optsize willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #42

; Function Attrs: mustprogress nounwind optsize willreturn allockind("realloc") allocsize(1) memory(argmem: readwrite, inaccessiblemem: readwrite)
declare noalias noundef ptr @realloc(ptr allocptr nocapture noundef, i64 noundef) local_unnamed_addr #43

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaopen_base(ptr noundef %0) #1 {
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -10002) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -10002, ptr noundef nonnull @.str.1.293) #46
  tail call void @luaL_register(ptr noundef %0, ptr noundef nonnull @.str.1.293, ptr noundef nonnull @base_funcs) #46
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.2.294, i64 noundef 7) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -10002, ptr noundef nonnull @.str.3.295) #46
  tail call fastcc void @auxopen(ptr noundef %0, ptr noundef nonnull @.str.4.296, ptr noundef nonnull @luaB_ipairs, ptr noundef nonnull @ipairsaux) #47
  tail call fastcc void @auxopen(ptr noundef %0, ptr noundef nonnull @.str.5.297, ptr noundef nonnull @luaB_pairs, ptr noundef nonnull @luaB_next) #47
  tail call void @lua_createtable(ptr noundef %0, i32 noundef 0, i32 noundef 1) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -1) #46
  %2 = tail call i32 @lua_setmetatable(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.6.298, i64 noundef 2) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.7.299) #46
  tail call void @lua_pushcclosure(ptr noundef %0, ptr noundef nonnull @luaB_newproxy, i32 noundef 1) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -10002, ptr noundef nonnull @.str.8.300) #46
  tail call void @luaL_register(ptr noundef %0, ptr noundef nonnull @.str.301, ptr noundef nonnull @co_funcs) #46
  ret i32 2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_ipairs(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -10003) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef 1) #46
  tail call void @lua_pushinteger(ptr noundef %0, i64 noundef 0) #46
  ret i32 3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @ipairsaux(ptr noundef %0) #1 {
  %2 = tail call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef 2) #46
  %3 = trunc i64 %2 to i32
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  %4 = add nsw i32 %3, 1
  %5 = sext i32 %4 to i64
  tail call void @lua_pushinteger(ptr noundef %0, i64 noundef %5) #46
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %4) #46
  %6 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %7 = icmp eq i32 %6, 0
  %8 = select i1 %7, i32 0, i32 2
  ret i32 %8
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @auxopen(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3) unnamed_addr #1 {
  tail call void @lua_pushcclosure(ptr noundef %0, ptr noundef %3, i32 noundef 0) #46
  tail call void @lua_pushcclosure(ptr noundef %0, ptr noundef %2, i32 noundef 1) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef %1) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_pairs(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -10003) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef 1) #46
  tail call void @lua_pushnil(ptr noundef %0) #46
  ret i32 3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_next(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef 2) #46
  %2 = tail call i32 @lua_next(ptr noundef %0, i32 noundef 1) #46
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  tail call void @lua_pushnil(ptr noundef %0) #46
  br label %5

5:                                                ; preds = %4, %1
  %6 = phi i32 [ 1, %4 ], [ 2, %1 ]
  ret i32 %6
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_newproxy(ptr noundef %0) #1 {
  tail call void @lua_settop(ptr noundef %0, i32 noundef 1) #46
  %2 = tail call ptr @lua_newuserdata(ptr noundef %0, i64 noundef 0) #46
  %3 = tail call i32 @lua_toboolean(ptr noundef %0, i32 noundef 1) #46
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %21, label %5

5:                                                ; preds = %1
  %6 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 1) #46
  %7 = icmp eq i32 %6, 1
  br i1 %7, label %8, label %9

8:                                                ; preds = %5
  tail call void @lua_createtable(ptr noundef %0, i32 noundef 0, i32 noundef 0) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -1) #46
  tail call void @lua_pushboolean(ptr noundef %0, i32 noundef 1) #46
  tail call void @lua_rawset(ptr noundef %0, i32 noundef -10003) #46
  br label %19

9:                                                ; preds = %5
  %10 = tail call i32 @lua_getmetatable(ptr noundef %0, i32 noundef 1) #46
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %15, label %12

12:                                               ; preds = %9
  tail call void @lua_rawget(ptr noundef %0, i32 noundef -10003) #46
  %13 = tail call i32 @lua_toboolean(ptr noundef %0, i32 noundef -1) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %17

15:                                               ; preds = %12, %9
  %16 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.64) #46
  br label %17

17:                                               ; preds = %15, %12
  %18 = tail call i32 @lua_getmetatable(ptr noundef %0, i32 noundef 1) #46
  br label %19

19:                                               ; preds = %17, %8
  %20 = tail call i32 @lua_setmetatable(ptr noundef %0, i32 noundef 2) #46
  br label %21

21:                                               ; preds = %19, %1
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_cocreate(ptr noundef %0) #1 {
  %2 = tail call ptr @lua_newthread(ptr noundef %0) #46
  %3 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 1) #46
  %4 = icmp eq i32 %3, 6
  br i1 %4, label %5, label %8

5:                                                ; preds = %1
  %6 = tail call i32 @lua_iscfunction(ptr noundef %0, i32 noundef 1) #46
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %10, label %8

8:                                                ; preds = %5, %1
  %9 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.71) #46
  br label %10

10:                                               ; preds = %8, %5
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef 1) #46
  tail call void @lua_xmove(ptr noundef %0, ptr noundef %2, i32 noundef 1) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_coresume(ptr noundef %0) #1 {
  %2 = tail call ptr @lua_tothread(ptr noundef %0, i32 noundef 1) #46
  %3 = icmp eq ptr %2, null
  br i1 %3, label %4, label %6

4:                                                ; preds = %1
  %5 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.72.302) #46
  br label %6

6:                                                ; preds = %4, %1
  %7 = tail call i32 @lua_gettop(ptr noundef %0) #46
  %8 = add nsw i32 %7, -1
  %9 = tail call fastcc i32 @auxresume(ptr noundef %0, ptr noundef %2, i32 noundef %8) #47
  %10 = icmp slt i32 %9, 0
  br i1 %10, label %11, label %12

11:                                               ; preds = %6
  tail call void @lua_pushboolean(ptr noundef %0, i32 noundef 0) #46
  br label %15

12:                                               ; preds = %6
  tail call void @lua_pushboolean(ptr noundef %0, i32 noundef 1) #46
  %13 = add nuw nsw i32 %9, 1
  %14 = xor i32 %9, -1
  br label %15

15:                                               ; preds = %12, %11
  %16 = phi i32 [ %14, %12 ], [ -2, %11 ]
  %17 = phi i32 [ %13, %12 ], [ 2, %11 ]
  tail call void @lua_insert(ptr noundef %0, i32 noundef %16) #46
  ret i32 %17
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_corunning(ptr noundef %0) #1 {
  %2 = tail call i32 @lua_pushthread(ptr noundef %0) #46
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %5, label %4

4:                                                ; preds = %1
  tail call void @lua_pushnil(ptr noundef %0) #46
  br label %5

5:                                                ; preds = %4, %1
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_costatus(ptr noundef %0) #1 {
  %2 = tail call ptr @lua_tothread(ptr noundef %0, i32 noundef 1) #46
  %3 = icmp eq ptr %2, null
  br i1 %3, label %4, label %6

4:                                                ; preds = %1
  %5 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.72.302) #46
  br label %6

6:                                                ; preds = %4, %1
  %7 = tail call fastcc i32 @costatus(ptr noundef %0, ptr noundef %2) #47, !range !403
  %8 = zext i32 %7 to i64
  %9 = getelementptr inbounds [4 x ptr], ptr @statnames, i64 0, i64 %8
  %10 = load ptr, ptr %9, align 8, !tbaa !39
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef %10) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_cowrap(ptr noundef %0) #1 {
  %2 = tail call i32 @luaB_cocreate(ptr noundef %0) #47
  tail call void @lua_pushcclosure(ptr noundef %0, ptr noundef nonnull @luaB_auxwrap, i32 noundef 1) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_yield(ptr noundef %0) #1 {
  %2 = tail call i32 @lua_gettop(ptr noundef %0) #46
  %3 = tail call i32 @lua_yield(ptr noundef %0, i32 noundef %2) #46
  ret i32 %3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_auxwrap(ptr noundef %0) #1 {
  %2 = tail call ptr @lua_tothread(ptr noundef %0, i32 noundef -10003) #46
  %3 = tail call i32 @lua_gettop(ptr noundef %0) #46
  %4 = tail call fastcc i32 @auxresume(ptr noundef %0, ptr noundef %2, i32 noundef %3) #47
  %5 = icmp slt i32 %4, 0
  br i1 %5, label %6, label %12

6:                                                ; preds = %1
  %7 = tail call i32 @lua_isstring(ptr noundef %0, i32 noundef -1) #46
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %10, label %9

9:                                                ; preds = %6
  tail call void @luaL_where(ptr noundef %0, i32 noundef 1) #46
  tail call void @lua_insert(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_concat(ptr noundef %0, i32 noundef 2) #46
  br label %10

10:                                               ; preds = %9, %6
  %11 = tail call i32 @lua_error(ptr noundef %0) #46
  br label %12

12:                                               ; preds = %10, %1
  ret i32 %4
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @auxresume(ptr noundef %0, ptr noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = tail call fastcc i32 @costatus(ptr noundef %0, ptr noundef %1) #47, !range !403
  %5 = tail call i32 @lua_checkstack(ptr noundef %1, i32 noundef %2) #46
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %9

7:                                                ; preds = %3
  %8 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.73) #46
  br label %9

9:                                                ; preds = %7, %3
  %10 = icmp eq i32 %4, 1
  br i1 %10, label %16, label %11

11:                                               ; preds = %9
  %12 = zext i32 %4 to i64
  %13 = getelementptr inbounds [4 x ptr], ptr @statnames, i64 0, i64 %12
  %14 = load ptr, ptr %13, align 8, !tbaa !39
  %15 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.74, ptr noundef %14) #46
  br label %28

16:                                               ; preds = %9
  tail call void @lua_xmove(ptr noundef %0, ptr noundef %1, i32 noundef %2) #46
  tail call void @lua_setlevel(ptr noundef %0, ptr noundef %1) #46
  %17 = tail call i32 @lua_resume(ptr noundef %1, i32 noundef %2) #46
  %18 = icmp ult i32 %17, 2
  br i1 %18, label %19, label %27

19:                                               ; preds = %16
  %20 = tail call i32 @lua_gettop(ptr noundef %1) #46
  %21 = add nsw i32 %20, 1
  %22 = tail call i32 @lua_checkstack(ptr noundef %0, i32 noundef %21) #46
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %24, label %26

24:                                               ; preds = %19
  %25 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.75) #46
  br label %26

26:                                               ; preds = %24, %19
  tail call void @lua_xmove(ptr noundef %1, ptr noundef %0, i32 noundef %20) #46
  br label %28

27:                                               ; preds = %16
  tail call void @lua_xmove(ptr noundef %1, ptr noundef %0, i32 noundef 1) #46
  br label %28

28:                                               ; preds = %27, %26, %11
  %29 = phi i32 [ -1, %11 ], [ %20, %26 ], [ -1, %27 ]
  ret i32 %29
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @costatus(ptr noundef readnone %0, ptr noundef %1) unnamed_addr #1 {
  %3 = alloca %struct.lua_Debug, align 8
  %4 = icmp eq ptr %0, %1
  br i1 %4, label %17, label %5

5:                                                ; preds = %2
  %6 = tail call i32 @lua_status(ptr noundef %1) #46
  switch i32 %6, label %16 [
    i32 1, label %17
    i32 0, label %7
  ]

7:                                                ; preds = %5
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %3) #48
  %8 = call i32 @lua_getstack(ptr noundef %1, i32 noundef 0, ptr noundef nonnull %3) #46
  %9 = icmp sgt i32 %8, 0
  br i1 %9, label %14, label %10

10:                                               ; preds = %7
  %11 = call i32 @lua_gettop(ptr noundef %1) #46
  %12 = icmp eq i32 %11, 0
  %13 = select i1 %12, i32 3, i32 1
  br label %14

14:                                               ; preds = %10, %7
  %15 = phi i32 [ 2, %7 ], [ %13, %10 ]
  call void @llvm.lifetime.end.p0(i64 120, ptr nonnull %3) #48
  br label %17

16:                                               ; preds = %5
  br label %17

17:                                               ; preds = %16, %14, %5, %2
  %18 = phi i32 [ 3, %16 ], [ %15, %14 ], [ 0, %2 ], [ %6, %5 ]
  ret i32 %18
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_assert(ptr noundef %0) #1 {
  tail call void @luaL_checkany(ptr noundef %0, i32 noundef 1) #46
  %2 = tail call i32 @lua_toboolean(ptr noundef %0, i32 noundef 1) #46
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %7

4:                                                ; preds = %1
  %5 = tail call ptr @luaL_optlstring(ptr noundef %0, i32 noundef 2, ptr noundef nonnull @.str.34.339, ptr noundef null) #46
  %6 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.33.340, ptr noundef %5) #46
  br label %9

7:                                                ; preds = %1
  %8 = tail call i32 @lua_gettop(ptr noundef %0) #46
  br label %9

9:                                                ; preds = %7, %4
  %10 = phi i32 [ %8, %7 ], [ %6, %4 ]
  ret i32 %10
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_collectgarbage(ptr noundef %0) #1 {
  %2 = tail call i32 @luaL_checkoption(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.37.332, ptr noundef nonnull @luaB_collectgarbage.opts) #46
  %3 = tail call i64 @luaL_optinteger(ptr noundef %0, i32 noundef 2, i64 noundef 0) #46
  %4 = trunc i64 %3 to i32
  %5 = sext i32 %2 to i64
  %6 = getelementptr inbounds [7 x i32], ptr @luaB_collectgarbage.optsnum, i64 0, i64 %5
  %7 = load i32, ptr %6, align 4, !tbaa !65
  %8 = tail call i32 @lua_gc(ptr noundef %0, i32 noundef %7, i32 noundef %4) #46
  switch i32 %7, label %16 [
    i32 3, label %9
    i32 5, label %15
  ]

9:                                                ; preds = %1
  %10 = tail call i32 @lua_gc(ptr noundef %0, i32 noundef 4, i32 noundef 0) #46
  %11 = sitofp i32 %8 to double
  %12 = sitofp i32 %10 to double
  %13 = fmul double %12, 0x3F50000000000000
  %14 = fadd double %13, %11
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %14) #46
  br label %18

15:                                               ; preds = %1
  tail call void @lua_pushboolean(ptr noundef %0, i32 noundef %8) #46
  br label %18

16:                                               ; preds = %1
  %17 = sitofp i32 %8 to double
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %17) #46
  br label %18

18:                                               ; preds = %16, %15, %9
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_dofile(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_optlstring(ptr noundef %0, i32 noundef 1, ptr noundef null, ptr noundef null) #46
  %3 = tail call i32 @lua_gettop(ptr noundef %0) #46
  %4 = tail call i32 @luaL_loadfile(ptr noundef %0, ptr noundef %2) #46
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %8, label %6

6:                                                ; preds = %1
  %7 = tail call i32 @lua_error(ptr noundef %0) #46
  br label %8

8:                                                ; preds = %6, %1
  tail call void @lua_call(ptr noundef %0, i32 noundef 0, i32 noundef -1) #46
  %9 = tail call i32 @lua_gettop(ptr noundef %0) #46
  %10 = sub nsw i32 %9, %3
  ret i32 %10
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_error(ptr noundef %0) #1 {
  %2 = tail call i64 @luaL_optinteger(ptr noundef %0, i32 noundef 2, i64 noundef 1) #46
  %3 = trunc i64 %2 to i32
  tail call void @lua_settop(ptr noundef %0, i32 noundef 1) #46
  %4 = tail call i32 @lua_isstring(ptr noundef %0, i32 noundef 1) #46
  %5 = icmp ne i32 %4, 0
  %6 = icmp sgt i32 %3, 0
  %7 = select i1 %5, i1 %6, i1 false
  br i1 %7, label %8, label %9

8:                                                ; preds = %1
  tail call void @luaL_where(ptr noundef %0, i32 noundef %3) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef 1) #46
  tail call void @lua_concat(ptr noundef %0, i32 noundef 2) #46
  br label %9

9:                                                ; preds = %8, %1
  %10 = tail call i32 @lua_error(ptr noundef %0) #46
  ret i32 %10
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_gcinfo(ptr noundef %0) #1 {
  %2 = tail call i32 @lua_gc(ptr noundef %0, i32 noundef 3, i32 noundef 0) #46
  %3 = sext i32 %2 to i64
  tail call void @lua_pushinteger(ptr noundef %0, i64 noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_getfenv(ptr noundef %0) #1 {
  tail call fastcc void @getfunc(ptr noundef %0, i32 noundef 1) #47
  %2 = tail call i32 @lua_iscfunction(ptr noundef %0, i32 noundef -1) #46
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %5, label %4

4:                                                ; preds = %1
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -10002) #46
  br label %6

5:                                                ; preds = %1
  tail call void @lua_getfenv(ptr noundef %0, i32 noundef -1) #46
  br label %6

6:                                                ; preds = %5, %4
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_getmetatable(ptr noundef %0) #1 {
  tail call void @luaL_checkany(ptr noundef %0, i32 noundef 1) #46
  %2 = tail call i32 @lua_getmetatable(ptr noundef %0, i32 noundef 1) #46
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  tail call void @lua_pushnil(ptr noundef %0) #46
  br label %7

5:                                                ; preds = %1
  %6 = tail call i32 @luaL_getmetafield(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.46.327) #46
  br label %7

7:                                                ; preds = %5, %4
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_loadfile(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_optlstring(ptr noundef %0, i32 noundef 1, ptr noundef null, ptr noundef null) #46
  %3 = tail call i32 @luaL_loadfile(ptr noundef %0, ptr noundef %2) #46
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %6, label %5

5:                                                ; preds = %1
  tail call void @lua_pushnil(ptr noundef %0) #46
  tail call void @lua_insert(ptr noundef %0, i32 noundef -2) #46
  br label %6

6:                                                ; preds = %5, %1
  %7 = phi i32 [ 2, %5 ], [ 1, %1 ]
  ret i32 %7
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_load(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_optlstring(ptr noundef %0, i32 noundef 2, ptr noundef nonnull @.str.47, ptr noundef null) #46
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 6) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef 3) #46
  %3 = tail call i32 @lua_load(ptr noundef %0, ptr noundef nonnull @generic_reader, ptr noundef null, ptr noundef %2) #46
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %6, label %5

5:                                                ; preds = %1
  tail call void @lua_pushnil(ptr noundef %0) #46
  tail call void @lua_insert(ptr noundef %0, i32 noundef -2) #46
  br label %6

6:                                                ; preds = %5, %1
  %7 = phi i32 [ 2, %5 ], [ 1, %1 ]
  ret i32 %7
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_loadstring(ptr noundef %0) #1 {
  %2 = alloca i64, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  %3 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef nonnull %2) #46
  %4 = call ptr @luaL_optlstring(ptr noundef %0, i32 noundef 2, ptr noundef %3, ptr noundef null) #46
  %5 = load i64, ptr %2, align 8, !tbaa !40
  %6 = call i32 @luaL_loadbuffer(ptr noundef %0, ptr noundef %3, i64 noundef %5, ptr noundef %4) #46
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %9, label %8

8:                                                ; preds = %1
  call void @lua_pushnil(ptr noundef %0) #46
  call void @lua_insert(ptr noundef %0, i32 noundef -2) #46
  br label %9

9:                                                ; preds = %8, %1
  %10 = phi i32 [ 2, %8 ], [ 1, %1 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  ret i32 %10
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_pcall(ptr noundef %0) #1 {
  tail call void @luaL_checkany(ptr noundef %0, i32 noundef 1) #46
  %2 = tail call i32 @lua_gettop(ptr noundef %0) #46
  %3 = add nsw i32 %2, -1
  %4 = tail call i32 @lua_pcall(ptr noundef %0, i32 noundef %3, i32 noundef -1, i32 noundef 0) #46
  %5 = icmp eq i32 %4, 0
  %6 = zext i1 %5 to i32
  tail call void @lua_pushboolean(ptr noundef %0, i32 noundef %6) #46
  tail call void @lua_insert(ptr noundef %0, i32 noundef 1) #46
  %7 = tail call i32 @lua_gettop(ptr noundef %0) #46
  ret i32 %7
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_print(ptr noundef %0) #1 {
  %2 = tail call i32 @lua_gettop(ptr noundef %0) #46
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -10002, ptr noundef nonnull @.str.29.323) #46
  %3 = icmp slt i32 %2, 1
  br i1 %3, label %20, label %4

4:                                                ; preds = %15, %1
  %5 = phi i32 [ %18, %15 ], [ 1, %1 ]
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -1) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef %5) #46
  tail call void @lua_call(ptr noundef %0, i32 noundef 1, i32 noundef 1) #46
  %6 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef -1, ptr noundef null) #46
  %7 = icmp eq ptr %6, null
  br i1 %7, label %8, label %10

8:                                                ; preds = %4
  %9 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.50) #46
  br label %23

10:                                               ; preds = %4
  %11 = icmp ugt i32 %5, 1
  br i1 %11, label %12, label %15

12:                                               ; preds = %10
  %13 = load ptr, ptr @stdout, align 8, !tbaa !39
  %14 = tail call i32 @fputs(ptr noundef nonnull @.str.51, ptr noundef %13) #47
  br label %15

15:                                               ; preds = %12, %10
  %16 = load ptr, ptr @stdout, align 8, !tbaa !39
  %17 = tail call i32 @fputs(ptr noundef nonnull %6, ptr noundef %16) #47
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  %18 = add nuw i32 %5, 1
  %19 = icmp eq i32 %5, %2
  br i1 %19, label %20, label %4, !llvm.loop !404

20:                                               ; preds = %15, %1
  %21 = load ptr, ptr @stdout, align 8, !tbaa !39
  %22 = tail call i32 @fputs(ptr noundef nonnull @.str.52, ptr noundef %21) #47
  br label %23

23:                                               ; preds = %20, %8
  %24 = phi i32 [ 0, %20 ], [ %9, %8 ]
  ret i32 %24
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_rawequal(ptr noundef %0) #1 {
  tail call void @luaL_checkany(ptr noundef %0, i32 noundef 1) #46
  tail call void @luaL_checkany(ptr noundef %0, i32 noundef 2) #46
  %2 = tail call i32 @lua_rawequal(ptr noundef %0, i32 noundef 1, i32 noundef 2) #46
  tail call void @lua_pushboolean(ptr noundef %0, i32 noundef %2) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_rawget(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  tail call void @luaL_checkany(ptr noundef %0, i32 noundef 2) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef 2) #46
  tail call void @lua_rawget(ptr noundef %0, i32 noundef 1) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_rawset(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  tail call void @luaL_checkany(ptr noundef %0, i32 noundef 2) #46
  tail call void @luaL_checkany(ptr noundef %0, i32 noundef 3) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef 3) #46
  tail call void @lua_rawset(ptr noundef %0, i32 noundef 1) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_select(ptr noundef %0) #1 {
  %2 = tail call i32 @lua_gettop(ptr noundef %0) #46
  %3 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 1) #46
  %4 = icmp eq i32 %3, 4
  br i1 %4, label %5, label %12

5:                                                ; preds = %1
  %6 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %7 = load i8, ptr %6, align 1, !tbaa !33
  %8 = icmp eq i8 %7, 35
  br i1 %8, label %9, label %12

9:                                                ; preds = %5
  %10 = add nsw i32 %2, -1
  %11 = sext i32 %10 to i64
  tail call void @lua_pushinteger(ptr noundef %0, i64 noundef %11) #46
  br label %24

12:                                               ; preds = %5, %1
  %13 = tail call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef 1) #46
  %14 = trunc i64 %13 to i32
  %15 = icmp slt i32 %14, 0
  %16 = add nsw i32 %2, %14
  %17 = tail call i32 @llvm.smin.i32(i32 %2, i32 %14)
  %18 = select i1 %15, i32 %16, i32 %17
  %19 = icmp sgt i32 %18, 0
  br i1 %19, label %22, label %20

20:                                               ; preds = %12
  %21 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.53) #46
  br label %22

22:                                               ; preds = %20, %12
  %23 = sub nsw i32 %2, %18
  br label %24

24:                                               ; preds = %22, %9
  %25 = phi i32 [ 1, %9 ], [ %23, %22 ]
  ret i32 %25
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_setfenv(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 2, i32 noundef 5) #46
  tail call fastcc void @getfunc(ptr noundef %0, i32 noundef 0) #47
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef 2) #46
  %2 = tail call i32 @lua_isnumber(ptr noundef %0, i32 noundef 1) #46
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %10, label %4

4:                                                ; preds = %1
  %5 = tail call double @lua_tonumber(ptr noundef %0, i32 noundef 1) #46
  %6 = fcmp oeq double %5, 0.000000e+00
  br i1 %6, label %7, label %10

7:                                                ; preds = %4
  %8 = tail call i32 @lua_pushthread(ptr noundef %0) #46
  tail call void @lua_insert(ptr noundef %0, i32 noundef -2) #46
  %9 = tail call i32 @lua_setfenv(ptr noundef %0, i32 noundef -2) #46
  br label %18

10:                                               ; preds = %4, %1
  %11 = tail call i32 @lua_iscfunction(ptr noundef %0, i32 noundef -2) #46
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %13, label %16

13:                                               ; preds = %10
  %14 = tail call i32 @lua_setfenv(ptr noundef %0, i32 noundef -2) #46
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %18

16:                                               ; preds = %13, %10
  %17 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.54) #46
  br label %18

18:                                               ; preds = %16, %13, %7
  %19 = phi i32 [ 0, %7 ], [ 1, %13 ], [ 1, %16 ]
  ret i32 %19
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_setmetatable(ptr noundef %0) #1 {
  %2 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 2) #46
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  switch i32 %2, label %3 [
    i32 5, label %5
    i32 0, label %5
  ]

3:                                                ; preds = %1
  %4 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef 2, ptr noundef nonnull @.str.55) #46
  br label %5

5:                                                ; preds = %3, %1, %1
  %6 = tail call i32 @luaL_getmetafield(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.46.327) #46
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %10, label %8

8:                                                ; preds = %5
  %9 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.56) #46
  br label %10

10:                                               ; preds = %8, %5
  tail call void @lua_settop(ptr noundef %0, i32 noundef 2) #46
  %11 = tail call i32 @lua_setmetatable(ptr noundef %0, i32 noundef 1) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_tonumber(ptr noundef %0) #1 {
  %2 = alloca ptr, align 8
  %3 = tail call i64 @luaL_optinteger(ptr noundef %0, i32 noundef 2, i64 noundef 10) #46
  %4 = trunc i64 %3 to i32
  %5 = icmp eq i32 %4, 10
  br i1 %5, label %6, label %11

6:                                                ; preds = %1
  tail call void @luaL_checkany(ptr noundef %0, i32 noundef 1) #46
  %7 = tail call i32 @lua_isnumber(ptr noundef %0, i32 noundef 1) #46
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %38, label %9

9:                                                ; preds = %6
  %10 = tail call double @lua_tonumber(ptr noundef %0, i32 noundef 1) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %10) #46
  br label %39

11:                                               ; preds = %1
  %12 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  %13 = add i32 %4, -2
  %14 = icmp ult i32 %13, 35
  br i1 %14, label %17, label %15

15:                                               ; preds = %11
  %16 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef 2, ptr noundef nonnull @.str.57) #46
  br label %17

17:                                               ; preds = %15, %11
  %18 = call i64 @strtoul(ptr noundef %12, ptr noundef nonnull %2, i32 noundef %4) #46
  %19 = load ptr, ptr %2, align 8, !tbaa !39
  %20 = icmp eq ptr %12, %19
  br i1 %20, label %37, label %21

21:                                               ; preds = %17
  %22 = tail call ptr @__ctype_b_loc() #52
  %23 = load ptr, ptr %22, align 8, !tbaa !39
  br label %24

24:                                               ; preds = %24, %21
  %25 = phi ptr [ %19, %21 ], [ %32, %24 ]
  %26 = load i8, ptr %25, align 1, !tbaa !33
  %27 = zext i8 %26 to i64
  %28 = getelementptr inbounds i16, ptr %23, i64 %27
  %29 = load i16, ptr %28, align 2, !tbaa !239
  %30 = and i16 %29, 8192
  %31 = icmp eq i16 %30, 0
  %32 = getelementptr inbounds i8, ptr %25, i64 1
  br i1 %31, label %33, label %24, !llvm.loop !405

33:                                               ; preds = %24
  %.lcssa = phi i8 [ %26, %24 ]
  %34 = icmp eq i8 %.lcssa, 0
  br i1 %34, label %35, label %37

35:                                               ; preds = %33
  %36 = uitofp i64 %18 to double
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %36) #46
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  br label %39

37:                                               ; preds = %33, %17
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  br label %38

38:                                               ; preds = %37, %6
  tail call void @lua_pushnil(ptr noundef %0) #46
  br label %39

39:                                               ; preds = %38, %35, %9
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_tostring(ptr noundef %0) #1 {
  tail call void @luaL_checkany(ptr noundef %0, i32 noundef 1) #46
  %2 = tail call i32 @luaL_callmeta(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.58) #46
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %19

4:                                                ; preds = %1
  %5 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 1) #46
  switch i32 %5, label %14 [
    i32 3, label %6
    i32 4, label %8
    i32 1, label %9
    i32 0, label %13
  ]

6:                                                ; preds = %4
  %7 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef %7) #46
  br label %19

8:                                                ; preds = %4
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef 1) #46
  br label %19

9:                                                ; preds = %4
  %10 = tail call i32 @lua_toboolean(ptr noundef %0, i32 noundef 1) #46
  %11 = icmp eq i32 %10, 0
  %12 = select i1 %11, ptr @.str.60, ptr @.str.59
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef nonnull %12) #46
  br label %19

13:                                               ; preds = %4
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.61, i64 noundef 3) #46
  br label %19

14:                                               ; preds = %4
  %15 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 1) #46
  %16 = tail call ptr @lua_typename(ptr noundef %0, i32 noundef %15) #46
  %17 = tail call ptr @lua_topointer(ptr noundef %0, i32 noundef 1) #46
  %18 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.62, ptr noundef %16, ptr noundef %17) #46
  br label %19

19:                                               ; preds = %14, %13, %9, %8, %6, %1
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_type(ptr noundef %0) #1 {
  tail call void @luaL_checkany(ptr noundef %0, i32 noundef 1) #46
  %2 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call ptr @lua_typename(ptr noundef %0, i32 noundef %2) #46
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_unpack(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  %2 = tail call i64 @luaL_optinteger(ptr noundef %0, i32 noundef 2, i64 noundef 1) #46
  %3 = trunc i64 %2 to i32
  %4 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 3) #46
  %5 = icmp slt i32 %4, 1
  br i1 %5, label %6, label %8

6:                                                ; preds = %1
  %7 = tail call i64 @lua_objlen(ptr noundef %0, i32 noundef 1) #46
  br label %10

8:                                                ; preds = %1
  %9 = tail call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef 3) #46
  br label %10

10:                                               ; preds = %8, %6
  %11 = phi i64 [ %7, %6 ], [ %9, %8 ]
  %12 = trunc i64 %11 to i32
  %13 = icmp sgt i32 %3, %12
  br i1 %13, label %29, label %14

14:                                               ; preds = %10
  %15 = sub nsw i32 %12, %3
  %16 = add nsw i32 %15, 1
  %17 = icmp slt i32 %15, 0
  br i1 %17, label %21, label %18

18:                                               ; preds = %14
  %19 = tail call i32 @lua_checkstack(ptr noundef %0, i32 noundef %16) #46
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %21, label %23

21:                                               ; preds = %18, %14
  %22 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.63) #46
  br label %29

23:                                               ; preds = %18
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %3) #46
  %24 = icmp slt i32 %3, %12
  br i1 %24, label %25, label %29

25:                                               ; preds = %25, %23
  %26 = phi i32 [ %27, %25 ], [ %3, %23 ]
  %27 = add nsw i32 %26, 1
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %27) #46
  %28 = icmp eq i32 %27, %12
  br i1 %28, label %29, label %25, !llvm.loop !406

29:                                               ; preds = %25, %23, %21, %10
  %30 = phi i32 [ %22, %21 ], [ 0, %10 ], [ %16, %23 ], [ %16, %25 ]
  ret i32 %30
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_xpcall(ptr noundef %0) #1 {
  tail call void @luaL_checkany(ptr noundef %0, i32 noundef 2) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef 2) #46
  tail call void @lua_insert(ptr noundef %0, i32 noundef 1) #46
  %2 = tail call i32 @lua_pcall(ptr noundef %0, i32 noundef 0, i32 noundef -1, i32 noundef 1) #46
  %3 = icmp eq i32 %2, 0
  %4 = zext i1 %3 to i32
  tail call void @lua_pushboolean(ptr noundef %0, i32 noundef %4) #46
  tail call void @lua_replace(ptr noundef %0, i32 noundef 1) #46
  %5 = tail call i32 @lua_gettop(ptr noundef %0) #46
  ret i32 %5
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @getfunc(ptr noundef %0, i32 noundef %1) unnamed_addr #1 {
  %3 = alloca %struct.lua_Debug, align 8
  %4 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 1) #46
  %5 = icmp eq i32 %4, 6
  br i1 %5, label %6, label %7

6:                                                ; preds = %2
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef 1) #46
  br label %31

7:                                                ; preds = %2
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %3) #48
  %8 = icmp eq i32 %1, 0
  br i1 %8, label %11, label %9

9:                                                ; preds = %7
  %10 = tail call i64 @luaL_optinteger(ptr noundef %0, i32 noundef 1, i64 noundef 1) #46
  br label %13

11:                                               ; preds = %7
  %12 = tail call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef 1) #46
  br label %13

13:                                               ; preds = %11, %9
  %14 = phi i64 [ %10, %9 ], [ %12, %11 ]
  %15 = trunc i64 %14 to i32
  %16 = icmp sgt i32 %15, -1
  br i1 %16, label %19, label %17

17:                                               ; preds = %13
  %18 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.42.328) #46
  br label %19

19:                                               ; preds = %17, %13
  %20 = call i32 @lua_getstack(ptr noundef %0, i32 noundef %15, ptr noundef nonnull %3) #46
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %22, label %24

22:                                               ; preds = %19
  %23 = call i32 @luaL_argerror(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.43.329) #46
  br label %24

24:                                               ; preds = %22, %19
  %25 = call i32 @lua_getinfo(ptr noundef %0, ptr noundef nonnull @.str.44.330, ptr noundef nonnull %3) #46
  %26 = call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %28, label %30

28:                                               ; preds = %24
  %29 = call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.45.331, i32 noundef %15) #46
  br label %30

30:                                               ; preds = %28, %24
  call void @llvm.lifetime.end.p0(i64 120, ptr nonnull %3) #48
  br label %31

31:                                               ; preds = %30, %6
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #12

; Function Attrs: nofree nounwind optsize
declare noundef i32 @fputs(ptr nocapture noundef readonly, ptr nocapture noundef) local_unnamed_addr #31

; Function Attrs: nounwind optsize uwtable
define internal ptr @generic_reader(ptr noundef %0, ptr nocapture readnone %1, ptr noundef %2) #1 {
  tail call void @luaL_checkstack(ptr noundef %0, i32 noundef 2, ptr noundef nonnull @.str.48) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef 1) #46
  tail call void @lua_call(ptr noundef %0, i32 noundef 0, i32 noundef 1) #46
  %4 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %7

6:                                                ; preds = %3
  store i64 0, ptr %2, align 8, !tbaa !40
  br label %14

7:                                                ; preds = %3
  %8 = tail call i32 @lua_isstring(ptr noundef %0, i32 noundef -1) #46
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %7
  tail call void @lua_replace(ptr noundef %0, i32 noundef 3) #46
  %11 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef 3, ptr noundef %2) #46
  br label %14

12:                                               ; preds = %7
  %13 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.49) #46
  br label %14

14:                                               ; preds = %12, %10, %6
  %15 = phi ptr [ null, %6 ], [ %11, %10 ], [ null, %12 ]
  ret ptr %15
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaopen_debug(ptr noundef %0) #1 {
  tail call void @luaL_register(ptr noundef %0, ptr noundef nonnull @.str.341, ptr noundef nonnull @dblib) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_debug(ptr noundef %0) #1 {
  %2 = alloca [250 x i8], align 16
  br label %3

3:                                                ; preds = %25, %1
  call void @llvm.lifetime.start.p0(i64 250, ptr nonnull %2) #48
  %4 = load ptr, ptr @stderr, align 8, !tbaa !39
  %5 = call i32 @fputs(ptr noundef nonnull @.str.14.391, ptr noundef %4) #54
  %6 = load ptr, ptr @stdin, align 8, !tbaa !39
  %7 = call ptr @fgets(ptr noundef nonnull %2, i32 noundef 250, ptr noundef %6) #47
  %8 = icmp eq ptr %7, null
  br i1 %8, label %26, label %9

9:                                                ; preds = %3
  %10 = call i32 @bcmp(ptr noundef nonnull dereferenceable(6) %2, ptr noundef nonnull dereferenceable(6) @.str.15.392, i64 6)
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %26, label %12

12:                                               ; preds = %9
  %13 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %2) #49
  %14 = call i32 @luaL_loadbuffer(ptr noundef %0, ptr noundef nonnull %2, i64 noundef %13, ptr noundef nonnull @.str.16.393) #46
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %19

16:                                               ; preds = %12
  %17 = call i32 @lua_pcall(ptr noundef %0, i32 noundef 0, i32 noundef 0, i32 noundef 0) #46
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %25, label %19

19:                                               ; preds = %16, %12
  %20 = call ptr @lua_tolstring(ptr noundef %0, i32 noundef -1, ptr noundef null) #46
  %21 = load ptr, ptr @stderr, align 8, !tbaa !39
  %22 = call i32 @fputs(ptr noundef %20, ptr noundef %21) #54
  %23 = load ptr, ptr @stderr, align 8, !tbaa !39
  %24 = call i32 @fputs(ptr noundef nonnull @.str.17.356, ptr noundef %23) #54
  br label %25

25:                                               ; preds = %19, %16
  call void @lua_settop(ptr noundef %0, i32 noundef 0) #46
  call void @llvm.lifetime.end.p0(i64 250, ptr nonnull %2) #48
  br label %3

26:                                               ; preds = %9, %3
  call void @llvm.lifetime.end.p0(i64 250, ptr nonnull %2) #48
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_getfenv(ptr noundef %0) #1 {
  tail call void @lua_getfenv(ptr noundef %0, i32 noundef 1) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_gethook(ptr noundef %0) #1 {
  %2 = alloca i32, align 4
  %3 = alloca [5 x i8], align 1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #48
  %4 = call fastcc ptr @getthread(ptr noundef %0, ptr noundef nonnull %2) #47
  call void @llvm.lifetime.start.p0(i64 5, ptr nonnull %3) #48
  %5 = tail call i32 @lua_gethookmask(ptr noundef %4) #46
  %6 = tail call ptr @lua_gethook(ptr noundef %4) #46
  %7 = icmp ne ptr %6, null
  %8 = icmp ne ptr %6, @hookf
  %9 = and i1 %7, %8
  br i1 %9, label %10, label %11

10:                                               ; preds = %1
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.18.390, i64 noundef 13) #46
  br label %12

11:                                               ; preds = %1
  tail call fastcc void @gethooktable(ptr noundef %0) #47
  tail call void @lua_pushlightuserdata(ptr noundef %0, ptr noundef %4) #46
  tail call void @lua_rawget(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_remove(ptr noundef %0, i32 noundef -2) #46
  br label %12

12:                                               ; preds = %11, %10
  %13 = and i32 %5, 1
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %16, label %15

15:                                               ; preds = %12
  store i8 99, ptr %3, align 1, !tbaa !33
  br label %16

16:                                               ; preds = %15, %12
  %17 = phi i32 [ 1, %15 ], [ 0, %12 ]
  %18 = and i32 %5, 2
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %24, label %20

20:                                               ; preds = %16
  %21 = add nuw nsw i32 %17, 1
  %22 = zext i32 %17 to i64
  %23 = getelementptr inbounds i8, ptr %3, i64 %22
  store i8 114, ptr %23, align 1, !tbaa !33
  br label %24

24:                                               ; preds = %20, %16
  %25 = phi i32 [ %21, %20 ], [ %17, %16 ]
  %26 = and i32 %5, 4
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %32, label %28

28:                                               ; preds = %24
  %29 = add nuw nsw i32 %25, 1
  %30 = zext i32 %25 to i64
  %31 = getelementptr inbounds i8, ptr %3, i64 %30
  store i8 108, ptr %31, align 1, !tbaa !33
  br label %32

32:                                               ; preds = %28, %24
  %33 = phi i32 [ %29, %28 ], [ %25, %24 ]
  %34 = zext i32 %33 to i64
  %35 = getelementptr inbounds i8, ptr %3, i64 %34
  store i8 0, ptr %35, align 1, !tbaa !33
  call void @lua_pushstring(ptr noundef %0, ptr noundef nonnull %3) #46
  %36 = call i32 @lua_gethookcount(ptr noundef %4) #46
  %37 = sext i32 %36 to i64
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %37) #46
  call void @llvm.lifetime.end.p0(i64 5, ptr nonnull %3) #48
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #48
  ret i32 3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_getinfo(ptr noundef %0) #1 {
  %2 = alloca %struct.lua_Debug, align 8
  %3 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %2) #48
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #48
  %4 = call fastcc ptr @getthread(ptr noundef %0, ptr noundef nonnull %3) #47
  %5 = load i32, ptr %3, align 4, !tbaa !65
  %6 = add nsw i32 %5, 2
  %7 = tail call ptr @luaL_optlstring(ptr noundef %0, i32 noundef %6, ptr noundef nonnull @.str.24.375, ptr noundef null) #46
  %8 = add nsw i32 %5, 1
  %9 = tail call i32 @lua_isnumber(ptr noundef %0, i32 noundef %8) #46
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %17, label %11

11:                                               ; preds = %1
  %12 = tail call i64 @lua_tointeger(ptr noundef %0, i32 noundef %8) #46
  %13 = trunc i64 %12 to i32
  %14 = call i32 @lua_getstack(ptr noundef %4, i32 noundef %13, ptr noundef nonnull %2) #46
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %25

16:                                               ; preds = %11
  call void @lua_pushnil(ptr noundef %0) #46
  br label %76

17:                                               ; preds = %1
  %18 = tail call i32 @lua_type(ptr noundef %0, i32 noundef %8) #46
  %19 = icmp eq i32 %18, 6
  br i1 %19, label %20, label %23

20:                                               ; preds = %17
  %21 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.25.376, ptr noundef %7) #46
  %22 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef -1, ptr noundef null) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef %8) #46
  tail call void @lua_xmove(ptr noundef %0, ptr noundef %4, i32 noundef 1) #46
  br label %25

23:                                               ; preds = %17
  %24 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef %8, ptr noundef nonnull @.str.26.377) #46
  br label %76

25:                                               ; preds = %20, %11
  %26 = phi ptr [ %7, %11 ], [ %22, %20 ]
  %27 = call i32 @lua_getinfo(ptr noundef %4, ptr noundef %26, ptr noundef nonnull %2) #46
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %29, label %31

29:                                               ; preds = %25
  %30 = call i32 @luaL_argerror(ptr noundef %0, i32 noundef %6, ptr noundef nonnull @.str.27.378) #46
  br label %76

31:                                               ; preds = %25
  call void @lua_createtable(ptr noundef %0, i32 noundef 0, i32 noundef 2) #46
  %32 = call ptr @strchr(ptr noundef nonnull dereferenceable(1) %26, i32 noundef 83) #49
  %33 = icmp eq ptr %32, null
  br i1 %33, label %46, label %34

34:                                               ; preds = %31
  %35 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 4
  %36 = load ptr, ptr %35, align 8, !tbaa !103
  call void @lua_pushstring(ptr noundef %0, ptr noundef %36) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.28.379) #46
  %37 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 9
  call void @lua_pushstring(ptr noundef %0, ptr noundef nonnull %37) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.29.380) #46
  %38 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 7
  %39 = load i32, ptr %38, align 8, !tbaa !104
  %40 = sext i32 %39 to i64
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %40) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.30.381) #46
  %41 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 8
  %42 = load i32, ptr %41, align 4, !tbaa !114
  %43 = sext i32 %42 to i64
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %43) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.31.382) #46
  %44 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 3
  %45 = load ptr, ptr %44, align 8, !tbaa !113
  call void @lua_pushstring(ptr noundef %0, ptr noundef %45) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.32.383) #46
  br label %46

46:                                               ; preds = %34, %31
  %47 = call ptr @strchr(ptr noundef nonnull dereferenceable(1) %26, i32 noundef 108) #49
  %48 = icmp eq ptr %47, null
  br i1 %48, label %53, label %49

49:                                               ; preds = %46
  %50 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 5
  %51 = load i32, ptr %50, align 8, !tbaa !108
  %52 = sext i32 %51 to i64
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %52) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.33.384) #46
  br label %53

53:                                               ; preds = %49, %46
  %54 = call ptr @strchr(ptr noundef nonnull dereferenceable(1) %26, i32 noundef 117) #49
  %55 = icmp eq ptr %54, null
  br i1 %55, label %60, label %56

56:                                               ; preds = %53
  %57 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 6
  %58 = load i32, ptr %57, align 4, !tbaa !109
  %59 = sext i32 %58 to i64
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %59) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.34.385) #46
  br label %60

60:                                               ; preds = %56, %53
  %61 = call ptr @strchr(ptr noundef nonnull dereferenceable(1) %26, i32 noundef 110) #49
  %62 = icmp eq ptr %61, null
  br i1 %62, label %68, label %63

63:                                               ; preds = %60
  %64 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 1
  %65 = load ptr, ptr %64, align 8, !tbaa !111
  call void @lua_pushstring(ptr noundef %0, ptr noundef %65) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.35.386) #46
  %66 = getelementptr inbounds %struct.lua_Debug, ptr %2, i64 0, i32 2
  %67 = load ptr, ptr %66, align 8, !tbaa !110
  call void @lua_pushstring(ptr noundef %0, ptr noundef %67) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.36.387) #46
  br label %68

68:                                               ; preds = %63, %60
  %69 = call ptr @strchr(ptr noundef nonnull dereferenceable(1) %26, i32 noundef 76) #49
  %70 = icmp eq ptr %69, null
  br i1 %70, label %72, label %71

71:                                               ; preds = %68
  call fastcc void @treatstackoption(ptr noundef %0, ptr noundef %4, ptr noundef nonnull @.str.37.388) #47
  br label %72

72:                                               ; preds = %71, %68
  %73 = call ptr @strchr(ptr noundef nonnull dereferenceable(1) %26, i32 noundef 102) #49
  %74 = icmp eq ptr %73, null
  br i1 %74, label %76, label %75

75:                                               ; preds = %72
  call fastcc void @treatstackoption(ptr noundef %0, ptr noundef %4, ptr noundef nonnull @.str.38.389) #47
  br label %76

76:                                               ; preds = %75, %72, %29, %23, %16
  %77 = phi i32 [ %30, %29 ], [ 1, %16 ], [ %24, %23 ], [ 1, %75 ], [ 1, %72 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #48
  call void @llvm.lifetime.end.p0(i64 120, ptr nonnull %2) #48
  ret i32 %77
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_getlocal(ptr noundef %0) #1 {
  %2 = alloca i32, align 4
  %3 = alloca %struct.lua_Debug, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #48
  %4 = call fastcc ptr @getthread(ptr noundef %0, ptr noundef nonnull %2) #47
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %3) #48
  %5 = load i32, ptr %2, align 4, !tbaa !65
  %6 = add nsw i32 %5, 1
  %7 = tail call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef %6) #46
  %8 = trunc i64 %7 to i32
  %9 = call i32 @lua_getstack(ptr noundef %4, i32 noundef %8, ptr noundef nonnull %3) #46
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %11, label %13

11:                                               ; preds = %1
  %12 = call i32 @luaL_argerror(ptr noundef %0, i32 noundef %6, ptr noundef nonnull @.str.39.368) #46
  br label %21

13:                                               ; preds = %1
  %14 = add nsw i32 %5, 2
  %15 = call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef %14) #46
  %16 = trunc i64 %15 to i32
  %17 = call ptr @lua_getlocal(ptr noundef %4, ptr noundef nonnull %3, i32 noundef %16) #46
  %18 = icmp eq ptr %17, null
  br i1 %18, label %20, label %19

19:                                               ; preds = %13
  call void @lua_xmove(ptr noundef %4, ptr noundef %0, i32 noundef 1) #46
  call void @lua_pushstring(ptr noundef %0, ptr noundef nonnull %17) #46
  call void @lua_pushvalue(ptr noundef %0, i32 noundef -2) #46
  br label %21

20:                                               ; preds = %13
  call void @lua_pushnil(ptr noundef %0) #46
  br label %21

21:                                               ; preds = %20, %19, %11
  %22 = phi i32 [ 2, %19 ], [ 1, %20 ], [ %12, %11 ]
  call void @llvm.lifetime.end.p0(i64 120, ptr nonnull %3) #48
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #48
  ret i32 %22
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_getregistry(ptr noundef %0) #1 {
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -10000) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_getmetatable(ptr noundef %0) #1 {
  tail call void @luaL_checkany(ptr noundef %0, i32 noundef 1) #46
  %2 = tail call i32 @lua_getmetatable(ptr noundef %0, i32 noundef 1) #46
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  tail call void @lua_pushnil(ptr noundef %0) #46
  br label %5

5:                                                ; preds = %4, %1
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_getupvalue(ptr noundef %0) #1 {
  %2 = tail call fastcc i32 @auxupvalue(ptr noundef %0, i32 noundef 1) #47, !range !150
  ret i32 %2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_setfenv(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 2, i32 noundef 5) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef 2) #46
  %2 = tail call i32 @lua_setfenv(ptr noundef %0, i32 noundef 1) #46
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %6

4:                                                ; preds = %1
  %5 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.40.374) #46
  br label %6

6:                                                ; preds = %4, %1
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_sethook(ptr noundef %0) #1 {
  %2 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #48
  %3 = call fastcc ptr @getthread(ptr noundef %0, ptr noundef nonnull %2) #47
  %4 = load i32, ptr %2, align 4, !tbaa !65
  %5 = add nsw i32 %4, 1
  %6 = tail call i32 @lua_type(ptr noundef %0, i32 noundef %5) #46
  %7 = icmp slt i32 %6, 1
  br i1 %7, label %8, label %9

8:                                                ; preds = %1
  tail call void @lua_settop(ptr noundef %0, i32 noundef %5) #46
  br label %29

9:                                                ; preds = %1
  %10 = add nsw i32 %4, 2
  %11 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef %10, ptr noundef null) #46
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef %5, i32 noundef 6) #46
  %12 = add nsw i32 %4, 3
  %13 = tail call i64 @luaL_optinteger(ptr noundef %0, i32 noundef %12, i64 noundef 0) #46
  %14 = trunc i64 %13 to i32
  %15 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %11, i32 noundef 99) #49
  %16 = icmp ne ptr %15, null
  %17 = zext i1 %16 to i32
  %18 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %11, i32 noundef 114) #49
  %19 = icmp eq ptr %18, null
  %20 = or i32 %17, 2
  %21 = select i1 %19, i32 %17, i32 %20
  %22 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %11, i32 noundef 108) #49
  %23 = icmp eq ptr %22, null
  %24 = or i32 %21, 4
  %25 = select i1 %23, i32 %21, i32 %24
  %26 = icmp sgt i32 %14, 0
  %27 = or i32 %25, 8
  %28 = select i1 %26, i32 %27, i32 %25
  br label %29

29:                                               ; preds = %9, %8
  %30 = phi ptr [ null, %8 ], [ @hookf, %9 ]
  %31 = phi i32 [ 0, %8 ], [ %14, %9 ]
  %32 = phi i32 [ 0, %8 ], [ %28, %9 ]
  tail call fastcc void @gethooktable(ptr noundef %0) #47
  tail call void @lua_pushlightuserdata(ptr noundef %0, ptr noundef %3) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef %5) #46
  tail call void @lua_rawset(ptr noundef %0, i32 noundef -3) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  %33 = tail call i32 @lua_sethook(ptr noundef %3, ptr noundef %30, i32 noundef %32, i32 noundef %31) #46
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #48
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_setlocal(ptr noundef %0) #1 {
  %2 = alloca i32, align 4
  %3 = alloca %struct.lua_Debug, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #48
  %4 = call fastcc ptr @getthread(ptr noundef %0, ptr noundef nonnull %2) #47
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %3) #48
  %5 = load i32, ptr %2, align 4, !tbaa !65
  %6 = add nsw i32 %5, 1
  %7 = tail call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef %6) #46
  %8 = trunc i64 %7 to i32
  %9 = call i32 @lua_getstack(ptr noundef %4, i32 noundef %8, ptr noundef nonnull %3) #46
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %11, label %13

11:                                               ; preds = %1
  %12 = call i32 @luaL_argerror(ptr noundef %0, i32 noundef %6, ptr noundef nonnull @.str.39.368) #46
  br label %19

13:                                               ; preds = %1
  %14 = add nsw i32 %5, 3
  call void @luaL_checkany(ptr noundef %0, i32 noundef %14) #46
  call void @lua_settop(ptr noundef %0, i32 noundef %14) #46
  call void @lua_xmove(ptr noundef %0, ptr noundef %4, i32 noundef 1) #46
  %15 = add nsw i32 %5, 2
  %16 = call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef %15) #46
  %17 = trunc i64 %16 to i32
  %18 = call ptr @lua_setlocal(ptr noundef %4, ptr noundef nonnull %3, i32 noundef %17) #46
  call void @lua_pushstring(ptr noundef %0, ptr noundef %18) #46
  br label %19

19:                                               ; preds = %13, %11
  %20 = phi i32 [ 1, %13 ], [ %12, %11 ]
  call void @llvm.lifetime.end.p0(i64 120, ptr nonnull %3) #48
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #48
  ret i32 %20
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_setmetatable(ptr noundef %0) #1 {
  %2 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 2) #46
  switch i32 %2, label %3 [
    i32 5, label %5
    i32 0, label %5
  ]

3:                                                ; preds = %1
  %4 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef 2, ptr noundef nonnull @.str.41.367) #46
  br label %5

5:                                                ; preds = %3, %1, %1
  tail call void @lua_settop(ptr noundef %0, i32 noundef 2) #46
  %6 = tail call i32 @lua_setmetatable(ptr noundef %0, i32 noundef 1) #46
  tail call void @lua_pushboolean(ptr noundef %0, i32 noundef %6) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_setupvalue(ptr noundef %0) #1 {
  tail call void @luaL_checkany(ptr noundef %0, i32 noundef 3) #46
  %2 = tail call fastcc i32 @auxupvalue(ptr noundef %0, i32 noundef 0) #47, !range !150
  ret i32 %2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_errorfb(ptr noundef %0) #1 {
  %2 = alloca i32, align 4
  %3 = alloca %struct.lua_Debug, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #48
  %4 = call fastcc ptr @getthread(ptr noundef %0, ptr noundef nonnull %2) #47
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %3) #48
  %5 = load i32, ptr %2, align 4, !tbaa !65
  %6 = add nsw i32 %5, 2
  %7 = tail call i32 @lua_isnumber(ptr noundef %0, i32 noundef %6) #46
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %12, label %9

9:                                                ; preds = %1
  %10 = tail call i64 @lua_tointeger(ptr noundef %0, i32 noundef %6) #46
  %11 = trunc i64 %10 to i32
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  br label %15

12:                                               ; preds = %1
  %13 = icmp eq ptr %4, %0
  %14 = zext i1 %13 to i32
  br label %15

15:                                               ; preds = %12, %9
  %16 = phi i32 [ %11, %9 ], [ %14, %12 ]
  %17 = tail call i32 @lua_gettop(ptr noundef %0) #46
  %18 = icmp eq i32 %17, %5
  br i1 %18, label %19, label %20

19:                                               ; preds = %15
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.42.355, i64 noundef 0) #46
  br label %25

20:                                               ; preds = %15
  %21 = add nsw i32 %5, 1
  %22 = tail call i32 @lua_isstring(ptr noundef %0, i32 noundef %21) #46
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %85, label %24

24:                                               ; preds = %20
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.17.356, i64 noundef 1) #46
  br label %25

25:                                               ; preds = %24, %19
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.43.357, i64 noundef 16) #46
  %26 = getelementptr inbounds %struct.lua_Debug, ptr %3, i64 0, i32 9
  %27 = getelementptr inbounds %struct.lua_Debug, ptr %3, i64 0, i32 5
  %28 = getelementptr inbounds %struct.lua_Debug, ptr %3, i64 0, i32 2
  %29 = getelementptr inbounds %struct.lua_Debug, ptr %3, i64 0, i32 1
  %30 = getelementptr inbounds %struct.lua_Debug, ptr %3, i64 0, i32 3
  %31 = getelementptr inbounds %struct.lua_Debug, ptr %3, i64 0, i32 7
  br label %32

32:                                               ; preds = %54, %25
  %33 = phi i32 [ %55, %54 ], [ %16, %25 ]
  %34 = phi i1 [ false, %54 ], [ true, %25 ]
  br label %35

35:                                               ; preds = %79, %32
  %36 = phi i32 [ %37, %79 ], [ %33, %32 ]
  %37 = add nsw i32 %36, 1
  %38 = call i32 @lua_getstack(ptr noundef %4, i32 noundef %36, ptr noundef nonnull %3) #46
  %39 = icmp eq i32 %38, 0
  br i1 %39, label %82, label %40

40:                                               ; preds = %35
  %41 = icmp sgt i32 %36, 11
  %42 = and i1 %41, %34
  br i1 %42, label %43, label %56

43:                                               ; preds = %40
  %.lcssa3 = phi i32 [ %36, %40 ]
  %.lcssa1 = phi i32 [ %37, %40 ]
  %44 = add nuw nsw i32 %.lcssa3, 11
  %45 = call i32 @lua_getstack(ptr noundef %4, i32 noundef %44, ptr noundef nonnull %3) #46
  %46 = icmp eq i32 %45, 0
  br i1 %46, label %54, label %47

47:                                               ; preds = %43
  call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.44.358, i64 noundef 5) #46
  br label %48

48:                                               ; preds = %48, %47
  %49 = phi i32 [ %.lcssa1, %47 ], [ %53, %48 ]
  %50 = add nsw i32 %49, 10
  %51 = call i32 @lua_getstack(ptr noundef %4, i32 noundef %50, ptr noundef nonnull %3) #46
  %52 = icmp eq i32 %51, 0
  %53 = add nsw i32 %49, 1
  br i1 %52, label %54, label %48, !llvm.loop !407

54:                                               ; preds = %48, %43
  %55 = phi i32 [ %.lcssa3, %43 ], [ %49, %48 ]
  br label %32, !llvm.loop !408

56:                                               ; preds = %40
  call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.45.359, i64 noundef 2) #46
  %57 = call i32 @lua_getinfo(ptr noundef %4, ptr noundef nonnull @.str.46.360, ptr noundef nonnull %3) #46
  %58 = call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.47.361, ptr noundef nonnull %26) #46
  %59 = load i32, ptr %27, align 8, !tbaa !108
  %60 = icmp sgt i32 %59, 0
  br i1 %60, label %61, label %63

61:                                               ; preds = %56
  %62 = call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.48.362, i32 noundef %59) #46
  br label %63

63:                                               ; preds = %61, %56
  %64 = load ptr, ptr %28, align 8, !tbaa !110
  %65 = load i8, ptr %64, align 1, !tbaa !33
  %66 = icmp eq i8 %65, 0
  br i1 %66, label %70, label %67

67:                                               ; preds = %63
  %68 = load ptr, ptr %29, align 8, !tbaa !111
  %69 = call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.49.363, ptr noundef %68) #46
  br label %79

70:                                               ; preds = %63
  %71 = load ptr, ptr %30, align 8, !tbaa !113
  %72 = load i8, ptr %71, align 1, !tbaa !33
  switch i8 %72, label %76 [
    i8 109, label %73
    i8 67, label %75
    i8 116, label %75
  ]

73:                                               ; preds = %70
  %74 = call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.50.364) #46
  br label %79

75:                                               ; preds = %70, %70
  call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.51.365, i64 noundef 2) #46
  br label %79

76:                                               ; preds = %70
  %77 = load i32, ptr %31, align 8, !tbaa !104
  %78 = call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.52.366, ptr noundef nonnull %26, i32 noundef %77) #46
  br label %79

79:                                               ; preds = %76, %75, %73, %67
  %80 = call i32 @lua_gettop(ptr noundef %0) #46
  %81 = sub nsw i32 %80, %5
  call void @lua_concat(ptr noundef %0, i32 noundef %81) #46
  br label %35, !llvm.loop !408

82:                                               ; preds = %35
  %83 = call i32 @lua_gettop(ptr noundef %0) #46
  %84 = sub nsw i32 %83, %5
  call void @lua_concat(ptr noundef %0, i32 noundef %84) #46
  br label %85

85:                                               ; preds = %82, %20
  call void @llvm.lifetime.end.p0(i64 120, ptr nonnull %3) #48
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #48
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @getthread(ptr noundef %0, ptr nocapture noundef writeonly %1) unnamed_addr #1 {
  %3 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 1) #46
  %4 = icmp eq i32 %3, 8
  br i1 %4, label %5, label %7

5:                                                ; preds = %2
  store i32 1, ptr %1, align 4, !tbaa !65
  %6 = tail call ptr @lua_tothread(ptr noundef %0, i32 noundef 1) #46
  br label %8

7:                                                ; preds = %2
  store i32 0, ptr %1, align 4, !tbaa !65
  br label %8

8:                                                ; preds = %7, %5
  %9 = phi ptr [ %6, %5 ], [ %0, %7 ]
  ret ptr %9
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @auxupvalue(ptr noundef %0, i32 noundef %1) unnamed_addr #1 {
  %3 = tail call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef 2) #46
  %4 = trunc i64 %3 to i32
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 6) #46
  %5 = tail call i32 @lua_iscfunction(ptr noundef %0, i32 noundef 1) #46
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %19

7:                                                ; preds = %2
  %8 = icmp eq i32 %1, 0
  br i1 %8, label %11, label %9

9:                                                ; preds = %7
  %10 = tail call ptr @lua_getupvalue(ptr noundef %0, i32 noundef 1, i32 noundef %4) #46
  br label %13

11:                                               ; preds = %7
  %12 = tail call ptr @lua_setupvalue(ptr noundef %0, i32 noundef 1, i32 noundef %4) #46
  br label %13

13:                                               ; preds = %11, %9
  %14 = phi ptr [ %10, %9 ], [ %12, %11 ]
  %15 = icmp eq ptr %14, null
  br i1 %15, label %19, label %16

16:                                               ; preds = %13
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef nonnull %14) #46
  %17 = add nuw nsw i32 %1, 1
  %18 = xor i32 %1, -1
  tail call void @lua_insert(ptr noundef %0, i32 noundef %18) #46
  br label %19

19:                                               ; preds = %16, %13, %2
  %20 = phi i32 [ %17, %16 ], [ 0, %2 ], [ 0, %13 ]
  ret i32 %20
}

; Function Attrs: nounwind optsize uwtable
define internal void @hookf(ptr noundef %0, ptr nocapture noundef readonly %1) #1 {
  tail call void @lua_pushlightuserdata(ptr noundef %0, ptr noundef nonnull @KEY_HOOK) #46
  tail call void @lua_rawget(ptr noundef %0, i32 noundef -10000) #46
  tail call void @lua_pushlightuserdata(ptr noundef %0, ptr noundef %0) #46
  tail call void @lua_rawget(ptr noundef %0, i32 noundef -2) #46
  %3 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %4 = icmp eq i32 %3, 6
  br i1 %4, label %5, label %17

5:                                                ; preds = %2
  %6 = load i32, ptr %1, align 8, !tbaa !137
  %7 = sext i32 %6 to i64
  %8 = getelementptr inbounds [5 x ptr], ptr @hookf.hooknames, i64 0, i64 %7
  %9 = load ptr, ptr %8, align 8, !tbaa !39
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef %9) #46
  %10 = getelementptr inbounds %struct.lua_Debug, ptr %1, i64 0, i32 5
  %11 = load i32, ptr %10, align 8, !tbaa !108
  %12 = icmp sgt i32 %11, -1
  br i1 %12, label %13, label %15

13:                                               ; preds = %5
  %14 = zext i32 %11 to i64
  tail call void @lua_pushinteger(ptr noundef %0, i64 noundef %14) #46
  br label %16

15:                                               ; preds = %5
  tail call void @lua_pushnil(ptr noundef %0) #46
  br label %16

16:                                               ; preds = %15, %13
  tail call void @lua_call(ptr noundef %0, i32 noundef 2, i32 noundef 0) #46
  br label %17

17:                                               ; preds = %16, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @gethooktable(ptr noundef %0) unnamed_addr #1 {
  tail call void @lua_pushlightuserdata(ptr noundef %0, ptr noundef nonnull @KEY_HOOK) #46
  tail call void @lua_rawget(ptr noundef %0, i32 noundef -10000) #46
  %2 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %3 = icmp eq i32 %2, 5
  br i1 %3, label %5, label %4

4:                                                ; preds = %1
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_createtable(ptr noundef %0, i32 noundef 0, i32 noundef 1) #46
  tail call void @lua_pushlightuserdata(ptr noundef %0, ptr noundef nonnull @KEY_HOOK) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_rawset(ptr noundef %0, i32 noundef -10000) #46
  br label %5

5:                                                ; preds = %4, %1
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @treatstackoption(ptr noundef %0, ptr noundef %1, ptr noundef %2) unnamed_addr #1 {
  %4 = icmp eq ptr %0, %1
  br i1 %4, label %5, label %6

5:                                                ; preds = %3
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_remove(ptr noundef %0, i32 noundef -3) #46
  br label %7

6:                                                ; preds = %3
  tail call void @lua_xmove(ptr noundef %1, ptr noundef %0, i32 noundef 1) #46
  br label %7

7:                                                ; preds = %6, %5
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef %2) #46
  ret void
}

; Function Attrs: nofree nounwind optsize
declare noundef ptr @fgets(ptr noundef, i32 noundef, ptr nocapture noundef) local_unnamed_addr #31

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaopen_io(ptr noundef %0) #1 {
  %2 = tail call i32 @luaL_newmetatable(ptr noundef %0, ptr noundef nonnull @.str.5.394) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -1) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.6.395) #46
  tail call void @luaL_register(ptr noundef %0, ptr noundef null, ptr noundef nonnull @flib) #46
  tail call fastcc void @newfenv(ptr noundef %0, ptr noundef nonnull @io_fclose) #47
  tail call void @lua_replace(ptr noundef %0, i32 noundef -10001) #46
  tail call void @luaL_register(ptr noundef %0, ptr noundef nonnull @.str.396, ptr noundef nonnull @iolib) #46
  tail call fastcc void @newfenv(ptr noundef %0, ptr noundef nonnull @io_noclose) #47
  %3 = load ptr, ptr @stdin, align 8, !tbaa !39
  tail call fastcc void @createstdfile(ptr noundef %0, ptr noundef %3, i32 noundef 1, ptr noundef nonnull @.str.1.397) #47
  %4 = load ptr, ptr @stdout, align 8, !tbaa !39
  tail call fastcc void @createstdfile(ptr noundef %0, ptr noundef %4, i32 noundef 2, ptr noundef nonnull @.str.2.398) #47
  %5 = load ptr, ptr @stderr, align 8, !tbaa !39
  tail call fastcc void @createstdfile(ptr noundef %0, ptr noundef %5, i32 noundef 0, ptr noundef nonnull @.str.3.399) #47
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -1, ptr noundef nonnull @.str.4.400) #46
  tail call fastcc void @newfenv(ptr noundef %0, ptr noundef nonnull @io_pclose) #47
  %6 = tail call i32 @lua_setfenv(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_fclose(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checkudata(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.5.394) #46
  %3 = load ptr, ptr %2, align 8, !tbaa !39
  %4 = tail call i32 @fclose(ptr noundef %3) #47
  %5 = icmp eq i32 %4, 0
  %6 = zext i1 %5 to i32
  store ptr null, ptr %2, align 8, !tbaa !39
  %7 = tail call fastcc i32 @pushresult(ptr noundef %0, i32 noundef %6, ptr noundef null) #47, !range !409
  ret i32 %7
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @newfenv(ptr noundef %0, ptr noundef %1) unnamed_addr #1 {
  tail call void @lua_createtable(ptr noundef %0, i32 noundef 0, i32 noundef 1) #46
  tail call void @lua_pushcclosure(ptr noundef %0, ptr noundef %1, i32 noundef 0) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.17.426) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_noclose(ptr noundef %0) #1 {
  tail call void @lua_pushnil(ptr noundef %0) #46
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.44.403, i64 noundef 26) #46
  ret i32 2
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @createstdfile(ptr noundef %0, ptr noundef %1, i32 noundef %2, ptr noundef %3) unnamed_addr #1 {
  %5 = tail call fastcc ptr @newfile(ptr noundef %0) #47
  store ptr %1, ptr %5, align 8, !tbaa !39
  %6 = icmp sgt i32 %2, 0
  br i1 %6, label %7, label %8

7:                                                ; preds = %4
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -1) #46
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef -10001, i32 noundef %2) #46
  br label %8

8:                                                ; preds = %7, %4
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -2) #46
  %9 = tail call i32 @lua_setfenv(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -3, ptr noundef %3) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_pclose(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checkudata(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.5.394) #46
  %3 = load ptr, ptr %2, align 8, !tbaa !39
  %4 = tail call i32 @pclose(ptr noundef %3) #47
  %5 = icmp ne i32 %4, -1
  %6 = zext i1 %5 to i32
  store ptr null, ptr %2, align 8, !tbaa !39
  %7 = tail call fastcc i32 @pushresult(ptr noundef %0, i32 noundef %6, ptr noundef null) #47, !range !409
  ret i32 %7
}

; Function Attrs: nofree nounwind optsize
declare noundef i32 @pclose(ptr nocapture noundef) local_unnamed_addr #31

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @pushresult(ptr noundef %0, i32 noundef %1, ptr noundef %2) unnamed_addr #1 {
  %4 = tail call ptr @__errno_location() #52
  %5 = load i32, ptr %4, align 4, !tbaa !65
  %6 = icmp eq i32 %1, 0
  br i1 %6, label %8, label %7

7:                                                ; preds = %3
  tail call void @lua_pushboolean(ptr noundef %0, i32 noundef 1) #46
  br label %17

8:                                                ; preds = %3
  tail call void @lua_pushnil(ptr noundef %0) #46
  %9 = icmp eq ptr %2, null
  %10 = tail call ptr @strerror(i32 noundef %5) #46
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.18.401, ptr noundef nonnull %2, ptr noundef %10) #46
  br label %15

13:                                               ; preds = %8
  %14 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.19.402, ptr noundef %10) #46
  br label %15

15:                                               ; preds = %13, %11
  %16 = sext i32 %5 to i64
  tail call void @lua_pushinteger(ptr noundef %0, i64 noundef %16) #46
  br label %17

17:                                               ; preds = %15, %7
  %18 = phi i32 [ 1, %7 ], [ 3, %15 ]
  ret i32 %18
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @newfile(ptr noundef %0) unnamed_addr #1 {
  %2 = tail call ptr @lua_newuserdata(ptr noundef %0, i64 noundef 8) #46
  store ptr null, ptr %2, align 8, !tbaa !39
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -10000, ptr noundef nonnull @.str.5.394) #46
  %3 = tail call i32 @lua_setmetatable(ptr noundef %0, i32 noundef -2) #46
  ret ptr %2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_close(ptr noundef %0) #1 {
  %2 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 1) #46
  %3 = icmp eq i32 %2, -1
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef -10001, i32 noundef 2) #46
  br label %5

5:                                                ; preds = %4, %1
  %6 = tail call fastcc ptr @tofile(ptr noundef %0) #47
  %7 = tail call fastcc i32 @aux_close(ptr noundef %0) #47
  ret i32 %7
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_flush(ptr noundef %0) #1 {
  %2 = tail call fastcc ptr @getiofile(ptr noundef %0, i32 noundef 2) #47
  %3 = tail call i32 @fflush(ptr noundef %2) #47
  %4 = icmp eq i32 %3, 0
  %5 = zext i1 %4 to i32
  %6 = tail call fastcc i32 @pushresult(ptr noundef %0, i32 noundef %5, ptr noundef null) #47, !range !409
  ret i32 %6
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_input(ptr noundef %0) #1 {
  tail call fastcc void @g_iofile(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.40.422) #47
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_lines(ptr noundef %0) #1 {
  %2 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 1) #46
  %3 = icmp slt i32 %2, 1
  br i1 %3, label %4, label %6

4:                                                ; preds = %1
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef -10001, i32 noundef 1) #46
  %5 = tail call fastcc ptr @tofile(ptr noundef %0) #47
  tail call fastcc void @aux_lines(ptr noundef %0, i32 noundef 1, i32 noundef 0) #47
  br label %14

6:                                                ; preds = %1
  %7 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %8 = tail call fastcc ptr @newfile(ptr noundef %0) #47
  %9 = tail call noalias ptr @fopen(ptr noundef %7, ptr noundef nonnull @.str.40.422) #47
  store ptr %9, ptr %8, align 8, !tbaa !39
  %10 = icmp eq ptr %9, null
  br i1 %10, label %11, label %12

11:                                               ; preds = %6
  tail call fastcc void @fileerror(ptr noundef %0, ptr noundef %7) #47
  br label %12

12:                                               ; preds = %11, %6
  %13 = tail call i32 @lua_gettop(ptr noundef %0) #46
  tail call fastcc void @aux_lines(ptr noundef %0, i32 noundef %13, i32 noundef 1) #47
  br label %14

14:                                               ; preds = %12, %4
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_open(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %3 = tail call ptr @luaL_optlstring(ptr noundef %0, i32 noundef 2, ptr noundef nonnull @.str.40.422, ptr noundef null) #46
  %4 = tail call fastcc ptr @newfile(ptr noundef %0) #47
  %5 = tail call noalias ptr @fopen(ptr noundef %2, ptr noundef %3) #47
  store ptr %5, ptr %4, align 8, !tbaa !39
  %6 = icmp eq ptr %5, null
  br i1 %6, label %7, label %9

7:                                                ; preds = %1
  %8 = tail call fastcc i32 @pushresult(ptr noundef %0, i32 noundef 0, ptr noundef %2) #47, !range !409
  br label %9

9:                                                ; preds = %7, %1
  %10 = phi i32 [ %8, %7 ], [ 1, %1 ]
  ret i32 %10
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_output(ptr noundef %0) #1 {
  tail call fastcc void @g_iofile(ptr noundef %0, i32 noundef 2, ptr noundef nonnull @.str.41.423) #47
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_popen(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %3 = tail call ptr @luaL_optlstring(ptr noundef %0, i32 noundef 2, ptr noundef nonnull @.str.40.422, ptr noundef null) #46
  %4 = tail call fastcc ptr @newfile(ptr noundef %0) #47
  %5 = tail call i32 @fflush(ptr noundef null) #47
  %6 = tail call noalias ptr @popen(ptr noundef %2, ptr noundef %3) #47
  store ptr %6, ptr %4, align 8, !tbaa !39
  %7 = icmp eq ptr %6, null
  br i1 %7, label %8, label %10

8:                                                ; preds = %1
  %9 = tail call fastcc i32 @pushresult(ptr noundef %0, i32 noundef 0, ptr noundef %2) #47, !range !409
  br label %10

10:                                               ; preds = %8, %1
  %11 = phi i32 [ %9, %8 ], [ 1, %1 ]
  ret i32 %11
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_read(ptr noundef %0) #1 {
  %2 = tail call fastcc ptr @getiofile(ptr noundef %0, i32 noundef 1) #47
  %3 = tail call fastcc i32 @g_read(ptr noundef %0, ptr noundef %2, i32 noundef 1) #47
  ret i32 %3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_tmpfile(ptr noundef %0) #1 {
  %2 = tail call fastcc ptr @newfile(ptr noundef %0) #47
  %3 = tail call noalias ptr @tmpfile() #47
  store ptr %3, ptr %2, align 8, !tbaa !39
  %4 = icmp eq ptr %3, null
  br i1 %4, label %5, label %7

5:                                                ; preds = %1
  %6 = tail call fastcc i32 @pushresult(ptr noundef %0, i32 noundef 0, ptr noundef null) #47, !range !409
  br label %7

7:                                                ; preds = %5, %1
  %8 = phi i32 [ %6, %5 ], [ 1, %1 ]
  ret i32 %8
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_type(ptr noundef %0) #1 {
  tail call void @luaL_checkany(ptr noundef %0, i32 noundef 1) #46
  %2 = tail call ptr @lua_touserdata(ptr noundef %0, i32 noundef 1) #46
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -10000, ptr noundef nonnull @.str.5.394) #46
  %3 = icmp eq ptr %2, null
  br i1 %3, label %10, label %4

4:                                                ; preds = %1
  %5 = tail call i32 @lua_getmetatable(ptr noundef %0, i32 noundef 1) #46
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %10, label %7

7:                                                ; preds = %4
  %8 = tail call i32 @lua_rawequal(ptr noundef %0, i32 noundef -2, i32 noundef -1) #46
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %11

10:                                               ; preds = %7, %4, %1
  tail call void @lua_pushnil(ptr noundef %0) #46
  br label %16

11:                                               ; preds = %7
  %12 = load ptr, ptr %2, align 8, !tbaa !39
  %13 = icmp eq ptr %12, null
  br i1 %13, label %14, label %15

14:                                               ; preds = %11
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.42.416, i64 noundef 11) #46
  br label %16

15:                                               ; preds = %11
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.43.417, i64 noundef 4) #46
  br label %16

16:                                               ; preds = %15, %14, %10
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_write(ptr noundef %0) #1 {
  %2 = tail call fastcc ptr @getiofile(ptr noundef %0, i32 noundef 2) #47
  %3 = tail call fastcc i32 @g_write(ptr noundef %0, ptr noundef %2, i32 noundef 1) #47, !range !409
  ret i32 %3
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @getiofile(ptr noundef %0, i32 noundef %1) unnamed_addr #1 {
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef -10001, i32 noundef %1) #46
  %3 = tail call ptr @lua_touserdata(ptr noundef %0, i32 noundef -1) #46
  %4 = load ptr, ptr %3, align 8, !tbaa !39
  %5 = icmp eq ptr %4, null
  br i1 %5, label %6, label %12

6:                                                ; preds = %2
  %7 = add nsw i32 %1, -1
  %8 = zext i32 %7 to i64
  %9 = getelementptr inbounds [2 x ptr], ptr @fnames, i64 0, i64 %8
  %10 = load ptr, ptr %9, align 8, !tbaa !39
  %11 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.39.415, ptr noundef %10) #46
  br label %12

12:                                               ; preds = %6, %2
  ret ptr %4
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @g_write(ptr noundef %0, ptr nocapture noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = alloca i64, align 8
  %5 = tail call i32 @lua_gettop(ptr noundef %0) #46
  %6 = add nsw i32 %5, -1
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %36, label %8

8:                                                ; preds = %30, %3
  %9 = phi i32 [ %34, %30 ], [ %6, %3 ]
  %10 = phi i32 [ %33, %30 ], [ %2, %3 ]
  %11 = phi i32 [ %32, %30 ], [ 1, %3 ]
  %12 = call i32 @lua_type(ptr noundef %0, i32 noundef %10) #46
  %13 = icmp eq i32 %12, 3
  br i1 %13, label %14, label %20

14:                                               ; preds = %8
  %15 = icmp eq i32 %11, 0
  br i1 %15, label %30, label %16

16:                                               ; preds = %14
  %17 = call double @lua_tonumber(ptr noundef %0, i32 noundef %10) #46
  %18 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %1, ptr noundef nonnull @.str.31.414, double noundef %17) #47
  %19 = icmp sgt i32 %18, 0
  br label %30

20:                                               ; preds = %8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #48
  %21 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef %10, ptr noundef nonnull %4) #46
  %22 = icmp eq i32 %11, 0
  br i1 %22, label %28, label %23

23:                                               ; preds = %20
  %24 = load i64, ptr %4, align 8, !tbaa !40
  %25 = call i64 @fwrite(ptr noundef %21, i64 noundef 1, i64 noundef %24, ptr noundef %1) #47
  %26 = load i64, ptr %4, align 8, !tbaa !40
  %27 = icmp eq i64 %25, %26
  br label %28

28:                                               ; preds = %23, %20
  %29 = phi i1 [ false, %20 ], [ %27, %23 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #48
  br label %30

30:                                               ; preds = %28, %16, %14
  %31 = phi i1 [ %29, %28 ], [ false, %14 ], [ %19, %16 ]
  %32 = zext i1 %31 to i32
  %33 = add nsw i32 %10, 1
  %34 = add nsw i32 %9, -1
  %35 = icmp eq i32 %34, 0
  br i1 %35, label %36, label %8, !llvm.loop !410

36:                                               ; preds = %30, %3
  %37 = phi i32 [ 1, %3 ], [ %32, %30 ]
  %38 = call fastcc i32 @pushresult(ptr noundef %0, i32 noundef %37, ptr noundef null) #47, !range !409
  ret i32 %38
}

; Function Attrs: nofree nounwind optsize
declare noundef i64 @fwrite(ptr nocapture noundef, i64 noundef, i64 noundef, ptr nocapture noundef) local_unnamed_addr #31

; Function Attrs: nofree nounwind optsize
declare noalias noundef ptr @tmpfile() local_unnamed_addr #31

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @g_read(ptr noundef %0, ptr noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = alloca double, align 8
  %5 = tail call i32 @lua_gettop(ptr noundef %0) #46
  tail call void @clearerr(ptr noundef %1) #46
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %7, label %10

7:                                                ; preds = %3
  %8 = tail call fastcc i32 @read_line(ptr noundef %0, ptr noundef %1) #47
  %9 = add nuw nsw i32 %2, 1
  br label %60

10:                                               ; preds = %3
  %11 = add nsw i32 %5, 19
  tail call void @luaL_checkstack(ptr noundef %0, i32 noundef %11, ptr noundef nonnull @.str.21.418) #46
  %12 = add nsw i32 %5, -2
  br label %13

13:                                               ; preds = %53, %10
  %14 = phi i32 [ %12, %10 ], [ %56, %53 ]
  %15 = phi i32 [ %2, %10 ], [ %55, %53 ]
  %16 = call i32 @lua_type(ptr noundef %0, i32 noundef %15) #46
  %17 = icmp eq i32 %16, 3
  br i1 %17, label %18, label %28

18:                                               ; preds = %13
  %19 = call i64 @lua_tointeger(ptr noundef %0, i32 noundef %15) #46
  %20 = icmp eq i64 %19, 0
  br i1 %20, label %21, label %26

21:                                               ; preds = %18
  %22 = call i32 @getc(ptr noundef %1) #47
  %23 = call i32 @ungetc(i32 noundef %22, ptr noundef %1) #47
  call void @lua_pushlstring(ptr noundef %0, ptr noundef null, i64 noundef 0) #46
  %24 = icmp ne i32 %22, -1
  %25 = zext i1 %24 to i32
  br label %53

26:                                               ; preds = %18
  %27 = call fastcc i32 @read_chars(ptr noundef %0, ptr noundef %1, i64 noundef %19) #47, !range !75
  br label %53

28:                                               ; preds = %13
  %29 = call ptr @lua_tolstring(ptr noundef %0, i32 noundef %15, ptr noundef null) #46
  %30 = icmp eq ptr %29, null
  br i1 %30, label %34, label %31

31:                                               ; preds = %28
  %32 = load i8, ptr %29, align 1, !tbaa !33
  %33 = icmp eq i8 %32, 42
  br i1 %33, label %36, label %34

34:                                               ; preds = %31, %28
  %35 = call i32 @luaL_argerror(ptr noundef %0, i32 noundef %15, ptr noundef nonnull @.str.22.419) #46
  br label %36

36:                                               ; preds = %34, %31
  %37 = getelementptr inbounds i8, ptr %29, i64 1
  %38 = load i8, ptr %37, align 1, !tbaa !33
  %39 = sext i8 %38 to i32
  switch i32 %39, label %51 [
    i32 110, label %40
    i32 108, label %47
    i32 97, label %49
  ]

40:                                               ; preds = %36
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #48
  %41 = call i32 (ptr, ptr, ...) @__isoc99_fscanf(ptr noundef %1, ptr noundef nonnull @.str.24.420, ptr noundef nonnull %4) #46
  %42 = icmp eq i32 %41, 1
  br i1 %42, label %43, label %45

43:                                               ; preds = %40
  %44 = load double, ptr %4, align 8, !tbaa !90
  call void @lua_pushnumber(ptr noundef %0, double noundef %44) #46
  br label %45

45:                                               ; preds = %43, %40
  %46 = phi i32 [ 1, %43 ], [ 0, %40 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #48
  br label %53

47:                                               ; preds = %36
  %48 = call fastcc i32 @read_line(ptr noundef %0, ptr noundef %1) #47
  br label %53

49:                                               ; preds = %36
  %50 = call fastcc i32 @read_chars(ptr noundef %0, ptr noundef %1, i64 noundef -1) #47, !range !75
  br label %53

51:                                               ; preds = %36
  %.lcssa = phi i32 [ %15, %36 ]
  %52 = call i32 @luaL_argerror(ptr noundef %0, i32 noundef %.lcssa, ptr noundef nonnull @.str.23.421) #46
  br label %72

53:                                               ; preds = %49, %47, %45, %26, %21
  %54 = phi i32 [ %25, %21 ], [ %27, %26 ], [ %46, %45 ], [ %48, %47 ], [ 1, %49 ]
  %55 = add nsw i32 %15, 1
  %56 = add nsw i32 %14, -1
  %57 = icmp ne i32 %14, 0
  %58 = icmp ne i32 %54, 0
  %59 = select i1 %57, i1 %58, i1 false
  br i1 %59, label %13, label %60, !llvm.loop !411

60:                                               ; preds = %53, %7
  %61 = phi i32 [ %8, %7 ], [ %54, %53 ]
  %62 = phi i32 [ %9, %7 ], [ %55, %53 ]
  %63 = call i32 @ferror(ptr noundef %1) #46
  %64 = icmp eq i32 %63, 0
  br i1 %64, label %67, label %65

65:                                               ; preds = %60
  %66 = call fastcc i32 @pushresult(ptr noundef %0, i32 noundef 0, ptr noundef null) #47, !range !409
  br label %72

67:                                               ; preds = %60
  %68 = icmp eq i32 %61, 0
  br i1 %68, label %69, label %70

69:                                               ; preds = %67
  call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  call void @lua_pushnil(ptr noundef %0) #46
  br label %70

70:                                               ; preds = %69, %67
  %71 = sub nsw i32 %62, %2
  br label %72

72:                                               ; preds = %70, %65, %51
  %73 = phi i32 [ %66, %65 ], [ %71, %70 ], [ %52, %51 ]
  ret i32 %73
}

; Function Attrs: nofree nounwind optsize
declare void @clearerr(ptr nocapture noundef) local_unnamed_addr #31

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @read_line(ptr noundef %0, ptr nocapture noundef %1) unnamed_addr #1 {
  %3 = alloca %struct.luaL_Buffer, align 8
  call void @llvm.lifetime.start.p0(i64 8216, ptr nonnull %3) #48
  call void @luaL_buffinit(ptr noundef %0, ptr noundef nonnull %3) #46
  br label %4

4:                                                ; preds = %23, %2
  %5 = call ptr @luaL_prepbuffer(ptr noundef nonnull %3) #46
  %6 = call ptr @fgets(ptr noundef %5, i32 noundef 8192, ptr noundef %1) #47
  %7 = icmp eq ptr %6, null
  br i1 %7, label %8, label %12

8:                                                ; preds = %4
  call void @luaL_pushresult(ptr noundef nonnull %3) #46
  %9 = call i64 @lua_objlen(ptr noundef %0, i32 noundef -1) #46
  %10 = icmp ne i64 %9, 0
  %11 = zext i1 %10 to i32
  br label %26

12:                                               ; preds = %4
  %13 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %5) #49
  %14 = icmp eq i64 %13, 0
  br i1 %14, label %23, label %15

15:                                               ; preds = %12
  %16 = add i64 %13, -1
  %17 = getelementptr inbounds i8, ptr %5, i64 %16
  %18 = load i8, ptr %17, align 1, !tbaa !33
  %19 = icmp eq i8 %18, 10
  br i1 %19, label %20, label %23

20:                                               ; preds = %15
  %.lcssa = phi i64 [ %16, %15 ]
  %21 = load ptr, ptr %3, align 8, !tbaa !392
  %22 = getelementptr inbounds i8, ptr %21, i64 %.lcssa
  store ptr %22, ptr %3, align 8, !tbaa !392
  call void @luaL_pushresult(ptr noundef nonnull %3) #46
  br label %26

23:                                               ; preds = %15, %12
  %24 = load ptr, ptr %3, align 8, !tbaa !392
  %25 = getelementptr inbounds i8, ptr %24, i64 %13
  store ptr %25, ptr %3, align 8, !tbaa !392
  br label %4

26:                                               ; preds = %20, %8
  %27 = phi i32 [ 1, %20 ], [ %11, %8 ]
  call void @llvm.lifetime.end.p0(i64 8216, ptr nonnull %3) #48
  ret i32 %27
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @read_chars(ptr noundef %0, ptr nocapture noundef %1, i64 noundef %2) unnamed_addr #1 {
  %4 = alloca %struct.luaL_Buffer, align 8
  call void @llvm.lifetime.start.p0(i64 8216, ptr nonnull %4) #48
  call void @luaL_buffinit(ptr noundef %0, ptr noundef nonnull %4) #46
  br label %5

5:                                                ; preds = %5, %3
  %6 = phi i64 [ 8192, %3 ], [ %9, %5 ]
  %7 = phi i64 [ %2, %3 ], [ %13, %5 ]
  %8 = call ptr @luaL_prepbuffer(ptr noundef nonnull %4) #46
  %9 = call i64 @llvm.umin.i64(i64 %6, i64 %7)
  %10 = call i64 @fread(ptr noundef %8, i64 noundef 1, i64 noundef %9, ptr noundef %1) #47
  %11 = load ptr, ptr %4, align 8, !tbaa !392
  %12 = getelementptr inbounds i8, ptr %11, i64 %10
  store ptr %12, ptr %4, align 8, !tbaa !392
  %13 = sub i64 %7, %10
  %14 = icmp ne i64 %13, 0
  %15 = icmp eq i64 %10, %9
  %16 = and i1 %15, %14
  br i1 %16, label %5, label %17, !llvm.loop !412

17:                                               ; preds = %5
  %.lcssa = phi i64 [ %13, %5 ]
  call void @luaL_pushresult(ptr noundef nonnull %4) #46
  %18 = icmp eq i64 %.lcssa, 0
  br i1 %18, label %23, label %19

19:                                               ; preds = %17
  %20 = call i64 @lua_objlen(ptr noundef %0, i32 noundef -1) #46
  %21 = icmp ne i64 %20, 0
  %22 = zext i1 %21 to i32
  br label %23

23:                                               ; preds = %19, %17
  %24 = phi i32 [ 1, %17 ], [ %22, %19 ]
  call void @llvm.lifetime.end.p0(i64 8216, ptr nonnull %4) #48
  ret i32 %24
}

; Function Attrs: optsize
declare i32 @__isoc99_fscanf(ptr noundef, ptr noundef, ...) local_unnamed_addr #39

; Function Attrs: nofree nounwind optsize
declare noundef i32 @fflush(ptr nocapture noundef) local_unnamed_addr #31

; Function Attrs: nofree nounwind optsize
declare noalias noundef ptr @popen(ptr nocapture noundef readonly, ptr nocapture noundef readonly) local_unnamed_addr #31

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @g_iofile(ptr noundef %0, i32 noundef %1, ptr nocapture noundef readonly %2) unnamed_addr #1 {
  %4 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 1) #46
  %5 = icmp slt i32 %4, 1
  br i1 %5, label %17, label %6

6:                                                ; preds = %3
  %7 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %8 = icmp eq ptr %7, null
  br i1 %8, label %14, label %9

9:                                                ; preds = %6
  %10 = tail call fastcc ptr @newfile(ptr noundef %0) #47
  %11 = tail call noalias ptr @fopen(ptr noundef nonnull %7, ptr noundef %2) #47
  store ptr %11, ptr %10, align 8, !tbaa !39
  %12 = icmp eq ptr %11, null
  br i1 %12, label %13, label %16

13:                                               ; preds = %9
  tail call fastcc void @fileerror(ptr noundef %0, ptr noundef nonnull %7) #47
  br label %16

14:                                               ; preds = %6
  %15 = tail call fastcc ptr @tofile(ptr noundef %0) #47
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef 1) #46
  br label %16

16:                                               ; preds = %14, %13, %9
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef -10001, i32 noundef %1) #46
  br label %17

17:                                               ; preds = %16, %3
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef -10001, i32 noundef %1) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @fileerror(ptr noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = tail call ptr @__errno_location() #52
  %4 = load i32, ptr %3, align 4, !tbaa !65
  %5 = tail call ptr @strerror(i32 noundef %4) #46
  %6 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.18.401, ptr noundef %1, ptr noundef %5) #46
  %7 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef -1, ptr noundef null) #46
  %8 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef 1, ptr noundef %7) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @tofile(ptr noundef %0) unnamed_addr #1 {
  %2 = tail call ptr @luaL_checkudata(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.5.394) #46
  %3 = load ptr, ptr %2, align 8, !tbaa !39
  %4 = icmp eq ptr %3, null
  br i1 %4, label %5, label %8

5:                                                ; preds = %1
  %6 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.16.424) #46
  %7 = load ptr, ptr %2, align 8, !tbaa !39
  br label %8

8:                                                ; preds = %5, %1
  %9 = phi ptr [ %7, %5 ], [ %3, %1 ]
  ret ptr %9
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @aux_lines(ptr noundef %0, i32 noundef %1, i32 noundef %2) unnamed_addr #1 {
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef %1) #46
  tail call void @lua_pushboolean(ptr noundef %0, i32 noundef %2) #46
  tail call void @lua_pushcclosure(ptr noundef %0, ptr noundef nonnull @io_readline, i32 noundef 2) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_readline(ptr noundef %0) #1 {
  %2 = tail call ptr @lua_touserdata(ptr noundef %0, i32 noundef -10003) #46
  %3 = load ptr, ptr %2, align 8, !tbaa !39
  %4 = icmp eq ptr %3, null
  br i1 %4, label %5, label %7

5:                                                ; preds = %1
  %6 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.20.425) #46
  br label %7

7:                                                ; preds = %5, %1
  %8 = tail call fastcc i32 @read_line(ptr noundef %0, ptr noundef %3) #47
  %9 = tail call i32 @ferror(ptr noundef %3) #46
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %16, label %11

11:                                               ; preds = %7
  %12 = tail call ptr @__errno_location() #52
  %13 = load i32, ptr %12, align 4, !tbaa !65
  %14 = tail call ptr @strerror(i32 noundef %13) #46
  %15 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.19.402, ptr noundef %14) #46
  br label %23

16:                                               ; preds = %7
  %17 = icmp eq i32 %8, 0
  br i1 %17, label %18, label %23

18:                                               ; preds = %16
  %19 = tail call i32 @lua_toboolean(ptr noundef %0, i32 noundef -10004) #46
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %23, label %21

21:                                               ; preds = %18
  tail call void @lua_settop(ptr noundef %0, i32 noundef 0) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -10003) #46
  %22 = tail call fastcc i32 @aux_close(ptr noundef %0) #47
  br label %23

23:                                               ; preds = %21, %18, %16, %11
  %24 = phi i32 [ %15, %11 ], [ 1, %16 ], [ 0, %21 ], [ 0, %18 ]
  ret i32 %24
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @aux_close(ptr noundef %0) unnamed_addr #1 {
  tail call void @lua_getfenv(ptr noundef %0, i32 noundef 1) #46
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -1, ptr noundef nonnull @.str.17.426) #46
  %2 = tail call ptr @lua_tocfunction(ptr noundef %0, i32 noundef -1) #46
  %3 = tail call i32 %2(ptr noundef %0) #46
  ret i32 %3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @f_flush(ptr noundef %0) #1 {
  %2 = tail call fastcc ptr @tofile(ptr noundef %0) #47
  %3 = tail call i32 @fflush(ptr noundef %2) #47
  %4 = icmp eq i32 %3, 0
  %5 = zext i1 %4 to i32
  %6 = tail call fastcc i32 @pushresult(ptr noundef %0, i32 noundef %5, ptr noundef null) #47, !range !409
  ret i32 %6
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @f_lines(ptr noundef %0) #1 {
  %2 = tail call fastcc ptr @tofile(ptr noundef %0) #47
  tail call fastcc void @aux_lines(ptr noundef %0, i32 noundef 1, i32 noundef 0) #47
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @f_read(ptr noundef %0) #1 {
  %2 = tail call fastcc ptr @tofile(ptr noundef %0) #47
  %3 = tail call fastcc i32 @g_read(ptr noundef %0, ptr noundef %2, i32 noundef 2) #47
  ret i32 %3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @f_seek(ptr noundef %0) #1 {
  %2 = tail call fastcc ptr @tofile(ptr noundef %0) #47
  %3 = tail call i32 @luaL_checkoption(ptr noundef %0, i32 noundef 2, ptr noundef nonnull @.str.26.436, ptr noundef nonnull @f_seek.modenames) #46
  %4 = tail call i64 @luaL_optinteger(ptr noundef %0, i32 noundef 3, i64 noundef 0) #46
  %5 = sext i32 %3 to i64
  %6 = getelementptr inbounds [3 x i32], ptr @f_seek.mode, i64 0, i64 %5
  %7 = load i32, ptr %6, align 4, !tbaa !65
  %8 = tail call i32 @fseek(ptr noundef %2, i64 noundef %4, i32 noundef %7) #47
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %1
  %11 = tail call fastcc i32 @pushresult(ptr noundef %0, i32 noundef 0, ptr noundef null) #47, !range !409
  br label %14

12:                                               ; preds = %1
  %13 = tail call i64 @ftell(ptr noundef %2) #47
  tail call void @lua_pushinteger(ptr noundef %0, i64 noundef %13) #46
  br label %14

14:                                               ; preds = %12, %10
  %15 = phi i32 [ %11, %10 ], [ 1, %12 ]
  ret i32 %15
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @f_setvbuf(ptr noundef %0) #1 {
  %2 = tail call fastcc ptr @tofile(ptr noundef %0) #47
  %3 = tail call i32 @luaL_checkoption(ptr noundef %0, i32 noundef 2, ptr noundef null, ptr noundef nonnull @f_setvbuf.modenames) #46
  %4 = tail call i64 @luaL_optinteger(ptr noundef %0, i32 noundef 3, i64 noundef 8192) #46
  %5 = sext i32 %3 to i64
  %6 = getelementptr inbounds [3 x i32], ptr @f_setvbuf.mode, i64 0, i64 %5
  %7 = load i32, ptr %6, align 4, !tbaa !65
  %8 = tail call i32 @setvbuf(ptr noundef %2, ptr noundef null, i32 noundef %7, i64 noundef %4) #46
  %9 = icmp eq i32 %8, 0
  %10 = zext i1 %9 to i32
  %11 = tail call fastcc i32 @pushresult(ptr noundef %0, i32 noundef %10, ptr noundef null) #47, !range !409
  ret i32 %11
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @f_write(ptr noundef %0) #1 {
  %2 = tail call fastcc ptr @tofile(ptr noundef %0) #47
  %3 = tail call fastcc i32 @g_write(ptr noundef %0, ptr noundef %2, i32 noundef 2) #47, !range !409
  ret i32 %3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_gc(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checkudata(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.5.394) #46
  %3 = load ptr, ptr %2, align 8, !tbaa !39
  %4 = icmp eq ptr %3, null
  br i1 %4, label %7, label %5

5:                                                ; preds = %1
  %6 = tail call fastcc i32 @aux_close(ptr noundef %0) #47
  br label %7

7:                                                ; preds = %5, %1
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_tostring(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checkudata(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.5.394) #46
  %3 = load ptr, ptr %2, align 8, !tbaa !39
  %4 = icmp eq ptr %3, null
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.32.431, i64 noundef 13) #46
  br label %8

6:                                                ; preds = %1
  %7 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.33.432, ptr noundef nonnull %3) #46
  br label %8

8:                                                ; preds = %6, %5
  ret i32 1
}

; Function Attrs: nofree nounwind optsize
declare noundef i32 @setvbuf(ptr nocapture noundef, ptr noundef, i32 noundef, i64 noundef) local_unnamed_addr #31

; Function Attrs: nofree nounwind optsize
declare noundef i32 @fseek(ptr nocapture noundef, i64 noundef, i32 noundef) local_unnamed_addr #31

; Function Attrs: nofree nounwind optsize
declare noundef i64 @ftell(ptr nocapture noundef) local_unnamed_addr #31

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaopen_math(ptr noundef %0) #1 {
  tail call void @luaL_register(ptr noundef %0, ptr noundef nonnull @.str.439, ptr noundef nonnull @mathlib) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef 0x400921FB54442D18) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.1.440) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef 0x7FF0000000000000) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.2.441) #46
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -1, ptr noundef nonnull @.str.3.442) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.4.443) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_abs(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @llvm.fabs.f64(double %2)
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_acos(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @acos(double noundef %2) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_asin(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @asin(double noundef %2) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_atan2(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 2) #46
  %4 = tail call double @atan2(double noundef %2, double noundef %3) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %4) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_atan(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @atan(double noundef %2) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_ceil(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @llvm.ceil.f64(double %2)
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_cosh(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @cosh(double noundef %2) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_cos(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @cos(double noundef %2) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_deg(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = fdiv double %2, 0x3F91DF46A2529D39
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_exp(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @exp(double noundef %2) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_floor(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @llvm.floor.f64(double %2)
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_fmod(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 2) #46
  %4 = tail call double @fmod(double noundef %2, double noundef %3) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %4) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_frexp(ptr noundef %0) #1 {
  %2 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #48
  %3 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %4 = call double @frexp(double noundef %3, ptr noundef nonnull %2) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %4) #46
  %5 = load i32, ptr %2, align 4, !tbaa !65
  %6 = sext i32 %5 to i64
  tail call void @lua_pushinteger(ptr noundef %0, i64 noundef %6) #46
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #48
  ret i32 2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_ldexp(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef 2) #46
  %4 = trunc i64 %3 to i32
  %5 = tail call double @ldexp(double noundef %2, i32 noundef %4) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %5) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_log10(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @log10(double noundef %2) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_log(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @log(double noundef %2) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_max(ptr noundef %0) #1 {
  %2 = tail call i32 @lua_gettop(ptr noundef %0) #46
  %3 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %4 = icmp slt i32 %2, 2
  br i1 %4, label %13, label %5

5:                                                ; preds = %5, %1
  %6 = phi double [ %10, %5 ], [ %3, %1 ]
  %7 = phi i32 [ %11, %5 ], [ 2, %1 ]
  %8 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef %7) #46
  %9 = fcmp ogt double %8, %6
  %10 = select i1 %9, double %8, double %6
  %11 = add nuw i32 %7, 1
  %12 = icmp eq i32 %7, %2
  br i1 %12, label %13, label %5, !llvm.loop !413

13:                                               ; preds = %5, %1
  %14 = phi double [ %3, %1 ], [ %10, %5 ]
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %14) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_min(ptr noundef %0) #1 {
  %2 = tail call i32 @lua_gettop(ptr noundef %0) #46
  %3 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %4 = icmp slt i32 %2, 2
  br i1 %4, label %13, label %5

5:                                                ; preds = %5, %1
  %6 = phi double [ %10, %5 ], [ %3, %1 ]
  %7 = phi i32 [ %11, %5 ], [ 2, %1 ]
  %8 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef %7) #46
  %9 = fcmp olt double %8, %6
  %10 = select i1 %9, double %8, double %6
  %11 = add nuw i32 %7, 1
  %12 = icmp eq i32 %7, %2
  br i1 %12, label %13, label %5, !llvm.loop !414

13:                                               ; preds = %5, %1
  %14 = phi double [ %3, %1 ], [ %10, %5 ]
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %14) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_modf(ptr noundef %0) #1 {
  %2 = alloca double, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  %3 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %4 = call double @modf(double noundef %3, ptr noundef nonnull %2) #46
  %5 = load double, ptr %2, align 8, !tbaa !90
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %5) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %4) #46
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  ret i32 2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_pow(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 2) #46
  %4 = tail call double @pow(double noundef %2, double noundef %3) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %4) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_rad(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = fmul double %2, 0x3F91DF46A2529D39
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_random(ptr noundef %0) #1 {
  %2 = tail call i32 @rand() #46
  %3 = srem i32 %2, 2147483647
  %4 = sitofp i32 %3 to double
  %5 = fdiv double %4, 0x41DFFFFFFFC00000
  %6 = tail call i32 @lua_gettop(ptr noundef %0) #46
  switch i32 %6, label %35 [
    i32 0, label %7
    i32 1, label %8
    i32 2, label %19
  ]

7:                                                ; preds = %1
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %5) #46
  br label %37

8:                                                ; preds = %1
  %9 = tail call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef 1) #46
  %10 = trunc i64 %9 to i32
  %11 = icmp sgt i32 %10, 0
  br i1 %11, label %14, label %12

12:                                               ; preds = %8
  %13 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.32.471) #46
  br label %14

14:                                               ; preds = %12, %8
  %15 = sitofp i32 %10 to double
  %16 = fmul double %5, %15
  %17 = tail call double @llvm.floor.f64(double %16)
  %18 = fadd double %17, 1.000000e+00
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %18) #46
  br label %37

19:                                               ; preds = %1
  %20 = tail call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef 1) #46
  %21 = trunc i64 %20 to i32
  %22 = tail call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef 2) #46
  %23 = trunc i64 %22 to i32
  %24 = icmp sgt i32 %21, %23
  br i1 %24, label %25, label %27

25:                                               ; preds = %19
  %26 = tail call i32 @luaL_argerror(ptr noundef %0, i32 noundef 2, ptr noundef nonnull @.str.32.471) #46
  br label %27

27:                                               ; preds = %25, %19
  %28 = sub i32 %23, %21
  %29 = add i32 %28, 1
  %30 = sitofp i32 %29 to double
  %31 = fmul double %5, %30
  %32 = tail call double @llvm.floor.f64(double %31)
  %33 = sitofp i32 %21 to double
  %34 = fadd double %32, %33
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %34) #46
  br label %37

35:                                               ; preds = %1
  %36 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.33.472) #46
  br label %37

37:                                               ; preds = %35, %27, %14, %7
  %38 = phi i32 [ %36, %35 ], [ 1, %27 ], [ 1, %14 ], [ 1, %7 ]
  ret i32 %38
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_randomseed(ptr noundef %0) #1 {
  %2 = tail call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef 1) #46
  %3 = trunc i64 %2 to i32
  tail call void @srand(i32 noundef %3) #46
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_sinh(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @sinh(double noundef %2) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_sin(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @sin(double noundef %2) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_sqrt(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @sqrt(double noundef %2) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_tanh(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @tanh(double noundef %2) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_tan(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = tail call double @tan(double noundef %2) #46
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %3) #46
  ret i32 1
}

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @tan(double noundef) local_unnamed_addr #15

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @tanh(double noundef) local_unnamed_addr #15

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @sqrt(double noundef) local_unnamed_addr #15

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @sin(double noundef) local_unnamed_addr #15

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @sinh(double noundef) local_unnamed_addr #15

; Function Attrs: nounwind optsize
declare void @srand(i32 noundef) local_unnamed_addr #27

; Function Attrs: nounwind optsize
declare i32 @rand() local_unnamed_addr #27

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(argmem: write)
declare double @modf(double noundef, ptr nocapture noundef) local_unnamed_addr #44

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @log(double noundef) local_unnamed_addr #15

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @log10(double noundef) local_unnamed_addr #15

; Function Attrs: mustprogress nofree nounwind optsize willreturn
declare double @ldexp(double noundef, i32 noundef) local_unnamed_addr #30

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(argmem: write)
declare double @frexp(double noundef, ptr nocapture noundef) local_unnamed_addr #44

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @fmod(double noundef, double noundef) local_unnamed_addr #15

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @exp(double noundef) local_unnamed_addr #15

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @cos(double noundef) local_unnamed_addr #15

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @cosh(double noundef) local_unnamed_addr #15

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.ceil.f64(double) #12

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @atan(double noundef) local_unnamed_addr #15

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @atan2(double noundef, double noundef) local_unnamed_addr #15

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @asin(double noundef) local_unnamed_addr #15

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(write)
declare double @acos(double noundef) local_unnamed_addr #15

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fabs.f64(double) #12

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaopen_os(ptr noundef %0) #1 {
  tail call void @luaL_register(ptr noundef %0, ptr noundef nonnull @.str.473, ptr noundef nonnull @syslib) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_clock(ptr noundef %0) #1 {
  %2 = tail call i64 @clock() #46
  %3 = sitofp i64 %2 to double
  %4 = fdiv double %3, 1.000000e+06
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %4) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_date(ptr noundef %0) #1 {
  %2 = alloca i64, align 8
  %3 = alloca [3 x i8], align 1
  %4 = alloca %struct.luaL_Buffer, align 8
  %5 = alloca [200 x i8], align 16
  %6 = tail call ptr @luaL_optlstring(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.12.502, ptr noundef null) #46
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  %7 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 2) #46
  %8 = icmp slt i32 %7, 1
  br i1 %8, label %9, label %11

9:                                                ; preds = %1
  %10 = tail call i64 @time(ptr noundef null) #46
  br label %14

11:                                               ; preds = %1
  %12 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 2) #46
  %13 = fptosi double %12 to i64
  br label %14

14:                                               ; preds = %11, %9
  %15 = phi i64 [ %10, %9 ], [ %13, %11 ]
  store i64 %15, ptr %2, align 8, !tbaa !40
  %16 = load i8, ptr %6, align 1, !tbaa !33
  %17 = icmp eq i8 %16, 33
  br i1 %17, label %18, label %21

18:                                               ; preds = %14
  %19 = call ptr @gmtime(ptr noundef nonnull %2) #46
  %20 = getelementptr inbounds i8, ptr %6, i64 1
  br label %23

21:                                               ; preds = %14
  %22 = call ptr @localtime(ptr noundef nonnull %2) #46
  br label %23

23:                                               ; preds = %21, %18
  %24 = phi ptr [ %19, %18 ], [ %22, %21 ]
  %25 = phi ptr [ %20, %18 ], [ %6, %21 ]
  %26 = icmp eq ptr %24, null
  br i1 %26, label %27, label %28

27:                                               ; preds = %23
  call void @lua_pushnil(ptr noundef %0) #46
  br label %91

28:                                               ; preds = %23
  %29 = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %25, ptr noundef nonnull dereferenceable(3) @.str.13.503) #49
  %30 = icmp eq i32 %29, 0
  br i1 %30, label %31, label %63

31:                                               ; preds = %28
  call void @lua_createtable(ptr noundef %0, i32 noundef 0, i32 noundef 9) #46
  %32 = load i32, ptr %24, align 8, !tbaa !415
  %33 = sext i32 %32 to i64
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %33) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.14.487) #46
  %34 = getelementptr inbounds %struct.tm, ptr %24, i64 0, i32 1
  %35 = load i32, ptr %34, align 4, !tbaa !417
  %36 = sext i32 %35 to i64
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %36) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.15.488) #46
  %37 = getelementptr inbounds %struct.tm, ptr %24, i64 0, i32 2
  %38 = load i32, ptr %37, align 8, !tbaa !418
  %39 = sext i32 %38 to i64
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %39) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.16.489) #46
  %40 = getelementptr inbounds %struct.tm, ptr %24, i64 0, i32 3
  %41 = load i32, ptr %40, align 4, !tbaa !419
  %42 = sext i32 %41 to i64
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %42) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.17.490) #46
  %43 = getelementptr inbounds %struct.tm, ptr %24, i64 0, i32 4
  %44 = load i32, ptr %43, align 8, !tbaa !420
  %45 = add nsw i32 %44, 1
  %46 = sext i32 %45 to i64
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %46) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.18.491) #46
  %47 = getelementptr inbounds %struct.tm, ptr %24, i64 0, i32 5
  %48 = load i32, ptr %47, align 4, !tbaa !421
  %49 = add nsw i32 %48, 1900
  %50 = sext i32 %49 to i64
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %50) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.19.492) #46
  %51 = getelementptr inbounds %struct.tm, ptr %24, i64 0, i32 6
  %52 = load i32, ptr %51, align 8, !tbaa !422
  %53 = add nsw i32 %52, 1
  %54 = sext i32 %53 to i64
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %54) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.20.504) #46
  %55 = getelementptr inbounds %struct.tm, ptr %24, i64 0, i32 7
  %56 = load i32, ptr %55, align 4, !tbaa !423
  %57 = add nsw i32 %56, 1
  %58 = sext i32 %57 to i64
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %58) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.21.505) #46
  %59 = getelementptr inbounds %struct.tm, ptr %24, i64 0, i32 8
  %60 = load i32, ptr %59, align 8, !tbaa !424
  %61 = icmp slt i32 %60, 0
  br i1 %61, label %91, label %62

62:                                               ; preds = %31
  call void @lua_pushboolean(ptr noundef %0, i32 noundef %60) #46
  call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.22.493) #46
  br label %91

63:                                               ; preds = %28
  call void @llvm.lifetime.start.p0(i64 3, ptr nonnull %3) #48
  call void @llvm.lifetime.start.p0(i64 8216, ptr nonnull %4) #48
  store i8 37, ptr %3, align 1, !tbaa !33
  %64 = getelementptr inbounds [3 x i8], ptr %3, i64 0, i64 2
  store i8 0, ptr %64, align 1, !tbaa !33
  call void @luaL_buffinit(ptr noundef %0, ptr noundef nonnull %4) #46
  %65 = getelementptr inbounds [3 x i8], ptr %3, i64 0, i64 1
  %66 = getelementptr inbounds %struct.luaL_Buffer, ptr %4, i64 1
  br label %67

67:                                               ; preds = %87, %63
  %68 = phi ptr [ %25, %63 ], [ %89, %87 ]
  %69 = load i8, ptr %68, align 1, !tbaa !33
  switch i8 %69, label %74 [
    i8 0, label %90
    i8 37, label %70
  ]

70:                                               ; preds = %67
  %71 = getelementptr inbounds i8, ptr %68, i64 1
  %72 = load i8, ptr %71, align 1, !tbaa !33
  %73 = icmp eq i8 %72, 0
  br i1 %73, label %74, label %85

74:                                               ; preds = %70, %67
  %75 = load ptr, ptr %4, align 8, !tbaa !392
  %76 = icmp ult ptr %75, %66
  br i1 %76, label %81, label %77

77:                                               ; preds = %74
  %78 = call ptr @luaL_prepbuffer(ptr noundef nonnull %4) #46
  %79 = load i8, ptr %68, align 1, !tbaa !33
  %80 = load ptr, ptr %4, align 8, !tbaa !392
  br label %81

81:                                               ; preds = %77, %74
  %82 = phi ptr [ %80, %77 ], [ %75, %74 ]
  %83 = phi i8 [ %79, %77 ], [ %69, %74 ]
  %84 = getelementptr inbounds i8, ptr %82, i64 1
  store ptr %84, ptr %4, align 8, !tbaa !392
  store i8 %83, ptr %82, align 1, !tbaa !33
  br label %87

85:                                               ; preds = %70
  call void @llvm.lifetime.start.p0(i64 200, ptr nonnull %5) #48
  store i8 %72, ptr %65, align 1, !tbaa !33
  %86 = call i64 @strftime(ptr noundef nonnull %5, i64 noundef 200, ptr noundef nonnull %3, ptr noundef nonnull %24) #46
  call void @luaL_addlstring(ptr noundef nonnull %4, ptr noundef nonnull %5, i64 noundef %86) #46
  call void @llvm.lifetime.end.p0(i64 200, ptr nonnull %5) #48
  br label %87

87:                                               ; preds = %85, %81
  %88 = phi ptr [ %68, %81 ], [ %71, %85 ]
  %89 = getelementptr inbounds i8, ptr %88, i64 1
  br label %67, !llvm.loop !425

90:                                               ; preds = %67
  call void @luaL_pushresult(ptr noundef nonnull %4) #46
  call void @llvm.lifetime.end.p0(i64 8216, ptr nonnull %4) #48
  call void @llvm.lifetime.end.p0(i64 3, ptr nonnull %3) #48
  br label %91

91:                                               ; preds = %90, %62, %31, %27
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_difftime(ptr noundef %0) #1 {
  %2 = tail call double @luaL_checknumber(ptr noundef %0, i32 noundef 1) #46
  %3 = fptosi double %2 to i64
  %4 = tail call double @luaL_optnumber(ptr noundef %0, i32 noundef 2, double noundef 0.000000e+00) #46
  %5 = fptosi double %4 to i64
  %6 = tail call double @difftime(i64 noundef %3, i64 noundef %5) #52
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %6) #46
  ret i32 1
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal i32 @os_execute(ptr nocapture readnone %0) #20 {
  %2 = load ptr, ptr @stderr, align 8, !tbaa !39
  %3 = tail call i64 @fwrite(ptr nonnull @.str.23.501, i64 29, i64 1, ptr %2) #55
  tail call void @abort() #50
  unreachable
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal i32 @os_exit(ptr noundef %0) #20 {
  %2 = tail call i64 @luaL_optinteger(ptr noundef %0, i32 noundef 1, i64 noundef 0) #46
  %3 = trunc i64 %2 to i32
  tail call void @exit(i32 noundef %3) #50
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_getenv(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %3 = tail call ptr @getenv(ptr noundef %2) #46
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef %3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_remove(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %3 = tail call i32 @remove(ptr noundef %2) #46
  %4 = icmp eq i32 %3, 0
  %5 = zext i1 %4 to i32
  %6 = tail call fastcc i32 @os_pushresult(ptr noundef %0, i32 noundef %5, ptr noundef %2) #47, !range !409
  ret i32 %6
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_rename(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %3 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 2, ptr noundef null) #46
  %4 = tail call i32 @rename(ptr noundef %2, ptr noundef %3) #46
  %5 = icmp eq i32 %4, 0
  %6 = zext i1 %5 to i32
  %7 = tail call fastcc i32 @os_pushresult(ptr noundef %0, i32 noundef %6, ptr noundef %2) #47, !range !409
  ret i32 %7
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_setlocale(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_optlstring(ptr noundef %0, i32 noundef 1, ptr noundef null, ptr noundef null) #46
  %3 = tail call i32 @luaL_checkoption(ptr noundef %0, i32 noundef 2, ptr noundef nonnull @.str.25.495, ptr noundef nonnull @os_setlocale.catnames) #46
  %4 = sext i32 %3 to i64
  %5 = getelementptr inbounds [6 x i32], ptr @os_setlocale.cat, i64 0, i64 %4
  %6 = load i32, ptr %5, align 4, !tbaa !65
  %7 = tail call ptr @setlocale(i32 noundef %6, ptr noundef %2) #46
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef %7) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_time(ptr noundef %0) #1 {
  %2 = alloca %struct.tm, align 8
  %3 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 1) #46
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %5, label %7

5:                                                ; preds = %1
  %6 = tail call i64 @time(ptr noundef null) #46
  br label %29

7:                                                ; preds = %1
  call void @llvm.lifetime.start.p0(i64 56, ptr nonnull %2) #48
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef 1) #46
  %8 = tail call fastcc i32 @getfield(ptr noundef %0, ptr noundef nonnull @.str.14.487, i32 noundef 0) #47
  store i32 %8, ptr %2, align 8, !tbaa !415
  %9 = tail call fastcc i32 @getfield(ptr noundef %0, ptr noundef nonnull @.str.15.488, i32 noundef 0) #47
  %10 = getelementptr inbounds %struct.tm, ptr %2, i64 0, i32 1
  store i32 %9, ptr %10, align 4, !tbaa !417
  %11 = tail call fastcc i32 @getfield(ptr noundef %0, ptr noundef nonnull @.str.16.489, i32 noundef 12) #47
  %12 = getelementptr inbounds %struct.tm, ptr %2, i64 0, i32 2
  store i32 %11, ptr %12, align 8, !tbaa !418
  %13 = tail call fastcc i32 @getfield(ptr noundef %0, ptr noundef nonnull @.str.17.490, i32 noundef -1) #47
  %14 = getelementptr inbounds %struct.tm, ptr %2, i64 0, i32 3
  store i32 %13, ptr %14, align 4, !tbaa !419
  %15 = tail call fastcc i32 @getfield(ptr noundef %0, ptr noundef nonnull @.str.18.491, i32 noundef -1) #47
  %16 = add nsw i32 %15, -1
  %17 = getelementptr inbounds %struct.tm, ptr %2, i64 0, i32 4
  store i32 %16, ptr %17, align 8, !tbaa !420
  %18 = tail call fastcc i32 @getfield(ptr noundef %0, ptr noundef nonnull @.str.19.492, i32 noundef -1) #47
  %19 = add nsw i32 %18, -1900
  %20 = getelementptr inbounds %struct.tm, ptr %2, i64 0, i32 5
  store i32 %19, ptr %20, align 4, !tbaa !421
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -1, ptr noundef nonnull @.str.22.493) #46
  %21 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %25, label %23

23:                                               ; preds = %7
  %24 = tail call i32 @lua_toboolean(ptr noundef %0, i32 noundef -1) #46
  br label %25

25:                                               ; preds = %23, %7
  %26 = phi i32 [ %24, %23 ], [ -1, %7 ]
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  %27 = getelementptr inbounds %struct.tm, ptr %2, i64 0, i32 8
  store i32 %26, ptr %27, align 8, !tbaa !424
  %28 = call i64 @mktime(ptr noundef nonnull %2) #46
  call void @llvm.lifetime.end.p0(i64 56, ptr nonnull %2) #48
  br label %29

29:                                               ; preds = %25, %5
  %30 = phi i64 [ %6, %5 ], [ %28, %25 ]
  %31 = icmp eq i64 %30, -1
  br i1 %31, label %32, label %33

32:                                               ; preds = %29
  tail call void @lua_pushnil(ptr noundef %0) #46
  br label %35

33:                                               ; preds = %29
  %34 = sitofp i64 %30 to double
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %34) #46
  br label %35

35:                                               ; preds = %33, %32
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_tmpname(ptr noundef %0) #1 {
  %2 = alloca [32 x i8], align 16
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %2) #48
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %2, ptr noundef nonnull align 1 dereferenceable(16) @.str.31.485, i64 16, i1 false) #46
  %3 = call i32 @mkstemp(ptr noundef nonnull %2) #46
  %4 = icmp eq i32 %3, -1
  br i1 %4, label %7, label %5

5:                                                ; preds = %1
  %6 = call i32 @close(i32 noundef %3) #46
  call void @lua_pushstring(ptr noundef %0, ptr noundef nonnull %2) #46
  br label %9

7:                                                ; preds = %1
  %8 = call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.32.486) #46
  br label %9

9:                                                ; preds = %7, %5
  %10 = phi i32 [ %8, %7 ], [ 1, %5 ]
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %2) #48
  ret i32 %10
}

; Function Attrs: optsize
declare i32 @mkstemp(ptr noundef) local_unnamed_addr #39

; Function Attrs: optsize
declare i32 @close(i32 noundef) local_unnamed_addr #39

; Function Attrs: nounwind optsize
declare i64 @time(ptr noundef) local_unnamed_addr #27

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @getfield(ptr noundef %0, ptr noundef %1, i32 noundef %2) unnamed_addr #1 {
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -1, ptr noundef %1) #46
  %4 = tail call i32 @lua_isnumber(ptr noundef %0, i32 noundef -1) #46
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %9, label %6

6:                                                ; preds = %3
  %7 = tail call i64 @lua_tointeger(ptr noundef %0, i32 noundef -1) #46
  %8 = trunc i64 %7 to i32
  br label %13

9:                                                ; preds = %3
  %10 = icmp slt i32 %2, 0
  br i1 %10, label %11, label %13

11:                                               ; preds = %9
  %12 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.30.494, ptr noundef %1) #46
  br label %15

13:                                               ; preds = %9, %6
  %14 = phi i32 [ %8, %6 ], [ %2, %9 ]
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  br label %15

15:                                               ; preds = %13, %11
  %16 = phi i32 [ %14, %13 ], [ %12, %11 ]
  ret i32 %16
}

; Function Attrs: mustprogress nofree nounwind optsize willreturn
declare noundef i64 @mktime(ptr nocapture noundef) local_unnamed_addr #30

; Function Attrs: nounwind optsize
declare ptr @setlocale(i32 noundef, ptr noundef) local_unnamed_addr #27

; Function Attrs: nofree nounwind optsize
declare noundef i32 @rename(ptr nocapture noundef readonly, ptr nocapture noundef readonly) local_unnamed_addr #31

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @os_pushresult(ptr noundef %0, i32 noundef %1, ptr noundef %2) unnamed_addr #1 {
  %4 = icmp eq i32 %1, 0
  br i1 %4, label %6, label %5

5:                                                ; preds = %3
  tail call void @lua_pushboolean(ptr noundef %0, i32 noundef 1) #46
  br label %12

6:                                                ; preds = %3
  %7 = tail call ptr @__errno_location() #52
  %8 = load i32, ptr %7, align 4, !tbaa !65
  tail call void @lua_pushnil(ptr noundef %0) #46
  %9 = tail call ptr @strerror(i32 noundef %8) #46
  %10 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.24.500, ptr noundef %2, ptr noundef %9) #46
  %11 = sext i32 %8 to i64
  tail call void @lua_pushinteger(ptr noundef %0, i64 noundef %11) #46
  br label %12

12:                                               ; preds = %6, %5
  %13 = phi i32 [ 1, %5 ], [ 3, %6 ]
  ret i32 %13
}

; Function Attrs: nofree nounwind optsize
declare noundef i32 @remove(ptr nocapture noundef readonly) local_unnamed_addr #31

; Function Attrs: nofree nounwind optsize memory(read)
declare noundef ptr @getenv(ptr nocapture noundef) local_unnamed_addr #40

; Function Attrs: noreturn nounwind optsize
declare void @abort() local_unnamed_addr #21

; Function Attrs: mustprogress nofree nosync nounwind optsize willreturn memory(none)
declare double @difftime(i64 noundef, i64 noundef) local_unnamed_addr #26

; Function Attrs: nounwind optsize
declare ptr @gmtime(ptr noundef) local_unnamed_addr #27

; Function Attrs: nounwind optsize
declare ptr @localtime(ptr noundef) local_unnamed_addr #27

; Function Attrs: nounwind optsize
declare i64 @strftime(ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr #27

; Function Attrs: nounwind optsize
declare i64 @clock() local_unnamed_addr #27

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaopen_table(ptr noundef %0) #1 {
  tail call void @luaL_register(ptr noundef %0, ptr noundef nonnull @.str.506, ptr noundef nonnull @tab_funcs) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @tconcat(ptr noundef %0) #1 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = alloca i64, align 8
  call void @llvm.lifetime.start.p0(i64 8216, ptr nonnull %2) #48
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #48
  %4 = call ptr @luaL_optlstring(ptr noundef %0, i32 noundef 2, ptr noundef nonnull @.str.10.516, ptr noundef nonnull %3) #46
  call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  %5 = call i64 @luaL_optinteger(ptr noundef %0, i32 noundef 3, i64 noundef 1) #46
  %6 = trunc i64 %5 to i32
  %7 = call i32 @lua_type(ptr noundef %0, i32 noundef 4) #46
  %8 = icmp slt i32 %7, 1
  br i1 %8, label %9, label %11

9:                                                ; preds = %1
  %10 = call i64 @lua_objlen(ptr noundef %0, i32 noundef 1) #46
  br label %13

11:                                               ; preds = %1
  %12 = call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef 4) #46
  br label %13

13:                                               ; preds = %11, %9
  %14 = phi i64 [ %10, %9 ], [ %12, %11 ]
  %15 = trunc i64 %14 to i32
  call void @luaL_buffinit(ptr noundef %0, ptr noundef nonnull %2) #46
  %16 = icmp slt i32 %6, %15
  br i1 %16, label %17, label %22

17:                                               ; preds = %17, %13
  %18 = phi i32 [ %20, %17 ], [ %6, %13 ]
  call fastcc void @addfield(ptr noundef %0, ptr noundef nonnull %2, i32 noundef %18) #47
  %19 = load i64, ptr %3, align 8, !tbaa !40
  call void @luaL_addlstring(ptr noundef nonnull %2, ptr noundef %4, i64 noundef %19) #46
  %20 = add i32 %18, 1
  %21 = icmp eq i32 %20, %15
  br i1 %21, label %24, label %17, !llvm.loop !426

22:                                               ; preds = %13
  %23 = icmp eq i32 %6, %15
  br i1 %23, label %24, label %25

24:                                               ; preds = %22, %17
  call fastcc void @addfield(ptr noundef %0, ptr noundef nonnull %2, i32 noundef %15) #47
  br label %25

25:                                               ; preds = %24, %22
  call void @luaL_pushresult(ptr noundef nonnull %2) #46
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #48
  call void @llvm.lifetime.end.p0(i64 8216, ptr nonnull %2) #48
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @foreach(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 2, i32 noundef 6) #46
  tail call void @lua_pushnil(ptr noundef %0) #46
  br label %2

2:                                                ; preds = %8, %1
  %3 = tail call i32 @lua_next(ptr noundef %0, i32 noundef 1) #46
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %9, label %5

5:                                                ; preds = %2
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef 2) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -3) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -3) #46
  tail call void @lua_call(ptr noundef %0, i32 noundef 2, i32 noundef 1) #46
  %6 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %9

8:                                                ; preds = %5
  tail call void @lua_settop(ptr noundef %0, i32 noundef -3) #46
  br label %2, !llvm.loop !427

9:                                                ; preds = %5, %2
  %10 = phi i32 [ 1, %5 ], [ 0, %2 ]
  ret i32 %10
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @foreachi(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  %2 = tail call i64 @lua_objlen(ptr noundef %0, i32 noundef 1) #46
  %3 = trunc i64 %2 to i32
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 2, i32 noundef 6) #46
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %16, label %5

5:                                                ; preds = %1
  %6 = add i64 %2, 1
  %7 = and i64 %6, 4294967295
  br label %8

8:                                                ; preds = %13, %5
  %9 = phi i64 [ 1, %5 ], [ %14, %13 ]
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef 2) #46
  tail call void @lua_pushinteger(ptr noundef %0, i64 noundef %9) #46
  %10 = trunc i64 %9 to i32
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %10) #46
  tail call void @lua_call(ptr noundef %0, i32 noundef 2, i32 noundef 1) #46
  %11 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %13, label %16

13:                                               ; preds = %8
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  %14 = add nuw nsw i64 %9, 1
  %15 = icmp eq i64 %14, %7
  br i1 %15, label %16, label %8, !llvm.loop !428

16:                                               ; preds = %13, %8, %1
  %17 = phi i32 [ 0, %1 ], [ 0, %13 ], [ 1, %8 ]
  ret i32 %17
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @getn(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  %2 = tail call i64 @lua_objlen(ptr noundef %0, i32 noundef 1) #46
  %3 = shl i64 %2, 32
  %4 = ashr exact i64 %3, 32
  tail call void @lua_pushinteger(ptr noundef %0, i64 noundef %4) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @maxn(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  tail call void @lua_pushnil(ptr noundef %0) #46
  br label %2

2:                                                ; preds = %10, %1
  %3 = phi double [ %13, %10 ], [ 0.000000e+00, %1 ]
  br label %4

4:                                                ; preds = %7, %2
  %5 = tail call i32 @lua_next(ptr noundef %0, i32 noundef 1) #46
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %14, label %7

7:                                                ; preds = %4
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  %8 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %9 = icmp eq i32 %8, 3
  br i1 %9, label %10, label %4, !llvm.loop !429

10:                                               ; preds = %7
  %11 = tail call double @lua_tonumber(ptr noundef %0, i32 noundef -1) #46
  %12 = fcmp ogt double %11, %3
  %13 = select i1 %12, double %11, double %3
  br label %2, !llvm.loop !429

14:                                               ; preds = %4
  %.lcssa = phi double [ %3, %4 ]
  tail call void @lua_pushnumber(ptr noundef %0, double noundef %.lcssa) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @tinsert(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  %2 = tail call i64 @lua_objlen(ptr noundef %0, i32 noundef 1) #46
  %3 = trunc i64 %2 to i32
  %4 = add nsw i32 %3, 1
  %5 = tail call i32 @lua_gettop(ptr noundef %0) #46
  switch i32 %5, label %14 [
    i32 2, label %16
    i32 3, label %6
  ]

6:                                                ; preds = %1
  %7 = tail call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef 2) #46
  %8 = trunc i64 %7 to i32
  %9 = icmp slt i32 %3, %8
  br i1 %9, label %16, label %10

10:                                               ; preds = %10, %6
  %11 = phi i32 [ %12, %10 ], [ %4, %6 ]
  %12 = add nsw i32 %11, -1
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %12) #46
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef 1, i32 noundef %11) #46
  %13 = icmp sgt i32 %12, %8
  br i1 %13, label %10, label %16, !llvm.loop !430

14:                                               ; preds = %1
  %15 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.12.519) #46
  br label %18

16:                                               ; preds = %10, %6, %1
  %17 = phi i32 [ %4, %1 ], [ %8, %6 ], [ %8, %10 ]
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef 1, i32 noundef %17) #46
  br label %18

18:                                               ; preds = %16, %14
  %19 = phi i32 [ %15, %14 ], [ 0, %16 ]
  ret i32 %19
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @tremove(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  %2 = tail call i64 @lua_objlen(ptr noundef %0, i32 noundef 1) #46
  %3 = trunc i64 %2 to i32
  %4 = shl i64 %2, 32
  %5 = ashr exact i64 %4, 32
  %6 = tail call i64 @luaL_optinteger(ptr noundef %0, i32 noundef 2, i64 noundef %5) #46
  %7 = trunc i64 %6 to i32
  %8 = icmp slt i32 %7, 1
  %9 = icmp sgt i32 %7, %3
  %10 = or i1 %8, %9
  br i1 %10, label %18, label %11

11:                                               ; preds = %1
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %7) #46
  %12 = icmp slt i32 %7, %3
  br i1 %12, label %13, label %17

13:                                               ; preds = %13, %11
  %14 = phi i32 [ %15, %13 ], [ %7, %11 ]
  %15 = add nuw nsw i32 %14, 1
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %15) #46
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef 1, i32 noundef %14) #46
  %16 = icmp eq i32 %15, %3
  br i1 %16, label %17, label %13, !llvm.loop !431

17:                                               ; preds = %13, %11
  tail call void @lua_pushnil(ptr noundef %0) #46
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef 1, i32 noundef %3) #46
  br label %18

18:                                               ; preds = %17, %1
  %19 = phi i32 [ 1, %17 ], [ 0, %1 ]
  ret i32 %19
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @setn(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  %2 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.13.518) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef 1) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @sort(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  %2 = tail call i64 @lua_objlen(ptr noundef %0, i32 noundef 1) #46
  tail call void @luaL_checkstack(ptr noundef %0, i32 noundef 40, ptr noundef nonnull @.str.10.516) #46
  %3 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 2) #46
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %6, label %5

5:                                                ; preds = %1
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 2, i32 noundef 6) #46
  br label %6

6:                                                ; preds = %5, %1
  %7 = trunc i64 %2 to i32
  tail call void @lua_settop(ptr noundef %0, i32 noundef 2) #46
  tail call fastcc void @auxsort(ptr noundef %0, i32 noundef 1, i32 noundef %7) #47
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @auxsort(ptr noundef %0, i32 noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = icmp slt i32 %1, %2
  br i1 %4, label %5, label %66

5:                                                ; preds = %56, %3
  %6 = phi i32 [ %62, %56 ], [ %2, %3 ]
  %7 = phi i32 [ %61, %56 ], [ %1, %3 ]
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %7) #46
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %6) #46
  %8 = tail call fastcc i32 @sort_comp(ptr noundef %0, i32 noundef -1, i32 noundef -2) #47
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %11, label %10

10:                                               ; preds = %5
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef 1, i32 noundef %7) #46
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef 1, i32 noundef %6) #46
  br label %12

11:                                               ; preds = %5
  tail call void @lua_settop(ptr noundef %0, i32 noundef -3) #46
  br label %12

12:                                               ; preds = %11, %10
  %13 = sub nsw i32 %6, %7
  %14 = icmp eq i32 %13, 1
  br i1 %14, label %66, label %15

15:                                               ; preds = %12
  %16 = add nsw i32 %6, %7
  %17 = sdiv i32 %16, 2
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %17) #46
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %7) #46
  %18 = tail call fastcc i32 @sort_comp(ptr noundef %0, i32 noundef -2, i32 noundef -1) #47
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %21, label %20

20:                                               ; preds = %15
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef 1, i32 noundef %17) #46
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef 1, i32 noundef %7) #46
  br label %26

21:                                               ; preds = %15
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %6) #46
  %22 = tail call fastcc i32 @sort_comp(ptr noundef %0, i32 noundef -1, i32 noundef -2) #47
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %25, label %24

24:                                               ; preds = %21
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef 1, i32 noundef %17) #46
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef 1, i32 noundef %6) #46
  br label %26

25:                                               ; preds = %21
  tail call void @lua_settop(ptr noundef %0, i32 noundef -3) #46
  br label %26

26:                                               ; preds = %25, %24, %20
  %27 = icmp eq i32 %13, 2
  br i1 %27, label %66, label %28

28:                                               ; preds = %26
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %17) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -1) #46
  %29 = add nsw i32 %6, -1
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %29) #46
  br label %30

30:                                               ; preds = %54, %28
  %31 = phi i32 [ %17, %28 ], [ %.lcssa.lcssa, %54 ]
  %32 = phi i32 [ %29, %28 ], [ %.lcssa2, %54 ]
  %33 = phi i32 [ %7, %28 ], [ %.lcssa.lcssa, %54 ]
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef 1, i32 noundef %31) #46
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef 1, i32 noundef %32) #46
  br label %34

34:                                               ; preds = %43, %30
  %35 = phi i32 [ %33, %30 ], [ %36, %43 ]
  %36 = add nsw i32 %35, 1
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %36) #46
  %37 = tail call fastcc i32 @sort_comp(ptr noundef %0, i32 noundef -1, i32 noundef -2) #47
  %38 = icmp eq i32 %37, 0
  br i1 %38, label %44, label %39

39:                                               ; preds = %34
  %40 = icmp slt i32 %35, %6
  br i1 %40, label %43, label %41

41:                                               ; preds = %39
  %42 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.14.517) #46
  br label %43

43:                                               ; preds = %41, %39
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  br label %34, !llvm.loop !432

44:                                               ; preds = %53, %34
  %.lcssa1 = phi i32 [ %.lcssa1, %53 ], [ %35, %34 ]
  %.lcssa = phi i32 [ %.lcssa, %53 ], [ %36, %34 ]
  %45 = phi i32 [ %46, %53 ], [ %32, %34 ]
  %46 = add nsw i32 %45, -1
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %46) #46
  %47 = tail call fastcc i32 @sort_comp(ptr noundef %0, i32 noundef -3, i32 noundef -1) #47
  %48 = icmp eq i32 %47, 0
  br i1 %48, label %54, label %49

49:                                               ; preds = %44
  %50 = icmp sgt i32 %45, %7
  br i1 %50, label %53, label %51

51:                                               ; preds = %49
  %52 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.14.517) #46
  br label %53

53:                                               ; preds = %51, %49
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  br label %44, !llvm.loop !433

54:                                               ; preds = %44
  %.lcssa3 = phi i32 [ %45, %44 ]
  %.lcssa2 = phi i32 [ %46, %44 ]
  %.lcssa1.lcssa = phi i32 [ %.lcssa1, %44 ]
  %.lcssa.lcssa = phi i32 [ %.lcssa, %44 ]
  %55 = icmp sgt i32 %.lcssa3, %.lcssa.lcssa
  br i1 %55, label %30, label %56

56:                                               ; preds = %54
  %.lcssa1.lcssa.lcssa = phi i32 [ %.lcssa1.lcssa, %54 ]
  %.lcssa.lcssa.lcssa = phi i32 [ %.lcssa.lcssa, %54 ]
  tail call void @lua_settop(ptr noundef %0, i32 noundef -4) #46
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %29) #46
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %.lcssa.lcssa.lcssa) #46
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef 1, i32 noundef %29) #46
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef 1, i32 noundef %.lcssa.lcssa.lcssa) #46
  %57 = sub nsw i32 %.lcssa.lcssa.lcssa, %7
  %58 = sub nsw i32 %6, %.lcssa.lcssa.lcssa
  %59 = icmp slt i32 %57, %58
  %60 = add nsw i32 %.lcssa1.lcssa.lcssa, 2
  %61 = select i1 %59, i32 %60, i32 %7
  %62 = select i1 %59, i32 %6, i32 %.lcssa1.lcssa.lcssa
  %63 = select i1 %59, i32 %.lcssa1.lcssa.lcssa, i32 %6
  %64 = select i1 %59, i32 %7, i32 %60
  tail call fastcc void @auxsort(ptr noundef %0, i32 noundef %64, i32 noundef %63) #47
  %65 = icmp slt i32 %61, %62
  br i1 %65, label %5, label %66

66:                                               ; preds = %56, %26, %12, %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @sort_comp(ptr noundef %0, i32 noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = tail call i32 @lua_type(ptr noundef %0, i32 noundef 2) #46
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %10, label %6

6:                                                ; preds = %3
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef 2) #46
  %7 = add nsw i32 %1, -1
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef %7) #46
  %8 = add nsw i32 %2, -2
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef %8) #46
  tail call void @lua_call(ptr noundef %0, i32 noundef 2, i32 noundef 1) #46
  %9 = tail call i32 @lua_toboolean(ptr noundef %0, i32 noundef -1) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  br label %12

10:                                               ; preds = %3
  %11 = tail call i32 @lua_lessthan(ptr noundef %0, i32 noundef %1, i32 noundef %2) #46
  br label %12

12:                                               ; preds = %10, %6
  %13 = phi i32 [ %11, %10 ], [ %9, %6 ]
  ret i32 %13
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @addfield(ptr noundef %0, ptr noundef %1, i32 noundef %2) unnamed_addr #1 {
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef 1, i32 noundef %2) #46
  %4 = tail call i32 @lua_isstring(ptr noundef %0, i32 noundef -1) #46
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %10

6:                                                ; preds = %3
  %7 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %8 = tail call ptr @lua_typename(ptr noundef %0, i32 noundef %7) #46
  %9 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.11.520, ptr noundef %8, i32 noundef %2) #46
  br label %10

10:                                               ; preds = %6, %3
  tail call void @luaL_addvalue(ptr noundef %1) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaopen_string(ptr noundef %0) #1 {
  tail call void @luaL_register(ptr noundef %0, ptr noundef nonnull @.str.521, ptr noundef nonnull @strlib) #46
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -1, ptr noundef nonnull @.str.1.522) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.2.523) #46
  tail call void @lua_createtable(ptr noundef %0, i32 noundef 0, i32 noundef 1) #46
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.38.524, i64 noundef 0) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -2) #46
  %2 = tail call i32 @lua_setmetatable(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.39.525) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_byte(ptr noundef %0) #1 {
  %2 = alloca i64, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  %3 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef nonnull %2) #46
  %4 = call i64 @luaL_optinteger(ptr noundef %0, i32 noundef 2, i64 noundef 1) #46
  %5 = load i64, ptr %2, align 8, !tbaa !40
  %6 = icmp slt i64 %4, 0
  %7 = add nsw i64 %5, 1
  %8 = select i1 %6, i64 %7, i64 0
  %9 = add nsw i64 %8, %4
  %10 = call i64 @llvm.smax.i64(i64 %9, i64 0)
  %11 = call i64 @luaL_optinteger(ptr noundef %0, i32 noundef 3, i64 noundef %10) #46
  %12 = load i64, ptr %2, align 8, !tbaa !40
  %13 = icmp slt i64 %11, 0
  %14 = add nsw i64 %12, 1
  %15 = select i1 %13, i64 %14, i64 0
  %16 = add nsw i64 %15, %11
  %17 = call i64 @llvm.smax.i64(i64 %16, i64 0)
  %18 = call i64 @llvm.smax.i64(i64 %9, i64 1)
  %19 = call i64 @llvm.umin.i64(i64 %17, i64 %12)
  %20 = icmp ugt i64 %18, %19
  br i1 %20, label %43, label %21

21:                                               ; preds = %1
  %22 = sub nsw i64 %19, %18
  %23 = trunc i64 %22 to i32
  %24 = add i32 %23, 1
  %25 = sext i32 %24 to i64
  %26 = add nsw i64 %18, %25
  %27 = icmp sgt i64 %26, %19
  br i1 %27, label %30, label %28

28:                                               ; preds = %21
  %29 = call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.16.559) #46
  br label %30

30:                                               ; preds = %28, %21
  call void @luaL_checkstack(ptr noundef %0, i32 noundef %24, ptr noundef nonnull @.str.16.559) #46
  %31 = icmp ult i32 %23, 2147483647
  br i1 %31, label %32, label %43

32:                                               ; preds = %30
  %33 = add nsw i64 %18, -1
  %34 = zext i32 %24 to i64
  br label %35

35:                                               ; preds = %35, %32
  %36 = phi i64 [ 0, %32 ], [ %41, %35 ]
  %37 = add nuw i64 %33, %36
  %38 = getelementptr inbounds i8, ptr %3, i64 %37
  %39 = load i8, ptr %38, align 1, !tbaa !33
  %40 = zext i8 %39 to i64
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %40) #46
  %41 = add nuw nsw i64 %36, 1
  %42 = icmp eq i64 %41, %34
  br i1 %42, label %43, label %35, !llvm.loop !434

43:                                               ; preds = %35, %30, %1
  %44 = phi i32 [ 0, %1 ], [ %24, %30 ], [ %24, %35 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  ret i32 %44
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_char(ptr noundef %0) #1 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = tail call i32 @lua_gettop(ptr noundef %0) #46
  call void @llvm.lifetime.start.p0(i64 8216, ptr nonnull %2) #48
  call void @luaL_buffinit(ptr noundef %0, ptr noundef nonnull %2) #46
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %26, label %5

5:                                                ; preds = %1
  %6 = getelementptr inbounds %struct.luaL_Buffer, ptr %2, i64 1
  br label %7

7:                                                ; preds = %21, %5
  %8 = phi i32 [ 1, %5 ], [ %24, %21 ]
  %9 = call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef %8) #46
  %10 = trunc i64 %9 to i8
  %11 = and i64 %9, 4294967040
  %12 = icmp eq i64 %11, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %7
  %14 = call i32 @luaL_argerror(ptr noundef %0, i32 noundef %8, ptr noundef nonnull @.str.17.558) #46
  br label %15

15:                                               ; preds = %13, %7
  %16 = load ptr, ptr %2, align 8, !tbaa !392
  %17 = icmp ult ptr %16, %6
  br i1 %17, label %21, label %18

18:                                               ; preds = %15
  %19 = call ptr @luaL_prepbuffer(ptr noundef nonnull %2) #46
  %20 = load ptr, ptr %2, align 8, !tbaa !392
  br label %21

21:                                               ; preds = %18, %15
  %22 = phi ptr [ %20, %18 ], [ %16, %15 ]
  %23 = getelementptr inbounds i8, ptr %22, i64 1
  store ptr %23, ptr %2, align 8, !tbaa !392
  store i8 %10, ptr %22, align 1, !tbaa !33
  %24 = add nuw i32 %8, 1
  %25 = icmp eq i32 %8, %3
  br i1 %25, label %26, label %7, !llvm.loop !435

26:                                               ; preds = %21, %1
  call void @luaL_pushresult(ptr noundef nonnull %2) #46
  call void @llvm.lifetime.end.p0(i64 8216, ptr nonnull %2) #48
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_dump(ptr noundef %0) #1 {
  %2 = alloca %struct.luaL_Buffer, align 8
  call void @llvm.lifetime.start.p0(i64 8216, ptr nonnull %2) #48
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 6) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef 1) #46
  call void @luaL_buffinit(ptr noundef %0, ptr noundef nonnull %2) #46
  %3 = call i32 @lua_dump(ptr noundef %0, ptr noundef nonnull @writer, ptr noundef nonnull %2) #46
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %7, label %5

5:                                                ; preds = %1
  %6 = call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.18.557) #46
  br label %7

7:                                                ; preds = %5, %1
  call void @luaL_pushresult(ptr noundef nonnull %2) #46
  call void @llvm.lifetime.end.p0(i64 8216, ptr nonnull %2) #48
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_find(ptr noundef %0) #1 {
  %2 = tail call fastcc i32 @str_find_aux(ptr noundef %0, i32 noundef 1) #47
  ret i32 %2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_format(ptr noundef %0) #1 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %struct.luaL_Buffer, align 8
  %5 = alloca [18 x i8], align 16
  %6 = alloca [512 x i8], align 16
  %7 = alloca i64, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #48
  %8 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef nonnull %3) #46
  %9 = load i64, ptr %3, align 8, !tbaa !40
  %10 = getelementptr inbounds i8, ptr %8, i64 %9
  call void @llvm.lifetime.start.p0(i64 8216, ptr nonnull %4) #48
  call void @luaL_buffinit(ptr noundef %0, ptr noundef nonnull %4) #46
  %11 = icmp sgt i64 %9, 0
  br i1 %11, label %12, label %242

12:                                               ; preds = %1
  %13 = getelementptr inbounds %struct.luaL_Buffer, ptr %4, i64 1
  %14 = getelementptr inbounds i8, ptr %5, i64 1
  br label %15

15:                                               ; preds = %238, %12
  %16 = phi i32 [ 1, %12 ], [ %240, %238 ]
  %17 = phi ptr [ %8, %12 ], [ %239, %238 ]
  %18 = load i8, ptr %17, align 1, !tbaa !33
  %19 = icmp eq i8 %18, 37
  br i1 %19, label %32, label %20

20:                                               ; preds = %15
  %21 = load ptr, ptr %4, align 8, !tbaa !392
  %22 = icmp ult ptr %21, %13
  br i1 %22, label %27, label %23

23:                                               ; preds = %20
  %24 = call ptr @luaL_prepbuffer(ptr noundef nonnull %4) #46
  %25 = load i8, ptr %17, align 1, !tbaa !33
  %26 = load ptr, ptr %4, align 8, !tbaa !392
  br label %27

27:                                               ; preds = %23, %20
  %28 = phi ptr [ %26, %23 ], [ %21, %20 ]
  %29 = phi i8 [ %25, %23 ], [ %18, %20 ]
  %30 = getelementptr inbounds i8, ptr %17, i64 1
  %31 = getelementptr inbounds i8, ptr %28, i64 1
  store ptr %31, ptr %4, align 8, !tbaa !392
  store i8 %29, ptr %28, align 1, !tbaa !33
  br label %238

32:                                               ; preds = %15
  %33 = getelementptr inbounds i8, ptr %17, i64 1
  %34 = load i8, ptr %33, align 1, !tbaa !33
  %35 = icmp eq i8 %34, 37
  br i1 %35, label %36, label %48

36:                                               ; preds = %32
  %37 = load ptr, ptr %4, align 8, !tbaa !392
  %38 = icmp ult ptr %37, %13
  br i1 %38, label %43, label %39

39:                                               ; preds = %36
  %40 = call ptr @luaL_prepbuffer(ptr noundef nonnull %4) #46
  %41 = load i8, ptr %33, align 1, !tbaa !33
  %42 = load ptr, ptr %4, align 8, !tbaa !392
  br label %43

43:                                               ; preds = %39, %36
  %44 = phi ptr [ %42, %39 ], [ %37, %36 ]
  %45 = phi i8 [ %41, %39 ], [ 37, %36 ]
  %46 = getelementptr inbounds i8, ptr %17, i64 2
  %47 = getelementptr inbounds i8, ptr %44, i64 1
  store ptr %47, ptr %4, align 8, !tbaa !392
  store i8 %45, ptr %44, align 1, !tbaa !33
  br label %238

48:                                               ; preds = %32
  call void @llvm.lifetime.start.p0(i64 18, ptr nonnull %5) #48
  call void @llvm.lifetime.start.p0(i64 512, ptr nonnull %6) #48
  %49 = add nsw i32 %16, 1
  %50 = icmp eq i8 %34, 0
  br i1 %50, label %61, label %51

51:                                               ; preds = %57, %48
  %52 = phi i8 [ %59, %57 ], [ %34, %48 ]
  %53 = phi ptr [ %58, %57 ], [ %33, %48 ]
  %54 = sext i8 %52 to i32
  %55 = call ptr @memchr(ptr nonnull dereferenceable(1) @.str.29.551, i32 %54, i64 6)
  %56 = icmp eq ptr %55, null
  br i1 %56, label %61, label %57

57:                                               ; preds = %51
  %58 = getelementptr inbounds i8, ptr %53, i64 1
  %59 = load i8, ptr %58, align 1, !tbaa !33
  %60 = icmp eq i8 %59, 0
  br i1 %60, label %61, label %51, !llvm.loop !436

61:                                               ; preds = %57, %51, %48
  %62 = phi i8 [ 0, %48 ], [ %52, %51 ], [ 0, %57 ]
  %63 = phi ptr [ %33, %48 ], [ %53, %51 ], [ %58, %57 ]
  %64 = ptrtoint ptr %63 to i64
  %65 = ptrtoint ptr %33 to i64
  %66 = sub i64 %64, %65
  %67 = icmp ugt i64 %66, 5
  br i1 %67, label %68, label %71

68:                                               ; preds = %61
  %69 = call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.30.552) #46
  %70 = load i8, ptr %63, align 1, !tbaa !33
  br label %71

71:                                               ; preds = %68, %61
  %72 = phi i8 [ %70, %68 ], [ %62, %61 ]
  %73 = tail call ptr @__ctype_b_loc() #52
  %74 = load ptr, ptr %73, align 8, !tbaa !39
  %75 = zext i8 %72 to i64
  %76 = getelementptr inbounds i16, ptr %74, i64 %75
  %77 = load i16, ptr %76, align 2, !tbaa !239
  %78 = lshr i16 %77, 11
  %79 = and i16 %78, 1
  %80 = zext i16 %79 to i64
  %81 = getelementptr inbounds i8, ptr %63, i64 %80
  %82 = load i8, ptr %81, align 1, !tbaa !33
  %83 = zext i8 %82 to i64
  %84 = getelementptr inbounds i16, ptr %74, i64 %83
  %85 = load i16, ptr %84, align 2, !tbaa !239
  %86 = lshr i16 %85, 11
  %87 = and i16 %86, 1
  %88 = zext i16 %87 to i64
  %89 = getelementptr inbounds i8, ptr %81, i64 %88
  %90 = load i8, ptr %89, align 1, !tbaa !33
  %91 = icmp eq i8 %90, 46
  br i1 %91, label %92, label %111

92:                                               ; preds = %71
  %93 = getelementptr inbounds i8, ptr %89, i64 1
  %94 = load i8, ptr %93, align 1, !tbaa !33
  %95 = zext i8 %94 to i64
  %96 = getelementptr inbounds i16, ptr %74, i64 %95
  %97 = load i16, ptr %96, align 2, !tbaa !239
  %98 = and i16 %97, 2048
  %99 = icmp eq i16 %98, 0
  %100 = getelementptr inbounds i8, ptr %89, i64 2
  %101 = select i1 %99, ptr %93, ptr %100
  %102 = load i8, ptr %101, align 1, !tbaa !33
  %103 = zext i8 %102 to i64
  %104 = getelementptr inbounds i16, ptr %74, i64 %103
  %105 = load i16, ptr %104, align 2, !tbaa !239
  %106 = lshr i16 %105, 11
  %107 = and i16 %106, 1
  %108 = zext i16 %107 to i64
  %109 = getelementptr inbounds i8, ptr %101, i64 %108
  %110 = load i8, ptr %109, align 1, !tbaa !33
  br label %111

111:                                              ; preds = %92, %71
  %112 = phi i8 [ %90, %71 ], [ %110, %92 ]
  %113 = phi ptr [ %89, %71 ], [ %109, %92 ]
  %114 = zext i8 %112 to i64
  %115 = getelementptr inbounds i16, ptr %74, i64 %114
  %116 = load i16, ptr %115, align 2, !tbaa !239
  %117 = and i16 %116, 2048
  %118 = icmp eq i16 %117, 0
  br i1 %118, label %121, label %119

119:                                              ; preds = %111
  %120 = call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.31.553) #46
  br label %121

121:                                              ; preds = %119, %111
  store i8 37, ptr %5, align 16, !tbaa !33
  %122 = ptrtoint ptr %113 to i64
  %123 = sub i64 %122, %65
  %124 = add nsw i64 %123, 1
  %125 = call ptr @strncpy(ptr noundef nonnull %14, ptr noundef nonnull %33, i64 noundef %124) #46
  %126 = getelementptr inbounds i8, ptr %14, i64 %124
  store i8 0, ptr %126, align 1, !tbaa !33
  %127 = getelementptr inbounds i8, ptr %113, i64 1
  %128 = load i8, ptr %113, align 1, !tbaa !33
  %129 = sext i8 %128 to i32
  switch i32 %129, label %233 [
    i32 99, label %130
    i32 100, label %134
    i32 105, label %134
    i32 111, label %146
    i32 117, label %146
    i32 120, label %146
    i32 88, label %146
    i32 101, label %158
    i32 69, label %158
    i32 102, label %158
    i32 103, label %158
    i32 71, label %158
    i32 113, label %161
    i32 115, label %223
  ]

130:                                              ; preds = %121
  %131 = call double @luaL_checknumber(ptr noundef %0, i32 noundef %49) #46
  %132 = fptosi double %131 to i32
  %133 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %6, ptr noundef nonnull dereferenceable(1) %5, i32 noundef %132) #46
  br label %235

134:                                              ; preds = %121, %121
  %135 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %5) #49
  %136 = add i64 %135, -1
  %137 = getelementptr inbounds i8, ptr %5, i64 %136
  %138 = load i8, ptr %137, align 1, !tbaa !33
  %139 = getelementptr inbounds i8, ptr %5, i64 %135
  %140 = getelementptr inbounds i8, ptr %139, i64 -1
  store i16 108, ptr %140, align 1
  store i8 %138, ptr %139, align 1, !tbaa !33
  %141 = add i64 %135, 1
  %142 = getelementptr inbounds i8, ptr %5, i64 %141
  store i8 0, ptr %142, align 1, !tbaa !33
  %143 = call double @luaL_checknumber(ptr noundef %0, i32 noundef %49) #46
  %144 = fptosi double %143 to i64
  %145 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %6, ptr noundef nonnull dereferenceable(1) %5, i64 noundef %144) #46
  br label %235

146:                                              ; preds = %121, %121, %121, %121
  %147 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %5) #49
  %148 = add i64 %147, -1
  %149 = getelementptr inbounds i8, ptr %5, i64 %148
  %150 = load i8, ptr %149, align 1, !tbaa !33
  %151 = getelementptr inbounds i8, ptr %5, i64 %147
  %152 = getelementptr inbounds i8, ptr %151, i64 -1
  store i16 108, ptr %152, align 1
  store i8 %150, ptr %151, align 1, !tbaa !33
  %153 = add i64 %147, 1
  %154 = getelementptr inbounds i8, ptr %5, i64 %153
  store i8 0, ptr %154, align 1, !tbaa !33
  %155 = call double @luaL_checknumber(ptr noundef %0, i32 noundef %49) #46
  %156 = fptoui double %155 to i64
  %157 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %6, ptr noundef nonnull dereferenceable(1) %5, i64 noundef %156) #46
  br label %235

158:                                              ; preds = %121, %121, %121, %121, %121
  %159 = call double @luaL_checknumber(ptr noundef %0, i32 noundef %49) #46
  %160 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %6, ptr noundef nonnull dereferenceable(1) %5, double noundef %159) #46
  br label %235

161:                                              ; preds = %121
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  %162 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef %49, ptr noundef nonnull %2) #46
  %163 = load ptr, ptr %4, align 8, !tbaa !392
  %164 = icmp ult ptr %163, %13
  br i1 %164, label %168, label %165

165:                                              ; preds = %161
  %166 = call ptr @luaL_prepbuffer(ptr noundef nonnull %4) #46
  %167 = load ptr, ptr %4, align 8, !tbaa !392
  br label %168

168:                                              ; preds = %165, %161
  %169 = phi ptr [ %167, %165 ], [ %163, %161 ]
  %170 = getelementptr inbounds i8, ptr %169, i64 1
  store ptr %170, ptr %4, align 8, !tbaa !392
  store i8 34, ptr %169, align 1, !tbaa !33
  %171 = load i64, ptr %2, align 8, !tbaa !40
  %172 = add i64 %171, -1
  store i64 %172, ptr %2, align 8, !tbaa !40
  %173 = icmp eq i64 %171, 0
  br i1 %173, label %214, label %174

174:                                              ; preds = %209, %168
  %175 = phi ptr [ %210, %209 ], [ %162, %168 ]
  %176 = load i8, ptr %175, align 1, !tbaa !33
  %177 = sext i8 %176 to i32
  switch i32 %177, label %198 [
    i32 34, label %178
    i32 92, label %178
    i32 10, label %178
    i32 13, label %196
    i32 0, label %197
  ]

178:                                              ; preds = %174, %174, %174
  %179 = load ptr, ptr %4, align 8, !tbaa !392
  %180 = icmp ult ptr %179, %13
  br i1 %180, label %184, label %181

181:                                              ; preds = %178
  %182 = call ptr @luaL_prepbuffer(ptr noundef nonnull %4) #46
  %183 = load ptr, ptr %4, align 8, !tbaa !392
  br label %184

184:                                              ; preds = %181, %178
  %185 = phi ptr [ %183, %181 ], [ %179, %178 ]
  %186 = getelementptr inbounds i8, ptr %185, i64 1
  store ptr %186, ptr %4, align 8, !tbaa !392
  store i8 92, ptr %185, align 1, !tbaa !33
  %187 = load ptr, ptr %4, align 8, !tbaa !392
  %188 = icmp ult ptr %187, %13
  br i1 %188, label %192, label %189

189:                                              ; preds = %184
  %190 = call ptr @luaL_prepbuffer(ptr noundef nonnull %4) #46
  %191 = load ptr, ptr %4, align 8, !tbaa !392
  br label %192

192:                                              ; preds = %189, %184
  %193 = phi ptr [ %191, %189 ], [ %187, %184 ]
  %194 = load i8, ptr %175, align 1, !tbaa !33
  %195 = getelementptr inbounds i8, ptr %193, i64 1
  store ptr %195, ptr %4, align 8, !tbaa !392
  store i8 %194, ptr %193, align 1, !tbaa !33
  br label %209

196:                                              ; preds = %174
  call void @luaL_addlstring(ptr noundef nonnull %4, ptr noundef nonnull @.str.33.554, i64 noundef 2) #46
  br label %209

197:                                              ; preds = %174
  call void @luaL_addlstring(ptr noundef nonnull %4, ptr noundef nonnull @.str.34.555, i64 noundef 4) #46
  br label %209

198:                                              ; preds = %174
  %199 = load ptr, ptr %4, align 8, !tbaa !392
  %200 = icmp ult ptr %199, %13
  br i1 %200, label %205, label %201

201:                                              ; preds = %198
  %202 = call ptr @luaL_prepbuffer(ptr noundef nonnull %4) #46
  %203 = load i8, ptr %175, align 1, !tbaa !33
  %204 = load ptr, ptr %4, align 8, !tbaa !392
  br label %205

205:                                              ; preds = %201, %198
  %206 = phi ptr [ %204, %201 ], [ %199, %198 ]
  %207 = phi i8 [ %203, %201 ], [ %176, %198 ]
  %208 = getelementptr inbounds i8, ptr %206, i64 1
  store ptr %208, ptr %4, align 8, !tbaa !392
  store i8 %207, ptr %206, align 1, !tbaa !33
  br label %209

209:                                              ; preds = %205, %197, %196, %192
  %210 = getelementptr inbounds i8, ptr %175, i64 1
  %211 = load i64, ptr %2, align 8, !tbaa !40
  %212 = add i64 %211, -1
  store i64 %212, ptr %2, align 8, !tbaa !40
  %213 = icmp eq i64 %211, 0
  br i1 %213, label %214, label %174, !llvm.loop !437

214:                                              ; preds = %209, %168
  %215 = load ptr, ptr %4, align 8, !tbaa !392
  %216 = icmp ult ptr %215, %13
  br i1 %216, label %220, label %217

217:                                              ; preds = %214
  %218 = call ptr @luaL_prepbuffer(ptr noundef nonnull %4) #46
  %219 = load ptr, ptr %4, align 8, !tbaa !392
  br label %220

220:                                              ; preds = %217, %214
  %221 = phi ptr [ %219, %217 ], [ %215, %214 ]
  %222 = getelementptr inbounds i8, ptr %221, i64 1
  store ptr %222, ptr %4, align 8, !tbaa !392
  store i8 34, ptr %221, align 1, !tbaa !33
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  br label %237, !llvm.loop !438

223:                                              ; preds = %121
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %7) #48
  %224 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef %49, ptr noundef nonnull %7) #46
  %225 = call ptr @strchr(ptr noundef nonnull dereferenceable(1) %5, i32 noundef 46) #49
  %226 = icmp ne ptr %225, null
  %227 = load i64, ptr %7, align 8
  %228 = icmp ult i64 %227, 100
  %229 = select i1 %226, i1 true, i1 %228
  br i1 %229, label %230, label %232

230:                                              ; preds = %223
  %231 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef nonnull dereferenceable(1) %6, ptr noundef nonnull dereferenceable(1) %5, ptr noundef %224) #46
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %7) #48
  br label %235

232:                                              ; preds = %223
  call void @lua_pushvalue(ptr noundef %0, i32 noundef %49) #46
  call void @luaL_addvalue(ptr noundef nonnull %4) #46
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %7) #48
  br label %237

233:                                              ; preds = %121
  %.lcssa = phi i32 [ %129, %121 ]
  %234 = call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.28.556, i32 noundef %.lcssa) #46
  call void @llvm.lifetime.end.p0(i64 512, ptr nonnull %6) #48
  call void @llvm.lifetime.end.p0(i64 18, ptr nonnull %5) #48
  br label %243

235:                                              ; preds = %230, %158, %146, %134, %130
  %236 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %6) #49
  call void @luaL_addlstring(ptr noundef nonnull %4, ptr noundef nonnull %6, i64 noundef %236) #46
  call void @llvm.lifetime.end.p0(i64 512, ptr nonnull %6) #48
  call void @llvm.lifetime.end.p0(i64 18, ptr nonnull %5) #48
  br label %238

237:                                              ; preds = %232, %220
  call void @llvm.lifetime.end.p0(i64 512, ptr nonnull %6) #48
  call void @llvm.lifetime.end.p0(i64 18, ptr nonnull %5) #48
  br label %238

238:                                              ; preds = %237, %235, %43, %27
  %239 = phi ptr [ %127, %237 ], [ %30, %27 ], [ %46, %43 ], [ %127, %235 ]
  %240 = phi i32 [ %49, %237 ], [ %16, %27 ], [ %16, %43 ], [ %49, %235 ]
  %241 = icmp ult ptr %239, %10
  br i1 %241, label %15, label %242, !llvm.loop !438

242:                                              ; preds = %238, %1
  call void @luaL_pushresult(ptr noundef nonnull %4) #46
  br label %243

243:                                              ; preds = %242, %233
  %244 = phi i32 [ 1, %242 ], [ %234, %233 ]
  call void @llvm.lifetime.end.p0(i64 8216, ptr nonnull %4) #48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #48
  ret i32 %244
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @gfind_nodef(ptr noundef %0) #1 {
  %2 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.35.550) #46
  ret i32 %2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @gmatch(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %3 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 2, ptr noundef null) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef 2) #46
  tail call void @lua_pushinteger(ptr noundef %0, i64 noundef 0) #46
  tail call void @lua_pushcclosure(ptr noundef %0, ptr noundef nonnull @gmatch_aux, i32 noundef 3) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_gsub(ptr noundef %0) #1 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %struct.MatchState, align 8
  %5 = alloca %struct.luaL_Buffer, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #48
  %6 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef nonnull %3) #46
  %7 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 2, ptr noundef null) #46
  %8 = call i32 @lua_type(ptr noundef %0, i32 noundef 3) #46
  %9 = load i64, ptr %3, align 8, !tbaa !40
  %10 = add i64 %9, 1
  %11 = call i64 @luaL_optinteger(ptr noundef %0, i32 noundef 4, i64 noundef %10) #46
  %12 = trunc i64 %11 to i32
  %13 = load i8, ptr %7, align 1, !tbaa !33
  %14 = icmp eq i8 %13, 94
  %15 = zext i1 %14 to i64
  %16 = getelementptr inbounds i8, ptr %7, i64 %15
  call void @llvm.lifetime.start.p0(i64 544, ptr nonnull %4) #48
  call void @llvm.lifetime.start.p0(i64 8216, ptr nonnull %5) #48
  %17 = add i32 %8, -3
  %18 = icmp ult i32 %17, 4
  br i1 %18, label %21, label %19

19:                                               ; preds = %1
  %20 = call i32 @luaL_argerror(ptr noundef %0, i32 noundef 3, ptr noundef nonnull @.str.36.548) #46
  br label %21

21:                                               ; preds = %19, %1
  call void @luaL_buffinit(ptr noundef %0, ptr noundef nonnull %5) #46
  %22 = getelementptr inbounds %struct.MatchState, ptr %4, i64 0, i32 2
  store ptr %0, ptr %22, align 8, !tbaa !439
  store ptr %6, ptr %4, align 8, !tbaa !441
  %23 = load i64, ptr %3, align 8, !tbaa !40
  %24 = getelementptr inbounds i8, ptr %6, i64 %23
  %25 = getelementptr inbounds %struct.MatchState, ptr %4, i64 0, i32 1
  store ptr %24, ptr %25, align 8, !tbaa !442
  %26 = getelementptr inbounds %struct.MatchState, ptr %4, i64 0, i32 3
  %27 = getelementptr inbounds %struct.luaL_Buffer, ptr %5, i64 1
  br label %28

28:                                               ; preds = %132, %21
  %29 = phi i32 [ 0, %21 ], [ %133, %132 ]
  %30 = phi ptr [ %6, %21 ], [ %134, %132 ]
  %31 = icmp slt i32 %29, %12
  br i1 %31, label %32, label %135

32:                                               ; preds = %28
  store i32 0, ptr %26, align 8, !tbaa !443
  %33 = call fastcc ptr @match(ptr noundef nonnull %4, ptr noundef %30, ptr noundef nonnull %16) #47
  %34 = icmp eq ptr %33, null
  br i1 %34, label %117, label %35

35:                                               ; preds = %32
  %36 = add nsw i32 %29, 1
  %37 = load ptr, ptr %22, align 8, !tbaa !439
  %38 = call i32 @lua_type(ptr noundef %37, i32 noundef 3) #46
  switch i32 %38, label %100 [
    i32 3, label %39
    i32 4, label %39
    i32 6, label %97
    i32 5, label %99
  ]

39:                                               ; preds = %35, %35
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  %40 = call ptr @lua_tolstring(ptr noundef %37, i32 noundef 3, ptr noundef nonnull %2) #46
  %41 = load i64, ptr %2, align 8, !tbaa !40
  %42 = icmp eq i64 %41, 0
  br i1 %42, label %96, label %43

43:                                               ; preds = %39
  %44 = ptrtoint ptr %33 to i64
  %45 = ptrtoint ptr %30 to i64
  %46 = sub i64 %44, %45
  br label %47

47:                                               ; preds = %91, %43
  %48 = phi i64 [ 0, %43 ], [ %93, %91 ]
  %49 = getelementptr inbounds i8, ptr %40, i64 %48
  %50 = load i8, ptr %49, align 1, !tbaa !33
  %51 = icmp eq i8 %50, 37
  br i1 %51, label %63, label %52

52:                                               ; preds = %47
  %53 = load ptr, ptr %5, align 8, !tbaa !392
  %54 = icmp ult ptr %53, %27
  br i1 %54, label %59, label %55

55:                                               ; preds = %52
  %56 = call ptr @luaL_prepbuffer(ptr noundef nonnull %5) #46
  %57 = load i8, ptr %49, align 1, !tbaa !33
  %58 = load ptr, ptr %5, align 8, !tbaa !392
  br label %59

59:                                               ; preds = %55, %52
  %60 = phi ptr [ %58, %55 ], [ %53, %52 ]
  %61 = phi i8 [ %57, %55 ], [ %50, %52 ]
  %62 = getelementptr inbounds i8, ptr %60, i64 1
  store ptr %62, ptr %5, align 8, !tbaa !392
  store i8 %61, ptr %60, align 1, !tbaa !33
  br label %91

63:                                               ; preds = %47
  %64 = add nuw i64 %48, 1
  %65 = tail call ptr @__ctype_b_loc() #52
  %66 = load ptr, ptr %65, align 8, !tbaa !39
  %67 = getelementptr inbounds i8, ptr %40, i64 %64
  %68 = load i8, ptr %67, align 1, !tbaa !33
  %69 = zext i8 %68 to i64
  %70 = getelementptr inbounds i16, ptr %66, i64 %69
  %71 = load i16, ptr %70, align 2, !tbaa !239
  %72 = and i16 %71, 2048
  %73 = icmp eq i16 %72, 0
  br i1 %73, label %74, label %85

74:                                               ; preds = %63
  %75 = load ptr, ptr %5, align 8, !tbaa !392
  %76 = icmp ult ptr %75, %27
  br i1 %76, label %81, label %77

77:                                               ; preds = %74
  %78 = call ptr @luaL_prepbuffer(ptr noundef nonnull %5) #46
  %79 = load i8, ptr %67, align 1, !tbaa !33
  %80 = load ptr, ptr %5, align 8, !tbaa !392
  br label %81

81:                                               ; preds = %77, %74
  %82 = phi ptr [ %80, %77 ], [ %75, %74 ]
  %83 = phi i8 [ %79, %77 ], [ %68, %74 ]
  %84 = getelementptr inbounds i8, ptr %82, i64 1
  store ptr %84, ptr %5, align 8, !tbaa !392
  store i8 %83, ptr %82, align 1, !tbaa !33
  br label %91

85:                                               ; preds = %63
  %86 = icmp eq i8 %68, 48
  br i1 %86, label %87, label %88

87:                                               ; preds = %85
  call void @luaL_addlstring(ptr noundef nonnull %5, ptr noundef %30, i64 noundef %46) #46
  br label %91

88:                                               ; preds = %85
  %89 = sext i8 %68 to i32
  %90 = add nsw i32 %89, -49
  call fastcc void @push_onecapture(ptr noundef nonnull %4, i32 noundef %90, ptr noundef %30, ptr noundef nonnull %33) #47
  call void @luaL_addvalue(ptr noundef nonnull %5) #46
  br label %91

91:                                               ; preds = %88, %87, %81, %59
  %92 = phi i64 [ %48, %59 ], [ %64, %87 ], [ %64, %88 ], [ %64, %81 ]
  %93 = add i64 %92, 1
  %94 = load i64, ptr %2, align 8, !tbaa !40
  %95 = icmp ult i64 %93, %94
  br i1 %95, label %47, label %96, !llvm.loop !444

96:                                               ; preds = %91, %39
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  br label %115

97:                                               ; preds = %35
  call void @lua_pushvalue(ptr noundef %37, i32 noundef 3) #46
  %98 = call fastcc i32 @push_captures(ptr noundef nonnull %4, ptr noundef %30, ptr noundef nonnull %33) #47
  call void @lua_call(ptr noundef %37, i32 noundef %98, i32 noundef 1) #46
  br label %100

99:                                               ; preds = %35
  call fastcc void @push_onecapture(ptr noundef nonnull %4, i32 noundef 0, ptr noundef %30, ptr noundef nonnull %33) #47
  call void @lua_gettable(ptr noundef %37, i32 noundef 3) #46
  br label %100

100:                                              ; preds = %99, %97, %35
  %101 = call i32 @lua_toboolean(ptr noundef %37, i32 noundef -1) #46
  %102 = icmp eq i32 %101, 0
  br i1 %102, label %103, label %107

103:                                              ; preds = %100
  call void @lua_settop(ptr noundef %37, i32 noundef -2) #46
  %104 = ptrtoint ptr %33 to i64
  %105 = ptrtoint ptr %30 to i64
  %106 = sub i64 %104, %105
  call void @lua_pushlstring(ptr noundef %37, ptr noundef %30, i64 noundef %106) #46
  br label %114

107:                                              ; preds = %100
  %108 = call i32 @lua_isstring(ptr noundef %37, i32 noundef -1) #46
  %109 = icmp eq i32 %108, 0
  br i1 %109, label %110, label %114

110:                                              ; preds = %107
  %111 = call i32 @lua_type(ptr noundef %37, i32 noundef -1) #46
  %112 = call ptr @lua_typename(ptr noundef %37, i32 noundef %111) #46
  %113 = call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %37, ptr noundef nonnull @.str.37.549, ptr noundef %112) #46
  br label %114

114:                                              ; preds = %110, %107, %103
  call void @luaL_addvalue(ptr noundef nonnull %5) #46
  br label %115

115:                                              ; preds = %114, %96
  %116 = icmp ugt ptr %33, %30
  br i1 %116, label %132, label %117

117:                                              ; preds = %115, %32
  %118 = phi i32 [ %36, %115 ], [ %29, %32 ]
  %119 = load ptr, ptr %25, align 8, !tbaa !442
  %120 = icmp ult ptr %30, %119
  br i1 %120, label %121, label %135

121:                                              ; preds = %117
  %122 = load ptr, ptr %5, align 8, !tbaa !392
  %123 = icmp ult ptr %122, %27
  br i1 %123, label %127, label %124

124:                                              ; preds = %121
  %125 = call ptr @luaL_prepbuffer(ptr noundef nonnull %5) #46
  %126 = load ptr, ptr %5, align 8, !tbaa !392
  br label %127

127:                                              ; preds = %124, %121
  %128 = phi ptr [ %126, %124 ], [ %122, %121 ]
  %129 = getelementptr inbounds i8, ptr %30, i64 1
  %130 = load i8, ptr %30, align 1, !tbaa !33
  %131 = getelementptr inbounds i8, ptr %128, i64 1
  store ptr %131, ptr %5, align 8, !tbaa !392
  store i8 %130, ptr %128, align 1, !tbaa !33
  br label %132

132:                                              ; preds = %127, %115
  %133 = phi i32 [ %118, %127 ], [ %36, %115 ]
  %134 = phi ptr [ %129, %127 ], [ %33, %115 ]
  br i1 %14, label %135, label %28

135:                                              ; preds = %132, %117, %28
  %136 = phi i32 [ %29, %28 ], [ %118, %117 ], [ %133, %132 ]
  %137 = phi ptr [ %30, %28 ], [ %30, %117 ], [ %134, %132 ]
  %138 = load ptr, ptr %25, align 8, !tbaa !442
  %139 = ptrtoint ptr %138 to i64
  %140 = ptrtoint ptr %137 to i64
  %141 = sub i64 %139, %140
  call void @luaL_addlstring(ptr noundef nonnull %5, ptr noundef %137, i64 noundef %141) #46
  call void @luaL_pushresult(ptr noundef nonnull %5) #46
  %142 = sext i32 %136 to i64
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %142) #46
  call void @llvm.lifetime.end.p0(i64 8216, ptr nonnull %5) #48
  call void @llvm.lifetime.end.p0(i64 544, ptr nonnull %4) #48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #48
  ret i32 2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_len(ptr noundef %0) #1 {
  %2 = alloca i64, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  %3 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef nonnull %2) #46
  %4 = load i64, ptr %2, align 8, !tbaa !40
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %4) #46
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_lower(ptr noundef %0) #1 {
  %2 = alloca i64, align 8
  %3 = alloca %struct.luaL_Buffer, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  call void @llvm.lifetime.start.p0(i64 8216, ptr nonnull %3) #48
  %4 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef nonnull %2) #46
  call void @luaL_buffinit(ptr noundef %0, ptr noundef nonnull %3) #46
  %5 = load i64, ptr %2, align 8, !tbaa !40
  %6 = icmp eq i64 %5, 0
  br i1 %6, label %30, label %7

7:                                                ; preds = %1
  %8 = getelementptr inbounds %struct.luaL_Buffer, ptr %3, i64 1
  br label %9

9:                                                ; preds = %16, %7
  %10 = phi i64 [ 0, %7 ], [ %27, %16 ]
  %11 = load ptr, ptr %3, align 8, !tbaa !392
  %12 = icmp ult ptr %11, %8
  br i1 %12, label %16, label %13

13:                                               ; preds = %9
  %14 = call ptr @luaL_prepbuffer(ptr noundef nonnull %3) #46
  %15 = load ptr, ptr %3, align 8, !tbaa !392
  br label %16

16:                                               ; preds = %13, %9
  %17 = phi ptr [ %15, %13 ], [ %11, %9 ]
  %18 = tail call ptr @__ctype_tolower_loc() #52
  %19 = load ptr, ptr %18, align 8, !tbaa !39
  %20 = getelementptr inbounds i8, ptr %4, i64 %10
  %21 = load i8, ptr %20, align 1, !tbaa !33
  %22 = zext i8 %21 to i64
  %23 = getelementptr inbounds i32, ptr %19, i64 %22
  %24 = load i32, ptr %23, align 4, !tbaa !65
  %25 = trunc i32 %24 to i8
  %26 = getelementptr inbounds i8, ptr %17, i64 1
  store ptr %26, ptr %3, align 8, !tbaa !392
  store i8 %25, ptr %17, align 1, !tbaa !33
  %27 = add nuw i64 %10, 1
  %28 = load i64, ptr %2, align 8, !tbaa !40
  %29 = icmp ult i64 %27, %28
  br i1 %29, label %9, label %30, !llvm.loop !445

30:                                               ; preds = %16, %1
  call void @luaL_pushresult(ptr noundef nonnull %3) #46
  call void @llvm.lifetime.end.p0(i64 8216, ptr nonnull %3) #48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_match(ptr noundef %0) #1 {
  %2 = tail call fastcc i32 @str_find_aux(ptr noundef %0, i32 noundef 0) #47
  ret i32 %2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_rep(ptr noundef %0) #1 {
  %2 = alloca i64, align 8
  %3 = alloca %struct.luaL_Buffer, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  call void @llvm.lifetime.start.p0(i64 8216, ptr nonnull %3) #48
  %4 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef nonnull %2) #46
  %5 = call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef 2) #46
  %6 = trunc i64 %5 to i32
  call void @luaL_buffinit(ptr noundef %0, ptr noundef nonnull %3) #46
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %13

8:                                                ; preds = %8, %1
  %9 = phi i32 [ %10, %8 ], [ %6, %1 ]
  %10 = add nsw i32 %9, -1
  %11 = load i64, ptr %2, align 8, !tbaa !40
  call void @luaL_addlstring(ptr noundef nonnull %3, ptr noundef %4, i64 noundef %11) #46
  %12 = icmp ugt i32 %9, 1
  br i1 %12, label %8, label %13, !llvm.loop !446

13:                                               ; preds = %8, %1
  call void @luaL_pushresult(ptr noundef nonnull %3) #46
  call void @llvm.lifetime.end.p0(i64 8216, ptr nonnull %3) #48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_reverse(ptr noundef %0) #1 {
  %2 = alloca i64, align 8
  %3 = alloca %struct.luaL_Buffer, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  call void @llvm.lifetime.start.p0(i64 8216, ptr nonnull %3) #48
  %4 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef nonnull %2) #46
  call void @luaL_buffinit(ptr noundef %0, ptr noundef nonnull %3) #46
  %5 = load i64, ptr %2, align 8, !tbaa !40
  %6 = add i64 %5, -1
  store i64 %6, ptr %2, align 8, !tbaa !40
  %7 = icmp eq i64 %5, 0
  br i1 %7, label %27, label %8

8:                                                ; preds = %1
  %9 = getelementptr inbounds %struct.luaL_Buffer, ptr %3, i64 1
  br label %10

10:                                               ; preds = %18, %8
  %11 = phi i64 [ %6, %8 ], [ %25, %18 ]
  %12 = load ptr, ptr %3, align 8, !tbaa !392
  %13 = icmp ult ptr %12, %9
  br i1 %13, label %18, label %14

14:                                               ; preds = %10
  %15 = call ptr @luaL_prepbuffer(ptr noundef nonnull %3) #46
  %16 = load i64, ptr %2, align 8, !tbaa !40
  %17 = load ptr, ptr %3, align 8, !tbaa !392
  br label %18

18:                                               ; preds = %14, %10
  %19 = phi ptr [ %17, %14 ], [ %12, %10 ]
  %20 = phi i64 [ %16, %14 ], [ %11, %10 ]
  %21 = getelementptr inbounds i8, ptr %4, i64 %20
  %22 = load i8, ptr %21, align 1, !tbaa !33
  %23 = getelementptr inbounds i8, ptr %19, i64 1
  store ptr %23, ptr %3, align 8, !tbaa !392
  store i8 %22, ptr %19, align 1, !tbaa !33
  %24 = load i64, ptr %2, align 8, !tbaa !40
  %25 = add i64 %24, -1
  store i64 %25, ptr %2, align 8, !tbaa !40
  %26 = icmp eq i64 %24, 0
  br i1 %26, label %27, label %10, !llvm.loop !447

27:                                               ; preds = %18, %1
  call void @luaL_pushresult(ptr noundef nonnull %3) #46
  call void @llvm.lifetime.end.p0(i64 8216, ptr nonnull %3) #48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_sub(ptr noundef %0) #1 {
  %2 = alloca i64, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  %3 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef nonnull %2) #46
  %4 = call i64 @luaL_checkinteger(ptr noundef %0, i32 noundef 2) #46
  %5 = load i64, ptr %2, align 8, !tbaa !40
  %6 = icmp slt i64 %4, 0
  %7 = add nsw i64 %5, 1
  %8 = select i1 %6, i64 %7, i64 0
  %9 = add nsw i64 %8, %4
  %10 = call i64 @luaL_optinteger(ptr noundef %0, i32 noundef 3, i64 noundef -1) #46
  %11 = load i64, ptr %2, align 8, !tbaa !40
  %12 = icmp slt i64 %10, 0
  %13 = add nsw i64 %11, 1
  %14 = select i1 %12, i64 %13, i64 0
  %15 = add nsw i64 %14, %10
  %16 = call i64 @llvm.smax.i64(i64 %15, i64 0)
  %17 = call i64 @llvm.smax.i64(i64 %9, i64 1)
  %18 = call i64 @llvm.smin.i64(i64 %16, i64 %11)
  %19 = icmp sgt i64 %17, %18
  br i1 %19, label %25, label %20

20:                                               ; preds = %1
  %21 = getelementptr inbounds i8, ptr %3, i64 %17
  %22 = getelementptr inbounds i8, ptr %21, i64 -1
  %23 = sub i64 %18, %17
  %24 = add i64 %23, 1
  call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull %22, i64 noundef %24) #46
  br label %26

25:                                               ; preds = %1
  call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.38.524, i64 noundef 0) #46
  br label %26

26:                                               ; preds = %25, %20
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_upper(ptr noundef %0) #1 {
  %2 = alloca i64, align 8
  %3 = alloca %struct.luaL_Buffer, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  call void @llvm.lifetime.start.p0(i64 8216, ptr nonnull %3) #48
  %4 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef nonnull %2) #46
  call void @luaL_buffinit(ptr noundef %0, ptr noundef nonnull %3) #46
  %5 = load i64, ptr %2, align 8, !tbaa !40
  %6 = icmp eq i64 %5, 0
  br i1 %6, label %30, label %7

7:                                                ; preds = %1
  %8 = getelementptr inbounds %struct.luaL_Buffer, ptr %3, i64 1
  br label %9

9:                                                ; preds = %16, %7
  %10 = phi i64 [ 0, %7 ], [ %27, %16 ]
  %11 = load ptr, ptr %3, align 8, !tbaa !392
  %12 = icmp ult ptr %11, %8
  br i1 %12, label %16, label %13

13:                                               ; preds = %9
  %14 = call ptr @luaL_prepbuffer(ptr noundef nonnull %3) #46
  %15 = load ptr, ptr %3, align 8, !tbaa !392
  br label %16

16:                                               ; preds = %13, %9
  %17 = phi ptr [ %15, %13 ], [ %11, %9 ]
  %18 = tail call ptr @__ctype_toupper_loc() #52
  %19 = load ptr, ptr %18, align 8, !tbaa !39
  %20 = getelementptr inbounds i8, ptr %4, i64 %10
  %21 = load i8, ptr %20, align 1, !tbaa !33
  %22 = zext i8 %21 to i64
  %23 = getelementptr inbounds i32, ptr %19, i64 %22
  %24 = load i32, ptr %23, align 4, !tbaa !65
  %25 = trunc i32 %24 to i8
  %26 = getelementptr inbounds i8, ptr %17, i64 1
  store ptr %26, ptr %3, align 8, !tbaa !392
  store i8 %25, ptr %17, align 1, !tbaa !33
  %27 = add nuw i64 %10, 1
  %28 = load i64, ptr %2, align 8, !tbaa !40
  %29 = icmp ult i64 %27, %28
  br i1 %29, label %9, label %30, !llvm.loop !448

30:                                               ; preds = %16, %1
  call void @luaL_pushresult(ptr noundef nonnull %3) #46
  call void @llvm.lifetime.end.p0(i64 8216, ptr nonnull %3) #48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  ret i32 1
}

; Function Attrs: mustprogress nofree nosync nounwind optsize willreturn memory(none)
declare ptr @__ctype_toupper_loc() local_unnamed_addr #26

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smax.i64(i64, i64) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smin.i64(i64, i64) #12

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @str_find_aux(ptr noundef %0, i32 noundef %1) unnamed_addr #1 {
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca %struct.MatchState, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #48
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #48
  %6 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef nonnull %3) #46
  %7 = call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 2, ptr noundef nonnull %4) #46
  %8 = call i64 @luaL_optinteger(ptr noundef %0, i32 noundef 3, i64 noundef 1) #46
  %9 = load i64, ptr %3, align 8
  %10 = icmp slt i64 %8, 0
  %11 = add nsw i64 %9, 1
  %12 = select i1 %10, i64 %11, i64 0
  %13 = add nsw i64 %12, %8
  %14 = call i64 @llvm.smax.i64(i64 %13, i64 0)
  %15 = add nsw i64 %14, -1
  %16 = call i64 @llvm.umin.i64(i64 %15, i64 %9)
  %17 = icmp sgt i64 %13, 0
  %18 = select i1 %17, i64 %16, i64 0
  %19 = icmp eq i32 %1, 0
  br i1 %19, label %69, label %20

20:                                               ; preds = %2
  %21 = call i32 @lua_toboolean(ptr noundef %0, i32 noundef 4) #46
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %23, label %28

23:                                               ; preds = %20
  %24 = call ptr @strpbrk(ptr noundef %7, ptr noundef nonnull @.str.19.539) #49
  %25 = icmp eq ptr %24, null
  br i1 %25, label %28, label %26

26:                                               ; preds = %23
  %27 = load i64, ptr %3, align 8, !tbaa !40
  br label %69

28:                                               ; preds = %23, %20
  %29 = getelementptr inbounds i8, ptr %6, i64 %18
  %30 = load i64, ptr %3, align 8, !tbaa !40
  %31 = sub i64 %30, %18
  %32 = load i64, ptr %4, align 8, !tbaa !40
  %33 = icmp eq i64 %32, 0
  br i1 %33, label %59, label %34

34:                                               ; preds = %28
  %35 = icmp ugt i64 %32, %31
  br i1 %35, label %103, label %36

36:                                               ; preds = %34
  %37 = add i64 %32, -1
  %38 = sub i64 %31, %37
  %39 = icmp eq i64 %38, 0
  br i1 %39, label %103, label %40

40:                                               ; preds = %36
  %41 = load i8, ptr %7, align 1, !tbaa !33
  %42 = sext i8 %41 to i32
  %43 = getelementptr inbounds i8, ptr %7, i64 1
  br label %44

44:                                               ; preds = %53, %40
  %45 = phi i64 [ %38, %40 ], [ %57, %53 ]
  %46 = phi ptr [ %29, %40 ], [ %50, %53 ]
  %47 = call ptr @memchr(ptr noundef %46, i32 noundef %42, i64 noundef %45) #49
  %48 = icmp eq ptr %47, null
  br i1 %48, label %103, label %49

49:                                               ; preds = %44
  %50 = getelementptr inbounds i8, ptr %47, i64 1
  %51 = call i32 @bcmp(ptr nonnull %50, ptr nonnull %43, i64 %37)
  %52 = icmp eq i32 %51, 0
  br i1 %52, label %61, label %53

53:                                               ; preds = %49
  %54 = ptrtoint ptr %50 to i64
  %55 = ptrtoint ptr %46 to i64
  %56 = add i64 %45, %55
  %57 = sub i64 %56, %54
  %58 = icmp eq i64 %57, 0
  br i1 %58, label %103, label %44, !llvm.loop !449

59:                                               ; preds = %28
  %60 = icmp eq ptr %6, null
  br i1 %60, label %103, label %61

61:                                               ; preds = %59, %49
  %62 = phi ptr [ %29, %59 ], [ %47, %49 ]
  %63 = ptrtoint ptr %62 to i64
  %64 = ptrtoint ptr %6 to i64
  %65 = sub i64 %63, %64
  %66 = add nsw i64 %65, 1
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %66) #46
  %67 = load i64, ptr %4, align 8, !tbaa !40
  %68 = add i64 %65, %67
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %68) #46
  br label %106

69:                                               ; preds = %26, %2
  %70 = phi i64 [ %27, %26 ], [ %9, %2 ]
  call void @llvm.lifetime.start.p0(i64 544, ptr nonnull %5) #48
  %71 = load i8, ptr %7, align 1, !tbaa !33
  %72 = icmp ne i8 %71, 94
  %73 = xor i1 %72, true
  %74 = zext i1 %73 to i64
  %75 = getelementptr inbounds i8, ptr %7, i64 %74
  %76 = getelementptr inbounds i8, ptr %6, i64 %18
  %77 = getelementptr inbounds %struct.MatchState, ptr %5, i64 0, i32 2
  store ptr %0, ptr %77, align 8, !tbaa !439
  store ptr %6, ptr %5, align 8, !tbaa !441
  %78 = getelementptr inbounds i8, ptr %6, i64 %70
  %79 = getelementptr inbounds %struct.MatchState, ptr %5, i64 0, i32 1
  store ptr %78, ptr %79, align 8, !tbaa !442
  %80 = getelementptr inbounds %struct.MatchState, ptr %5, i64 0, i32 3
  br label %81

81:                                               ; preds = %97, %69
  %82 = phi ptr [ %76, %69 ], [ %98, %97 ]
  store i32 0, ptr %80, align 8, !tbaa !443
  %83 = call fastcc ptr @match(ptr noundef nonnull %5, ptr noundef %82, ptr noundef nonnull %75) #47
  %84 = icmp eq ptr %83, null
  br i1 %84, label %97, label %85

85:                                               ; preds = %81
  %.lcssa2 = phi ptr [ %82, %81 ]
  %.lcssa = phi ptr [ %83, %81 ]
  br i1 %19, label %95, label %86

86:                                               ; preds = %85
  %87 = ptrtoint ptr %.lcssa2 to i64
  %88 = ptrtoint ptr %6 to i64
  %89 = sub i64 %87, %88
  %90 = add i64 %89, 1
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %90) #46
  %91 = ptrtoint ptr %.lcssa to i64
  %92 = sub i64 %91, %88
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %92) #46
  %93 = call fastcc i32 @push_captures(ptr noundef nonnull %5, ptr noundef null, ptr noundef null) #47
  %94 = add nsw i32 %93, 2
  br label %104

95:                                               ; preds = %85
  %96 = call fastcc i32 @push_captures(ptr noundef nonnull %5, ptr noundef %.lcssa2, ptr noundef nonnull %.lcssa) #47
  br label %104

97:                                               ; preds = %81
  %98 = getelementptr inbounds i8, ptr %82, i64 1
  %99 = load ptr, ptr %79, align 8, !tbaa !442
  %100 = icmp ult ptr %82, %99
  %101 = and i1 %72, %100
  br i1 %101, label %81, label %102, !llvm.loop !450

102:                                              ; preds = %97
  call void @llvm.lifetime.end.p0(i64 544, ptr nonnull %5) #48
  br label %103

103:                                              ; preds = %102, %59, %53, %44, %36, %34
  call void @lua_pushnil(ptr noundef %0) #46
  br label %106

104:                                              ; preds = %95, %86
  %105 = phi i32 [ %96, %95 ], [ %94, %86 ]
  call void @llvm.lifetime.end.p0(i64 544, ptr nonnull %5) #48
  br label %106

106:                                              ; preds = %104, %103, %61
  %107 = phi i32 [ 1, %103 ], [ 2, %61 ], [ %105, %104 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #48
  ret i32 %107
}

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(argmem: read)
declare ptr @strpbrk(ptr noundef, ptr nocapture noundef) local_unnamed_addr #10

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(argmem: read)
declare ptr @memchr(ptr noundef, i32 noundef, i64 noundef) local_unnamed_addr #10

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @match(ptr nocapture noundef %0, ptr noundef %1, ptr noundef %2) unnamed_addr #1 {
  %4 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 2
  %5 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 1
  %6 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 3
  br label %7

7:                                                ; preds = %108, %3
  %8 = phi ptr [ %2, %3 ], [ %109, %108 ]
  %9 = phi ptr [ %1, %3 ], [ %110, %108 ]
  %10 = getelementptr inbounds i8, ptr %9, i64 -1
  %11 = getelementptr inbounds i8, ptr %9, i64 1
  br label %12

12:                                               ; preds = %206, %7
  %13 = phi ptr [ %207, %206 ], [ %8, %7 ]
  br label %14

14:                                               ; preds = %130, %12
  %15 = phi ptr [ %119, %130 ], [ %13, %12 ]
  %16 = load i8, ptr %15, align 1, !tbaa !33
  %17 = sext i8 %16 to i32
  switch i32 %17, label %186 [
    i32 40, label %18
    i32 41, label %27
    i32 37, label %57
    i32 0, label %230
    i32 36, label %178
  ]

18:                                               ; preds = %14
  %.lcssa22 = phi ptr [ %9, %14 ]
  %.lcssa4 = phi ptr [ %15, %14 ]
  %19 = getelementptr inbounds i8, ptr %.lcssa4, i64 1
  %20 = load i8, ptr %19, align 1, !tbaa !33
  %21 = icmp eq i8 %20, 41
  br i1 %21, label %22, label %25

22:                                               ; preds = %18
  %23 = getelementptr inbounds i8, ptr %.lcssa4, i64 2
  %24 = tail call fastcc ptr @start_capture(ptr noundef %0, ptr noundef %.lcssa22, ptr noundef nonnull %23, i32 noundef -2) #47
  br label %230

25:                                               ; preds = %18
  %26 = tail call fastcc ptr @start_capture(ptr noundef %0, ptr noundef %.lcssa22, ptr noundef nonnull %19, i32 noundef -1) #47
  br label %230

27:                                               ; preds = %14
  %.lcssa23 = phi ptr [ %9, %14 ]
  %.lcssa5 = phi ptr [ %15, %14 ]
  %28 = getelementptr inbounds i8, ptr %.lcssa5, i64 1
  %29 = load i32, ptr %6, align 8, !tbaa !443
  %30 = zext i32 %29 to i64
  br label %31

31:                                               ; preds = %35, %27
  %32 = phi i64 [ %36, %35 ], [ %30, %27 ]
  %33 = trunc i64 %32 to i32
  %34 = icmp sgt i32 %33, 0
  br i1 %34, label %35, label %40

35:                                               ; preds = %31
  %36 = add nsw i64 %32, -1
  %37 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 4, i64 %36, i32 1
  %38 = load i64, ptr %37, align 8, !tbaa !451
  %39 = icmp eq i64 %38, -1
  br i1 %39, label %43, label %31, !llvm.loop !453

40:                                               ; preds = %31
  %41 = load ptr, ptr %4, align 8, !tbaa !439
  %42 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %41, ptr noundef nonnull @.str.22.543) #46
  br label %45

43:                                               ; preds = %35
  %.lcssa = phi i64 [ %36, %35 ]
  %44 = trunc i64 %.lcssa to i32
  br label %45

45:                                               ; preds = %43, %40
  %46 = phi i32 [ %42, %40 ], [ %44, %43 ]
  %47 = sext i32 %46 to i64
  %48 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 4, i64 %47
  %49 = load ptr, ptr %48, align 8, !tbaa !454
  %50 = ptrtoint ptr %.lcssa23 to i64
  %51 = ptrtoint ptr %49 to i64
  %52 = sub i64 %50, %51
  %53 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 4, i64 %47, i32 1
  store i64 %52, ptr %53, align 8, !tbaa !451
  %54 = tail call fastcc ptr @match(ptr noundef nonnull %0, ptr noundef %.lcssa23, ptr noundef nonnull %28) #47
  %55 = icmp eq ptr %54, null
  br i1 %55, label %56, label %230

56:                                               ; preds = %45
  store i64 -1, ptr %53, align 8, !tbaa !451
  br label %230

57:                                               ; preds = %14
  %58 = getelementptr inbounds i8, ptr %15, i64 1
  %59 = load i8, ptr %58, align 1, !tbaa !33
  %60 = sext i8 %59 to i32
  switch i32 %60, label %135 [
    i32 98, label %61
    i32 102, label %111
  ]

61:                                               ; preds = %57
  %.lcssa9 = phi ptr [ %15, %57 ]
  %62 = getelementptr inbounds i8, ptr %.lcssa9, i64 2
  %63 = ptrtoint ptr %9 to i64
  %64 = load i8, ptr %62, align 1, !tbaa !33
  %65 = icmp eq i8 %64, 0
  br i1 %65, label %70, label %66

66:                                               ; preds = %61
  %67 = getelementptr inbounds i8, ptr %.lcssa9, i64 3
  %68 = load i8, ptr %67, align 1, !tbaa !33
  %69 = icmp eq i8 %68, 0
  br i1 %69, label %70, label %74

70:                                               ; preds = %66, %61
  %71 = load ptr, ptr %4, align 8, !tbaa !439
  %72 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %71, ptr noundef nonnull @.str.23.544) #46
  %73 = load i8, ptr %62, align 1, !tbaa !33
  br label %74

74:                                               ; preds = %70, %66
  %75 = phi i8 [ %73, %70 ], [ %64, %66 ]
  %76 = load i8, ptr %9, align 1, !tbaa !33
  %77 = icmp eq i8 %76, %75
  br i1 %77, label %78, label %230

78:                                               ; preds = %74
  %79 = getelementptr inbounds i8, ptr %.lcssa9, i64 3
  %80 = load i8, ptr %79, align 1, !tbaa !33
  %81 = load ptr, ptr %5, align 8, !tbaa !442
  %82 = getelementptr inbounds i8, ptr %9, i64 1
  %83 = icmp ult ptr %82, %81
  br i1 %83, label %84, label %230

84:                                               ; preds = %78
  %85 = ptrtoint ptr %81 to i64
  %86 = sub i64 %85, %63
  %87 = getelementptr i8, ptr %9, i64 %86
  br label %88

88:                                               ; preds = %101, %84
  %89 = phi ptr [ %103, %101 ], [ %82, %84 ]
  %90 = phi i32 [ %102, %101 ], [ 1, %84 ]
  %91 = phi ptr [ %89, %101 ], [ %9, %84 ]
  %92 = load i8, ptr %89, align 1, !tbaa !33
  %93 = icmp eq i8 %92, %80
  br i1 %93, label %94, label %97

94:                                               ; preds = %88
  %95 = add nsw i32 %90, -1
  %96 = icmp eq i32 %95, 0
  br i1 %96, label %105, label %101

97:                                               ; preds = %88
  %98 = icmp eq i8 %92, %75
  %99 = zext i1 %98 to i32
  %100 = add nsw i32 %90, %99
  br label %101

101:                                              ; preds = %97, %94
  %102 = phi i32 [ %95, %94 ], [ %100, %97 ]
  %103 = getelementptr inbounds i8, ptr %89, i64 1
  %104 = icmp eq ptr %103, %87
  br i1 %104, label %230, label %88, !llvm.loop !455

105:                                              ; preds = %94
  %.lcssa21 = phi ptr [ %91, %94 ]
  %106 = getelementptr inbounds i8, ptr %.lcssa21, i64 2
  %107 = getelementptr inbounds i8, ptr %.lcssa9, i64 4
  br label %108

108:                                              ; preds = %228, %175, %105
  %109 = phi ptr [ %.lcssa13, %228 ], [ %177, %175 ], [ %107, %105 ]
  %110 = phi ptr [ %229, %228 ], [ %176, %175 ], [ %106, %105 ]
  br label %7

111:                                              ; preds = %57
  %112 = getelementptr inbounds i8, ptr %15, i64 2
  %113 = load i8, ptr %112, align 1, !tbaa !33
  %114 = icmp eq i8 %113, 91
  br i1 %114, label %118, label %115

115:                                              ; preds = %111
  %116 = load ptr, ptr %4, align 8, !tbaa !439
  %117 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %116, ptr noundef nonnull @.str.20.545) #46
  br label %118

118:                                              ; preds = %115, %111
  %119 = tail call fastcc ptr @classend(ptr noundef %0, ptr noundef nonnull %112) #47
  %120 = load ptr, ptr %0, align 8, !tbaa !441
  %121 = icmp eq ptr %9, %120
  br i1 %121, label %124, label %122

122:                                              ; preds = %118
  %123 = load i8, ptr %10, align 1, !tbaa !33
  br label %124

124:                                              ; preds = %122, %118
  %125 = phi i8 [ %123, %122 ], [ 0, %118 ]
  %126 = zext i8 %125 to i32
  %127 = getelementptr inbounds i8, ptr %119, i64 -1
  %128 = tail call fastcc i32 @matchbracketclass(i32 noundef %126, ptr noundef nonnull %112, ptr noundef nonnull %127) #47, !range !75
  %129 = icmp eq i32 %128, 0
  br i1 %129, label %130, label %230

130:                                              ; preds = %124
  %131 = load i8, ptr %9, align 1, !tbaa !33
  %132 = zext i8 %131 to i32
  %133 = tail call fastcc i32 @matchbracketclass(i32 noundef %132, ptr noundef nonnull %112, ptr noundef nonnull %127) #47, !range !75
  %134 = icmp eq i32 %133, 0
  br i1 %134, label %230, label %14

135:                                              ; preds = %57
  %.lcssa8 = phi ptr [ %15, %57 ]
  %.lcssa1 = phi i8 [ %59, %57 ]
  %136 = tail call ptr @__ctype_b_loc() #52
  %137 = load ptr, ptr %136, align 8, !tbaa !39
  %138 = zext i8 %.lcssa1 to i64
  %139 = getelementptr inbounds i16, ptr %137, i64 %138
  %140 = load i16, ptr %139, align 2, !tbaa !239
  %141 = and i16 %140, 2048
  %142 = icmp eq i16 %141, 0
  br i1 %142, label %186, label %143

143:                                              ; preds = %135
  %.lcssa8.lcssa = phi ptr [ %.lcssa8, %135 ]
  %.lcssa1.lcssa = phi i8 [ %.lcssa1, %135 ]
  %144 = zext i8 %.lcssa1.lcssa to i32
  %145 = add nsw i32 %144, -49
  %146 = icmp ult i8 %.lcssa1.lcssa, 49
  br i1 %146, label %155, label %147

147:                                              ; preds = %143
  %148 = load i32, ptr %6, align 8, !tbaa !443
  %149 = icmp slt i32 %145, %148
  br i1 %149, label %150, label %155

150:                                              ; preds = %147
  %151 = zext i32 %145 to i64
  %152 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 4, i64 %151, i32 1
  %153 = load i64, ptr %152, align 8, !tbaa !451
  %154 = icmp eq i64 %153, -1
  br i1 %154, label %155, label %158

155:                                              ; preds = %150, %147, %143
  %156 = load ptr, ptr %4, align 8, !tbaa !439
  %157 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %156, ptr noundef nonnull @.str.26.541) #46
  br label %158

158:                                              ; preds = %155, %150
  %159 = phi i32 [ %157, %155 ], [ %145, %150 ]
  %160 = sext i32 %159 to i64
  %161 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 4, i64 %160, i32 1
  %162 = load i64, ptr %161, align 8, !tbaa !451
  %163 = load ptr, ptr %5, align 8, !tbaa !442
  %164 = ptrtoint ptr %163 to i64
  %165 = ptrtoint ptr %9 to i64
  %166 = sub i64 %164, %165
  %167 = icmp ult i64 %166, %162
  br i1 %167, label %230, label %168

168:                                              ; preds = %158
  %169 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 4, i64 %160
  %170 = load ptr, ptr %169, align 8, !tbaa !454
  %171 = tail call i32 @bcmp(ptr %170, ptr %9, i64 %162)
  %172 = icmp ne i32 %171, 0
  %173 = icmp eq ptr %9, null
  %174 = select i1 %172, i1 true, i1 %173
  br i1 %174, label %230, label %175

175:                                              ; preds = %168
  %176 = getelementptr inbounds i8, ptr %9, i64 %162
  %177 = getelementptr inbounds i8, ptr %.lcssa8.lcssa, i64 2
  br label %108

178:                                              ; preds = %14
  %.lcssa7 = phi ptr [ %15, %14 ]
  %179 = getelementptr inbounds i8, ptr %.lcssa7, i64 1
  %180 = load i8, ptr %179, align 1, !tbaa !33
  %181 = icmp eq i8 %180, 0
  br i1 %181, label %182, label %186

182:                                              ; preds = %178
  %.lcssa25 = phi ptr [ %9, %178 ]
  %.lcssa7.lcssa = phi ptr [ %.lcssa7, %178 ]
  %183 = load ptr, ptr %5, align 8, !tbaa !442
  %184 = icmp eq ptr %.lcssa25, %183
  %185 = select i1 %184, ptr %.lcssa25, ptr null
  br label %230

186:                                              ; preds = %178, %135, %14
  %.lcssa3 = phi ptr [ %.lcssa7, %178 ], [ %.lcssa8, %135 ], [ %15, %14 ]
  %187 = tail call fastcc ptr @classend(ptr noundef %0, ptr noundef nonnull %.lcssa3) #47
  %188 = load ptr, ptr %5, align 8, !tbaa !442
  %189 = icmp ult ptr %9, %188
  br i1 %189, label %190, label %195

190:                                              ; preds = %186
  %191 = load i8, ptr %9, align 1, !tbaa !33
  %192 = zext i8 %191 to i32
  %193 = tail call fastcc i32 @singlematch(i32 noundef %192, ptr noundef nonnull %.lcssa3, ptr noundef nonnull %187) #47, !range !456
  %194 = icmp ne i32 %193, 0
  br label %195

195:                                              ; preds = %190, %186
  %196 = phi i1 [ false, %186 ], [ %194, %190 ]
  %197 = load i8, ptr %187, align 1, !tbaa !33
  %198 = sext i8 %197 to i32
  switch i32 %198, label %227 [
    i32 63, label %201
    i32 42, label %208
    i32 43, label %210
    i32 45, label %199
  ]

199:                                              ; preds = %195
  %.lcssa28 = phi ptr [ %9, %195 ]
  %.lcssa16 = phi ptr [ %187, %195 ]
  %.lcssa3.lcssa12 = phi ptr [ %.lcssa3, %195 ]
  %200 = getelementptr inbounds i8, ptr %.lcssa16, i64 1
  br label %214

201:                                              ; preds = %195
  br i1 %196, label %202, label %206

202:                                              ; preds = %201
  %203 = getelementptr inbounds i8, ptr %187, i64 1
  %204 = tail call fastcc ptr @match(ptr noundef nonnull %0, ptr noundef nonnull %11, ptr noundef nonnull %203) #47
  %205 = icmp eq ptr %204, null
  br i1 %205, label %206, label %230

206:                                              ; preds = %202, %201
  %207 = getelementptr inbounds i8, ptr %187, i64 1
  br label %12

208:                                              ; preds = %195
  %.lcssa26 = phi ptr [ %9, %195 ]
  %.lcssa14 = phi ptr [ %187, %195 ]
  %.lcssa3.lcssa10 = phi ptr [ %.lcssa3, %195 ]
  %209 = tail call fastcc ptr @max_expand(ptr noundef nonnull %0, ptr noundef %.lcssa26, ptr noundef nonnull %.lcssa3.lcssa10, ptr noundef nonnull %.lcssa14) #47
  br label %230

210:                                              ; preds = %195
  %.lcssa27 = phi ptr [ %9, %195 ]
  %.lcssa19 = phi i1 [ %196, %195 ]
  %.lcssa15 = phi ptr [ %187, %195 ]
  %.lcssa3.lcssa11 = phi ptr [ %.lcssa3, %195 ]
  br i1 %.lcssa19, label %211, label %230

211:                                              ; preds = %210
  %212 = getelementptr inbounds i8, ptr %.lcssa27, i64 1
  %213 = tail call fastcc ptr @max_expand(ptr noundef nonnull %0, ptr noundef nonnull %212, ptr noundef nonnull %.lcssa3.lcssa11, ptr noundef nonnull %.lcssa15) #47
  br label %230

214:                                              ; preds = %221, %199
  %215 = phi ptr [ %226, %221 ], [ %.lcssa28, %199 ]
  %216 = tail call fastcc ptr @match(ptr noundef nonnull %0, ptr noundef %215, ptr noundef nonnull %200) #47
  %217 = icmp eq ptr %216, null
  br i1 %217, label %218, label %230

218:                                              ; preds = %214
  %219 = load ptr, ptr %5, align 8, !tbaa !442
  %220 = icmp ult ptr %215, %219
  br i1 %220, label %221, label %230

221:                                              ; preds = %218
  %222 = load i8, ptr %215, align 1, !tbaa !33
  %223 = zext i8 %222 to i32
  %224 = tail call fastcc i32 @singlematch(i32 noundef %223, ptr noundef nonnull %.lcssa3.lcssa12, ptr noundef nonnull %.lcssa16) #47, !range !456
  %225 = icmp eq i32 %224, 0
  %226 = getelementptr inbounds i8, ptr %215, i64 1
  br i1 %225, label %230, label %214

227:                                              ; preds = %195
  %.lcssa17 = phi i1 [ %196, %195 ]
  %.lcssa13 = phi ptr [ %187, %195 ]
  %.lcssa3.lcssa = phi ptr [ %.lcssa3, %195 ]
  br i1 %.lcssa17, label %228, label %230

228:                                              ; preds = %227
  %229 = getelementptr inbounds i8, ptr %9, i64 1
  br label %108

230:                                              ; preds = %227, %221, %218, %214, %211, %210, %208, %202, %182, %168, %158, %130, %124, %101, %78, %74, %56, %45, %25, %22, %14
  %231 = phi ptr [ %185, %182 ], [ %24, %22 ], [ %26, %25 ], [ %54, %45 ], [ null, %56 ], [ null, %210 ], [ %213, %211 ], [ %209, %208 ], [ null, %218 ], [ null, %221 ], [ %216, %214 ], [ null, %101 ], [ %9, %14 ], [ null, %130 ], [ null, %124 ], [ %204, %202 ], [ null, %227 ], [ null, %168 ], [ null, %158 ], [ null, %78 ], [ null, %74 ]
  ret ptr %231
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @push_captures(ptr nocapture noundef readonly %0, ptr noundef %1, ptr noundef %2) unnamed_addr #1 {
  %4 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 3
  %5 = load i32, ptr %4, align 8, !tbaa !443
  %6 = icmp eq i32 %5, 0
  %7 = icmp ne ptr %1, null
  %8 = and i1 %7, %6
  %9 = select i1 %8, i32 1, i32 %5
  %10 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 2
  %11 = load ptr, ptr %10, align 8, !tbaa !439
  tail call void @luaL_checkstack(ptr noundef %11, i32 noundef %9, ptr noundef nonnull @.str.21.540) #46
  %12 = icmp sgt i32 %9, 0
  br i1 %12, label %13, label %17

13:                                               ; preds = %13, %3
  %14 = phi i32 [ %15, %13 ], [ 0, %3 ]
  tail call fastcc void @push_onecapture(ptr noundef %0, i32 noundef %14, ptr noundef %1, ptr noundef %2) #47
  %15 = add nuw nsw i32 %14, 1
  %16 = icmp eq i32 %15, %9
  br i1 %16, label %17, label %13, !llvm.loop !457

17:                                               ; preds = %13, %3
  ret i32 %9
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @push_onecapture(ptr nocapture noundef readonly %0, i32 noundef %1, ptr noundef %2, ptr noundef %3) unnamed_addr #1 {
  %5 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 3
  %6 = load i32, ptr %5, align 8, !tbaa !443
  %7 = icmp sgt i32 %6, %1
  br i1 %7, label %18, label %8

8:                                                ; preds = %4
  %9 = icmp eq i32 %1, 0
  %10 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 2
  %11 = load ptr, ptr %10, align 8, !tbaa !439
  br i1 %9, label %12, label %16

12:                                               ; preds = %8
  %13 = ptrtoint ptr %3 to i64
  %14 = ptrtoint ptr %2 to i64
  %15 = sub i64 %13, %14
  tail call void @lua_pushlstring(ptr noundef %11, ptr noundef %2, i64 noundef %15) #46
  br label %40

16:                                               ; preds = %8
  %17 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %11, ptr noundef nonnull @.str.26.541) #46
  br label %40

18:                                               ; preds = %4
  %19 = sext i32 %1 to i64
  %20 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 4, i64 %19
  %21 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 4, i64 %19, i32 1
  %22 = load i64, ptr %21, align 8, !tbaa !451
  switch i64 %22, label %36 [
    i64 -1, label %23
    i64 -2, label %27
  ]

23:                                               ; preds = %18
  %24 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 2
  %25 = load ptr, ptr %24, align 8, !tbaa !439
  %26 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %25, ptr noundef nonnull @.str.27.542) #46
  br label %36

27:                                               ; preds = %18
  %28 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 2
  %29 = load ptr, ptr %28, align 8, !tbaa !439
  %30 = load ptr, ptr %20, align 8, !tbaa !454
  %31 = load ptr, ptr %0, align 8, !tbaa !441
  %32 = ptrtoint ptr %30 to i64
  %33 = ptrtoint ptr %31 to i64
  %34 = add i64 %32, 1
  %35 = sub i64 %34, %33
  tail call void @lua_pushinteger(ptr noundef %29, i64 noundef %35) #46
  br label %40

36:                                               ; preds = %23, %18
  %37 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 2
  %38 = load ptr, ptr %37, align 8, !tbaa !439
  %39 = load ptr, ptr %20, align 8, !tbaa !454
  tail call void @lua_pushlstring(ptr noundef %38, ptr noundef %39, i64 noundef %22) #46
  br label %40

40:                                               ; preds = %36, %27, %16, %12
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @start_capture(ptr nocapture noundef %0, ptr noundef %1, ptr noundef %2, i32 noundef %3) unnamed_addr #1 {
  %5 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 3
  %6 = load i32, ptr %5, align 8, !tbaa !443
  %7 = icmp sgt i32 %6, 31
  br i1 %7, label %8, label %12

8:                                                ; preds = %4
  %9 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 2
  %10 = load ptr, ptr %9, align 8, !tbaa !439
  %11 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %10, ptr noundef nonnull @.str.21.540) #46
  br label %12

12:                                               ; preds = %8, %4
  %13 = sext i32 %6 to i64
  %14 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 4, i64 %13
  store ptr %1, ptr %14, align 8, !tbaa !454
  %15 = sext i32 %3 to i64
  %16 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 4, i64 %13, i32 1
  store i64 %15, ptr %16, align 8, !tbaa !451
  %17 = add nsw i32 %6, 1
  store i32 %17, ptr %5, align 8, !tbaa !443
  %18 = tail call fastcc ptr @match(ptr noundef nonnull %0, ptr noundef %1, ptr noundef %2) #47
  %19 = icmp eq ptr %18, null
  br i1 %19, label %20, label %23

20:                                               ; preds = %12
  %21 = load i32, ptr %5, align 8, !tbaa !443
  %22 = add nsw i32 %21, -1
  store i32 %22, ptr %5, align 8, !tbaa !443
  br label %23

23:                                               ; preds = %20, %12
  ret ptr %18
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc nonnull ptr @classend(ptr nocapture noundef readonly %0, ptr noundef readonly %1) unnamed_addr #1 {
  %3 = getelementptr inbounds i8, ptr %1, i64 1
  %4 = load i8, ptr %1, align 1, !tbaa !33
  %5 = sext i8 %4 to i32
  switch i32 %5, label %45 [
    i32 37, label %6
    i32 91, label %15
  ]

6:                                                ; preds = %2
  %7 = load i8, ptr %3, align 1, !tbaa !33
  %8 = icmp eq i8 %7, 0
  br i1 %8, label %9, label %13

9:                                                ; preds = %6
  %10 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 2
  %11 = load ptr, ptr %10, align 8, !tbaa !439
  %12 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %11, ptr noundef nonnull @.str.24.546) #46
  br label %13

13:                                               ; preds = %9, %6
  %14 = getelementptr inbounds i8, ptr %1, i64 2
  br label %45

15:                                               ; preds = %2
  %16 = load i8, ptr %3, align 1, !tbaa !33
  %17 = icmp eq i8 %16, 94
  %18 = getelementptr inbounds i8, ptr %1, i64 2
  %19 = select i1 %17, ptr %18, ptr %3
  %20 = load i8, ptr %19, align 1, !tbaa !33
  %21 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 2
  br label %22

22:                                               ; preds = %39, %15
  %23 = phi i8 [ %41, %39 ], [ %20, %15 ]
  %24 = phi ptr [ %40, %39 ], [ %19, %15 ]
  %25 = icmp eq i8 %23, 0
  br i1 %25, label %26, label %30

26:                                               ; preds = %22
  %27 = load ptr, ptr %21, align 8, !tbaa !439
  %28 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %27, ptr noundef nonnull @.str.25.547) #46
  %29 = load i8, ptr %24, align 1, !tbaa !33
  br label %30

30:                                               ; preds = %26, %22
  %31 = phi i8 [ %29, %26 ], [ %23, %22 ]
  %32 = getelementptr inbounds i8, ptr %24, i64 1
  %33 = icmp eq i8 %31, 37
  br i1 %33, label %34, label %39

34:                                               ; preds = %30
  %35 = load i8, ptr %32, align 1, !tbaa !33
  %36 = icmp eq i8 %35, 0
  %37 = getelementptr inbounds i8, ptr %24, i64 2
  %38 = select i1 %36, ptr %32, ptr %37
  br label %39

39:                                               ; preds = %34, %30
  %40 = phi ptr [ %32, %30 ], [ %38, %34 ]
  %41 = load i8, ptr %40, align 1, !tbaa !33
  %42 = icmp eq i8 %41, 93
  br i1 %42, label %43, label %22, !llvm.loop !458

43:                                               ; preds = %39
  %.lcssa = phi ptr [ %40, %39 ]
  %44 = getelementptr inbounds i8, ptr %.lcssa, i64 1
  br label %45

45:                                               ; preds = %43, %13, %2
  %46 = phi ptr [ %44, %43 ], [ %14, %13 ], [ %3, %2 ]
  ret ptr %46
}

; Function Attrs: nofree nounwind optsize memory(read) uwtable
define internal fastcc i32 @matchbracketclass(i32 noundef %0, ptr noundef readonly %1, ptr noundef readnone %2) unnamed_addr #36 {
  %4 = getelementptr inbounds i8, ptr %1, i64 1
  %5 = load i8, ptr %4, align 1, !tbaa !33
  %6 = icmp eq i8 %5, 94
  %7 = select i1 %6, ptr %4, ptr %1
  %8 = xor i1 %6, true
  %9 = getelementptr inbounds i8, ptr %7, i64 1
  %10 = icmp ult ptr %9, %2
  br i1 %10, label %11, label %41

11:                                               ; preds = %37, %3
  %12 = phi ptr [ %39, %37 ], [ %9, %3 ]
  %13 = phi ptr [ %38, %37 ], [ %7, %3 ]
  %14 = load i8, ptr %12, align 1, !tbaa !33
  %15 = icmp eq i8 %14, 37
  %16 = getelementptr inbounds i8, ptr %13, i64 2
  %17 = load i8, ptr %16, align 1, !tbaa !33
  br i1 %15, label %18, label %22

18:                                               ; preds = %11
  %19 = zext i8 %17 to i32
  %20 = tail call fastcc i32 @match_class(i32 noundef %0, i32 noundef %19) #47, !range !456
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %37, label %41

22:                                               ; preds = %11
  %23 = icmp eq i8 %17, 45
  br i1 %23, label %24, label %34

24:                                               ; preds = %22
  %25 = getelementptr inbounds i8, ptr %13, i64 3
  %26 = icmp ult ptr %25, %2
  br i1 %26, label %27, label %34

27:                                               ; preds = %24
  %28 = zext i8 %14 to i32
  %29 = icmp sgt i32 %28, %0
  br i1 %29, label %37, label %30

30:                                               ; preds = %27
  %31 = load i8, ptr %25, align 1, !tbaa !33
  %32 = zext i8 %31 to i32
  %33 = icmp slt i32 %32, %0
  br i1 %33, label %37, label %41

34:                                               ; preds = %24, %22
  %35 = zext i8 %14 to i32
  %36 = icmp eq i32 %35, %0
  br i1 %36, label %41, label %37

37:                                               ; preds = %34, %30, %27, %18
  %38 = phi ptr [ %16, %18 ], [ %25, %30 ], [ %25, %27 ], [ %12, %34 ]
  %39 = getelementptr inbounds i8, ptr %38, i64 1
  %40 = icmp ult ptr %39, %2
  br i1 %40, label %11, label %41, !llvm.loop !459

41:                                               ; preds = %37, %34, %30, %18, %3
  %42 = phi i1 [ %6, %3 ], [ %6, %37 ], [ %8, %34 ], [ %8, %30 ], [ %8, %18 ]
  %43 = zext i1 %42 to i32
  ret i32 %43
}

; Function Attrs: nofree nounwind optsize memory(read) uwtable
define internal fastcc i32 @singlematch(i32 noundef %0, ptr noundef readonly %1, ptr noundef readnone %2) unnamed_addr #36 {
  %4 = load i8, ptr %1, align 1, !tbaa !33
  %5 = sext i8 %4 to i32
  switch i32 %5, label %14 [
    i32 46, label %18
    i32 37, label %6
    i32 91, label %11
  ]

6:                                                ; preds = %3
  %7 = getelementptr inbounds i8, ptr %1, i64 1
  %8 = load i8, ptr %7, align 1, !tbaa !33
  %9 = zext i8 %8 to i32
  %10 = tail call fastcc i32 @match_class(i32 noundef %0, i32 noundef %9) #47, !range !456
  br label %18

11:                                               ; preds = %3
  %12 = getelementptr inbounds i8, ptr %2, i64 -1
  %13 = tail call fastcc i32 @matchbracketclass(i32 noundef %0, ptr noundef nonnull %1, ptr noundef nonnull %12) #47, !range !75
  br label %18

14:                                               ; preds = %3
  %15 = zext i8 %4 to i32
  %16 = icmp eq i32 %15, %0
  %17 = zext i1 %16 to i32
  br label %18

18:                                               ; preds = %14, %11, %6, %3
  %19 = phi i32 [ %17, %14 ], [ %13, %11 ], [ %10, %6 ], [ 1, %3 ]
  ret i32 %19
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @max_expand(ptr nocapture noundef %0, ptr noundef %1, ptr noundef readonly %2, ptr noundef %3) unnamed_addr #1 {
  %5 = getelementptr inbounds %struct.MatchState, ptr %0, i64 0, i32 1
  %6 = load ptr, ptr %5, align 8, !tbaa !442
  %7 = icmp ugt ptr %6, %1
  br i1 %7, label %8, label %23

8:                                                ; preds = %4
  %9 = ptrtoint ptr %6 to i64
  %10 = ptrtoint ptr %1 to i64
  %11 = sub i64 %9, %10
  br label %12

12:                                               ; preds = %19, %8
  %13 = phi ptr [ %21, %19 ], [ %1, %8 ]
  %14 = phi i64 [ %20, %19 ], [ 0, %8 ]
  %15 = load i8, ptr %13, align 1, !tbaa !33
  %16 = zext i8 %15 to i32
  %17 = tail call fastcc i32 @singlematch(i32 noundef %16, ptr noundef %2, ptr noundef %3) #47, !range !456
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %23, label %19

19:                                               ; preds = %12
  %20 = add nuw i64 %14, 1
  %21 = getelementptr inbounds i8, ptr %1, i64 %20
  %22 = icmp eq i64 %20, %11
  br i1 %22, label %23, label %12, !llvm.loop !460

23:                                               ; preds = %19, %12, %4
  %24 = phi i64 [ 0, %4 ], [ %11, %19 ], [ %14, %12 ]
  %25 = getelementptr inbounds i8, ptr %3, i64 1
  br label %26

26:                                               ; preds = %29, %23
  %27 = phi i64 [ %24, %23 ], [ %33, %29 ]
  %28 = icmp sgt i64 %27, -1
  br i1 %28, label %29, label %34

29:                                               ; preds = %26
  %30 = getelementptr inbounds i8, ptr %1, i64 %27
  %31 = tail call fastcc ptr @match(ptr noundef %0, ptr noundef %30, ptr noundef nonnull %25) #47
  %32 = icmp eq ptr %31, null
  %33 = add nsw i64 %27, -1
  br i1 %32, label %26, label %34, !llvm.loop !461

34:                                               ; preds = %29, %26
  %35 = phi ptr [ %31, %29 ], [ null, %26 ]
  ret ptr %35
}

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(read) uwtable
define internal fastcc i32 @match_class(i32 noundef %0, i32 noundef %1) unnamed_addr #45 {
  %3 = tail call i32 @tolower(i32 noundef %1) #49
  switch i32 %3, label %80 [
    i32 97, label %4
    i32 99, label %12
    i32 100, label %20
    i32 108, label %28
    i32 112, label %36
    i32 115, label %44
    i32 117, label %52
    i32 119, label %60
    i32 120, label %68
    i32 122, label %76
  ]

4:                                                ; preds = %2
  %5 = tail call ptr @__ctype_b_loc() #52
  %6 = load ptr, ptr %5, align 8, !tbaa !39
  %7 = zext i32 %0 to i64
  %8 = getelementptr inbounds i16, ptr %6, i64 %7
  %9 = load i16, ptr %8, align 2, !tbaa !239
  %10 = and i16 %9, 1024
  %11 = zext i16 %10 to i32
  br label %83

12:                                               ; preds = %2
  %13 = tail call ptr @__ctype_b_loc() #52
  %14 = load ptr, ptr %13, align 8, !tbaa !39
  %15 = zext i32 %0 to i64
  %16 = getelementptr inbounds i16, ptr %14, i64 %15
  %17 = load i16, ptr %16, align 2, !tbaa !239
  %18 = and i16 %17, 2
  %19 = zext i16 %18 to i32
  br label %83

20:                                               ; preds = %2
  %21 = tail call ptr @__ctype_b_loc() #52
  %22 = load ptr, ptr %21, align 8, !tbaa !39
  %23 = zext i32 %0 to i64
  %24 = getelementptr inbounds i16, ptr %22, i64 %23
  %25 = load i16, ptr %24, align 2, !tbaa !239
  %26 = and i16 %25, 2048
  %27 = zext i16 %26 to i32
  br label %83

28:                                               ; preds = %2
  %29 = tail call ptr @__ctype_b_loc() #52
  %30 = load ptr, ptr %29, align 8, !tbaa !39
  %31 = zext i32 %0 to i64
  %32 = getelementptr inbounds i16, ptr %30, i64 %31
  %33 = load i16, ptr %32, align 2, !tbaa !239
  %34 = and i16 %33, 512
  %35 = zext i16 %34 to i32
  br label %83

36:                                               ; preds = %2
  %37 = tail call ptr @__ctype_b_loc() #52
  %38 = load ptr, ptr %37, align 8, !tbaa !39
  %39 = zext i32 %0 to i64
  %40 = getelementptr inbounds i16, ptr %38, i64 %39
  %41 = load i16, ptr %40, align 2, !tbaa !239
  %42 = and i16 %41, 4
  %43 = zext i16 %42 to i32
  br label %83

44:                                               ; preds = %2
  %45 = tail call ptr @__ctype_b_loc() #52
  %46 = load ptr, ptr %45, align 8, !tbaa !39
  %47 = zext i32 %0 to i64
  %48 = getelementptr inbounds i16, ptr %46, i64 %47
  %49 = load i16, ptr %48, align 2, !tbaa !239
  %50 = and i16 %49, 8192
  %51 = zext i16 %50 to i32
  br label %83

52:                                               ; preds = %2
  %53 = tail call ptr @__ctype_b_loc() #52
  %54 = load ptr, ptr %53, align 8, !tbaa !39
  %55 = zext i32 %0 to i64
  %56 = getelementptr inbounds i16, ptr %54, i64 %55
  %57 = load i16, ptr %56, align 2, !tbaa !239
  %58 = and i16 %57, 256
  %59 = zext i16 %58 to i32
  br label %83

60:                                               ; preds = %2
  %61 = tail call ptr @__ctype_b_loc() #52
  %62 = load ptr, ptr %61, align 8, !tbaa !39
  %63 = zext i32 %0 to i64
  %64 = getelementptr inbounds i16, ptr %62, i64 %63
  %65 = load i16, ptr %64, align 2, !tbaa !239
  %66 = and i16 %65, 8
  %67 = zext i16 %66 to i32
  br label %83

68:                                               ; preds = %2
  %69 = tail call ptr @__ctype_b_loc() #52
  %70 = load ptr, ptr %69, align 8, !tbaa !39
  %71 = zext i32 %0 to i64
  %72 = getelementptr inbounds i16, ptr %70, i64 %71
  %73 = load i16, ptr %72, align 2, !tbaa !239
  %74 = and i16 %73, 4096
  %75 = zext i16 %74 to i32
  br label %83

76:                                               ; preds = %2
  %77 = icmp eq i32 %0, 0
  %78 = zext i1 %77 to i32
  %79 = tail call ptr @__ctype_b_loc() #52
  br label %83

80:                                               ; preds = %2
  %81 = icmp eq i32 %1, %0
  %82 = zext i1 %81 to i32
  br label %95

83:                                               ; preds = %76, %68, %60, %52, %44, %36, %28, %20, %12, %4
  %84 = phi ptr [ %79, %76 ], [ %69, %68 ], [ %61, %60 ], [ %53, %52 ], [ %45, %44 ], [ %37, %36 ], [ %29, %28 ], [ %21, %20 ], [ %13, %12 ], [ %5, %4 ]
  %85 = phi i32 [ %78, %76 ], [ %75, %68 ], [ %67, %60 ], [ %59, %52 ], [ %51, %44 ], [ %43, %36 ], [ %35, %28 ], [ %27, %20 ], [ %19, %12 ], [ %11, %4 ]
  %86 = load ptr, ptr %84, align 8, !tbaa !39
  %87 = zext i32 %1 to i64
  %88 = getelementptr inbounds i16, ptr %86, i64 %87
  %89 = load i16, ptr %88, align 2, !tbaa !239
  %90 = and i16 %89, 512
  %91 = icmp eq i16 %90, 0
  %92 = icmp eq i32 %85, 0
  %93 = zext i1 %92 to i32
  %94 = select i1 %91, i32 %93, i32 %85
  br label %95

95:                                               ; preds = %83, %80
  %96 = phi i32 [ %82, %80 ], [ %94, %83 ]
  ret i32 %96
}

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(read)
declare i32 @tolower(i32 noundef) local_unnamed_addr #37

; Function Attrs: mustprogress nofree nosync nounwind optsize willreturn memory(none)
declare ptr @__ctype_tolower_loc() local_unnamed_addr #26

; Function Attrs: nounwind optsize uwtable
define internal i32 @gmatch_aux(ptr noundef %0) #1 {
  %2 = alloca %struct.MatchState, align 8
  %3 = alloca i64, align 8
  call void @llvm.lifetime.start.p0(i64 544, ptr nonnull %2) #48
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #48
  %4 = call ptr @lua_tolstring(ptr noundef %0, i32 noundef -10003, ptr noundef nonnull %3) #46
  %5 = call ptr @lua_tolstring(ptr noundef %0, i32 noundef -10004, ptr noundef null) #46
  %6 = getelementptr inbounds %struct.MatchState, ptr %2, i64 0, i32 2
  store ptr %0, ptr %6, align 8, !tbaa !439
  store ptr %4, ptr %2, align 8, !tbaa !441
  %7 = load i64, ptr %3, align 8, !tbaa !40
  %8 = getelementptr inbounds i8, ptr %4, i64 %7
  %9 = getelementptr inbounds %struct.MatchState, ptr %2, i64 0, i32 1
  store ptr %8, ptr %9, align 8, !tbaa !442
  %10 = call i64 @lua_tointeger(ptr noundef %0, i32 noundef -10005) #46
  %11 = icmp sgt i64 %10, %7
  br i1 %11, label %31, label %12

12:                                               ; preds = %1
  %13 = getelementptr inbounds i8, ptr %4, i64 %10
  %14 = getelementptr inbounds %struct.MatchState, ptr %2, i64 0, i32 3
  br label %15

15:                                               ; preds = %27, %12
  %16 = phi ptr [ %13, %12 ], [ %28, %27 ]
  store i32 0, ptr %14, align 8, !tbaa !443
  %17 = call fastcc ptr @match(ptr noundef nonnull %2, ptr noundef %16, ptr noundef %5) #47
  %18 = icmp eq ptr %17, null
  br i1 %18, label %27, label %19

19:                                               ; preds = %15
  %.lcssa1 = phi ptr [ %16, %15 ]
  %.lcssa = phi ptr [ %17, %15 ]
  %20 = ptrtoint ptr %.lcssa to i64
  %21 = ptrtoint ptr %4 to i64
  %22 = sub i64 %20, %21
  %23 = icmp eq ptr %.lcssa, %.lcssa1
  %24 = zext i1 %23 to i64
  %25 = add nsw i64 %22, %24
  call void @lua_pushinteger(ptr noundef %0, i64 noundef %25) #46
  call void @lua_replace(ptr noundef %0, i32 noundef -10005) #46
  %26 = call fastcc i32 @push_captures(ptr noundef nonnull %2, ptr noundef %.lcssa1, ptr noundef nonnull %.lcssa) #47
  br label %31

27:                                               ; preds = %15
  %28 = getelementptr inbounds i8, ptr %16, i64 1
  %29 = load ptr, ptr %9, align 8, !tbaa !442
  %30 = icmp ugt ptr %28, %29
  br i1 %30, label %31, label %15, !llvm.loop !462

31:                                               ; preds = %27, %19, %1
  %32 = phi i32 [ %26, %19 ], [ 0, %1 ], [ 0, %27 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #48
  call void @llvm.lifetime.end.p0(i64 544, ptr nonnull %2) #48
  ret i32 %32
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @writer(ptr nocapture readnone %0, ptr noundef %1, i64 noundef %2, ptr noundef %3) #1 {
  tail call void @luaL_addlstring(ptr noundef %3, ptr noundef %1, i64 noundef %2) #46
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaopen_package(ptr noundef %0) #1 {
  %2 = tail call i32 @luaL_newmetatable(ptr noundef %0, ptr noundef nonnull @.str.560) #46
  tail call void @lua_pushcclosure(ptr noundef %0, ptr noundef nonnull @gctm, i32 noundef 0) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.1.561) #46
  tail call void @luaL_register(ptr noundef %0, ptr noundef nonnull @.str.2.562, ptr noundef nonnull @pk_funcs) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -1) #46
  tail call void @lua_replace(ptr noundef %0, i32 noundef -10001) #46
  tail call void @lua_createtable(ptr noundef %0, i32 noundef 0, i32 noundef 4) #46
  br label %3

3:                                                ; preds = %3, %1
  %4 = phi i64 [ 0, %1 ], [ %7, %3 ]
  %5 = getelementptr inbounds [5 x ptr], ptr @loaders, i64 0, i64 %4
  %6 = load ptr, ptr %5, align 8, !tbaa !39
  tail call void @lua_pushcclosure(ptr noundef %0, ptr noundef %6, i32 noundef 0) #46
  %7 = add nuw nsw i64 %4, 1
  %8 = trunc i64 %7 to i32
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef -2, i32 noundef %8) #46
  %9 = icmp eq i64 %7, 4
  br i1 %9, label %10, label %3, !llvm.loop !463

10:                                               ; preds = %3
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.3.563) #46
  tail call fastcc void @setpath(ptr noundef %0, ptr noundef nonnull @.str.4.564, ptr noundef nonnull @.str.5.565, ptr noundef nonnull @.str.6.566) #47
  tail call fastcc void @setpath(ptr noundef %0, ptr noundef nonnull @.str.7.567, ptr noundef nonnull @.str.8.568, ptr noundef nonnull @.str.9.569) #47
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.10.570, i64 noundef 9) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.11.571) #46
  %11 = tail call ptr @luaL_findtable(ptr noundef %0, i32 noundef -10000, ptr noundef nonnull @.str.12.572, i32 noundef 2) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.13.573) #46
  tail call void @lua_createtable(ptr noundef %0, i32 noundef 0, i32 noundef 0) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.14.574) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -10002) #46
  tail call void @luaL_register(ptr noundef %0, ptr noundef null, ptr noundef nonnull @ll_funcs) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @gctm(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checkudata(ptr noundef %0, i32 noundef 1, ptr noundef nonnull @.str.560) #46
  store ptr null, ptr %2, align 8, !tbaa !39
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @setpath(ptr noundef %0, ptr noundef %1, ptr nocapture noundef readonly %2, ptr noundef %3) unnamed_addr #1 {
  %5 = tail call ptr @getenv(ptr noundef %2) #46
  %6 = icmp eq ptr %5, null
  br i1 %6, label %7, label %8

7:                                                ; preds = %4
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef %3) #46
  br label %11

8:                                                ; preds = %4
  %9 = tail call ptr @luaL_gsub(ptr noundef %0, ptr noundef nonnull %5, ptr noundef nonnull @.str.38.587, ptr noundef nonnull @.str.39.588) #46
  %10 = tail call ptr @luaL_gsub(ptr noundef %0, ptr noundef %9, ptr noundef nonnull @.str.40.589, ptr noundef %3) #46
  tail call void @lua_remove(ptr noundef %0, i32 noundef -2) #46
  br label %11

11:                                               ; preds = %8, %7
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef %1) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @ll_module(ptr noundef %0) #1 {
  %2 = alloca %struct.lua_Debug, align 8
  %3 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %4 = tail call i32 @lua_gettop(ptr noundef %0) #46
  %5 = add nsw i32 %4, 1
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -10000, ptr noundef nonnull @.str.12.572) #46
  tail call void @lua_getfield(ptr noundef %0, i32 noundef %5, ptr noundef %3) #46
  %6 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %7 = icmp eq i32 %6, 5
  br i1 %7, label %14, label %8

8:                                                ; preds = %1
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  %9 = tail call ptr @luaL_findtable(ptr noundef %0, i32 noundef -10002, ptr noundef %3, i32 noundef 1) #46
  %10 = icmp eq ptr %9, null
  br i1 %10, label %13, label %11

11:                                               ; preds = %8
  %12 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.43.581, ptr noundef %3) #46
  br label %43

13:                                               ; preds = %8
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -1) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef %5, ptr noundef %3) #46
  br label %14

14:                                               ; preds = %13, %1
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -1, ptr noundef nonnull @.str.44.582) #46
  %15 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %16 = icmp eq i32 %15, 0
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  br i1 %16, label %17, label %25

17:                                               ; preds = %14
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -1) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.45.583) #46
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef %3) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.44.582) #46
  %18 = tail call ptr @strrchr(ptr noundef nonnull dereferenceable(1) %3, i32 noundef 46) #49
  %19 = icmp eq ptr %18, null
  %20 = getelementptr inbounds i8, ptr %18, i64 1
  %21 = select i1 %19, ptr %3, ptr %20
  %22 = ptrtoint ptr %21 to i64
  %23 = ptrtoint ptr %3 to i64
  %24 = sub i64 %22, %23
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef %3, i64 noundef %24) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.46.584) #46
  br label %25

25:                                               ; preds = %17, %14
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -1) #46
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %2) #48
  %26 = call i32 @lua_getstack(ptr noundef %0, i32 noundef 1, ptr noundef nonnull %2) #46
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %34, label %28

28:                                               ; preds = %25
  %29 = call i32 @lua_getinfo(ptr noundef %0, ptr noundef nonnull @.str.47.585, ptr noundef nonnull %2) #46
  %30 = icmp eq i32 %29, 0
  br i1 %30, label %34, label %31

31:                                               ; preds = %28
  %32 = call i32 @lua_iscfunction(ptr noundef %0, i32 noundef -1) #46
  %33 = icmp eq i32 %32, 0
  br i1 %33, label %36, label %34

34:                                               ; preds = %31, %28, %25
  %35 = call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.48.586) #46
  br label %36

36:                                               ; preds = %34, %31
  call void @lua_pushvalue(ptr noundef %0, i32 noundef -2) #46
  %37 = call i32 @lua_setfenv(ptr noundef %0, i32 noundef -2) #46
  call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  call void @llvm.lifetime.end.p0(i64 120, ptr nonnull %2) #48
  %38 = icmp slt i32 %4, 2
  br i1 %38, label %43, label %39

39:                                               ; preds = %39, %36
  %40 = phi i32 [ %41, %39 ], [ 2, %36 ]
  call void @lua_pushvalue(ptr noundef %0, i32 noundef %40) #46
  call void @lua_pushvalue(ptr noundef %0, i32 noundef -2) #46
  call void @lua_call(ptr noundef %0, i32 noundef 1, i32 noundef 0) #46
  %41 = add nuw i32 %40, 1
  %42 = icmp eq i32 %40, %4
  br i1 %42, label %43, label %39, !llvm.loop !464

43:                                               ; preds = %39, %36, %11
  %44 = phi i32 [ %12, %11 ], [ 0, %36 ], [ 0, %39 ]
  ret i32 %44
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @ll_require(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  tail call void @lua_settop(ptr noundef %0, i32 noundef 1) #46
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -10000, ptr noundef nonnull @.str.12.572) #46
  tail call void @lua_getfield(ptr noundef %0, i32 noundef 2, ptr noundef %2) #46
  %3 = tail call i32 @lua_toboolean(ptr noundef %0, i32 noundef -1) #46
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %10, label %5

5:                                                ; preds = %1
  %6 = tail call ptr @lua_touserdata(ptr noundef %0, i32 noundef -1) #46
  %7 = icmp eq ptr %6, @sentinel_
  br i1 %7, label %8, label %41

8:                                                ; preds = %5
  %9 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.49.577, ptr noundef %2) #46
  br label %41

10:                                               ; preds = %1
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -10001, ptr noundef nonnull @.str.3.563) #46
  %11 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %12 = icmp eq i32 %11, 5
  br i1 %12, label %15, label %13

13:                                               ; preds = %10
  %14 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.50.578) #46
  br label %15

15:                                               ; preds = %13, %10
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.28.579, i64 noundef 0) #46
  br label %16

16:                                               ; preds = %31, %15
  %17 = phi i32 [ 1, %15 ], [ %32, %31 ]
  tail call void @lua_rawgeti(ptr noundef %0, i32 noundef -2, i32 noundef %17) #46
  %18 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %23

20:                                               ; preds = %16
  %21 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef -2, ptr noundef null) #46
  %22 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.51.580, ptr noundef %2, ptr noundef %21) #46
  br label %23

23:                                               ; preds = %20, %16
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef %2) #46
  tail call void @lua_call(ptr noundef %0, i32 noundef 1, i32 noundef 1) #46
  %24 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %25 = icmp eq i32 %24, 6
  br i1 %25, label %33, label %26

26:                                               ; preds = %23
  %27 = tail call i32 @lua_isstring(ptr noundef %0, i32 noundef -1) #46
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %30, label %29

29:                                               ; preds = %26
  tail call void @lua_concat(ptr noundef %0, i32 noundef 2) #46
  br label %31

30:                                               ; preds = %26
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  br label %31

31:                                               ; preds = %30, %29
  %32 = add nuw nsw i32 %17, 1
  br label %16

33:                                               ; preds = %23
  tail call void @lua_pushlightuserdata(ptr noundef %0, ptr noundef nonnull @sentinel_) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef 2, ptr noundef %2) #46
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef %2) #46
  tail call void @lua_call(ptr noundef %0, i32 noundef 1, i32 noundef 1) #46
  %34 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %35 = icmp eq i32 %34, 0
  br i1 %35, label %37, label %36

36:                                               ; preds = %33
  tail call void @lua_setfield(ptr noundef %0, i32 noundef 2, ptr noundef %2) #46
  br label %37

37:                                               ; preds = %36, %33
  tail call void @lua_getfield(ptr noundef %0, i32 noundef 2, ptr noundef %2) #46
  %38 = tail call ptr @lua_touserdata(ptr noundef %0, i32 noundef -1) #46
  %39 = icmp eq ptr %38, @sentinel_
  br i1 %39, label %40, label %41

40:                                               ; preds = %37
  tail call void @lua_pushboolean(ptr noundef %0, i32 noundef 1) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -1) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef 2, ptr noundef %2) #46
  br label %41

41:                                               ; preds = %40, %37, %8, %5
  ret i32 1
}

; Function Attrs: mustprogress nofree nounwind optsize willreturn memory(argmem: read)
declare ptr @strrchr(ptr noundef, i32 noundef) local_unnamed_addr #10

; Function Attrs: nounwind optsize uwtable
define internal i32 @loader_preload(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -10001, ptr noundef nonnull @.str.14.574) #46
  %3 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %4 = icmp eq i32 %3, 5
  br i1 %4, label %7, label %5

5:                                                ; preds = %1
  %6 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.23.603) #46
  br label %7

7:                                                ; preds = %5, %1
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -1, ptr noundef %2) #46
  %8 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %12

10:                                               ; preds = %7
  %11 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.24.604, ptr noundef %2) #46
  br label %12

12:                                               ; preds = %10, %7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @loader_Lua(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %3 = tail call fastcc ptr @findfile(ptr noundef %0, ptr noundef %2, ptr noundef nonnull @.str.4.564) #47
  %4 = icmp eq ptr %3, null
  br i1 %4, label %9, label %5

5:                                                ; preds = %1
  %6 = tail call i32 @luaL_loadfile(ptr noundef %0, ptr noundef nonnull %3) #46
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %9, label %8

8:                                                ; preds = %5
  tail call fastcc void @loaderror(ptr noundef %0, ptr noundef nonnull %3) #47
  br label %9

9:                                                ; preds = %8, %5, %1
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @loader_C(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %3 = tail call fastcc ptr @findfile(ptr noundef %0, ptr noundef %2, ptr noundef nonnull @.str.7.567) #47
  %4 = icmp eq ptr %3, null
  br i1 %4, label %7, label %5

5:                                                ; preds = %1
  tail call fastcc void @mkfuncname(ptr noundef %0, ptr noundef %2) #47
  %6 = tail call fastcc i32 @ll_loadfunc(ptr noundef %0, ptr noundef nonnull %3) #47
  tail call fastcc void @loaderror(ptr noundef %0, ptr noundef nonnull %3) #47
  br label %7

7:                                                ; preds = %5, %1
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @loader_Croot(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %3 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %2, i32 noundef 46) #49
  %4 = icmp eq ptr %3, null
  br i1 %4, label %18, label %5

5:                                                ; preds = %1
  %6 = ptrtoint ptr %3 to i64
  %7 = ptrtoint ptr %2 to i64
  %8 = sub i64 %6, %7
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef %2, i64 noundef %8) #46
  %9 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef -1, ptr noundef null) #46
  %10 = tail call fastcc ptr @findfile(ptr noundef %0, ptr noundef %9, ptr noundef nonnull @.str.7.567) #47
  %11 = icmp eq ptr %10, null
  br i1 %11, label %18, label %12

12:                                               ; preds = %5
  tail call fastcc void @mkfuncname(ptr noundef %0, ptr noundef %2) #47
  %13 = tail call fastcc i32 @ll_loadfunc(ptr noundef %0, ptr noundef nonnull %10) #47
  %14 = icmp eq i32 %13, 2
  br i1 %14, label %16, label %15

15:                                               ; preds = %12
  tail call fastcc void @loaderror(ptr noundef %0, ptr noundef nonnull %10) #47
  br label %16

16:                                               ; preds = %15, %12
  %17 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.37.590, ptr noundef %2, ptr noundef nonnull %10) #46
  br label %18

18:                                               ; preds = %16, %5, %1
  %19 = phi i32 [ 1, %16 ], [ 0, %1 ], [ 1, %5 ]
  ret i32 %19
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc ptr @findfile(ptr noundef %0, ptr noundef %1, ptr noundef %2) unnamed_addr #1 {
  %4 = tail call ptr @luaL_gsub(ptr noundef %0, ptr noundef %1, ptr noundef nonnull @.str.25.595, ptr noundef nonnull @.str.26.598) #46
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -10001, ptr noundef %2) #46
  %5 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef -1, ptr noundef null) #46
  %6 = icmp eq ptr %5, null
  br i1 %6, label %7, label %9

7:                                                ; preds = %3
  %8 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.27.599, ptr noundef %2) #46
  br label %9

9:                                                ; preds = %7, %3
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.28.579, i64 noundef 0) #46
  br label %10

10:                                               ; preds = %15, %9
  %11 = phi ptr [ %5, %9 ], [ %16, %15 ]
  %12 = load i8, ptr %11, align 1, !tbaa !33
  switch i8 %12, label %17 [
    i8 59, label %13
    i8 0, label %38
  ]

13:                                               ; preds = %10
  %14 = getelementptr inbounds i8, ptr %11, i64 1
  br label %15

15:                                               ; preds = %36, %13
  %16 = phi ptr [ %14, %13 ], [ %29, %36 ]
  br label %10, !llvm.loop !465

17:                                               ; preds = %10
  %18 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %11, i32 noundef 59) #49
  %19 = icmp eq ptr %18, null
  br i1 %19, label %24, label %20

20:                                               ; preds = %17
  %21 = ptrtoint ptr %18 to i64
  %22 = ptrtoint ptr %11 to i64
  %23 = sub i64 %21, %22
  br label %27

24:                                               ; preds = %17
  %25 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %11) #49
  %26 = getelementptr inbounds i8, ptr %11, i64 %25
  br label %27

27:                                               ; preds = %24, %20
  %28 = phi i64 [ %25, %24 ], [ %23, %20 ]
  %29 = phi ptr [ %26, %24 ], [ %18, %20 ]
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull %11, i64 noundef %28) #46
  %30 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef -1, ptr noundef null) #46
  %31 = tail call ptr @luaL_gsub(ptr noundef %0, ptr noundef %30, ptr noundef nonnull @.str.29.600, ptr noundef %4) #46
  tail call void @lua_remove(ptr noundef %0, i32 noundef -2) #46
  %32 = tail call noalias ptr @fopen(ptr noundef %31, ptr noundef nonnull @.str.32.601) #47
  %33 = icmp eq ptr %32, null
  br i1 %33, label %36, label %34

34:                                               ; preds = %27
  %.lcssa1 = phi ptr [ %31, %27 ]
  %.lcssa = phi ptr [ %32, %27 ]
  %35 = tail call i32 @fclose(ptr noundef nonnull %.lcssa) #47
  br label %38

36:                                               ; preds = %27
  %37 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.30.602, ptr noundef %31) #46
  tail call void @lua_remove(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_concat(ptr noundef %0, i32 noundef 2) #46
  br label %15

38:                                               ; preds = %34, %10
  %39 = phi ptr [ %.lcssa1, %34 ], [ null, %10 ]
  ret ptr %39
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @mkfuncname(ptr noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %1, i32 noundef 45) #49
  %4 = icmp eq ptr %3, null
  %5 = getelementptr inbounds i8, ptr %3, i64 1
  %6 = select i1 %4, ptr %1, ptr %5
  %7 = tail call ptr @luaL_gsub(ptr noundef %0, ptr noundef %6, ptr noundef nonnull @.str.25.595, ptr noundef nonnull @.str.35.596) #46
  %8 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.36.597, ptr noundef %7) #46
  tail call void @lua_remove(ptr noundef %0, i32 noundef -2) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @ll_loadfunc(ptr noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.19.592, ptr noundef nonnull @.str.20.593, ptr noundef %1) #46
  tail call void @lua_gettable(ptr noundef %0, i32 noundef -10000) #46
  %4 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = tail call ptr @lua_touserdata(ptr noundef %0, i32 noundef -1) #46
  br label %12

8:                                                ; preds = %2
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  %9 = tail call ptr @lua_newuserdata(ptr noundef %0, i64 noundef 8) #46
  store ptr null, ptr %9, align 8, !tbaa !39
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -10000, ptr noundef nonnull @.str.560) #46
  %10 = tail call i32 @lua_setmetatable(ptr noundef %0, i32 noundef -2) #46
  %11 = tail call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.19.592, ptr noundef nonnull @.str.20.593, ptr noundef %1) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -2) #46
  tail call void @lua_settable(ptr noundef %0, i32 noundef -10000) #46
  br label %12

12:                                               ; preds = %8, %6
  %13 = phi ptr [ %9, %8 ], [ %7, %6 ]
  %14 = load ptr, ptr %13, align 8, !tbaa !39
  %15 = icmp eq ptr %14, null
  tail call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.21.594, i64 noundef 58) #46
  br i1 %15, label %16, label %17

16:                                               ; preds = %12
  store ptr null, ptr %13, align 8, !tbaa !39
  br label %17

17:                                               ; preds = %16, %12
  %18 = phi i32 [ 1, %16 ], [ 2, %12 ]
  ret i32 %18
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @loaderror(ptr noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %4 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef -1, ptr noundef null) #46
  %5 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.33.591, ptr noundef %3, ptr noundef %1, ptr noundef %4) #46
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @ll_loadlib(ptr noundef %0) #1 {
  %2 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %3 = tail call ptr @luaL_checklstring(ptr noundef %0, i32 noundef 2, ptr noundef null) #46
  %4 = tail call fastcc i32 @ll_loadfunc(ptr noundef %0, ptr noundef %2) #47
  tail call void @lua_pushnil(ptr noundef %0) #46
  tail call void @lua_insert(ptr noundef %0, i32 noundef -2) #46
  %5 = icmp eq i32 %4, 1
  %6 = select i1 %5, ptr @.str.17.608, ptr @.str.18.609
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef nonnull %6) #46
  ret i32 3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @ll_seeall(ptr noundef %0) #1 {
  tail call void @luaL_checktype(ptr noundef %0, i32 noundef 1, i32 noundef 5) #46
  %2 = tail call i32 @lua_getmetatable(ptr noundef %0, i32 noundef 1) #46
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %6

4:                                                ; preds = %1
  tail call void @lua_createtable(ptr noundef %0, i32 noundef 0, i32 noundef 1) #46
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -1) #46
  %5 = tail call i32 @lua_setmetatable(ptr noundef %0, i32 noundef 1) #46
  br label %6

6:                                                ; preds = %4, %1
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef -10002) #46
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -2, ptr noundef nonnull @.str.22.607) #46
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal void @luaL_openlibs(ptr noundef %0) #1 {
  br label %2

2:                                                ; preds = %2, %1
  %3 = phi ptr [ @luaopen_base, %1 ], [ %8, %2 ]
  %4 = phi ptr [ @lualibs, %1 ], [ %6, %2 ]
  tail call void @lua_pushcclosure(ptr noundef %0, ptr noundef nonnull %3, i32 noundef 0) #46
  %5 = load ptr, ptr %4, align 8, !tbaa !383
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef %5) #46
  tail call void @lua_call(ptr noundef %0, i32 noundef 1, i32 noundef 0) #46
  %6 = getelementptr inbounds %struct.CCallS, ptr %4, i64 1
  %7 = getelementptr inbounds %struct.CCallS, ptr %4, i64 1, i32 1
  %8 = load ptr, ptr %7, align 8, !tbaa !387
  %9 = icmp eq ptr %8, null
  br i1 %9, label %10, label %2, !llvm.loop !466

10:                                               ; preds = %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define dso_local i32 @main(i32 noundef %0, ptr noundef %1) #1 {
  %3 = alloca %struct.Smain, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3) #48
  %4 = tail call ptr @luaL_newstate() #46
  %5 = icmp eq ptr %4, null
  br i1 %5, label %6, label %8

6:                                                ; preds = %2
  %7 = load ptr, ptr %1, align 8, !tbaa !39
  tail call fastcc void @l_message(ptr noundef %7, ptr noundef nonnull @.str.618) #47
  br label %18

8:                                                ; preds = %2
  store ptr @.str.1.619, ptr %1, align 8, !tbaa !39
  store i32 %0, ptr %3, align 8, !tbaa !467
  %9 = getelementptr inbounds %struct.Smain, ptr %3, i64 0, i32 1
  store ptr %1, ptr %9, align 8, !tbaa !469
  %10 = call i32 @lua_cpcall(ptr noundef nonnull %4, ptr noundef nonnull @pmain, ptr noundef nonnull %3) #46
  %11 = call fastcc i32 @report(ptr noundef nonnull %4, i32 noundef %10) #47
  call void @lua_close(ptr noundef nonnull %4) #46
  %12 = icmp ne i32 %10, 0
  %13 = getelementptr inbounds %struct.Smain, ptr %3, i64 0, i32 2
  %14 = load i32, ptr %13, align 8
  %15 = icmp ne i32 %14, 0
  %16 = select i1 %12, i1 true, i1 %15
  %17 = zext i1 %16 to i32
  br label %18

18:                                               ; preds = %8, %6
  %19 = phi i32 [ 1, %6 ], [ %17, %8 ]
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3) #48
  ret i32 %19
}

; Function Attrs: nofree nounwind optsize uwtable
define internal fastcc void @l_message(ptr noundef %0, ptr noundef %1) unnamed_addr #29 {
  %3 = icmp eq ptr %0, null
  br i1 %3, label %7, label %4

4:                                                ; preds = %2
  %5 = load ptr, ptr @stderr, align 8, !tbaa !39
  %6 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %5, ptr noundef nonnull @.str.2.645, ptr noundef nonnull %0) #54
  br label %7

7:                                                ; preds = %4, %2
  %8 = load ptr, ptr @stderr, align 8, !tbaa !39
  %9 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %8, ptr noundef nonnull @.str.3.624, ptr noundef %1) #54
  %10 = load ptr, ptr @stderr, align 8, !tbaa !39
  %11 = tail call i32 @fflush(ptr noundef %10) #47
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @pmain(ptr noundef %0) #1 {
  %2 = tail call ptr @lua_touserdata(ptr noundef %0, i32 noundef 1) #46
  %3 = getelementptr inbounds %struct.Smain, ptr %2, i64 0, i32 1
  %4 = load ptr, ptr %3, align 8, !tbaa !469
  store ptr %0, ptr @globalL, align 8, !tbaa !39
  %5 = load ptr, ptr %4, align 8, !tbaa !39
  %6 = icmp eq ptr %5, null
  br i1 %6, label %11, label %7

7:                                                ; preds = %1
  %8 = load i8, ptr %5, align 1, !tbaa !33
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %11, label %10

10:                                               ; preds = %7
  store ptr %5, ptr @progname, align 8, !tbaa !39
  br label %11

11:                                               ; preds = %10, %7, %1
  %12 = tail call i32 @lua_gc(ptr noundef %0, i32 noundef 0, i32 noundef 0) #46
  tail call void @luaL_openlibs(ptr noundef %0) #46
  %13 = tail call i32 @lua_gc(ptr noundef %0, i32 noundef 1, i32 noundef 0) #46
  %14 = tail call ptr @getenv(ptr noundef nonnull @.str.4.621) #46
  %15 = icmp eq ptr %14, null
  br i1 %15, label %16, label %18

16:                                               ; preds = %11
  %17 = getelementptr inbounds %struct.Smain, ptr %2, i64 0, i32 2
  store i32 0, ptr %17, align 8, !tbaa !470
  br label %30

18:                                               ; preds = %11
  %19 = load i8, ptr %14, align 1, !tbaa !33
  %20 = icmp eq i8 %19, 64
  br i1 %20, label %21, label %24

21:                                               ; preds = %18
  %22 = getelementptr inbounds i8, ptr %14, i64 1
  %23 = tail call fastcc i32 @dofile(ptr noundef %0, ptr noundef nonnull %22) #47
  br label %26

24:                                               ; preds = %18
  %25 = tail call fastcc i32 @dostring(ptr noundef %0, ptr noundef nonnull %14, ptr noundef nonnull @.str.5.622) #47
  br label %26

26:                                               ; preds = %24, %21
  %27 = phi i32 [ %23, %21 ], [ %25, %24 ]
  %28 = getelementptr inbounds %struct.Smain, ptr %2, i64 0, i32 2
  store i32 %27, ptr %28, align 8, !tbaa !470
  %29 = icmp eq i32 %27, 0
  br i1 %29, label %30, label %238

30:                                               ; preds = %26, %16
  %31 = phi ptr [ %17, %16 ], [ %28, %26 ]
  %32 = getelementptr inbounds ptr, ptr %4, i64 1
  %33 = load ptr, ptr %32, align 8, !tbaa !39
  %34 = icmp eq ptr %33, null
  br i1 %34, label %109, label %35

35:                                               ; preds = %77, %30
  %36 = phi i32 [ %78, %77 ], [ 0, %30 ]
  %37 = phi i32 [ %79, %77 ], [ 0, %30 ]
  %38 = phi i32 [ %80, %77 ], [ 0, %30 ]
  %39 = phi ptr [ %85, %77 ], [ %33, %30 ]
  %40 = phi i32 [ %82, %77 ], [ 1, %30 ]
  %41 = load i8, ptr %39, align 1, !tbaa !33
  %42 = icmp eq i8 %41, 45
  br i1 %42, label %43, label %87

43:                                               ; preds = %35
  %44 = getelementptr inbounds i8, ptr %39, i64 1
  %45 = load i8, ptr %44, align 1, !tbaa !33
  %46 = sext i8 %45 to i32
  switch i32 %46, label %90 [
    i32 45, label %47
    i32 0, label %87
    i32 105, label %57
    i32 118, label %61
    i32 101, label %65
    i32 108, label %66
  ]

47:                                               ; preds = %43
  %.lcssa19 = phi i32 [ %36, %43 ]
  %.lcssa15 = phi i32 [ %37, %43 ]
  %.lcssa11 = phi i32 [ %38, %43 ]
  %.lcssa7 = phi ptr [ %39, %43 ]
  %.lcssa3 = phi i32 [ %40, %43 ]
  %48 = getelementptr inbounds i8, ptr %.lcssa7, i64 2
  %49 = load i8, ptr %48, align 1, !tbaa !33
  %50 = icmp eq i8 %49, 0
  br i1 %50, label %51, label %90

51:                                               ; preds = %47
  %52 = add nsw i32 %.lcssa3, 1
  %53 = sext i32 %52 to i64
  %54 = getelementptr inbounds ptr, ptr %4, i64 %53
  %55 = load ptr, ptr %54, align 8, !tbaa !39
  %56 = icmp eq ptr %55, null
  br i1 %56, label %96, label %87

57:                                               ; preds = %43
  %58 = getelementptr inbounds i8, ptr %39, i64 2
  %59 = load i8, ptr %58, align 1, !tbaa !33
  %60 = icmp eq i8 %59, 0
  br i1 %60, label %77, label %90

61:                                               ; preds = %43
  %62 = getelementptr inbounds i8, ptr %39, i64 2
  %63 = load i8, ptr %62, align 1, !tbaa !33
  %64 = icmp eq i8 %63, 0
  br i1 %64, label %77, label %90

65:                                               ; preds = %43
  br label %66

66:                                               ; preds = %65, %43
  %67 = phi i32 [ %38, %43 ], [ 1, %65 ]
  %68 = getelementptr inbounds i8, ptr %39, i64 2
  %69 = load i8, ptr %68, align 1, !tbaa !33
  %70 = icmp eq i8 %69, 0
  br i1 %70, label %71, label %77

71:                                               ; preds = %66
  %72 = add nsw i32 %40, 1
  %73 = sext i32 %72 to i64
  %74 = getelementptr inbounds ptr, ptr %4, i64 %73
  %75 = load ptr, ptr %74, align 8, !tbaa !39
  %76 = icmp eq ptr %75, null
  br i1 %76, label %90, label %77

77:                                               ; preds = %71, %66, %61, %57
  %78 = phi i32 [ %36, %71 ], [ %36, %66 ], [ %36, %61 ], [ 1, %57 ]
  %79 = phi i32 [ %37, %71 ], [ %37, %66 ], [ 1, %61 ], [ 1, %57 ]
  %80 = phi i32 [ %67, %71 ], [ %67, %66 ], [ %38, %61 ], [ %38, %57 ]
  %81 = phi i32 [ %72, %71 ], [ %40, %66 ], [ %40, %61 ], [ %40, %57 ]
  %82 = add nsw i32 %81, 1
  %83 = sext i32 %82 to i64
  %84 = getelementptr inbounds ptr, ptr %4, i64 %83
  %85 = load ptr, ptr %84, align 8, !tbaa !39
  %86 = icmp eq ptr %85, null
  br i1 %86, label %96, label %35, !llvm.loop !471

87:                                               ; preds = %51, %43, %35
  %.lcssa17 = phi i32 [ %.lcssa19, %51 ], [ %36, %43 ], [ %36, %35 ]
  %.lcssa13 = phi i32 [ %.lcssa15, %51 ], [ %37, %43 ], [ %37, %35 ]
  %.lcssa9 = phi i32 [ %.lcssa11, %51 ], [ %38, %43 ], [ %38, %35 ]
  %.lcssa5 = phi ptr [ %.lcssa7, %51 ], [ %39, %43 ], [ %39, %35 ]
  %.lcssa1 = phi i32 [ %.lcssa3, %51 ], [ %40, %43 ], [ %40, %35 ]
  %88 = phi i32 [ %52, %51 ], [ %40, %43 ], [ %40, %35 ]
  %89 = icmp slt i32 %88, 0
  br i1 %89, label %90, label %96

90:                                               ; preds = %87, %71, %61, %57, %47, %43
  %91 = load ptr, ptr @stderr, align 8, !tbaa !39
  %92 = load ptr, ptr @progname, align 8, !tbaa !39
  %93 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %91, ptr noundef nonnull @.str.9.623, ptr noundef %92) #54
  %94 = load ptr, ptr @stderr, align 8, !tbaa !39
  %95 = tail call i32 @fflush(ptr noundef %94) #47
  store i32 1, ptr %31, align 8, !tbaa !470
  br label %238

96:                                               ; preds = %87, %77, %51
  %97 = phi i32 [ %88, %87 ], [ 0, %51 ], [ 0, %77 ]
  %98 = phi i32 [ %.lcssa9, %87 ], [ %.lcssa11, %51 ], [ %80, %77 ]
  %99 = phi i32 [ %.lcssa13, %87 ], [ %.lcssa15, %51 ], [ %79, %77 ]
  %100 = phi i32 [ %.lcssa17, %87 ], [ %.lcssa19, %51 ], [ %78, %77 ]
  %101 = icmp eq i32 %99, 0
  br i1 %101, label %107, label %102

102:                                              ; preds = %96
  %103 = load ptr, ptr @stderr, align 8, !tbaa !39
  %104 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %103, ptr noundef nonnull @.str.3.624, ptr noundef nonnull @.str.10.625) #54
  %105 = load ptr, ptr @stderr, align 8, !tbaa !39
  %106 = tail call i32 @fflush(ptr noundef %105) #47
  br label %107

107:                                              ; preds = %102, %96
  %108 = icmp eq i32 %97, 0
  br i1 %108, label %109, label %114

109:                                              ; preds = %107, %30
  %110 = phi i32 [ %98, %107 ], [ 0, %30 ]
  %111 = phi i32 [ %99, %107 ], [ 0, %30 ]
  %112 = phi i32 [ %100, %107 ], [ 0, %30 ]
  %113 = load i32, ptr %2, align 8, !tbaa !467
  br label %114

114:                                              ; preds = %109, %107
  %115 = phi i32 [ 0, %109 ], [ %97, %107 ]
  %116 = phi i32 [ %110, %109 ], [ %98, %107 ]
  %117 = phi i32 [ %111, %109 ], [ %99, %107 ]
  %118 = phi i32 [ %112, %109 ], [ %100, %107 ]
  %119 = phi i32 [ %113, %109 ], [ %97, %107 ]
  %120 = icmp sgt i32 %119, 1
  br i1 %120, label %121, label %165

121:                                              ; preds = %160, %114
  %122 = phi i32 [ %162, %160 ], [ 1, %114 ]
  %123 = sext i32 %122 to i64
  %124 = getelementptr inbounds ptr, ptr %4, i64 %123
  %125 = load ptr, ptr %124, align 8, !tbaa !39
  %126 = icmp eq ptr %125, null
  br i1 %126, label %160, label %127

127:                                              ; preds = %121
  %128 = getelementptr inbounds i8, ptr %125, i64 1
  %129 = load i8, ptr %128, align 1, !tbaa !33
  %130 = sext i8 %129 to i32
  switch i32 %130, label %160 [
    i32 101, label %131
    i32 108, label %145
  ]

131:                                              ; preds = %127
  %132 = getelementptr inbounds i8, ptr %125, i64 2
  %133 = load i8, ptr %132, align 1, !tbaa !33
  %134 = icmp eq i8 %133, 0
  br i1 %134, label %135, label %140

135:                                              ; preds = %131
  %136 = add nsw i32 %122, 1
  %137 = sext i32 %136 to i64
  %138 = getelementptr inbounds ptr, ptr %4, i64 %137
  %139 = load ptr, ptr %138, align 8, !tbaa !39
  br label %140

140:                                              ; preds = %135, %131
  %141 = phi i32 [ %136, %135 ], [ %122, %131 ]
  %142 = phi ptr [ %139, %135 ], [ %132, %131 ]
  %143 = tail call fastcc i32 @dostring(ptr noundef %0, ptr noundef %142, ptr noundef nonnull @.str.11.626) #47
  %144 = icmp eq i32 %143, 0
  br i1 %144, label %160, label %164

145:                                              ; preds = %127
  %146 = getelementptr inbounds i8, ptr %125, i64 2
  %147 = load i8, ptr %146, align 1, !tbaa !33
  %148 = icmp eq i8 %147, 0
  br i1 %148, label %149, label %154

149:                                              ; preds = %145
  %150 = add nsw i32 %122, 1
  %151 = sext i32 %150 to i64
  %152 = getelementptr inbounds ptr, ptr %4, i64 %151
  %153 = load ptr, ptr %152, align 8, !tbaa !39
  br label %154

154:                                              ; preds = %149, %145
  %155 = phi i32 [ %150, %149 ], [ %122, %145 ]
  %156 = phi ptr [ %153, %149 ], [ %146, %145 ]
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -10002, ptr noundef nonnull @.str.12.627) #46
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef %156) #46
  %157 = tail call fastcc i32 @docall(ptr noundef %0, i32 noundef 1, i32 noundef 1) #47
  %158 = tail call fastcc i32 @report(ptr noundef %0, i32 noundef %157) #47
  %159 = icmp eq i32 %157, 0
  br i1 %159, label %160, label %164

160:                                              ; preds = %154, %140, %127, %121
  %161 = phi i32 [ %122, %121 ], [ %122, %127 ], [ %155, %154 ], [ %141, %140 ]
  %162 = add nsw i32 %161, 1
  %163 = icmp slt i32 %162, %119
  br i1 %163, label %121, label %165, !llvm.loop !472

164:                                              ; preds = %154, %140
  store i32 1, ptr %31, align 8, !tbaa !470
  br label %238

165:                                              ; preds = %160, %114
  store i32 0, ptr %31, align 8, !tbaa !470
  %166 = icmp ne i32 %115, 0
  br i1 %166, label %167, label %225

167:                                              ; preds = %167, %165
  %168 = phi i64 [ %172, %167 ], [ 0, %165 ]
  %169 = getelementptr inbounds ptr, ptr %4, i64 %168
  %170 = load ptr, ptr %169, align 8, !tbaa !39
  %171 = icmp eq ptr %170, null
  %172 = add i64 %168, 1
  br i1 %171, label %173, label %167, !llvm.loop !473

173:                                              ; preds = %167
  %.lcssa = phi i64 [ %168, %167 ]
  %174 = trunc i64 %.lcssa to i32
  %175 = add nuw nsw i32 %115, 1
  %176 = sub nsw i32 %174, %175
  %177 = add nsw i32 %176, 3
  tail call void @luaL_checkstack(ptr noundef %0, i32 noundef %177, ptr noundef nonnull @.str.16.628) #46
  %178 = icmp slt i32 %175, %174
  br i1 %178, label %179, label %188

179:                                              ; preds = %173
  %180 = sext i32 %175 to i64
  br label %181

181:                                              ; preds = %181, %179
  %182 = phi i64 [ %180, %179 ], [ %185, %181 ]
  %183 = getelementptr inbounds ptr, ptr %4, i64 %182
  %184 = load ptr, ptr %183, align 8, !tbaa !39
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef %184) #46
  %185 = add nsw i64 %182, 1
  %186 = trunc i64 %185 to i32
  %187 = icmp eq i32 %174, %186
  br i1 %187, label %188, label %181, !llvm.loop !474

188:                                              ; preds = %181, %173
  tail call void @lua_createtable(ptr noundef %0, i32 noundef %176, i32 noundef %175) #46
  %189 = icmp eq i32 %174, 0
  br i1 %189, label %200, label %190

190:                                              ; preds = %188
  %191 = and i64 %.lcssa, 4294967295
  br label %192

192:                                              ; preds = %192, %190
  %193 = phi i64 [ 0, %190 ], [ %198, %192 ]
  %194 = getelementptr inbounds ptr, ptr %4, i64 %193
  %195 = load ptr, ptr %194, align 8, !tbaa !39
  tail call void @lua_pushstring(ptr noundef %0, ptr noundef %195) #46
  %196 = trunc i64 %193 to i32
  %197 = sub nsw i32 %196, %115
  tail call void @lua_rawseti(ptr noundef %0, i32 noundef -2, i32 noundef %197) #46
  %198 = add nuw nsw i64 %193, 1
  %199 = icmp eq i64 %198, %191
  br i1 %199, label %200, label %192, !llvm.loop !475

200:                                              ; preds = %192, %188
  tail call void @lua_setfield(ptr noundef %0, i32 noundef -10002, ptr noundef nonnull @.str.13.629) #46
  %201 = zext i32 %115 to i64
  %202 = getelementptr inbounds ptr, ptr %4, i64 %201
  %203 = load ptr, ptr %202, align 8, !tbaa !39
  %204 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %203, ptr noundef nonnull dereferenceable(2) @.str.14.630) #49
  %205 = icmp eq i32 %204, 0
  br i1 %205, label %206, label %214

206:                                              ; preds = %200
  %207 = add nsw i32 %115, -1
  %208 = zext i32 %207 to i64
  %209 = getelementptr inbounds ptr, ptr %4, i64 %208
  %210 = load ptr, ptr %209, align 8, !tbaa !39
  %211 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %210, ptr noundef nonnull dereferenceable(3) @.str.15.631) #49
  %212 = icmp eq i32 %211, 0
  %213 = select i1 %212, ptr %203, ptr null
  br label %214

214:                                              ; preds = %206, %200
  %215 = phi ptr [ %203, %200 ], [ %213, %206 ]
  %216 = tail call i32 @luaL_loadfile(ptr noundef %0, ptr noundef %215) #46
  %217 = xor i32 %176, -1
  tail call void @lua_insert(ptr noundef %0, i32 noundef %217) #46
  %218 = icmp eq i32 %216, 0
  br i1 %218, label %221, label %219

219:                                              ; preds = %214
  tail call void @lua_settop(ptr noundef %0, i32 noundef %217) #46
  %220 = tail call fastcc i32 @report(ptr noundef %0, i32 noundef %216) #47
  store i32 %216, ptr %31, align 8, !tbaa !470
  br label %238

221:                                              ; preds = %214
  %222 = tail call fastcc i32 @docall(ptr noundef %0, i32 noundef %176, i32 noundef 0) #47
  %223 = tail call fastcc i32 @report(ptr noundef %0, i32 noundef %222) #47
  store i32 %222, ptr %31, align 8, !tbaa !470
  %224 = icmp eq i32 %222, 0
  br i1 %224, label %225, label %238

225:                                              ; preds = %221, %165
  %226 = icmp eq i32 %118, 0
  br i1 %226, label %228, label %227

227:                                              ; preds = %225
  tail call fastcc void @dotty(ptr noundef %0) #47
  br label %238

228:                                              ; preds = %225
  %229 = or i32 %117, %116
  %230 = icmp ne i32 %229, 0
  %231 = select i1 %166, i1 true, i1 %230
  br i1 %231, label %238, label %232

232:                                              ; preds = %228
  %233 = tail call i32 @isatty(i32 noundef 0) #46
  %234 = icmp eq i32 %233, 0
  br i1 %234, label %236, label %235

235:                                              ; preds = %232
  tail call fastcc void @print_version() #47
  tail call fastcc void @dotty(ptr noundef %0) #47
  br label %238

236:                                              ; preds = %232
  %237 = tail call fastcc i32 @dofile(ptr noundef %0, ptr noundef null) #47
  br label %238

238:                                              ; preds = %236, %235, %228, %227, %221, %219, %164, %90, %26
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @report(ptr noundef %0, i32 noundef returned %1) unnamed_addr #1 {
  %3 = icmp eq i32 %1, 0
  br i1 %3, label %12, label %4

4:                                                ; preds = %2
  %5 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %12, label %7

7:                                                ; preds = %4
  %8 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef -1, ptr noundef null) #46
  %9 = icmp eq ptr %8, null
  %10 = select i1 %9, ptr @.str.27.620, ptr %8
  %11 = load ptr, ptr @progname, align 8, !tbaa !39
  tail call fastcc void @l_message(ptr noundef %11, ptr noundef nonnull %10) #47
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  br label %12

12:                                               ; preds = %7, %4, %2
  ret i32 %1
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @dofile(ptr noundef %0, ptr noundef %1) unnamed_addr #1 {
  %3 = tail call i32 @luaL_loadfile(ptr noundef %0, ptr noundef %1) #46
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %9

5:                                                ; preds = %2
  %6 = tail call fastcc i32 @docall(ptr noundef %0, i32 noundef 0, i32 noundef 1) #47
  %7 = icmp ne i32 %6, 0
  %8 = zext i1 %7 to i32
  br label %9

9:                                                ; preds = %5, %2
  %10 = phi i32 [ 1, %2 ], [ %8, %5 ]
  %11 = tail call fastcc i32 @report(ptr noundef %0, i32 noundef %10) #47
  ret i32 %10
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @dostring(ptr noundef %0, ptr noundef %1, ptr noundef %2) unnamed_addr #1 {
  %4 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %1) #49
  %5 = tail call i32 @luaL_loadbuffer(ptr noundef %0, ptr noundef %1, i64 noundef %4, ptr noundef %2) #46
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %11

7:                                                ; preds = %3
  %8 = tail call fastcc i32 @docall(ptr noundef %0, i32 noundef 0, i32 noundef 1) #47
  %9 = icmp ne i32 %8, 0
  %10 = zext i1 %9 to i32
  br label %11

11:                                               ; preds = %7, %3
  %12 = phi i32 [ 1, %3 ], [ %10, %7 ]
  %13 = tail call fastcc i32 @report(ptr noundef %0, i32 noundef %12) #47
  ret i32 %12
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @docall(ptr noundef %0, i32 noundef %1, i32 noundef %2) unnamed_addr #1 {
  %4 = tail call i32 @lua_gettop(ptr noundef %0) #46
  %5 = sub nsw i32 %4, %1
  tail call void @lua_pushcclosure(ptr noundef %0, ptr noundef nonnull @traceback, i32 noundef 0) #46
  tail call void @lua_insert(ptr noundef %0, i32 noundef %5) #46
  %6 = tail call ptr @signal(i32 noundef 2, ptr noundef nonnull @laction) #46
  %7 = icmp eq i32 %2, 0
  %8 = sext i1 %7 to i32
  %9 = tail call i32 @lua_pcall(ptr noundef %0, i32 noundef %1, i32 noundef %8, i32 noundef %5) #46
  %10 = tail call ptr @signal(i32 noundef 2, ptr noundef null) #46
  tail call void @lua_remove(ptr noundef %0, i32 noundef %5) #46
  %11 = icmp eq i32 %9, 0
  br i1 %11, label %14, label %12

12:                                               ; preds = %3
  %13 = tail call i32 @lua_gc(ptr noundef %0, i32 noundef 2, i32 noundef 0) #46
  br label %14

14:                                               ; preds = %12, %3
  ret i32 %9
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @dotty(ptr noundef %0) unnamed_addr #1 {
  %2 = alloca i64, align 8
  %3 = load ptr, ptr @progname, align 8, !tbaa !39
  store ptr null, ptr @progname, align 8, !tbaa !39
  br label %4

4:                                                ; preds = %28, %1
  call void @lua_settop(ptr noundef %0, i32 noundef 0) #46
  %5 = call fastcc i32 @pushline(ptr noundef %0, i32 noundef 1) #47, !range !75
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %45, label %7

7:                                                ; preds = %23, %4
  %8 = call ptr @lua_tolstring(ptr noundef %0, i32 noundef 1, ptr noundef null) #46
  %9 = call i64 @lua_objlen(ptr noundef %0, i32 noundef 1) #46
  %10 = call i32 @luaL_loadbuffer(ptr noundef %0, ptr noundef %8, i64 noundef %9, ptr noundef nonnull @.str.20.632) #46
  %11 = icmp eq i32 %10, 3
  br i1 %11, label %12, label %24

12:                                               ; preds = %7
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2) #48
  %13 = call ptr @lua_tolstring(ptr noundef %0, i32 noundef -1, ptr noundef nonnull %2) #46
  %14 = load i64, ptr %2, align 8, !tbaa !40
  %15 = getelementptr inbounds i8, ptr %13, i64 %14
  %16 = getelementptr inbounds i8, ptr %15, i64 -7
  %17 = call ptr @strstr(ptr noundef nonnull dereferenceable(1) %13, ptr noundef nonnull dereferenceable(1) @.str.26.633) #49
  %18 = icmp eq ptr %17, %16
  br i1 %18, label %20, label %19

19:                                               ; preds = %12
  %.lcssa1 = phi i32 [ %10, %12 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  call void @lua_remove(ptr noundef %0, i32 noundef 1) #46
  br label %25

20:                                               ; preds = %12
  call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2) #48
  %21 = call fastcc i32 @pushline(ptr noundef %0, i32 noundef 0) #47, !range !75
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %45, label %23

23:                                               ; preds = %20
  call void @lua_pushlstring(ptr noundef %0, ptr noundef nonnull @.str.19.634, i64 noundef 1) #46
  call void @lua_insert(ptr noundef %0, i32 noundef -2) #46
  call void @lua_concat(ptr noundef %0, i32 noundef 3) #46
  br label %7

24:                                               ; preds = %7
  %.lcssa = phi i32 [ %10, %7 ]
  call void @lua_remove(ptr noundef %0, i32 noundef 1) #46
  switch i32 %.lcssa, label %25 [
    i32 -1, label %45
    i32 0, label %29
  ]

25:                                               ; preds = %24, %19
  %26 = phi i32 [ %.lcssa, %24 ], [ %.lcssa1, %19 ]
  %27 = call fastcc i32 @report(ptr noundef %0, i32 noundef %26) #47
  br label %28

28:                                               ; preds = %41, %36, %33, %29, %25
  br label %4, !llvm.loop !476

29:                                               ; preds = %24
  %30 = call fastcc i32 @docall(ptr noundef %0, i32 noundef 0, i32 noundef 0) #47
  %31 = call fastcc i32 @report(ptr noundef %0, i32 noundef %30) #47
  %32 = icmp eq i32 %30, 0
  br i1 %32, label %33, label %28

33:                                               ; preds = %29
  %34 = call i32 @lua_gettop(ptr noundef %0) #46
  %35 = icmp sgt i32 %34, 0
  br i1 %35, label %36, label %28

36:                                               ; preds = %33
  call void @lua_getfield(ptr noundef %0, i32 noundef -10002, ptr noundef nonnull @.str.17.635) #46
  call void @lua_insert(ptr noundef %0, i32 noundef 1) #46
  %37 = call i32 @lua_gettop(ptr noundef %0) #46
  %38 = add nsw i32 %37, -1
  %39 = call i32 @lua_pcall(ptr noundef %0, i32 noundef %38, i32 noundef 0, i32 noundef 0) #46
  %40 = icmp eq i32 %39, 0
  br i1 %40, label %28, label %41

41:                                               ; preds = %36
  %42 = load ptr, ptr @progname, align 8, !tbaa !39
  %43 = call ptr @lua_tolstring(ptr noundef %0, i32 noundef -1, ptr noundef null) #46
  %44 = call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.18.636, ptr noundef %43) #46
  call fastcc void @l_message(ptr noundef %42, ptr noundef %44) #47
  br label %28

45:                                               ; preds = %24, %20, %4
  call void @lua_settop(ptr noundef %0, i32 noundef 0) #46
  %46 = load ptr, ptr @stdout, align 8, !tbaa !39
  %47 = call i32 @fputs(ptr noundef nonnull @.str.19.634, ptr noundef %46) #47
  %48 = load ptr, ptr @stdout, align 8, !tbaa !39
  %49 = call i32 @fflush(ptr noundef %48) #47
  store ptr %3, ptr @progname, align 8, !tbaa !39
  ret void
}

; Function Attrs: nounwind optsize
declare i32 @isatty(i32 noundef) local_unnamed_addr #27

; Function Attrs: nofree nounwind optsize uwtable
define internal fastcc void @print_version() unnamed_addr #29 {
  %1 = load ptr, ptr @stderr, align 8, !tbaa !39
  %2 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %1, ptr noundef nonnull @.str.3.624, ptr noundef nonnull @.str.10.625) #54
  %3 = load ptr, ptr @stderr, align 8, !tbaa !39
  %4 = tail call i32 @fflush(ptr noundef %3) #47
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @pushline(ptr noundef %0, i32 noundef %1) unnamed_addr #1 {
  %3 = alloca [512 x i8], align 16
  call void @llvm.lifetime.start.p0(i64 512, ptr nonnull %3) #48
  %4 = icmp eq i32 %1, 0
  %5 = select i1 %4, ptr @.str.23.637, ptr @.str.22.638
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -10002, ptr noundef nonnull %5) #46
  %6 = tail call ptr @lua_tolstring(ptr noundef %0, i32 noundef -1, ptr noundef null) #46
  %7 = icmp eq ptr %6, null
  %8 = select i1 %4, ptr @.str.25.639, ptr @.str.24.640
  %9 = select i1 %7, ptr %8, ptr %6
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  %10 = load ptr, ptr @stdout, align 8, !tbaa !39
  %11 = tail call i32 @fputs(ptr noundef nonnull %9, ptr noundef %10) #47
  %12 = load ptr, ptr @stdout, align 8, !tbaa !39
  %13 = tail call i32 @fflush(ptr noundef %12) #47
  %14 = load ptr, ptr @stdin, align 8, !tbaa !39
  %15 = call ptr @fgets(ptr noundef nonnull %3, i32 noundef 512, ptr noundef %14) #47
  %16 = icmp eq ptr %15, null
  br i1 %16, label %35, label %17

17:                                               ; preds = %2
  %18 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %3) #49
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %26, label %20

20:                                               ; preds = %17
  %21 = add i64 %18, -1
  %22 = getelementptr inbounds i8, ptr %3, i64 %21
  %23 = load i8, ptr %22, align 1, !tbaa !33
  %24 = icmp eq i8 %23, 10
  br i1 %24, label %25, label %26

25:                                               ; preds = %20
  store i8 0, ptr %22, align 1, !tbaa !33
  br label %26

26:                                               ; preds = %25, %20, %17
  %27 = icmp ne i32 %1, 0
  %28 = load i8, ptr %3, align 16
  %29 = icmp eq i8 %28, 61
  %30 = select i1 %27, i1 %29, i1 false
  br i1 %30, label %31, label %34

31:                                               ; preds = %26
  %32 = getelementptr inbounds i8, ptr %3, i64 1
  %33 = call ptr (ptr, ptr, ...) @lua_pushfstring(ptr noundef %0, ptr noundef nonnull @.str.21.641, ptr noundef nonnull %32) #46
  br label %35

34:                                               ; preds = %26
  call void @lua_pushstring(ptr noundef %0, ptr noundef nonnull %3) #46
  br label %35

35:                                               ; preds = %34, %31, %2
  %36 = phi i32 [ 0, %2 ], [ 1, %34 ], [ 1, %31 ]
  call void @llvm.lifetime.end.p0(i64 512, ptr nonnull %3) #48
  ret i32 %36
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @traceback(ptr noundef %0) #1 {
  %2 = tail call i32 @lua_isstring(ptr noundef %0, i32 noundef 1) #46
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %13, label %4

4:                                                ; preds = %1
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -10002, ptr noundef nonnull @.str.6.643) #46
  %5 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %6 = icmp eq i32 %5, 5
  br i1 %6, label %8, label %7

7:                                                ; preds = %4
  tail call void @lua_settop(ptr noundef %0, i32 noundef -2) #46
  br label %13

8:                                                ; preds = %4
  tail call void @lua_getfield(ptr noundef %0, i32 noundef -1, ptr noundef nonnull @.str.7.644) #46
  %9 = tail call i32 @lua_type(ptr noundef %0, i32 noundef -1) #46
  %10 = icmp eq i32 %9, 6
  br i1 %10, label %12, label %11

11:                                               ; preds = %8
  tail call void @lua_settop(ptr noundef %0, i32 noundef -3) #46
  br label %13

12:                                               ; preds = %8
  tail call void @lua_pushvalue(ptr noundef %0, i32 noundef 1) #46
  tail call void @lua_pushinteger(ptr noundef %0, i64 noundef 2) #46
  tail call void @lua_call(ptr noundef %0, i32 noundef 2, i32 noundef 1) #46
  br label %13

13:                                               ; preds = %12, %11, %7, %1
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal void @laction(i32 noundef %0) #1 {
  %2 = tail call ptr @signal(i32 noundef %0, ptr noundef null) #46
  %3 = load ptr, ptr @globalL, align 8, !tbaa !39
  %4 = tail call i32 @lua_sethook(ptr noundef %3, ptr noundef nonnull @lstop, i32 noundef 11, i32 noundef 1) #46
  ret void
}

; Function Attrs: nounwind optsize
declare ptr @signal(i32 noundef, ptr noundef) local_unnamed_addr #27

; Function Attrs: nounwind optsize uwtable
define internal void @lstop(ptr noundef %0, ptr nocapture readnone %1) #1 {
  %3 = tail call i32 @lua_sethook(ptr noundef %0, ptr noundef null, i32 noundef 0, i32 noundef 0) #46
  %4 = tail call i32 (ptr, ptr, ...) @luaL_error(ptr noundef %0, ptr noundef nonnull @.str.8.642) #46
  ret void
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind optsize willreturn memory(write, argmem: readwrite, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nounwind optsize uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { nofree norecurse nosync nounwind optsize memory(readwrite, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: readwrite) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { mustprogress nofree norecurse nosync nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: read) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { nofree norecurse nosync nounwind optsize memory(write, argmem: readwrite, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { mustprogress nofree norecurse nosync nounwind optsize willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { mustprogress nofree norecurse nosync nounwind optsize willreturn memory(none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #10 = { mustprogress nofree nounwind optsize willreturn memory(argmem: read) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { nocallback nofree nosync nounwind willreturn }
attributes #12 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #13 = { mustprogress nofree nosync nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #14 = { nofree norecurse nosync nounwind optsize memory(read, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #15 = { mustprogress nofree nounwind optsize willreturn memory(write) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #16 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #17 = { mustprogress nofree norecurse nosync nounwind optsize willreturn memory(argmem: write) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #18 = { nofree norecurse nosync nounwind optsize memory(read, argmem: readwrite, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #19 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite) }
attributes #20 = { noreturn nounwind optsize uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #21 = { noreturn nounwind optsize "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #22 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #23 = { nounwind optsize returns_twice "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #24 = { nofree nosync nounwind optsize memory(readwrite, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #25 = { nofree nosync nounwind optsize memory(read, argmem: readwrite, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #26 = { mustprogress nofree nosync nounwind optsize willreturn memory(none) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #27 = { nounwind optsize "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #28 = { nofree norecurse nosync nounwind optsize memory(none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #29 = { nofree nounwind optsize uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #30 = { mustprogress nofree nounwind optsize willreturn "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #31 = { nofree nounwind optsize "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #32 = { mustprogress nofree nounwind optsize willreturn memory(readwrite, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #33 = { mustprogress nofree nounwind optsize willreturn memory(argmem: readwrite) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #34 = { nofree nounwind willreturn memory(argmem: read) }
attributes #35 = { mustprogress nofree norecurse nosync nounwind optsize willreturn memory(read, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #36 = { nofree nounwind optsize memory(read) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #37 = { mustprogress nofree nounwind optsize willreturn memory(read) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #38 = { mustprogress nofree nosync nounwind optsize willreturn memory(argmem: write) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #39 = { optsize "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #40 = { nofree nounwind optsize memory(read) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #41 = { mustprogress nounwind optsize willreturn memory(argmem: readwrite, inaccessiblemem: readwrite) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #42 = { mustprogress nounwind optsize willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #43 = { mustprogress nounwind optsize willreturn allockind("realloc") allocsize(1) memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #44 = { mustprogress nofree nounwind optsize willreturn memory(argmem: write) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #45 = { mustprogress nofree nounwind optsize willreturn memory(read) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #46 = { nounwind optsize }
attributes #47 = { optsize }
attributes #48 = { nounwind }
attributes #49 = { nounwind optsize willreturn memory(read) }
attributes #50 = { noreturn nounwind optsize }
attributes #51 = { nounwind optsize returns_twice }
attributes #52 = { nounwind optsize willreturn memory(none) }
attributes #53 = { nounwind optsize allocsize(1) }
attributes #54 = { cold optsize }
attributes #55 = { cold }

!llvm.ident = !{!0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0}
!llvm.module.flags = !{!1, !2, !3, !4, !5, !6}

!0 = !{!"clang version 17.0.6 (https://github.com/Casperento/llvm-project.git 9b0073551ece0d22bf3378af2b03e456a26031b6)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"uwtable", i32 2}
!5 = !{i32 1, !"ThinLTO", i32 0}
!6 = !{i32 1, !"EnableSplitLTOUnit", i32 1}
!7 = !{!8, !9, i64 16}
!8 = !{!"lua_State", !9, i64 0, !10, i64 8, !10, i64 9, !10, i64 10, !9, i64 16, !9, i64 24, !9, i64 32, !9, i64 40, !9, i64 48, !9, i64 56, !9, i64 64, !9, i64 72, !9, i64 80, !12, i64 88, !12, i64 92, !13, i64 96, !13, i64 98, !10, i64 100, !10, i64 101, !12, i64 104, !12, i64 108, !9, i64 112, !14, i64 120, !14, i64 136, !9, i64 152, !9, i64 160, !9, i64 168, !15, i64 176}
!9 = !{!"any pointer", !10, i64 0}
!10 = !{!"omnipotent char", !11, i64 0}
!11 = !{!"Simple C/C++ TBAA"}
!12 = !{!"int", !10, i64 0}
!13 = !{!"short", !10, i64 0}
!14 = !{!"lua_TValue", !10, i64 0, !12, i64 8}
!15 = !{!"long", !10, i64 0}
!16 = !{!14, !12, i64 8}
!17 = !{!8, !9, i64 24}
!18 = !{!8, !9, i64 56}
!19 = !{!8, !9, i64 40}
!20 = !{!21, !9, i64 16}
!21 = !{!"CallInfo", !9, i64 0, !9, i64 8, !9, i64 16, !9, i64 24, !12, i64 32, !12, i64 36}
!22 = distinct !{!22, !23}
!23 = !{!"llvm.loop.mustprogress"}
!24 = !{!8, !13, i64 96}
!25 = !{!8, !9, i64 32}
!26 = !{!27, !9, i64 152}
!27 = !{!"global_State", !28, i64 0, !9, i64 16, !9, i64 24, !10, i64 32, !10, i64 33, !12, i64 36, !9, i64 40, !9, i64 48, !9, i64 56, !9, i64 64, !9, i64 72, !9, i64 80, !29, i64 88, !15, i64 112, !15, i64 120, !15, i64 128, !15, i64 136, !12, i64 144, !12, i64 148, !9, i64 152, !14, i64 160, !9, i64 176, !30, i64 184, !10, i64 224, !10, i64 296}
!28 = !{!"stringtable", !9, i64 0, !12, i64 8, !12, i64 12}
!29 = !{!"Mbuffer", !9, i64 0, !15, i64 8, !15, i64 16}
!30 = !{!"UpVal", !9, i64 0, !10, i64 8, !10, i64 9, !9, i64 16, !10, i64 24}
!31 = !{!27, !15, i64 120}
!32 = !{!27, !15, i64 112}
!33 = !{!10, !10, i64 0}
!34 = distinct !{!34, !23}
!35 = distinct !{!35, !23}
!36 = !{!21, !9, i64 8}
!37 = distinct !{!37, !23}
!38 = !{!8, !9, i64 80}
!39 = !{!9, !9, i64 0}
!40 = !{!15, !15, i64 0}
!41 = distinct !{!41, !23}
!42 = !{!27, !9, i64 176}
!43 = !{!8, !9, i64 64}
!44 = !{!45, !9, i64 0}
!45 = !{!"CallS", !9, i64 0, !12, i64 8}
!46 = !{!45, !12, i64 8}
!47 = !{!48, !9, i64 0}
!48 = !{!"CCallS", !9, i64 0, !9, i64 8}
!49 = !{!48, !9, i64 8}
!50 = !{!8, !10, i64 10}
!51 = !{!27, !10, i64 33}
!52 = distinct !{!52, !23}
!53 = !{!27, !12, i64 144}
!54 = !{!27, !12, i64 148}
!55 = !{!56, !12, i64 72}
!56 = !{!"Proto", !9, i64 0, !10, i64 8, !10, i64 9, !9, i64 16, !9, i64 24, !9, i64 32, !9, i64 40, !9, i64 48, !9, i64 56, !9, i64 64, !12, i64 72, !12, i64 76, !12, i64 80, !12, i64 84, !12, i64 88, !12, i64 92, !12, i64 96, !12, i64 100, !9, i64 104, !10, i64 112, !10, i64 113, !10, i64 114, !10, i64 115}
!57 = !{!30, !9, i64 16}
!58 = !{!56, !9, i64 56}
!59 = !{!60, !12, i64 48}
!60 = !{!"FuncState", !9, i64 0, !9, i64 8, !9, i64 16, !9, i64 24, !9, i64 32, !9, i64 40, !12, i64 48, !12, i64 52, !12, i64 56, !12, i64 60, !12, i64 64, !12, i64 68, !13, i64 72, !10, i64 74, !10, i64 75, !10, i64 196}
!61 = !{!60, !12, i64 52}
!62 = !{!60, !10, i64 74}
!63 = !{!60, !9, i64 0}
!64 = !{!56, !9, i64 24}
!65 = !{!12, !12, i64 0}
!66 = !{!60, !9, i64 24}
!67 = !{!68, !12, i64 8}
!68 = !{!"LexState", !12, i64 0, !12, i64 4, !12, i64 8, !69, i64 16, !69, i64 32, !9, i64 48, !9, i64 56, !9, i64 64, !9, i64 72, !9, i64 80, !10, i64 88}
!69 = !{!"Token", !12, i64 0, !10, i64 8}
!70 = !{!60, !12, i64 56}
!71 = !{!56, !12, i64 80}
!72 = !{!60, !9, i64 32}
!73 = !{!56, !12, i64 84}
!74 = !{!56, !9, i64 40}
!75 = !{i32 0, i32 2}
!76 = distinct !{!76, !23}
!77 = distinct !{!77, !23}
!78 = !{!60, !12, i64 60}
!79 = !{!56, !10, i64 115}
!80 = !{!60, !9, i64 8}
!81 = !{!56, !12, i64 76}
!82 = !{!60, !12, i64 64}
!83 = !{!56, !9, i64 16}
!84 = distinct !{!84, !23}
!85 = !{!86, !10, i64 0}
!86 = !{!"expdesc", !10, i64 0, !10, i64 8, !12, i64 16, !12, i64 20}
!87 = !{!86, !12, i64 16}
!88 = !{!86, !12, i64 20}
!89 = !{i64 0, i64 4, !33, i64 8, i64 4, !65, i64 12, i64 4, !65, i64 8, i64 8, !90, i64 16, i64 4, !65, i64 20, i64 4, !65}
!90 = !{!91, !91, i64 0}
!91 = !{!"double", !10, i64 0}
!92 = !{!8, !9, i64 112}
!93 = !{!8, !12, i64 104}
!94 = !{!8, !12, i64 108}
!95 = !{!8, !10, i64 100}
!96 = !{!21, !12, i64 36}
!97 = distinct !{!97, !23}
!98 = !{!99, !12, i64 116}
!99 = !{!"lua_Debug", !12, i64 0, !9, i64 8, !9, i64 16, !9, i64 24, !9, i64 32, !12, i64 40, !12, i64 44, !12, i64 48, !12, i64 52, !10, i64 56, !12, i64 116}
!100 = !{!21, !9, i64 0}
!101 = !{!21, !9, i64 24}
!102 = !{!8, !9, i64 48}
!103 = !{!99, !9, i64 32}
!104 = !{!99, !12, i64 48}
!105 = !{!56, !9, i64 64}
!106 = !{!56, !12, i64 96}
!107 = !{!56, !12, i64 100}
!108 = !{!99, !12, i64 40}
!109 = !{!99, !12, i64 44}
!110 = !{!99, !9, i64 16}
!111 = !{!99, !9, i64 8}
!112 = distinct !{!112, !23}
!113 = !{!99, !9, i64 24}
!114 = !{!99, !12, i64 52}
!115 = distinct !{!115, !23}
!116 = !{!56, !10, i64 113}
!117 = !{!56, !10, i64 114}
!118 = !{!56, !10, i64 112}
!119 = distinct !{!119, !23}
!120 = !{!56, !12, i64 88}
!121 = !{!56, !9, i64 32}
!122 = distinct !{!122, !23}
!123 = distinct !{!123, !23}
!124 = distinct !{!124, !23}
!125 = !{!8, !15, i64 176}
!126 = !{!8, !9, i64 168}
!127 = !{!128, !12, i64 208}
!128 = !{!"lua_longjmp", !9, i64 0, !10, i64 8, !12, i64 208}
!129 = !{!8, !13, i64 98}
!130 = !{!8, !10, i64 101}
!131 = !{!8, !12, i64 92}
!132 = !{!8, !9, i64 72}
!133 = !{!128, !9, i64 0}
!134 = !{!8, !12, i64 88}
!135 = distinct !{!135, !23}
!136 = distinct !{!136, !23}
!137 = !{!99, !12, i64 0}
!138 = distinct !{!138, !23}
!139 = !{!140, !10, i64 10}
!140 = !{!"LClosure", !9, i64 0, !10, i64 8, !10, i64 9, !10, i64 10, !10, i64 11, !9, i64 16, !9, i64 24, !9, i64 32, !10, i64 40}
!141 = !{!140, !9, i64 32}
!142 = distinct !{!142, !23}
!143 = distinct !{!143, !23}
!144 = distinct !{!144, !23}
!145 = !{!21, !12, i64 32}
!146 = distinct !{!146, !23}
!147 = distinct !{!147, !23}
!148 = distinct !{!148, !23}
!149 = distinct !{!149, !23}
!150 = !{i32 0, i32 3}
!151 = !{!152, !9, i64 0}
!152 = !{!"SParser", !9, i64 0, !29, i64 8, !9, i64 32}
!153 = !{!152, !9, i64 32}
!154 = !{!152, !9, i64 8}
!155 = !{!152, !15, i64 24}
!156 = !{ptr @luaU_undump, ptr @luaY_parser}
!157 = distinct !{!157, !23}
!158 = !{!159, !9, i64 0}
!159 = !{!"", !9, i64 0, !9, i64 8, !9, i64 16, !12, i64 24, !12, i64 28}
!160 = !{!159, !9, i64 8}
!161 = !{!159, !9, i64 16}
!162 = !{!159, !12, i64 24}
!163 = !{!159, !12, i64 28}
!164 = distinct !{!164, !23}
!165 = distinct !{!165, !23}
!166 = !{!56, !12, i64 92}
!167 = !{!56, !9, i64 48}
!168 = !{!169, !9, i64 0}
!169 = !{!"LocVar", !9, i64 0, !12, i64 8, !12, i64 12}
!170 = !{!169, !12, i64 8}
!171 = !{!169, !12, i64 12}
!172 = distinct !{!172, !23}
!173 = distinct !{!173, !23}
!174 = distinct !{!174, !23}
!175 = !{!27, !10, i64 32}
!176 = !{!30, !10, i64 8}
!177 = !{!30, !10, i64 9}
!178 = !{!30, !9, i64 0}
!179 = !{!8, !9, i64 152}
!180 = distinct !{!180, !23}
!181 = distinct !{!181, !23}
!182 = !{!183, !10, i64 10}
!183 = !{!"Table", !9, i64 0, !10, i64 8, !10, i64 9, !10, i64 10, !10, i64 11, !9, i64 16, !9, i64 24, !9, i64 32, !9, i64 40, !9, i64 48, !12, i64 56}
!184 = !{!27, !9, i64 80}
!185 = distinct !{!185, !23}
!186 = distinct !{!186, !23}
!187 = !{!8, !9, i64 0}
!188 = !{!27, !12, i64 12}
!189 = !{!27, !9, i64 0}
!190 = distinct !{!190, !23}
!191 = !{!27, !9, i64 40}
!192 = !{!27, !12, i64 8}
!193 = distinct !{!193, !23}
!194 = !{!27, !15, i64 136}
!195 = distinct !{!195, !23}
!196 = !{!27, !15, i64 128}
!197 = !{!27, !9, i64 56}
!198 = !{i64 -120259084224, i64 120259084417}
!199 = distinct !{!199, !23}
!200 = distinct !{!200, !23}
!201 = !{!27, !9, i64 72}
!202 = !{!27, !9, i64 64}
!203 = distinct !{!203, !23}
!204 = !{!183, !10, i64 9}
!205 = !{!183, !12, i64 56}
!206 = !{!183, !9, i64 24}
!207 = distinct !{!207, !23}
!208 = !{!183, !10, i64 11}
!209 = !{!183, !9, i64 32}
!210 = !{!211, !12, i64 8}
!211 = !{!"Node", !14, i64 0, !10, i64 16}
!212 = distinct !{!212, !23}
!213 = !{!183, !9, i64 48}
!214 = distinct !{!214, !23}
!215 = !{!27, !12, i64 36}
!216 = !{!27, !9, i64 48}
!217 = !{!27, !15, i64 104}
!218 = !{!27, !9, i64 88}
!219 = !{!8, !12, i64 128}
!220 = !{!27, !12, i64 168}
!221 = !{!183, !9, i64 16}
!222 = distinct !{!222, !23}
!223 = distinct !{!223, !23}
!224 = distinct !{!224, !23}
!225 = distinct !{!225, !23}
!226 = !{!8, !9, i64 160}
!227 = distinct !{!227, !23}
!228 = distinct !{!228, !23}
!229 = distinct !{!229, !23}
!230 = !{!56, !9, i64 104}
!231 = distinct !{!231, !23}
!232 = distinct !{!232, !23}
!233 = distinct !{!233, !23}
!234 = distinct !{!234, !23}
!235 = distinct !{!235, !23}
!236 = distinct !{!236, !23}
!237 = distinct !{!237, !23}
!238 = distinct !{!238, !23}
!239 = !{!13, !13, i64 0}
!240 = !{!68, !9, i64 56}
!241 = !{!68, !9, i64 80}
!242 = !{!68, !12, i64 4}
!243 = !{!68, !9, i64 72}
!244 = !{!29, !9, i64 0}
!245 = !{!29, !15, i64 8}
!246 = !{!29, !15, i64 16}
!247 = !{!68, !12, i64 16}
!248 = !{!68, !9, i64 48}
!249 = !{!68, !10, i64 88}
!250 = !{!68, !12, i64 32}
!251 = !{!68, !9, i64 64}
!252 = !{!253, !15, i64 0}
!253 = !{!"Zio", !15, i64 0, !9, i64 8, !9, i64 16, !9, i64 24, !9, i64 32}
!254 = !{!253, !9, i64 8}
!255 = !{!68, !12, i64 0}
!256 = !{i64 0, i64 4, !65, i64 8, i64 8, !90, i64 8, i64 8, !39}
!257 = distinct !{!257, !23}
!258 = distinct !{!258, !23}
!259 = distinct !{!259, !23}
!260 = distinct !{!260, !23}
!261 = distinct !{!261, !23}
!262 = distinct !{!262, !23}
!263 = distinct !{!263, !23}
!264 = distinct !{!264, !23}
!265 = !{!266, !9, i64 0}
!266 = !{!"lconv", !9, i64 0, !9, i64 8, !9, i64 16, !9, i64 24, !9, i64 32, !9, i64 40, !9, i64 48, !9, i64 56, !9, i64 64, !9, i64 72, !10, i64 80, !10, i64 81, !10, i64 82, !10, i64 83, !10, i64 84, !10, i64 85, !10, i64 86, !10, i64 87, !10, i64 88, !10, i64 89, !10, i64 90, !10, i64 91, !10, i64 92, !10, i64 93}
!267 = !{!27, !9, i64 16}
!268 = !{!27, !9, i64 24}
!269 = distinct !{!269, !23}
!270 = distinct !{!270, !23}
!271 = distinct !{!271, !23}
!272 = !{!60, !9, i64 16}
!273 = !{!60, !9, i64 40}
!274 = distinct !{!274, !23}
!275 = !{!276, !12, i64 8}
!276 = !{!"BlockCnt", !9, i64 0, !12, i64 8, !10, i64 12, !10, i64 13, !10, i64 14}
!277 = !{!276, !10, i64 14}
!278 = !{!276, !10, i64 12}
!279 = !{!276, !10, i64 13}
!280 = !{!276, !9, i64 0}
!281 = !{i32 0, i32 16}
!282 = distinct !{!282, !23}
!283 = distinct !{!283, !23}
!284 = distinct !{!284, !23}
!285 = !{!286, !10, i64 8}
!286 = !{!"LHS_assign", !9, i64 0, !86, i64 8}
!287 = !{!286, !9, i64 0}
!288 = distinct !{!288, !23}
!289 = distinct !{!289, !23}
!290 = !{!60, !12, i64 68}
!291 = !{!60, !13, i64 72}
!292 = distinct !{!292, !23}
!293 = !{!294, !10, i64 0}
!294 = !{!"", !10, i64 0, !10, i64 1}
!295 = !{!294, !10, i64 1}
!296 = distinct !{!296, !23}
!297 = distinct !{!297, !23}
!298 = distinct !{!298, !23}
!299 = distinct !{!299, !23}
!300 = !{i32 6, i32 9}
!301 = distinct !{!301, !23}
!302 = !{!303, !10, i64 0}
!303 = !{!"upvaldesc", !10, i64 0, !10, i64 1}
!304 = !{!303, !10, i64 1}
!305 = distinct !{!305, !23}
!306 = distinct !{!306, !23}
!307 = !{!308, !12, i64 40}
!308 = !{!"ConsControl", !86, i64 0, !9, i64 24, !12, i64 32, !12, i64 36, !12, i64 40}
!309 = !{!308, !12, i64 32}
!310 = !{!308, !12, i64 36}
!311 = !{!308, !9, i64 24}
!312 = !{!308, !10, i64 0}
!313 = distinct !{!313, !23}
!314 = distinct !{!314, !23}
!315 = distinct !{!315, !23}
!316 = distinct !{!316, !23}
!317 = distinct !{!317, !23}
!318 = !{!8, !10, i64 8}
!319 = !{!8, !10, i64 9}
!320 = distinct !{!320, !23}
!321 = !{!28, !12, i64 12}
!322 = !{!28, !9, i64 0}
!323 = distinct !{!323, !23}
!324 = distinct !{!324, !23}
!325 = distinct !{!325, !23}
!326 = distinct !{!326, !23}
!327 = !{!28, !12, i64 8}
!328 = distinct !{!328, !23}
!329 = distinct !{!329, !23}
!330 = distinct !{!330, !23}
!331 = distinct !{!331, !23}
!332 = distinct !{!332, !23}
!333 = distinct !{!333, !23}
!334 = distinct !{!334, !23}
!335 = !{!183, !9, i64 40}
!336 = distinct !{!336, !23}
!337 = distinct !{!337, !23}
!338 = distinct !{!338, !23}
!339 = distinct !{!339, !23}
!340 = distinct !{!340, !23}
!341 = distinct !{!341, !23}
!342 = distinct !{!342, !23}
!343 = distinct !{!343, !23}
!344 = !{i64 0, i64 8, !39, i64 0, i64 8, !39, i64 0, i64 8, !90, i64 0, i64 4, !65, i64 8, i64 4, !65, i64 16, i64 8, !39, i64 16, i64 8, !39, i64 16, i64 8, !90, i64 16, i64 4, !65, i64 24, i64 4, !65, i64 32, i64 8, !39, i64 16, i64 8, !39, i64 16, i64 8, !39, i64 16, i64 8, !90, i64 16, i64 4, !65, i64 24, i64 4, !65}
!345 = distinct !{!345, !23}
!346 = distinct !{!346, !23}
!347 = distinct !{!347, !23}
!348 = distinct !{!348, !23}
!349 = distinct !{!349, !23}
!350 = distinct !{!350, !23}
!351 = !{!352, !9, i64 24}
!352 = !{!"", !9, i64 0, !9, i64 8, !9, i64 16, !9, i64 24}
!353 = !{!352, !9, i64 0}
!354 = !{!352, !9, i64 8}
!355 = !{!352, !9, i64 16}
!356 = distinct !{!356, !23, !357, !358}
!357 = !{!"llvm.loop.isvectorized", i32 1}
!358 = !{!"llvm.loop.unroll.runtime.disable"}
!359 = distinct !{!359, !23}
!360 = distinct !{!360, !23}
!361 = distinct !{!361, !23}
!362 = distinct !{!362, !23, !357, !358}
!363 = distinct !{!363, !23}
!364 = distinct !{!364, !23}
!365 = distinct !{!365, !23}
!366 = distinct !{!366, !23}
!367 = distinct !{!367, !23}
!368 = !{i32 -1, i32 2}
!369 = distinct !{!369, !23}
!370 = distinct !{!370, !23}
!371 = distinct !{!371, !23}
!372 = distinct !{!372, !23}
!373 = !{!140, !9, i64 24}
!374 = distinct !{!374, !23}
!375 = distinct !{!375, !23}
!376 = distinct !{!376, !23}
!377 = distinct !{!377, !23}
!378 = !{!253, !9, i64 32}
!379 = !{!253, !9, i64 16}
!380 = !{!253, !9, i64 24}
!381 = !{i32 -1, i32 256}
!382 = distinct !{!382, !23}
!383 = !{!384, !9, i64 0}
!384 = !{!"luaL_Reg", !9, i64 0, !9, i64 8}
!385 = distinct !{!385, !23}
!386 = distinct !{!386, !23}
!387 = !{!384, !9, i64 8}
!388 = distinct !{!388, !23}
!389 = distinct !{!389, !23}
!390 = !{!391, !9, i64 16}
!391 = !{!"luaL_Buffer", !9, i64 0, !12, i64 8, !9, i64 16, !10, i64 24}
!392 = !{!391, !9, i64 0}
!393 = !{!391, !12, i64 8}
!394 = distinct !{!394, !23}
!395 = distinct !{!395, !23}
!396 = distinct !{!396, !23}
!397 = !{!398, !12, i64 0}
!398 = !{!"LoadF", !12, i64 0, !9, i64 8, !10, i64 16}
!399 = !{!398, !9, i64 8}
!400 = !{!401, !9, i64 0}
!401 = !{!"LoadS", !9, i64 0, !15, i64 8}
!402 = !{!401, !15, i64 8}
!403 = !{i32 0, i32 4}
!404 = distinct !{!404, !23}
!405 = distinct !{!405, !23}
!406 = distinct !{!406, !23}
!407 = distinct !{!407, !23}
!408 = distinct !{!408, !23}
!409 = !{i32 1, i32 4}
!410 = distinct !{!410, !23}
!411 = distinct !{!411, !23}
!412 = distinct !{!412, !23}
!413 = distinct !{!413, !23}
!414 = distinct !{!414, !23}
!415 = !{!416, !12, i64 0}
!416 = !{!"tm", !12, i64 0, !12, i64 4, !12, i64 8, !12, i64 12, !12, i64 16, !12, i64 20, !12, i64 24, !12, i64 28, !12, i64 32, !15, i64 40, !9, i64 48}
!417 = !{!416, !12, i64 4}
!418 = !{!416, !12, i64 8}
!419 = !{!416, !12, i64 12}
!420 = !{!416, !12, i64 16}
!421 = !{!416, !12, i64 20}
!422 = !{!416, !12, i64 24}
!423 = !{!416, !12, i64 28}
!424 = !{!416, !12, i64 32}
!425 = distinct !{!425, !23}
!426 = distinct !{!426, !23}
!427 = distinct !{!427, !23}
!428 = distinct !{!428, !23}
!429 = distinct !{!429, !23}
!430 = distinct !{!430, !23}
!431 = distinct !{!431, !23}
!432 = distinct !{!432, !23}
!433 = distinct !{!433, !23}
!434 = distinct !{!434, !23}
!435 = distinct !{!435, !23}
!436 = distinct !{!436, !23}
!437 = distinct !{!437, !23}
!438 = distinct !{!438, !23}
!439 = !{!440, !9, i64 16}
!440 = !{!"MatchState", !9, i64 0, !9, i64 8, !9, i64 16, !12, i64 24, !10, i64 32}
!441 = !{!440, !9, i64 0}
!442 = !{!440, !9, i64 8}
!443 = !{!440, !12, i64 24}
!444 = distinct !{!444, !23}
!445 = distinct !{!445, !23}
!446 = distinct !{!446, !23}
!447 = distinct !{!447, !23}
!448 = distinct !{!448, !23}
!449 = distinct !{!449, !23}
!450 = distinct !{!450, !23}
!451 = !{!452, !15, i64 8}
!452 = !{!"", !9, i64 0, !15, i64 8}
!453 = distinct !{!453, !23}
!454 = !{!452, !9, i64 0}
!455 = distinct !{!455, !23}
!456 = !{i32 0, i32 8193}
!457 = distinct !{!457, !23}
!458 = distinct !{!458, !23}
!459 = distinct !{!459, !23}
!460 = distinct !{!460, !23}
!461 = distinct !{!461, !23}
!462 = distinct !{!462, !23}
!463 = distinct !{!463, !23}
!464 = distinct !{!464, !23}
!465 = distinct !{!465, !23}
!466 = distinct !{!466, !23}
!467 = !{!468, !12, i64 0}
!468 = !{!"Smain", !12, i64 0, !9, i64 8, !12, i64 16}
!469 = !{!468, !9, i64 8}
!470 = !{!468, !12, i64 16}
!471 = distinct !{!471, !23}
!472 = distinct !{!472, !23}
!473 = distinct !{!473, !23}
!474 = distinct !{!474, !23}
!475 = distinct !{!475, !23}
!476 = distinct !{!476, !23}
